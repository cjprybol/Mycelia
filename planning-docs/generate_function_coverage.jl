import Pkg

Pkg.activate(joinpath(@__DIR__, ".."))

import Dates
import TOML

import Mycelia

const REPO_ROOT = normpath(joinpath(@__DIR__, ".."))
const SRC_ROOT = joinpath(REPO_ROOT, "src")
const MAPPING_PATH = joinpath(@__DIR__, "function-coverage-map.toml")
const OUTPUT_PATH = joinpath(@__DIR__, "FUNCTION_COVERAGE_AUDIT.md")
const MODULES = [Mycelia, Mycelia.Rhizomorph]

function method_file_path(method::Method)::Union{Nothing, String}
    file = method.file
    file_str = file isa Symbol ? String(file) : (file isa String ? file : "")
    if isempty(file_str) || file_str == "none" || startswith(file_str, "REPL[")
        return nothing
    end
    return isabspath(file_str) ? normpath(file_str) : normpath(joinpath(REPO_ROOT, file_str))
end

function collect_methods_by_file()::Dict{String, Set{Tuple{Module, Symbol}}}
    methods_by_file = Dict{String, Set{Tuple{Module, Symbol}}}()
    for module_ref in MODULES
        for name in names(module_ref; all = true, imported = false)
            if !isdefined(module_ref, name)
                continue
            end
            obj = getfield(module_ref, name)
            if !(obj isa Function)
                continue
            end
            for method in methods(obj)
                file_path = method_file_path(method)
                if file_path === nothing || !startswith(file_path, SRC_ROOT)
                    continue
                end
                rel_path = relpath(file_path, SRC_ROOT)
                symbols = get!(methods_by_file, rel_path, Set{Tuple{Module, Symbol}}())
                push!(symbols, (module_ref, name))
            end
        end
    end
    return methods_by_file
end

function count_docstrings(symbols::Set{Tuple{Module, Symbol}})::Int
    doc_count = 0
    for (module_ref, symbol) in symbols
        if Base.Docs.doc(Base.Docs.Binding(module_ref, symbol)) !== nothing
            doc_count += 1
        end
    end
    return doc_count
end

function docstring_ratio(doc_count::Int, total_count::Int)::String
    if total_count == 0
        return "0/0 (0%)"
    end
    percent = round(Int, (doc_count / total_count) * 100)
    return "$(doc_count)/$(total_count) ($(percent)%)"
end

function build_doc_cell(label::String, path::String)::String
    if isempty(path)
        return label
    end
    return "[$(label)]($(path))"
end

function load_mapping(path::String)::Tuple{Dict{String, Any}, Vector{Dict{String, Any}}}
    mapping = TOML.parsefile(path)
    settings = get(mapping, "settings", Dict{String, Any}())
    modules = get(mapping, "modules", Any[])
    module_dicts = Dict{String, Any}[]
    for entry in modules
        if entry isa Dict{String, Any}
            push!(module_dicts, entry)
        end
    end
    return settings, module_dicts
end

function should_include_unmapped(file::String, settings::Dict{String, Any})::Bool
    include_subdirs = get(settings, "include_subdirs", false)
    if !include_subdirs && occursin('/', file)
        return false
    end
    exclude_files = Set(get(settings, "exclude_files", String[]))
    for excluded in exclude_files
        if file == excluded || startswith(file, excluded)
            return false
        end
    end
    return true
end

function render_audit()
    settings, modules = load_mapping(MAPPING_PATH)
    methods_by_file = collect_methods_by_file()
    mapped_files = Set{String}()
    lines = String[]

    timestamp = Dates.format(Dates.now(), Dates.DateFormat("yyyy-mm-ddTHH:MM:SS")) * "Z"

    push!(lines, "# Function Coverage Audit")
    push!(lines, "")
    push!(lines, "<!-- Generated by planning-docs/generate_function_coverage.jl; do not edit by hand. -->")
    push!(lines, "")
    push!(lines, "Generated: $(timestamp)")
    push!(lines, "")
    push!(lines, "This audit maps source modules in `src/` to documentation anchors so newly added capabilities stay discoverable.")
    push!(
        lines,
        "Docstring coverage is counted per function symbol (not per method) across Mycelia + Mycelia.Rhizomorph and may overcount when symbols appear in multiple files."
    )
    push!(lines, "")
    push!(lines, "## Module-Level Coverage")
    push!(lines, "")
    push!(lines, "| Source Module | Function Count | Docstring Coverage | Primary Documentation | Coverage Notes |")
    push!(lines, "| --- | --- | --- | --- | --- |")

    for module_entry in modules
        file = get(module_entry, "file", "")
        label = get(module_entry, "primary_doc_label", "Internal")
        path = get(module_entry, "primary_doc_path", "")
        notes = get(module_entry, "coverage_notes", "")
        push!(mapped_files, file)
        symbols = get(methods_by_file, file, Set{Tuple{Module, Symbol}}())
        total_count = length(symbols)
        doc_count = count_docstrings(symbols)
        doc_cell = build_doc_cell(label, path)
        push!(
            lines,
            "| `$(file)` | $(total_count) | $(docstring_ratio(doc_count, total_count)) | $(doc_cell) | $(notes) |"
        )
    end

    append_unmapped = get(settings, "append_unmapped", true)
    if append_unmapped
        unmapped = String[]
        for file in keys(methods_by_file)
            if file in mapped_files
                continue
            end
            if should_include_unmapped(file, settings)
                push!(unmapped, file)
            end
        end
        sort!(unmapped)
        if !isempty(unmapped)
            push!(lines, "")
            push!(lines, "## Unmapped Source Files")
            push!(lines, "")
            push!(
                lines,
                "These `src` files appear in the code but are not listed in `planning-docs/function-coverage-map.toml`."
            )
            push!(lines, "")
            for file in unmapped
                symbols = get(methods_by_file, file, Set{Tuple{Module, Symbol}}())
                total_count = length(symbols)
                doc_count = count_docstrings(symbols)
                push!(
                    lines,
                    "- `$(file)` â€” $(total_count) functions, $(docstring_ratio(doc_count, total_count)) documented"
                )
            end
        end
    end

    push!(lines, "")
    push!(lines, "## How to Keep This Audit Fresh")
    push!(lines, "")
    push!(lines, "1. When adding a new function, link it from:")
    push!(lines, "   - the nearest workflow page and/or tutorial, and")
    push!(lines, "   - `docs/src/workflow-map.md` if it creates a new input/output path.")
    push!(
        lines,
        "2. If you add a new module or want to promote an unmapped file, update `planning-docs/function-coverage-map.toml`."
    )
    push!(lines, "3. For wrappers around external tools, record expected inputs/outputs in the workflow map.")
    push!(lines, "4. Refresh this audit with:")
    push!(lines, "")
    push!(lines, "```bash")
    push!(lines, "julia --project=. planning-docs/generate_function_coverage.jl")
    push!(lines, "```")
    push!(lines, "")
    push!(lines, "## Cross-check with Complete API")
    push!(lines, "")
    push!(lines, "Use the `docs/src/api/all-functions.md` page as a ground truth index of documented symbols (Mycelia + Mycelia.Rhizomorph):")
    push!(lines, "")
    push!(lines, "- If a function appears in the code but not in the API page, it is missing a docstring.")
    push!(lines, "- If it appears in the API page, but not in `docs/src/workflow-map.md` and any tutorial, it is likely undiscoverable and should be linked.")
    push!(lines, "")
    push!(lines, "## Immediate Documentation Tasks")
    push!(lines, "")
    push!(lines, "- Add API snippets and at least one tutorial for `variant-analysis.jl` (normalize VCF to evaluate ROC).")
    push!(lines, "- Surface taxonomy abundance plotting (`plot_taxa_abundances`) in a tutorial.")
    push!(lines, "- Add visualization examples once plotting references are consolidated.")

    write(OUTPUT_PATH, join(lines, "\n"))
end

render_audit()
