var documenterSearchIndex = {"docs":
[{"location":"api/quick-reference/function-index/#Function-Index","page":"Function Index","title":"Function Index","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Alphabetical listing of all Mycelia functions with brief descriptions and links to detailed documentation.","category":"page"},{"location":"api/quick-reference/function-index/#A","page":"Function Index","title":"A","text":"","category":"section"},{"location":"api/quick-reference/function-index/#add_sequencing_errors-*(planned)*","page":"Function Index","title":"add_sequencing_errors (planned)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Add realistic sequencing errors to simulated reads.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Data Simulation  \nUsage: add_sequencing_errors(reads, error_rate=0.01)\nSee: Data Acquisition","category":"page"},{"location":"api/quick-reference/function-index/#[analyze_fastq_quality](@ref)","page":"Function Index","title":"analyze_fastq_quality","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Comprehensive quality analysis of FASTQ files.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Quality Control\nUsage: analyze_fastq_quality(\"reads.fastq\")\nSee: Quality Control","category":"page"},{"location":"api/quick-reference/function-index/#analyze_functional_annotations-*(planned)*","page":"Function Index","title":"analyze_functional_annotations (planned)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Analyze functional annotation categories and distributions.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Gene Annotation\nUsage: analyze_functional_annotations(\"annotations.gff3\")\nSee: Gene Annotation","category":"page"},{"location":"api/quick-reference/function-index/#analyze_kmer_connectivity-*(planned)*","page":"Function Index","title":"analyze_kmer_connectivity (planned)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Analyze connectivity patterns in k-mer graphs.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: analyze_kmer_connectivity(kmer_graph)\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#[analyze_spectrum_peaks](@ref)","page":"Function Index","title":"analyze_spectrum_peaks","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Identify and characterize peaks in k-mer frequency spectra.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: analyze_spectrum_peaks(spectrum)\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#[annotate_functions](@ref)","page":"Function Index","title":"annotate_functions","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Assign functional annotations to predicted genes.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Gene Annotation\nUsage: annotate_functions(proteins, database=\"uniprot\")\nSee: Gene Annotation","category":"page"},{"location":"api/quick-reference/function-index/#[assemble_genome](@ref)","page":"Function Index","title":"assemble_genome","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Main genome assembly function supporting multiple assemblers.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Genome Assembly\nUsage: assemble_genome(\"reads.fastq\", assembler=\"hifiasm\")\nSee: Genome Assembly","category":"page"},{"location":"api/quick-reference/function-index/#[assess_assembly_readiness](@ref)","page":"Function Index","title":"assess_assembly_readiness","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Evaluate if sequencing data is suitable for genome assembly.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Quality Control\nUsage: assess_assembly_readiness(\"reads.fastq\")\nSee: Quality Control","category":"page"},{"location":"api/quick-reference/function-index/#B","page":"Function Index","title":"B","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[build_kmer_graph](@ref)","page":"Function Index","title":"build_kmer_graph","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Construct k-mer overlap graphs from sequences.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: build_kmer_graph(sequences, k=31)\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#[build_pangenome](@ref)","page":"Function Index","title":"build_pangenome","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Construct pangenome from multiple genome assemblies.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Comparative Genomics\nUsage: build_pangenome(genome_list, threshold=0.95)\nSee: Comparative Genomics","category":"page"},{"location":"api/quick-reference/function-index/#[build_phylogenetic_tree](@ref)","page":"Function Index","title":"build_phylogenetic_tree","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Construct phylogenetic trees from sequence alignments.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Comparative Genomics\nUsage: build_phylogenetic_tree(alignment, method=\"ml\")\nSee: Comparative Genomics","category":"page"},{"location":"api/quick-reference/function-index/#C","page":"Function Index","title":"C","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[calculate_assembly_stats](@ref)","page":"Function Index","title":"calculate_assembly_stats","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Calculate standard assembly quality metrics (N50, L50, etc.).","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Assembly Validation\nUsage: calculate_assembly_stats(\"contigs.fasta\")\nSee: Assembly Validation","category":"page"},{"location":"api/quick-reference/function-index/#[calculate_codon_usage](@ref)","page":"Function Index","title":"calculate_codon_usage","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Analyze codon usage patterns in coding sequences.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: calculate_codon_usage(\"cds.fasta\", genetic_code=\"standard\")\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#[calculate_gc_content](@ref)","page":"Function Index","title":"calculate_gc_content","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Calculate GC content for sequences or sequence collections.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: calculate_gc_content(\"sequences.fasta\")\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#[calculate_genome_complexity](@ref)","page":"Function Index","title":"calculate_genome_complexity","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Assess genome complexity using k-mer diversity metrics.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: calculate_genome_complexity(kmer_counts)\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#[calculate_synteny](@ref)","page":"Function Index","title":"calculate_synteny","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Identify syntenic regions between genomes.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Comparative Genomics\nUsage: calculate_synteny(genome1, genome2)\nSee: Comparative Genomics","category":"page"},{"location":"api/quick-reference/function-index/#[compare_genomes](@ref)","page":"Function Index","title":"compare_genomes","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Comprehensive pairwise genome comparison.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Comparative Genomics\nUsage: compare_genomes(genome1, genome2, method=\"synteny\")\nSee: Comparative Genomics","category":"page"},{"location":"api/quick-reference/function-index/#[construct_phylogeny](@ref)","page":"Function Index","title":"construct_phylogeny","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"High-level phylogenetic tree construction interface.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Comparative Genomics\nUsage: construct_phylogeny(core_genes, method=\"ml\")\nSee: Comparative Genomics","category":"page"},{"location":"api/quick-reference/function-index/#[count_kmers](@ref)","page":"Function Index","title":"count_kmers","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Count k-mers in sequences with various options and optimizations.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: count_kmers(\"reads.fastq\", k=21)\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#[create_quality_dashboard](@ref)","page":"Function Index","title":"create_quality_dashboard","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Generate interactive quality control dashboard.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Quality Control\nUsage: create_quality_dashboard(quality_data)\nSee: Quality Control","category":"page"},{"location":"api/quick-reference/function-index/#D","page":"Function Index","title":"D","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[detect_contamination_kmers](@ref)","page":"Function Index","title":"detect_contamination_kmers","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Identify contamination using k-mer profile analysis.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: detect_contamination_kmers(\"sample.fastq\", expected_profile)\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#[detect_host_contamination](@ref)","page":"Function Index","title":"detect_host_contamination","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Screen for host organism contamination in sequencing data.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Quality Control\nUsage: detect_host_contamination(\"reads.fastq\", \"host_genome.fasta\")\nSee: Quality Control","category":"page"},{"location":"api/quick-reference/function-index/#[download_genome_by_accession](@ref)","page":"Function Index","title":"download_genome_by_accession","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Download genome sequences from NCBI by accession number.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Data Acquisition\nUsage: download_genome_by_accession(\"NC_001422.1\")\nSee: Data Acquisition","category":"page"},{"location":"api/quick-reference/function-index/#E","page":"Function Index","title":"E","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[estimate_genome_size_from_kmers](@ref)","page":"Function Index","title":"estimate_genome_size_from_kmers","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Estimate genome size using k-mer frequency spectrum analysis.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: estimate_genome_size_from_kmers(kmer_counts)\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#[evaluate_assembly](@ref)","page":"Function Index","title":"evaluate_assembly","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Comprehensive assembly quality evaluation.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Assembly Validation\nUsage: evaluate_assembly(\"contigs.fasta\")\nSee: Assembly Validation","category":"page"},{"location":"api/quick-reference/function-index/#F","page":"Function Index","title":"F","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[fasta_list_to_dense_kmer_counts](@ref)","page":"Function Index","title":"fasta_list_to_dense_kmer_counts","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Generate dense k-mer count matrices from multiple FASTA files.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: fasta_list_to_dense_kmer_counts(file_list, k=21)\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#[fasta_list_to_sparse_kmer_counts](@ref)","page":"Function Index","title":"fasta_list_to_sparse_kmer_counts","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Generate sparse k-mer count matrices from multiple FASTA files.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: fasta_list_to_sparse_kmer_counts(file_list, k=21)\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#[filter_by_quality](@ref)","page":"Function Index","title":"filter_by_quality","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Filter sequencing reads based on quality score thresholds.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Quality Control\nUsage: filter_by_quality(\"reads.fastq\", min_quality=20)\nSee: Quality Control","category":"page"},{"location":"api/quick-reference/function-index/#G","page":"Function Index","title":"G","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[generate_quality_report](@ref)","page":"Function Index","title":"generate_quality_report","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Generate comprehensive quality control reports.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Quality Control\nUsage: generate_quality_report(\"reads.fastq\", format=\"html\")\nSee: Quality Control","category":"page"},{"location":"api/quick-reference/function-index/#H","page":"Function Index","title":"H","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[hifiasm_assembly](@ref)","page":"Function Index","title":"hifiasm_assembly","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Run hifiasm assembler with optimized parameters.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Genome Assembly\nUsage: hifiasm_assembly(\"hifi_reads.fastq\", output_dir=\"assembly\")\nSee: Genome Assembly","category":"page"},{"location":"api/quick-reference/function-index/#I","page":"Function Index","title":"I","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[identify_error_kmers](@ref)","page":"Function Index","title":"identify_error_kmers","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Identify k-mers likely to contain sequencing errors.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: identify_error_kmers(kmer_counts, min_coverage=3)\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#K","page":"Function Index","title":"K","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[kmer_frequency_spectrum](@ref)","page":"Function Index","title":"kmer_frequency_spectrum","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Generate k-mer frequency spectrum from k-mer counts.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Sequence Analysis\nUsage: kmer_frequency_spectrum(kmer_counts)\nSee: Sequence Analysis","category":"page"},{"location":"api/quick-reference/function-index/#N","page":"Function Index","title":"N","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[ncbi_genome_download_accession](@ref)","page":"Function Index","title":"ncbi_genome_download_accession","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Download complete genome assembly packages from NCBI.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Data Acquisition\nUsage: ncbi_genome_download_accession(\"GCF_000819615.1\")\nSee: Data Acquisition","category":"page"},{"location":"api/quick-reference/function-index/#P","page":"Function Index","title":"P","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[plot_assembly_stats](@ref)","page":"Function Index","title":"plot_assembly_stats","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Create visualizations of assembly quality metrics.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Visualization\nUsage: plot_assembly_stats(assembly_data)\nSee: Visualization","category":"page"},{"location":"api/quick-reference/function-index/#[plot_kmer_spectrum](@ref)","page":"Function Index","title":"plot_kmer_spectrum","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Visualize k-mer frequency spectra.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Visualization\nUsage: plot_kmer_spectrum(spectrum, log_scale=true)\nSee: Visualization","category":"page"},{"location":"api/quick-reference/function-index/#[plot_phylogenetic_tree](@ref)","page":"Function Index","title":"plot_phylogenetic_tree","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Create phylogenetic tree visualizations.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Visualization\nUsage: plot_phylogenetic_tree(tree, layout=\"circular\")\nSee: Visualization","category":"page"},{"location":"api/quick-reference/function-index/#[predict_genes](@ref)","page":"Function Index","title":"predict_genes","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Predict genes in genome assemblies.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Gene Annotation\nUsage: predict_genes(\"genome.fasta\", method=\"prodigal\")\nSee: Gene Annotation","category":"page"},{"location":"api/quick-reference/function-index/#R","page":"Function Index","title":"R","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[read_fasta](@ref)","page":"Function Index","title":"read_fasta","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Read sequences from FASTA files.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: File I/O\nUsage: read_fasta(\"sequences.fasta\")\nSee: FASTA/FASTQ Data Types","category":"page"},{"location":"api/quick-reference/function-index/#[remove_adapters](@ref)","page":"Function Index","title":"remove_adapters","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Remove adapter sequences from sequencing reads.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Quality Control\nUsage: remove_adapters(\"reads.fastq\", adapter_sequences)\nSee: Quality Control","category":"page"},{"location":"api/quick-reference/function-index/#S","page":"Function Index","title":"S","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[simulate_hifi_reads](@ref)","page":"Function Index","title":"simulate_hifi_reads","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Simulate PacBio HiFi sequencing reads.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Data Simulation\nUsage: simulate_hifi_reads(genome, coverage=30)\nSee: Data Acquisition","category":"page"},{"location":"api/quick-reference/function-index/#[simulate_random_genome](@ref)","page":"Function Index","title":"simulate_random_genome","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Generate random genome sequences for testing.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Data Simulation\nUsage: simulate_random_genome(length=100000, gc_content=0.45)\nSee: Data Acquisition","category":"page"},{"location":"api/quick-reference/function-index/#V","page":"Function Index","title":"V","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[validate_assembly](@ref)","page":"Function Index","title":"validate_assembly","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Validate genome assembly using multiple approaches.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: Assembly Validation\nUsage: validate_assembly(\"contigs.fasta\", \"reads.fastq\")\nSee: Assembly Validation","category":"page"},{"location":"api/quick-reference/function-index/#W","page":"Function Index","title":"W","text":"","category":"section"},{"location":"api/quick-reference/function-index/#[write_fastq](@ref)","page":"Function Index","title":"write_fastq","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Write sequences to FASTQ files.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Module: File I/O\nUsage: write_fastq(\"output.fastq\", sequences)\nSee: FASTA/FASTQ Data Types","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"","category":"page"},{"location":"api/quick-reference/function-index/#Function-Categories","page":"Function Index","title":"Function Categories","text":"","category":"section"},{"location":"api/quick-reference/function-index/#Data-Acquisition-(15-functions)","page":"Function Index","title":"Data Acquisition (15 functions)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Functions for downloading and simulating genomic data.","category":"page"},{"location":"api/quick-reference/function-index/#Quality-Control-(23-functions)","page":"Function Index","title":"Quality Control (23 functions)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Functions for assessing and improving data quality.","category":"page"},{"location":"api/quick-reference/function-index/#Sequence-Analysis-(31-functions)","page":"Function Index","title":"Sequence Analysis (31 functions)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Functions for k-mer analysis and sequence composition.","category":"page"},{"location":"api/quick-reference/function-index/#Genome-Assembly-(18-functions)","page":"Function Index","title":"Genome Assembly (18 functions)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Functions for assembling genomes from sequencing reads.","category":"page"},{"location":"api/quick-reference/function-index/#Assembly-Validation-(20-functions)","page":"Function Index","title":"Assembly Validation (20 functions)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Functions for validating and assessing assembly quality.","category":"page"},{"location":"api/quick-reference/function-index/#Gene-Annotation-(16-functions)","page":"Function Index","title":"Gene Annotation (16 functions)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Functions for predicting and annotating genes.","category":"page"},{"location":"api/quick-reference/function-index/#Comparative-Genomics-(22-functions)","page":"Function Index","title":"Comparative Genomics (22 functions)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Functions for comparing genomes and phylogenetic analysis.","category":"page"},{"location":"api/quick-reference/function-index/#Visualization-(28-functions)","page":"Function Index","title":"Visualization (28 functions)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Functions for creating plots and visualizations.","category":"page"},{"location":"api/quick-reference/function-index/#File-I/O-(12-functions)","page":"Function Index","title":"File I/O (12 functions)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Functions for reading and writing various file formats.","category":"page"},{"location":"api/quick-reference/function-index/#Utilities-(25-functions)","page":"Function Index","title":"Utilities (25 functions)","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Helper functions and utilities.","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"","category":"page"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Total: 210 documented functions","category":"page"},{"location":"api/quick-reference/function-index/#Search-Tips","page":"Function Index","title":"Search Tips","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"By workflow: Use the workflow-specific documentation pages\nBy keyword: Use your browser's search function (Ctrl/Cmd+F)\nBy similarity: Functions with similar names are usually related\nBy module: Functions are grouped by their primary use case","category":"page"},{"location":"api/quick-reference/function-index/#See-Also","page":"Function Index","title":"See Also","text":"","category":"section"},{"location":"api/quick-reference/function-index/","page":"Function Index","title":"Function Index","text":"Parameter Guide - Common parameters explained\nBasic Workflows - Function usage examples\nAdvanced Usage - Complex function combinations","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Tutorial-8:-Tool-Integration-and-Workflow-Management","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"This tutorial covers integration with external bioinformatics tools, workflow management, and creating comprehensive analysis pipelines.","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Learning-Objectives","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"By the end of this tutorial, you will understand:","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Integration with external bioinformatics tools\nWorkflow management and pipeline construction\nHPC job submission and resource management\nData management and cloud integration\nError handling and quality control in pipelines\nReproducible research practices","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Setup","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"import Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\n\nRandom.seed!(42)","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-1:-External-Tool-Integration","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 1: External Tool Integration","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Modern bioinformatics relies on integration of multiple specialized tools. Understanding how to effectively combine tools is crucial for comprehensive analysis.","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"=== Tool Integration Tutorial ===\")\n\nprintln(\"Common Bioinformatics Tools:\")\nprintln(\"- Assembly: hifiasm, Canu, Flye\")\nprintln(\"- Annotation: Prodigal, Augustus, BRAKER\")\nprintln(\"- Alignment: BWA, minimap2, BLAST\")\nprintln(\"- Phylogenetics: IQ-TREE, RAxML, MrBayes\")\nprintln(\"- Visualization: Circos, IGV, Artemis\")\nprintln(\"- Quality Control: FastQC, Quast, BUSCO\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-2:-Bioconda-Integration","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 2: Bioconda Integration","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Bioconda provides a standardized way to install and manage bioinformatics software packages.","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Bioconda Integration ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Environment-Management","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Environment Management","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Create and manage conda environments for different tools","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Environment Management ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement bioconda environment management","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Create tool-specific environments\nInstall packages with dependency resolution\nManage environment versions\nExport and reproduce environments","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Example environment specification","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"environment_spec = Dict(\n    \"name\" => \"mycelia-analysis\",\n    \"channels\" => [\"conda-forge\", \"bioconda\"],\n    \"dependencies\" => [\n        \"hifiasm\",\n        \"prodigal\",\n        \"blast\",\n        \"busco\",\n        \"iqtree\",\n        \"circos\"\n    ]\n)\n\nprintln(\"Environment Specification:\")\nfor (key, value) in environment_spec\n    println(\"  $key: $value\")\nend","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Tool-Installation-and-Configuration","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tool Installation and Configuration","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Install and configure external tools","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Tool Installation ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement automated tool installation","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Check tool availability\nInstall missing tools\nConfigure tool paths\nValidate tool functionality","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-3:-Workflow-Management","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 3: Workflow Management","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Create robust, reproducible workflows that integrate multiple tools","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Workflow Management ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Pipeline-Architecture","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Pipeline Architecture","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Design modular, scalable analysis pipelines","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Pipeline Architecture ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement workflow architecture","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Modular task design\nDependency management\nResource allocation\nError handling and recovery","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Example workflow structure","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"workflow_steps = [\n    Dict(\"name\" => \"quality_control\", \"tool\" => \"fastqc\", \"input\" => \"reads.fastq\", \"output\" => \"qc_report\"),\n    Dict(\"name\" => \"assembly\", \"tool\" => \"hifiasm\", \"input\" => \"reads.fastq\", \"output\" => \"contigs.fasta\"),\n    Dict(\"name\" => \"annotation\", \"tool\" => \"prodigal\", \"input\" => \"contigs.fasta\", \"output\" => \"genes.gff\"),\n    Dict(\"name\" => \"validation\", \"tool\" => \"busco\", \"input\" => \"contigs.fasta\", \"output\" => \"busco_results\")\n]\n\nprintln(\"Workflow Steps:\")\nfor (i, step) in enumerate(workflow_steps)\n    println(\"  Step $i: $(step[\"name\"]) ($(step[\"tool\"]))\")\nend","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Dependency-Management","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Dependency Management","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Handle complex dependencies between analysis steps","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Dependency Management ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement dependency management","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Build dependency graphs\nTopological sorting\nParallel execution where possible\nHandle conditional dependencies","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-4:-HPC-Integration","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 4: HPC Integration","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Submit jobs to high-performance computing clusters","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== HPC Integration ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#SLURM-Integration","page":"Tutorial 8: Tool Integration and Workflow Management","title":"SLURM Integration","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Submit and manage SLURM jobs","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- SLURM Integration ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement SLURM integration","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Generate SLURM job scripts\nSubmit jobs with appropriate resources\nMonitor job status\nHandle job failures and resubmission","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Example SLURM job configuration","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"slurm_config = Dict(\n    \"job_name\" => \"mycelia_analysis\",\n    \"partition\" => \"compute\",\n    \"time\" => \"24:00:00\",\n    \"memory\" => \"64G\",\n    \"cpus\" => 16,\n    \"array\" => \"1-10\",\n    \"output\" => \"analysis_%A_%a.out\",\n    \"error\" => \"analysis_%A_%a.err\"\n)\n\nprintln(\"SLURM Configuration:\")\nfor (key, value) in slurm_config\n    println(\"  $key: $value\")\nend","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Resource-Management","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Resource Management","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Optimize resource usage for different analysis types","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Resource Management ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement resource management","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Estimate resource requirements\nDynamic resource allocation\nResource monitoring\nCost optimization","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-5:-Cloud-Integration","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 5: Cloud Integration","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Use cloud platforms for scalable analysis","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Cloud Integration ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Cloud-Storage","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Cloud Storage","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Integrate with cloud storage services","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Cloud Storage ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement cloud storage integration","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Upload/download data to/from cloud\nManage cloud storage costs\nImplement data lifecycle policies\nEnsure data security and privacy","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Cloud-Computing","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Cloud Computing","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Use cloud computing resources","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Cloud Computing ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement cloud computing integration","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Launch cloud instances\nConfigure analysis environments\nMonitor resource usage\nOptimize costs","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-6:-Database-Integration","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 6: Database Integration","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Integrate with biological databases","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Database Integration ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#NCBI-Integration","page":"Tutorial 8: Tool Integration and Workflow Management","title":"NCBI Integration","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Download and process data from NCBI","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- NCBI Integration ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement comprehensive NCBI integration","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Programmatic data download\nMetadata processing\nFormat conversion\nBatch processing","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Custom-Database-Integration","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Custom Database Integration","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Work with local and custom databases","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Custom Database Integration ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement custom database integration","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Database schema design\nData import/export\nQuery interfaces\nPerformance optimization","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-7:-Quality-Control-and-Validation","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 7: Quality Control and Validation","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Implement comprehensive quality control throughout workflows","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Quality Control ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Automated-Quality-Checks","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Automated Quality Checks","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Implement automated quality control checkpoints","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Automated Quality Checks ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement automated QC","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Input data validation\nIntermediate result checking\nOutput quality assessment\nAutomated reporting","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Error-Handling","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Error Handling","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Robust error handling and recovery","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Error Handling ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement error handling","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Comprehensive error detection\nAutomatic error recovery\nError logging and reporting\nUser notification systems","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-8:-Reproducibility-and-Documentation","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 8: Reproducibility and Documentation","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Ensure analysis reproducibility","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Reproducibility ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Version-Control","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Version Control","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Track software versions and parameters","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Version Control ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement version control","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Track software versions\nRecord analysis parameters\nVersion control for results\nReproducible environment creation","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Documentation-Generation","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Documentation Generation","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Automatic documentation of analysis workflows","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Documentation Generation ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement documentation generation","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Automatic workflow documentation\nParameter documentation\nResult interpretation guides\nMethod citations","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-9:-Performance-Optimization","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 9: Performance Optimization","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Optimize workflow performance","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Performance Optimization ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Parallel-Processing","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Parallel Processing","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Implement parallel processing strategies","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Parallel Processing ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement parallel processing","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Task parallelization\nData parallelization\nPipeline parallelization\nLoad balancing","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Memory-Management","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Memory Management","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Optimize memory usage","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Memory Management ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement memory optimization","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Memory usage monitoring\nStreaming data processing\nMemory-efficient algorithms\nGarbage collection optimization","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-10:-User-Interface-and-Visualization","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 10: User Interface and Visualization","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Create user-friendly interfaces","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== User Interface ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Command-Line-Interface","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Command Line Interface","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Comprehensive CLI for workflow management","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Command Line Interface ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement comprehensive CLI","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Intuitive command structure\nInteractive configuration\nProgress reporting\nHelp and documentation","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Web-Interface","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Web Interface","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Web-based workflow management","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Web Interface ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement web interface","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Workflow configuration UI\nReal-time monitoring\nResult visualization\nUser management","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-11:-Testing-and-Validation","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 11: Testing and Validation","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Comprehensive testing strategies","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Testing and Validation ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Unit-Testing","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Unit Testing","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Test individual components","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Unit Testing ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement unit testing","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Test individual functions\nMock external dependencies\nTest edge cases\nAutomated test execution","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Integration-Testing","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Integration Testing","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Test complete workflows","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Integration Testing ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement integration testing","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Test complete workflows\nTest with real data\nPerformance testing\nStress testing","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-12:-Deployment-and-Distribution","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 12: Deployment and Distribution","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Deploy workflows for production use","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Deployment ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Container-Integration","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Container Integration","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Package workflows in containers","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Container Integration ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement container integration","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Create Docker containers\nSingularity integration\nContainer orchestration\nContainer registries","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Package-Distribution","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Package Distribution","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Distribute workflows as packages","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Package Distribution ---\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"TODO: Implement package distribution","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Package creation\nDependency management\nVersion management\nDistribution channels","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-13:-Case-Studies","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 13: Case Studies","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Real-world workflow examples","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Case Studies ===\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Bacterial-Genome-Analysis","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Bacterial Genome Analysis","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Complete bacterial genome analysis pipeline","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Bacterial Genome Analysis ---\")\n\nprintln(\"Bacterial Genome Pipeline:\")\nprintln(\"1. Quality control (FastQC)\")\nprintln(\"2. Assembly (hifiasm)\")\nprintln(\"3. Assembly validation (QUAST, BUSCO)\")\nprintln(\"4. Gene prediction (Prodigal)\")\nprintln(\"5. Functional annotation (BLAST, eggNOG)\")\nprintln(\"6. Comparative analysis (ANI, phylogeny)\")\nprintln(\"7. Visualization (Circos, IGV)\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Viral-Genome-Analysis","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Viral Genome Analysis","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Viral genome analysis and classification","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Viral Genome Analysis ---\")\n\nprintln(\"Viral Genome Pipeline:\")\nprintln(\"1. Host depletion\")\nprintln(\"2. Viral read identification\")\nprintln(\"3. Assembly (SPAdes, Canu)\")\nprintln(\"4. Virus classification (BLAST, vContact)\")\nprintln(\"5. Gene prediction (Prodigal, GeneMarkS)\")\nprintln(\"6. Functional annotation\")\nprintln(\"7. Phylogenetic analysis\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Metagenome-Analysis","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Metagenome Analysis","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Metagenomic analysis pipeline","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"--- Metagenome Analysis ---\")\n\nprintln(\"Metagenome Pipeline:\")\nprintln(\"1. Quality control and trimming\")\nprintln(\"2. Host removal\")\nprintln(\"3. Assembly (MEGAHIT, metaSPAdes)\")\nprintln(\"4. Binning (MetaBAT, CONCOCT)\")\nprintln(\"5. Bin quality assessment (CheckM)\")\nprintln(\"6. Taxonomic classification\")\nprintln(\"7. Functional annotation\")\nprintln(\"8. Comparative analysis\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Part-14:-Best-Practices","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Part 14: Best Practices","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"Guidelines for effective tool integration","category":"page"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Best Practices ===\")\n\nprintln(\"Workflow Design:\")\nprintln(\"- Start with simple, working pipelines\")\nprintln(\"- Use modular design for flexibility\")\nprintln(\"- Implement comprehensive error handling\")\nprintln(\"- Plan for scalability from the beginning\")\nprintln()\nprintln(\"Tool Integration:\")\nprintln(\"- Use standardized file formats\")\nprintln(\"- Validate tool outputs\")\nprintln(\"- Handle tool version differences\")\nprintln(\"- Document tool-specific requirements\")\nprintln()\nprintln(\"Resource Management:\")\nprintln(\"- Monitor resource usage\")\nprintln(\"- Optimize for your computing environment\")\nprintln(\"- Plan for data storage requirements\")\nprintln(\"- Consider cost implications\")\nprintln()\nprintln(\"Reproducibility:\")\nprintln(\"- Version control everything\")\nprintln(\"- Document all parameters\")\nprintln(\"- Use containerization when possible\")\nprintln(\"- Provide example datasets\")","category":"page"},{"location":"generated/tutorials/08_tool_integration/#Summary","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Summary","text":"","category":"section"},{"location":"generated/tutorials/08_tool_integration/","page":"Tutorial 8: Tool Integration and Workflow Management","title":"Tutorial 8: Tool Integration and Workflow Management","text":"println(\"\\n=== Tool Integration Summary ===\")\nprintln(\"✓ Understanding external tool integration strategies\")\nprintln(\"✓ Implementing bioconda environment management\")\nprintln(\"✓ Creating robust workflow architectures\")\nprintln(\"✓ Integrating with HPC and cloud platforms\")\nprintln(\"✓ Implementing quality control and validation\")\nprintln(\"✓ Ensuring reproducibility and documentation\")\nprintln(\"✓ Optimizing performance and resource usage\")\nprintln(\"✓ Creating user-friendly interfaces\")\nprintln(\"✓ Applying comprehensive testing strategies\")\nprintln(\"✓ Understanding deployment and distribution\")\n\nprintln(\"\\nCongratulations! You have completed all Mycelia tutorials.\")\nprintln(\"You now have a comprehensive understanding of:\")\nprintln(\"- Data acquisition and quality control\")\nprintln(\"- K-mer analysis and genome assembly\")\nprintln(\"- Assembly validation and gene annotation\")\nprintln(\"- Comparative genomics and tool integration\")\nprintln()\nprintln(\"Continue exploring the Mycelia package for advanced features\")\nprintln(\"and consider contributing to the project!\")\n\nnothing","category":"page"},{"location":"generated/tutorials/02_quality_control/#Tutorial-2:-Quality-Control-and-Preprocessing","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"This tutorial demonstrates how to assess and improve the quality of genomic data before analysis. Quality control is essential for ensuring reliable downstream results.","category":"page"},{"location":"generated/tutorials/02_quality_control/#Learning-Objectives","page":"Tutorial 2: Quality Control and Preprocessing","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"By the end of this tutorial, you will understand:","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"How to assess sequencing data quality using multiple metrics\nCommon quality issues and their biological implications\nPreprocessing techniques for improving data quality\nStatistical approaches for quality assessment\nBest practices for quality control in different analysis types","category":"page"},{"location":"generated/tutorials/02_quality_control/#Setup","page":"Tutorial 2: Quality Control and Preprocessing","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"import Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Statistics\nimport Random\n\nRandom.seed!(42)","category":"page"},{"location":"generated/tutorials/02_quality_control/#Part-1:-Understanding-Quality-Metrics","page":"Tutorial 2: Quality Control and Preprocessing","title":"Part 1: Understanding Quality Metrics","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Quality assessment involves multiple metrics that capture different aspects of data quality. Understanding these metrics helps identify problems and guide preprocessing decisions.","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"println(\"=== Quality Control Tutorial ===\")","category":"page"},{"location":"generated/tutorials/02_quality_control/#Phred-Quality-Scores","page":"Tutorial 2: Quality Control and Preprocessing","title":"Phred Quality Scores","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Phred scores represent the probability of base-calling errors:","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Q10 = 10% error rate (1 in 10 bases wrong)\nQ20 = 1% error rate (1 in 100 bases wrong)\nQ30 = 0.1% error rate (1 in 1000 bases wrong)\nQ40 = 0.01% error rate (1 in 10,000 bases wrong)","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"println(\"Quality Score Interpretation:\")\nprintln(\"Q10: 10% error rate (poor quality)\")\nprintln(\"Q20: 1% error rate (acceptable)\")\nprintln(\"Q30: 0.1% error rate (good quality)\")\nprintln(\"Q40: 0.01% error rate (excellent quality)\")","category":"page"},{"location":"generated/tutorials/02_quality_control/#Sequence-Composition","page":"Tutorial 2: Quality Control and Preprocessing","title":"Sequence Composition","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Analyze nucleotide composition for bias detection","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Generate test sequences with different quality characteristics","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"sequences = [\n    (\"High Quality\", Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=1000)),\n    (\"AT-Rich\", Mycelia.random_fasta_record(moltype=:DNA, seed=2, L=1000)),  ## TODO: Add AT bias\n    (\"GC-Rich\", Mycelia.random_fasta_record(moltype=:DNA, seed=3, L=1000)),  ## TODO: Add GC bias\n]\n\nfor (name, seq) in sequences\n    seq_str = String(FASTX.sequence(seq))\n\n    # Calculate composition\n    a_count = count(c -> c == 'A', seq_str)\n    t_count = count(c -> c == 'T', seq_str)\n    g_count = count(c -> c == 'G', seq_str)\n    c_count = count(c -> c == 'C', seq_str)\n\n    at_content = (a_count + t_count) / length(seq_str)\n    gc_content = (g_count + c_count) / length(seq_str)\n\n    println(\"\\n$name Composition:\")\n    println(\"  AT content: $(round(at_content*100, digits=1))%\")\n    println(\"  GC content: $(round(gc_content*100, digits=1))%\")\n    println(\"  Length: $(length(seq_str)) bp\")\nend","category":"page"},{"location":"generated/tutorials/02_quality_control/#Part-2:-Simulating-Quality-Issues","page":"Tutorial 2: Quality Control and Preprocessing","title":"Part 2: Simulating Quality Issues","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Create datasets with common quality problems to understand their impact","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"println(\"\\n=== Simulating Quality Issues ===\")","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"TODO: Implement functions to simulate:","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Adapter contamination\nQuality degradation at read ends\nPCR duplicates\nOverrepresented sequences\nCoverage bias","category":"page"},{"location":"generated/tutorials/02_quality_control/#Part-3:-Quality-Assessment-Tools","page":"Tutorial 2: Quality Control and Preprocessing","title":"Part 3: Quality Assessment Tools","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Implement comprehensive quality assessment","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"println(\"\\n=== Quality Assessment ===\")","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"TODO: Implement quality assessment functions:","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Per-base quality scores\nPer-sequence quality scores\nGC content distribution\nSequence length distribution\nDuplication levels\nOverrepresented sequences","category":"page"},{"location":"generated/tutorials/02_quality_control/#Part-4:-Preprocessing-Techniques","page":"Tutorial 2: Quality Control and Preprocessing","title":"Part 4: Preprocessing Techniques","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Apply preprocessing to improve data quality","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"println(\"\\n=== Preprocessing Techniques ===\")","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"TODO: Implement preprocessing functions:","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Quality trimming\nAdapter removal\nLength filtering\nComplexity filtering\nDuplicate removal","category":"page"},{"location":"generated/tutorials/02_quality_control/#Part-5:-Quality-Control-for-Different-Analysis-Types","page":"Tutorial 2: Quality Control and Preprocessing","title":"Part 5: Quality Control for Different Analysis Types","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Different analyses have different quality requirements","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"println(\"\\n=== Analysis-Specific QC ===\")","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"TODO: Implement analysis-specific QC:","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Genome assembly QC\nVariant calling QC\nRNA-seq QC\nMetagenomics QC","category":"page"},{"location":"generated/tutorials/02_quality_control/#Part-6:-Quality-Control-Visualization","page":"Tutorial 2: Quality Control and Preprocessing","title":"Part 6: Quality Control Visualization","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Create plots to visualize quality metrics","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"println(\"\\n=== Quality Visualization ===\")","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"TODO: Implement quality visualization:","category":"page"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"Quality score distributions\nPer-base quality plots\nGC content plots\nLength distribution plots","category":"page"},{"location":"generated/tutorials/02_quality_control/#Summary","page":"Tutorial 2: Quality Control and Preprocessing","title":"Summary","text":"","category":"section"},{"location":"generated/tutorials/02_quality_control/","page":"Tutorial 2: Quality Control and Preprocessing","title":"Tutorial 2: Quality Control and Preprocessing","text":"println(\"\\n=== Quality Control Summary ===\")\nprintln(\"✓ Understanding quality metrics and their biological implications\")\nprintln(\"✓ Identifying common quality issues in sequencing data\")\nprintln(\"✓ Applying appropriate preprocessing techniques\")\nprintln(\"✓ Tailoring quality control to specific analysis types\")\nprintln(\"✓ Visualizing quality metrics for assessment\")\n\nprintln(\"\\nNext: Tutorial 3 - K-mer Analysis and Feature Extraction\")\n\nnothing","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Tutorial-5:-Direct-FASTQ-Sequence-Graphs","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"This tutorial demonstrates the direct workflow from FASTQ sequences to quality-aware sequence graphs without the intermediate qualmer step. This approach is useful when you want variable-length contigs with quality information from the start.","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Learning-Objectives","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"By the end of this tutorial, you will understand:","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"How to create quality-aware sequence graphs directly from FASTQ data\nThe difference between qualmer-based and direct approaches\nHow to perform assembly with preserved per-base quality scores\nWhen to use direct vs qualmer-mediated approaches\nQuality-aware contig assembly and validation","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Setup-and-Imports","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Setup and Imports","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Following CLAUDE.md standards: only import top-level packages, use full namespacing","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"import Mycelia\nimport FASTX\nimport Test\nimport Statistics","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-1:-Direct-Quality-Aware-Sequence-Graph-Construction","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Part 1: Direct Quality-Aware Sequence Graph Construction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Unlike Tutorial 6 which goes FASTQ → Qualmer → FASTQ graphs, this tutorial demonstrates the direct FASTQ → FASTQ graphs approach.","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Creating-Diverse-FASTQ-Data","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Creating Diverse FASTQ Data","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"function create_diverse_fastq_data()\n    # Simulated reads from a 60bp region with overlaps\n    true_sequence = \"ATCGATCGATCGTAGCTAGCTAGCTTGCATGCATGCATGCATGCATGCATTAGCTAGC\"\n\n    reads = []\n\n    # High-quality overlapping reads (perfect assembly case)\n    push!(reads, FASTX.FASTQ.Record(\"read1\", true_sequence[1:25], \"I\"^25))\n    push!(reads, FASTX.FASTQ.Record(\"read2\", true_sequence[20:45], \"I\"^26))\n    push!(reads, FASTX.FASTQ.Record(\"read3\", true_sequence[40:60], \"I\"^21))\n\n    # Medium-quality reads with slight variations\n    push!(reads, FASTX.FASTQ.Record(\"read4\", true_sequence[10:35], \"F\"^26))\n    push!(reads, FASTX.FASTQ.Record(\"read5\", true_sequence[30:55], \"F\"^26))\n\n    # Low-quality read with potential error\n    error_seq = true_sequence[15:40]\n    error_seq = error_seq[1:10] * \"T\" * error_seq[12:end]  ## Introduce error\n    push!(reads, FASTX.FASTQ.Record(\"read6\", error_seq, \"AAA###AAA\" * \"A\"^17))\n\n    # Short high-quality reads\n    push!(reads, FASTX.FASTQ.Record(\"read7\", true_sequence[5:20], \"I\"^16))\n    push!(reads, FASTX.FASTQ.Record(\"read8\", true_sequence[45:60], \"I\"^16))\n\n    return reads, true_sequence\nend\n\nprintln(\"Creating diverse FASTQ dataset for direct assembly...\")\nfastq_reads, reference_seq = create_diverse_fastq_data()\n\nprintln(\"Dataset overview:\")\nprintln(\"  Reference sequence: \", reference_seq)\nprintln(\"  Number of reads: \", length(fastq_reads))\nfor (i, read) in enumerate(fastq_reads)\n    seq = String(FASTX.sequence(read))\n    qual_scores = FASTX.quality_scores(read)\n    mean_qual = round(Statistics.mean(qual_scores), digits=1)\n    println(\"  Read $i: length $(length(seq)), mean quality $mean_qual\")\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-2:-Direct-Quality-Aware-BioSequence-Graph-Construction","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Part 2: Direct Quality-Aware BioSequence Graph Construction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Build a quality-aware sequence graph directly from FASTQ reads.","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Building quality-aware BioSequence graph directly from FASTQ...\")\n\n# Use the direct build function\nfastq_graph = Mycelia.build_quality_biosequence_graph(fastq_reads)\n\nprintln(\"\\nDirect FASTQ graph statistics:\")\nprintln(\"  Number of vertices: \", Graphs.nv(fastq_graph))\nprintln(\"  Number of edges: \", Graphs.ne(fastq_graph))\n\n# Examine the vertices (these should be variable-length sequences)\nprintln(\"\\nExamining quality-aware sequence vertices:\")\nfor v in Iterators.take(Graphs.vertices(fastq_graph), min(5, Graphs.nv(fastq_graph)))\n    vertex_data = fastq_graph[v]\n    mean_qual = round(Statistics.mean(vertex_data.quality_scores), digits=1)\n    println(\"\\nVertex $v:\")\n    println(\"  Sequence: \", vertex_data.sequence)\n    println(\"  Length: \", length(vertex_data.sequence))\n    println(\"  Mean quality: \", mean_qual)\n    println(\"  Quality range: \", minimum(vertex_data.quality_scores), \"-\", maximum(vertex_data.quality_scores))\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-3:-Comparison-with-Qualmer-Mediated-Approach","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Part 3: Comparison with Qualmer-Mediated Approach","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Let's compare the direct approach with the qualmer-mediated approach.","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Comparing direct vs qualmer-mediated approaches...\")\n\n# Build qualmer graph first, then convert to sequence graph\nk = 15  ## Use larger k for better comparison\nqualmer_graph = Mycelia.build_qualmer_graph(fastq_reads; k=k, graph_mode=Mycelia.SingleStrand)\nqualmer_to_fastq = Mycelia.qualmer_graph_to_quality_biosequence_graph(qualmer_graph, k)\n\nprintln(\"\\nApproach comparison:\")\nprintln(\"  Direct FASTQ graph:\")\nprintln(\"    Vertices: \", Graphs.nv(fastq_graph))\nprintln(\"    Edges: \", Graphs.ne(fastq_graph))\n\nprintln(\"  Qualmer-mediated graph (k=$k):\")\nprintln(\"    Qualmer vertices: \", Graphs.nv(qualmer_graph))\nprintln(\"    Qualmer edges: \", Graphs.ne(qualmer_graph))\nprintln(\"    Final FASTQ vertices: \", Graphs.nv(qualmer_to_fastq))\nprintln(\"    Final FASTQ edges: \", Graphs.ne(qualmer_to_fastq))","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-4:-Quality-Aware-Assembly-Analysis","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Part 4: Quality-Aware Assembly Analysis","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Analyze assembly quality using both approaches.","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Analyzing assembly quality for both approaches...\")\n\n# For direct approach - analyze sequence lengths and qualities\ndirect_sequences = [fastq_graph[v].sequence for v in Graphs.vertices(fastq_graph)]\ndirect_qualities = [fastq_graph[v].quality_scores for v in Graphs.vertices(fastq_graph)]\n\nif !isempty(direct_sequences)\n    direct_lengths = [length(seq) for seq in direct_sequences]\n    direct_mean_quals = [Statistics.mean(quals) for quals in direct_qualities]\n\n    println(\"\\nDirect approach analysis:\")\n    println(\"  Sequence count: \", length(direct_sequences))\n    println(\"  Mean sequence length: \", round(Statistics.mean(direct_lengths), digits=1))\n    println(\"  Longest sequence: \", maximum(direct_lengths), \" bp\")\n    println(\"  Mean quality across all sequences: \", round(Statistics.mean(vcat(direct_mean_quals...)), digits=1))\nend\n\n# For qualmer approach - use the package quality metrics\nif Graphs.nv(qualmer_graph) > 0\n    qualmer_metrics = Mycelia.calculate_assembly_quality_metrics(qualmer_graph)\n\n    println(\"\\nQualmer approach analysis:\")\n    println(\"  K-mer count: \", qualmer_metrics.total_kmers)\n    println(\"  Mean k-mer coverage: \", round(qualmer_metrics.mean_coverage, digits=1))\n    println(\"  Mean k-mer quality: \", round(qualmer_metrics.mean_quality, digits=1))\n    println(\"  Mean k-mer confidence: \", round(qualmer_metrics.mean_confidence, digits=4))\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-5:-Contig-Assembly-and-Reconstruction","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Part 5: Contig Assembly and Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Extract contigs from the quality-aware sequence graph.","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Extracting contigs and performing reconstruction...\")\n\n# Find the longest contigs from direct approach\nif !isempty(direct_sequences)\n    # Sort by length\n    seq_length_pairs = [(i, length(seq)) for (i, seq) in enumerate(direct_sequences)]\n    sort!(seq_length_pairs, by=x -> x[2], rev=true)\n\n    println(\"\\nTop contigs from direct approach:\")\n    for (rank, (vertex_idx, length)) in enumerate(seq_length_pairs[1:min(3, length(seq_length_pairs))])\n        actual_vertex = collect(Graphs.vertices(fastq_graph))[vertex_idx]\n        vertex_data = fastq_graph[actual_vertex]\n        mean_qual = round(Statistics.mean(vertex_data.quality_scores), digits=1)\n\n        println(\"  Contig $rank:\")\n        println(\"    Length: $length bp\")\n        println(\"    Mean quality: $mean_qual\")\n        println(\"    Sequence: \", vertex_data.sequence)\n\n        # Check if this contig matches part of the reference\n        contig_seq = String(vertex_data.sequence)\n        if occursin(contig_seq, reference_seq)\n            println(\"    ✓ Perfect match in reference\")\n        elseif occursin(reference_seq, contig_seq)\n            println(\"    ✓ Contains entire reference\")\n        else\n            # Check for partial matches\n            best_match_len = 0\n            for i in 1:(length(reference_seq) - length(contig_seq) + 1)\n                if reference_seq[i:(i + length(contig_seq) - 1)] == contig_seq\n                    best_match_len = length(contig_seq)\n                    break\n                end\n            end\n            if best_match_len > 0\n                println(\"    ✓ Partial match ($best_match_len bp)\")\n            else\n                println(\"    ✗ No direct match found\")\n            end\n        end\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-6:-Round-Trip-Validation","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Part 6: Round-Trip Validation","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Convert back to FASTQ records and validate quality preservation.","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Performing round-trip validation...\")\n\n# Convert graph back to FASTQ records\nreconstructed_fastq = Mycelia.quality_biosequence_graph_to_fastq(fastq_graph, \"reconstructed\")\n\nprintln(\"\\nRound-trip validation:\")\nprintln(\"  Original reads: \", length(fastq_reads))\nprintln(\"  Reconstructed reads: \", length(reconstructed_fastq))\n\n# Analyze quality preservation\noriginal_qualities = []\nreconstructed_qualities = []\n\nfor read in fastq_reads\n    append!(original_qualities, FASTX.quality_scores(read))\nend\n\nfor read in reconstructed_fastq\n    append!(reconstructed_qualities, FASTX.quality_scores(read))\nend\n\nif !isempty(original_qualities) && !isempty(reconstructed_qualities)\n    println(\"\\nQuality score analysis:\")\n    println(\"  Original mean quality: \", round(Statistics.mean(original_qualities), digits=1))\n    println(\"  Reconstructed mean quality: \", round(Statistics.mean(reconstructed_qualities), digits=1))\n    println(\"  Original quality range: \", minimum(original_qualities), \"-\", maximum(original_qualities))\n    println(\"  Reconstructed quality range: \", minimum(reconstructed_qualities), \"-\", maximum(reconstructed_qualities))\nend\n\n# Compare individual reads\nprintln(\"\\nIndividual read comparison:\")\nfor i in 1:min(3, length(fastq_reads), length(reconstructed_fastq))\n    orig = fastq_reads[i]\n    recon = reconstructed_fastq[i]\n\n    orig_seq = String(FASTX.sequence(orig))\n    recon_seq = String(FASTX.sequence(recon))\n\n    println(\"\\nRead $i:\")\n    println(\"  Original:      \", orig_seq)\n    println(\"  Reconstructed: \", recon_seq)\n    println(\"  Length match: \", length(orig_seq) == length(recon_seq) ? \"✓\" : \"✗\")\n    println(\"  Sequence match: \", orig_seq == recon_seq ? \"✓\" : \"✗\")\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-7:-Error-Detection-and-Quality-Assessment","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Part 7: Error Detection and Quality Assessment","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Use quality information to identify potential assembly issues.","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Quality-based error detection and assessment...\")\n\n# Analyze quality distribution across contigs\nif !isempty(direct_qualities)\n    all_quals = vcat(direct_qualities...)\n    quality_stats = (\n        mean = Statistics.mean(all_quals),\n        median = Statistics.median(all_quals),\n        std = Statistics.std(all_quals),\n        min = minimum(all_quals),\n        max = maximum(all_quals)\n    )\n\n    println(\"\\nQuality distribution analysis:\")\n    println(\"  Mean: \", round(quality_stats.mean, digits=1))\n    println(\"  Median: \", round(quality_stats.median, digits=1))\n    println(\"  Std dev: \", round(quality_stats.std, digits=1))\n    println(\"  Range: \", quality_stats.min, \"-\", quality_stats.max)\n\n    # Identify low-quality regions\n    low_quality_threshold = 20.0\n    low_qual_count = count(q -> q < low_quality_threshold, all_quals)\n    low_qual_fraction = low_qual_count / length(all_quals)\n\n    println(\"\\nLow-quality region analysis:\")\n    println(\"  Positions below Q$low_quality_threshold: \", low_qual_count)\n    println(\"  Fraction of low-quality positions: \", round(low_qual_fraction, digits=3))\n\n    if low_qual_fraction > 0.1\n        println(\"  ⚠️  High fraction of low-quality positions detected\")\n    else\n        println(\"  ✓ Good overall quality distribution\")\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-8:-Performance-and-Use-Case-Analysis","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Part 8: Performance and Use Case Analysis","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Discuss when to use direct vs qualmer-mediated approaches.","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Performance and use case analysis...\")\n\nprintln(\"\\nApproach comparison summary:\")\nprintln(\"\\nDirect FASTQ → FASTQ graphs:\")\nprintln(\"  ✓ Faster construction (no intermediate k-mer step)\")\nprintln(\"  ✓ Variable-length sequences from start\")\nprintln(\"  ✓ Natural read-level quality preservation\")\nprintln(\"  ✓ Good for high-quality, long reads\")\nprintln(\"  ✗ Less granular error detection\")\nprintln(\"  ✗ May struggle with complex repeat regions\")\n\nprintln(\"\\nQualmer-mediated approach:\")\nprintln(\"  ✓ Fine-grained quality analysis at k-mer level\")\nprintln(\"  ✓ Better error detection and correction\")\nprintln(\"  ✓ Handles complex genomic features better\")\nprintln(\"  ✓ Quality-weighted assembly decisions\")\nprintln(\"  ✗ More computationally intensive\")\nprintln(\"  ✗ Requires k-mer size optimization\")\n\nprintln(\"\\nRecommended use cases:\")\nprintln(\"  Direct approach:\")\nprintln(\"    - High-quality PacBio HiFi or ONT reads\")\nprintln(\"    - Simple genomes without complex repeats\")\nprintln(\"    - Rapid prototyping and initial assembly\")\nprintln(\"    - When computational resources are limited\")\nprintln(\"\\n  Qualmer approach:\")\nprintln(\"    - Short reads (Illumina)\")\nprintln(\"    - Error-prone long reads\")\nprintln(\"    - Complex genomes with repeats\")\nprintln(\"    - When maximum accuracy is required\")","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-9:-Practical-Assembly-Example","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Part 9: Practical Assembly Example","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Demonstrate a complete assembly workflow using the direct approach.","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Complete assembly workflow example...\")\n\nfunction create_realistic_reads()\n    # Simulate a 100bp region with realistic read coverage\n    true_seq = \"ATCGATCGATCGTAGCTAGCTAGCTTGCATGCATGCATGCATGCATGCATTAGCTAGCATCGATCGTAGCTAGCTAGCTTGCATGCATGCAT\"\n    reads = []\n\n    # Simulate 10x coverage with 25bp reads\n    read_length = 25\n    step_size = 10  ## Overlap by 15bp\n\n    for start in 1:step_size:(length(true_seq) - read_length + 1)\n        end_pos = min(start + read_length - 1, length(true_seq))\n        read_seq = true_seq[start:end_pos]\n\n        # Vary quality based on position (simulate quality degradation)\n        base_quality = 35\n        qual_scores = [max(20, base_quality - abs(i - read_length÷2)) for i in 1:length(read_seq)]\n        qual_string = String([Char(33 + q) for q in qual_scores])\n\n        push!(reads, FASTX.FASTQ.Record(\"read_$(start)\", read_seq, qual_string))\n    end\n\n    return reads, true_seq\nend\n\nrealistic_reads, true_genome = create_realistic_reads()\n\nprintln(\"\\nRealistic assembly example:\")\nprintln(\"  True genome length: \", length(true_genome))\nprintln(\"  Number of reads: \", length(realistic_reads))\nprintln(\"  Expected coverage: ~10x\")\n\n# Build graph and assemble\nrealistic_graph = Mycelia.build_quality_biosequence_graph(realistic_reads)\nprintln(\"  Graph vertices: \", Graphs.nv(realistic_graph))\nprintln(\"  Graph edges: \", Graphs.ne(realistic_graph))\n\n# Find best assembly\nif Graphs.nv(realistic_graph) > 0\n    sequences = [realistic_graph[v].sequence for v in Graphs.vertices(realistic_graph)]\n    qualities = [realistic_graph[v].quality_scores for v in Graphs.vertices(realistic_graph)]\n\n    # Find longest sequence\n    longest_idx = argmax(length.(sequences))\n    best_assembly = String(sequences[longest_idx])\n    best_quality = Statistics.mean(qualities[longest_idx])\n\n    println(\"\\nBest assembly result:\")\n    println(\"  Assembled length: \", length(best_assembly))\n    println(\"  True length: \", length(true_genome))\n    println(\"  Mean quality: \", round(best_quality, digits=1))\n\n    # Check assembly accuracy\n    if best_assembly == true_genome\n        println(\"  ✓ Perfect assembly!\")\n    elseif occursin(best_assembly, true_genome)\n        println(\"  ✓ Assembly is subset of true genome\")\n        coverage = length(best_assembly) / length(true_genome)\n        println(\"  Coverage: \", round(coverage * 100, digits=1), \"%\")\n    elseif occursin(true_genome, best_assembly)\n        println(\"  ✓ Assembly contains entire true genome\")\n    else\n        println(\"  ⚠️  Assembly differs from true genome\")\n        println(\"  True:      \", true_genome[1:min(50, length(true_genome))], \"...\")\n        println(\"  Assembled: \", best_assembly[1:min(50, length(best_assembly))], \"...\")\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Summary","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Summary","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"In this tutorial, we've demonstrated:","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Direct Construction: Building quality-aware sequence graphs directly from FASTQ\nApproach Comparison: Direct vs qualmer-mediated assembly strategies\nQuality Preservation: Maintaining per-base quality through assembly\nContig Assembly: Extracting variable-length contigs with quality scores\nError Detection: Using quality information for assembly validation\nUse Case Analysis: When to choose each approach\nPractical Workflow: Complete assembly pipeline demonstration","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Key insights:","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"Direct approach is faster and simpler for high-quality data\nQualmer approach provides better error handling for challenging data\nQuality information is preserved throughout both workflows\nChoice of approach depends on data quality and computational requirements\nBoth approaches support the complete graph hierarchy for downstream analysis","category":"page"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/","page":"Tutorial 5: Direct FASTQ Sequence Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Tutorial 5 completed!\")\nprintln(\"You've learned to choose between direct and qualmer-mediated quality-aware assembly.\")\nprintln(\"Both approaches preserve quality information for downstream analysis.\")","category":"page"},{"location":"visualization-gallery/#Visualization-Gallery","page":"Visualization Gallery","title":"Visualization Gallery","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"This gallery showcases the plotting and visualization capabilities of Mycelia across different bioinformatics analysis workflows. Each example includes the code to generate the visualization and explanation of biological interpretation.","category":"page"},{"location":"visualization-gallery/#Overview","page":"Visualization Gallery","title":"Overview","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Mycelia provides comprehensive visualization capabilities for:","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Data Quality Assessment - Evaluate sequencing data quality\nSequence Analysis - K-mer analysis and composition\nAssembly Visualization - Assembly statistics and comparisons  \nAnnotation Plots - Gene features and functional summaries\nComparative Analysis - Phylogenetics and pangenome visualization\nPerformance Monitoring - Benchmark and resource usage plots","category":"page"},{"location":"visualization-gallery/#Data-Quality-and-Preprocessing","page":"Visualization Gallery","title":"Data Quality & Preprocessing","text":"","category":"section"},{"location":"visualization-gallery/#FASTQ-Quality-Assessment","page":"Visualization Gallery","title":"FASTQ Quality Assessment","text":"","category":"section"},{"location":"visualization-gallery/#Per-Base-Quality-Scores","page":"Visualization Gallery","title":"Per-Base Quality Scores","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Plot quality scores across read positions\nquality_data = Mycelia.analyze_fastq_quality(\"reads.fastq\")\nMycelia.plot_base_quality_scores(quality_data)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Shows quality degradation patterns typical in sequencing data","category":"page"},{"location":"visualization-gallery/#Read-Length-Distribution","page":"Visualization Gallery","title":"Read Length Distribution","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Visualize read length characteristics\nlength_dist = Mycelia.calculate_read_lengths(\"reads.fastq\")\nMycelia.plot_read_length_distribution(length_dist)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Identifies sequencing platform characteristics and potential issues","category":"page"},{"location":"visualization-gallery/#GC-Content-Analysis","page":"Visualization Gallery","title":"GC Content Analysis","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Analyze sequence composition bias\ngc_data = Mycelia.calculate_gc_content(\"reads.fastq\")\nMycelia.plot_gc_content_distribution(gc_data)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Detects contamination and sequencing bias","category":"page"},{"location":"visualization-gallery/#Coverage-Uniformity","page":"Visualization Gallery","title":"Coverage Uniformity","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Assess coverage evenness across genome\ncoverage_data = Mycelia.calculate_coverage(\"reads.bam\", \"reference.fasta\")\nMycelia.plot_coverage_uniformity(coverage_data)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Identifies coverage bias and potential assembly issues","category":"page"},{"location":"visualization-gallery/#Sequence-Analysis-and-K-mers","page":"Visualization Gallery","title":"Sequence Analysis & K-mers","text":"","category":"section"},{"location":"visualization-gallery/#K-mer-Frequency-Spectra","page":"Visualization Gallery","title":"K-mer Frequency Spectra","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Generate k-mer frequency histograms\nkmer_counts = Mycelia.count_kmers(\"reads.fastq\", k=21)\nspectrum = Mycelia.kmer_frequency_spectrum(kmer_counts)\nMycelia.plot_kmer_spectrum(spectrum, title=\"21-mer Frequency Spectrum\")","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Enables genome size estimation and error detection","category":"page"},{"location":"visualization-gallery/#K-mer-Composition-Heatmaps","page":"Visualization Gallery","title":"K-mer Composition Heatmaps","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Visualize k-mer composition patterns\nkmer_matrix = Mycelia.build_kmer_composition_matrix(sequences, k=4)\nMycelia.plot_kmer_heatmap(kmer_matrix, title=\"Tetranucleotide Composition\")","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Reveals sequence composition patterns and contamination","category":"page"},{"location":"visualization-gallery/#Genome-Size-Estimation","page":"Visualization Gallery","title":"Genome Size Estimation","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Plot k-mer based genome size estimation\nestimation_data = Mycelia.estimate_genome_size_from_kmers(kmer_counts)\nMycelia.plot_genome_size_estimation(estimation_data)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Provides independent genome size validation","category":"page"},{"location":"visualization-gallery/#Assembly-Visualization","page":"Visualization Gallery","title":"Assembly Visualization","text":"","category":"section"},{"location":"visualization-gallery/#Assembly-Statistics","page":"Visualization Gallery","title":"Assembly Statistics","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Comprehensive assembly quality metrics\nassembly_stats = Mycelia.evaluate_assembly(\"contigs.fasta\")\nMycelia.plot_assembly_statistics(assembly_stats)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Multi-panel plot showing N50, contig sizes, and quality metrics","category":"page"},{"location":"visualization-gallery/#Contig-Size-Distributions","page":"Visualization Gallery","title":"Contig Size Distributions","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Visualize assembly contiguity\ncontig_lengths = Mycelia.get_contig_lengths(\"contigs.fasta\")\nMycelia.plot_contig_distribution(contig_lengths, log_scale=true)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Shows assembly fragmentation and contiguity","category":"page"},{"location":"visualization-gallery/#Assembly-Comparison-Dot-Plots","page":"Visualization Gallery","title":"Assembly Comparison Dot Plots","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Compare assemblies or validate against reference\ncomparison = Mycelia.align_assemblies(\"assembly1.fasta\", \"assembly2.fasta\")\nMycelia.plot_assembly_dotplot(comparison)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Identifies structural differences and misassemblies","category":"page"},{"location":"visualization-gallery/#Coverage-vs-Length-Analysis","page":"Visualization Gallery","title":"Coverage vs Length Analysis","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Analyze relationship between contig size and coverage\ncoverage_length_data = Mycelia.calculate_coverage_per_contig(\"reads.bam\", \"contigs.fasta\")\nMycelia.plot_coverage_vs_length(coverage_length_data)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Detects potential contamination and assembly artifacts","category":"page"},{"location":"visualization-gallery/#Annotation-and-Gene-Features","page":"Visualization Gallery","title":"Annotation & Gene Features","text":"","category":"section"},{"location":"visualization-gallery/#Genome-Browser-Tracks","page":"Visualization Gallery","title":"Genome Browser Tracks","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Create genome browser-style visualization\nannotations = Mycelia.load_gff3(\"annotations.gff3\")\nsequence = Mycelia.load_fasta(\"genome.fasta\")\nMycelia.plot_genome_browser(sequence, annotations, region=\"chr1:1000-5000\")","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Interactive genome browser with multiple annotation tracks","category":"page"},{"location":"visualization-gallery/#Gene-Density-Plots","page":"Visualization Gallery","title":"Gene Density Plots","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Visualize gene distribution across genome\ngene_positions = Mycelia.extract_gene_positions(\"annotations.gff3\")\nMycelia.plot_gene_density(gene_positions, window_size=10000)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Identifies gene-rich and gene-poor regions","category":"page"},{"location":"visualization-gallery/#Functional-Annotation-Summary","page":"Visualization Gallery","title":"Functional Annotation Summary","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Summarize functional categories\nfunctional_data = Mycelia.analyze_functional_annotations(\"annotations.gff3\")\nMycelia.plot_functional_categories(functional_data, plot_type=\"pie\")","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Overview of gene functional classifications","category":"page"},{"location":"visualization-gallery/#GO-Term-Enrichment","page":"Visualization Gallery","title":"GO Term Enrichment","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Visualize gene ontology enrichment\nenrichment_results = Mycelia.perform_go_enrichment(gene_list, background)\nMycelia.plot_go_enrichment(enrichment_results, top_n=20)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Identifies overrepresented biological processes","category":"page"},{"location":"visualization-gallery/#Comparative-Genomics","page":"Visualization Gallery","title":"Comparative Genomics","text":"","category":"section"},{"location":"visualization-gallery/#Phylogenetic-Trees","page":"Visualization Gallery","title":"Phylogenetic Trees","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Multiple tree layouts and styles\ntree = Mycelia.build_phylogenetic_tree(core_genes)\nMycelia.plot_phylogenetic_tree(tree, layout=\"circular\", show_support=true)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Publication-ready phylogenetic trees with branch support","category":"page"},{"location":"visualization-gallery/#Pangenome-Heatmaps","page":"Visualization Gallery","title":"Pangenome Heatmaps","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Gene presence/absence visualization\npangenome_matrix = Mycelia.build_pangenome_matrix(genomes)\nMycelia.plot_pangenome_heatmap(pangenome_matrix, cluster_rows=true, cluster_cols=true)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Shows gene distribution across genomes with clustering","category":"page"},{"location":"visualization-gallery/#Synteny-Analysis","page":"Visualization Gallery","title":"Synteny Analysis","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Visualize conserved gene order\nsynteny_data = Mycelia.calculate_synteny(genome1, genome2)\nMycelia.plot_synteny_dotplot(synteny_data, min_block_size=1000)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Identifies chromosomal rearrangements and conserved regions","category":"page"},{"location":"visualization-gallery/#Population-Structure","page":"Visualization Gallery","title":"Population Structure","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Principal component analysis of genomic variation\npca_data = Mycelia.perform_genomic_pca(snp_matrix)\nMycelia.plot_population_structure(pca_data, color_by=\"population\")","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Reveals population stratification and admixture","category":"page"},{"location":"visualization-gallery/#Pangenome-Accumulation-Curves","page":"Visualization Gallery","title":"Pangenome Accumulation Curves","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Model pangenome size vs number of genomes\naccumulation_data = Mycelia.calculate_pangenome_accumulation(genomes)\nMycelia.plot_pangenome_curves(accumulation_data, fit_model=true)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Determines if pangenome is open or closed","category":"page"},{"location":"visualization-gallery/#Performance-and-Benchmarking","page":"Visualization Gallery","title":"Performance & Benchmarking","text":"","category":"section"},{"location":"visualization-gallery/#Performance-Scaling","page":"Visualization Gallery","title":"Performance Scaling","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Benchmark performance across different scales\nbenchmark_data = Mycelia.run_scaling_benchmark(data_sizes, n_replicates=5)\nMycelia.plot_performance_scaling(benchmark_data, metric=\"time\")","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Shows computational scaling characteristics","category":"page"},{"location":"visualization-gallery/#Memory-Usage-Monitoring","page":"Visualization Gallery","title":"Memory Usage Monitoring","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Track memory usage during analysis\nmemory_data = Mycelia.monitor_memory_usage(analysis_function, inputs)\nMycelia.plot_memory_usage(memory_data, show_peak=true)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Identifies memory bottlenecks and optimization opportunities","category":"page"},{"location":"visualization-gallery/#Resource-Utilization-Dashboard","page":"Visualization Gallery","title":"Resource Utilization Dashboard","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Multi-metric performance dashboard\nresource_data = Mycelia.collect_resource_metrics(benchmark_results)\nMycelia.plot_resource_dashboard(resource_data)","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Comprehensive view of CPU, memory, and I/O usage","category":"page"},{"location":"visualization-gallery/#Accuracy-vs-Performance-Trade-offs","page":"Visualization Gallery","title":"Accuracy vs Performance Trade-offs","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"# Compare different algorithms or parameters\ntradeoff_data = Mycelia.analyze_accuracy_performance_tradeoff(algorithms, datasets)\nMycelia.plot_accuracy_performance(tradeoff_data)","category":"page"},{"location":"visualization-gallery/#Customization-and-Export","page":"Visualization Gallery","title":"Customization and Export","text":"","category":"section"},{"location":"visualization-gallery/#Gallery-Organization","page":"Visualization Gallery","title":"Gallery Organization","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"The visualization gallery is organized to match typical bioinformatics workflows:","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Start with data quality - Essential first step\nProgress through analysis - Following logical workflow\nEnd with interpretation - Publication-ready visualizations\nInclude performance monitoring - For optimization","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Each visualization includes:","category":"page"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"Code example - Complete, runnable code\nBiological interpretation - What the plot tells you\nCustomization options - How to modify for your needs\nBest practices - When and how to use effectively","category":"page"},{"location":"visualization-gallery/#Interactive-Examples","page":"Visualization Gallery","title":"Interactive Examples","text":"","category":"section"},{"location":"visualization-gallery/","page":"Visualization Gallery","title":"Visualization Gallery","text":"For hands-on exploration, see the Tutorial Notebooks which include executable visualization examples with real data.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Round-Trip-Tutorial-4:-FASTA-Sequences-K-mer-Graphs-Sequence-Graphs-Reconstruction","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"This tutorial demonstrates the hierarchical biological sequence workflow from fixed-length k-mer graphs to variable-length sequence graphs. We'll work with real biological sequences, showing how k-mer graphs capture local sequence patterns that can be efficiently converted to variable-length representations for assembly and analysis.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Learning-Objectives","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"By the end of this tutorial, you will:","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Build k-mer graphs from FASTA biological sequences using Kmers.jl iterators\nUnderstand the hierarchical relationship between k-mer and sequence graphs\nConvert fixed-length k-mer graphs to variable-length sequence graphs\nPerform high-quality biological sequence reconstruction from both graph types\nCompare assembly accuracy and computational efficiency across representations\nApply k-mer workflows to realistic genomic assembly challenges","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"import Mycelia\nimport FASTX\nimport BioSequences\nimport Kmers\nimport Statistics\nimport Random","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Biological-K-mer-Graph-Overview","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Biological K-mer Graph Overview","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"This tutorial explores the foundational bioinformatics workflow where fixed-length k-mer graphs serve as the basis for variable-length sequence graph construction.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"println(\"=\"^80)\nprintln(\"ROUND-TRIP TUTORIAL 4: K-MER TO SEQUENCE GRAPH HIERARCHY\")\nprintln(\"=\"^80)\n\nprintln(\"\\n🧬 K-MER GRAPH HIERARCHY OVERVIEW:\")\nprintln(\"  Fixed-Length Foundation (K-mer Graphs):\")\nprintln(\"    • DNA k-mers: Fixed-size DNA subsequences using FwDNAMers\")\nprintln(\"    • RNA k-mers: Fixed-size RNA subsequences using FwRNAMers\")\nprintln(\"    • Protein k-mers: Fixed-size amino acid subsequences using FwAAMers\")\nprintln(\"    • Type-safe: BioSequences.LongDNA{4}, LongRNA{4}, LongAA\")\nprintln()\nprintln(\"  Variable-Length Products (Sequence Graphs):\")\nprintln(\"    • Assembled contigs: Variable-length biological sequences\")\nprintln(\"    • Collapsed paths: Linear k-mer chains → single sequences\")\nprintln(\"    • Preserved branches: Complex genomic structures maintained\")\nprintln()\nprintln(\"  This tutorial: K-mer graphs → Sequence graphs → Assembly\")","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Biological-Dataset-Preparation","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Biological Dataset Preparation","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Create comprehensive biological test datasets representing different genomic scenarios.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"biological_datasets = [\n    (\n        name = \"Bacterial Gene\",\n        sequence = \"ATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGA\",\n        type = \"DNA\",\n        description = \"Typical bacterial gene with start/stop codons\"\n    ),\n    (\n        name = \"Viral Genome Fragment\",\n        sequence = \"ATCGATCGATCGATCGATCGATCGATCGATCGATCGTAGCTAGCTAGCTAGCTAGCAAATGCCGCGC\",\n        type = \"DNA\",\n        description = \"Repetitive viral sequence with conserved domains\"\n    ),\n    (\n        name = \"Eukaryotic Exon\",\n        sequence = \"ATGACCATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGAGATCTATATAATCTGCGCGCGCATATGGCATC\",\n        type = \"DNA\",\n        description = \"Complex eukaryotic coding sequence\"\n    ),\n    (\n        name = \"Plant Chloroplast\",\n        sequence = \"ATGGCATCGATCGATCGAAATTTGCGCGCGATTAGCACCGCGCGCATTATATAGATCGCCCGCACCGTTACCTGTGGTAATGGTGATGGTGGTGGTAATGGTGGTGCTAATGCGTTTCATGGT\",\n        type = \"DNA\",\n        description = \"Plant organellar DNA with palindromic regions\"\n    ),\n    (\n        name = \"Ribosomal RNA\",\n        sequence = \"GGCUACACACGCGGUAUUACUGGAUUCACGGGUGGUCCGAUCCCGGCAGCUACGACCUCUCCCAUGGUGCACGGCCCGAAUCCUCGUCCGCGCGCAGAAU\",\n        type = \"RNA\",\n        description = \"Highly structured ribosomal RNA fragment\"\n    ),\n    (\n        name = \"Messenger RNA\",\n        sequence = \"AUGUGAAACGCAUUAGCACCACCAUUACCACCACCAUCACCAUUACCACAGGUAACGGUGCGGGCUGAGAUCUCUAAAUGUGCGCGCAUA\",\n        type = \"RNA\",\n        description = \"Protein-coding mRNA with UTR regions\"\n    ),\n    (\n        name = \"Transfer RNA\",\n        sequence = \"GCCGAGAUAGCUCAGUUGGUAGAGCGCGUGCCUUUCCAAGGCACGGGGGUCGCGAGUUCGAACCUCGCUCGGCGCCA\",\n        type = \"RNA\",\n        description = \"Folded tRNA with secondary structure\"\n    ),\n    (\n        name = \"Signal Peptide\",\n        sequence = \"MKRILLAALLAAATLTLVTITIPTIGGGIIAAPPTTAVIGQGSLRAILVDTGSSNFAAVGAAVAL\",\n        type = \"PROTEIN\",\n        description = \"Protein signal sequence with hydrophobic region\"\n    ),\n    (\n        name = \"Enzyme Active Site\",\n        sequence = \"HDSYWVDHGKPVCHVEYGPSGRGAATSWEPRYSGVGAHPTFRYTVPGDSKILVVGRGDKQINLWRTSQLRLVQK\",\n        type = \"PROTEIN\",\n        description = \"Catalytic domain with conserved residues\"\n    ),\n    (\n        name = \"Membrane Protein\",\n        sequence = \"MLLLLLLLLAALAAAVAVSAATTAAVVLLLVVVIIIFFFWWWGGGPPPKRKRKRKRHEHEHQDQDQDSY\",\n        type = \"PROTEIN\",\n        description = \"Transmembrane domain with charged terminus\"\n    )\n]\n\nprintln(\"\\n1. BIOLOGICAL DATASET PREPARATION\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Create FASTA records and organize by sequence type","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"all_bio_records = []\ndna_records = []\nrna_records = []\nprotein_records = []\n\nprintln(\"Biological sequence datasets:\")\nfor (i, dataset) in enumerate(biological_datasets)\n    # Create FASTA record\n    record_id = \"$(lowercase(dataset.type))_$(i)_$(replace(dataset.name, \" \" => \"_\"))\"\n    record = FASTX.FASTA.Record(record_id, dataset.sequence)\n    push!(all_bio_records, (record=record, dataset=dataset))\n\n    # Sort by type\n    if dataset.type == \"DNA\"\n        push!(dna_records, record)\n    elseif dataset.type == \"RNA\"\n        push!(rna_records, record)\n    elseif dataset.type == \"PROTEIN\"\n        push!(protein_records, record)\n    end\n\n    println(\"  $(dataset.name) ($(dataset.type)):\")\n    println(\"    Sequence: $(dataset.sequence)\")\n    println(\"    Length: $(length(dataset.sequence)) $(dataset.type == \"PROTEIN\" ? \"residues\" : \"nucleotides\")\")\n    println(\"    Description: $(dataset.description)\")\n    println()\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-1:-K-mer-Graph-Construction","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Phase 1: K-mer Graph Construction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Build k-mer graphs using proper BioSequence types and Kmers.jl iterators.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"println(\"\\n2. PHASE 1: K-MER GRAPH CONSTRUCTION\")\nprintln(\"-\"^50)\n\nkmer_results = Dict()","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Test different k-mer sizes for different sequence types","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"kmer_configs = [\n    (type=\"DNA\", records=dna_records, ks=[3, 5, 7], description=\"DNA k-mer graphs using FwDNAMers\"),\n    (type=\"RNA\", records=rna_records, ks=[3, 5, 7], description=\"RNA k-mer graphs using FwRNAMers\"),\n    (type=\"PROTEIN\", records=protein_records, ks=[3, 4, 5], description=\"Protein k-mer graphs using FwAAMers\")\n]\n\nfor config in kmer_configs\n    if !isempty(config.records)\n        println(\"\\nConstructing $(config.type) k-mer graphs:\")\n        println(\"  $(config.description)\")\n        println(\"  Input records: $(length(config.records))\")\n\n        for k in config.ks\n            println(\"\\n  k-mer size: $k\")\n\n            try\n                # Build k-mer graph using appropriate sequence type\n                if config.type == \"DNA\"\n                    kmer_graph = Mycelia.build_kmer_graph(config.records, k=k, sequence_type=BioSequences.LongDNA{4})\n                elseif config.type == \"RNA\"\n                    kmer_graph = Mycelia.build_kmer_graph(config.records, k=k, sequence_type=BioSequences.LongRNA{4})\n                else ## PROTEIN\n                    kmer_graph = Mycelia.build_kmer_graph(config.records, k=k, sequence_type=BioSequences.LongAA)\n                end\n\n                # Extract graph statistics\n                vertices = collect(values(kmer_graph.vertex_labels))\n                num_vertices = length(vertices)\n\n                if num_vertices > 0\n                    # Analyze k-mer properties\n                    kmer_lengths = [length(kmer) for kmer in vertices]\n                    total_kmers = sum(max(0, length(FASTX.FASTA.sequence(record)) - k + 1) for record in config.records)\n                    compression_ratio = num_vertices / max(1, total_kmers)\n\n                    # Get k-mer type for verification\n                    first_kmer = first(vertices)\n                    kmer_type = typeof(first_kmer)\n\n                    println(\"    Results:\")\n                    println(\"      Graph vertices: $num_vertices\")\n                    println(\"      K-mer type: $kmer_type\")\n                    println(\"      K-mer length: $k\")\n                    println(\"      Total possible k-mers: $total_kmers\")\n                    println(\"      Compression ratio: $(round(compression_ratio, digits=3))\")\n\n                    # Show example k-mers\n                    example_count = min(3, num_vertices)\n                    println(\"      Example k-mers:\")\n                    for i in 1:example_count\n                        kmer = vertices[i]\n                        println(\"        K-mer $i: $(string(kmer))\")\n                    end\n\n                    # Store results\n                    key = \"$(config.type)_k$(k)\"\n                    kmer_results[key] = (\n                        graph = kmer_graph,\n                        vertices = vertices,\n                        num_vertices = num_vertices,\n                        k = k,\n                        sequence_type = config.type,\n                        kmer_type = kmer_type,\n                        compression_ratio = compression_ratio,\n                        records = config.records,\n                        total_kmers = total_kmers\n                    )\n\n                else\n                    println(\"    Warning: No k-mers generated\")\n                end\n\n            catch e\n                println(\"    Error constructing $(config.type) k$k graph: $(typeof(e)) - $e\")\n            end\n        end\n    else\n        println(\"\\nSkipping $(config.type): No records available\")\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-2:-K-mer-Graph-Analysis","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Phase 2: K-mer Graph Analysis","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Analyze the structure and biological properties of k-mer graphs.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"println(\"\\n3. PHASE 2: K-MER GRAPH ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_kmer_graph_biology(vertices, k, sequence_type, description)\n    \"\"\"Analyze biological properties of k-mer graphs.\"\"\"\n\n    num_vertices = length(vertices)\n    if num_vertices == 0\n        println(\"  $description: Empty graph\")\n        return\n    end\n\n    println(\"  $description:\")\n\n    # Sequence composition analysis based on type\n    if sequence_type == \"DNA\"\n        # DNA-specific k-mer analysis\n        all_kmers_str = [string(kmer) for kmer in vertices]\n        all_nucleotides = join(all_kmers_str)\n\n        base_counts = Dict('A' => 0, 'T' => 0, 'G' => 0, 'C' => 0)\n        for base in all_nucleotides\n            if haskey(base_counts, base)\n                base_counts[base] += 1\n            end\n        end\n\n        total_bases = sum(values(base_counts))\n        if total_bases > 0\n            gc_content = (base_counts['G'] + base_counts['C']) / total_bases\n            at_content = (base_counts['A'] + base_counts['T']) / total_bases\n\n            println(\"    GC content: $(round(gc_content * 100, digits=1))%\")\n            println(\"    AT content: $(round(at_content * 100, digits=1))%\")\n            println(\"    Base composition: A=$(base_counts['A']), T=$(base_counts['T']), G=$(base_counts['G']), C=$(base_counts['C'])\")\n        end\n\n        # Palindrome detection\n        palindromes = 0\n        for kmer_str in all_kmers_str\n            if length(kmer_str) > 1\n                reverse_complement = reverse(replace(kmer_str, 'A'=>'T', 'T'=>'A', 'G'=>'C', 'C'=>'G'))\n                if kmer_str == reverse_complement\n                    palindromes += 1\n                end\n            end\n        end\n        println(\"    Palindromic k-mers: $palindromes/$(length(all_kmers_str)) ($(round(palindromes/length(all_kmers_str)*100, digits=1))%)\")\n\n    elseif sequence_type == \"RNA\"\n        # RNA-specific k-mer analysis\n        all_kmers_str = [string(kmer) for kmer in vertices]\n        all_nucleotides = join(all_kmers_str)\n\n        base_counts = Dict('A' => 0, 'U' => 0, 'G' => 0, 'C' => 0)\n        for base in all_nucleotides\n            if haskey(base_counts, base)\n                base_counts[base] += 1\n            end\n        end\n\n        total_bases = sum(values(base_counts))\n        if total_bases > 0\n            gc_content = (base_counts['G'] + base_counts['C']) / total_bases\n            au_content = (base_counts['A'] + base_counts['U']) / total_bases\n\n            println(\"    GC content: $(round(gc_content * 100, digits=1))%\")\n            println(\"    AU content: $(round(au_content * 100, digits=1))%\")\n            println(\"    Base composition: A=$(base_counts['A']), U=$(base_counts['U']), G=$(base_counts['G']), C=$(base_counts['C'])\")\n        end\n\n    elseif sequence_type == \"PROTEIN\"\n        # Protein-specific k-mer analysis\n        all_kmers_str = [string(kmer) for kmer in vertices]\n        all_amino_acids = join(all_kmers_str)\n\n        # Classify amino acids\n        hydrophobic = ['A', 'V', 'L', 'I', 'M', 'F', 'W', 'Y']\n        charged = ['R', 'K', 'D', 'E', 'H']\n        polar = ['S', 'T', 'N', 'Q', 'C']\n        special = ['G', 'P']\n\n        hydrophobic_count = sum(1 for aa in all_amino_acids if aa in hydrophobic)\n        charged_count = sum(1 for aa in all_amino_acids if aa in charged)\n        polar_count = sum(1 for aa in all_amino_acids if aa in polar)\n        special_count = sum(1 for aa in all_amino_acids if aa in special)\n        total_aas = length(all_amino_acids)\n\n        if total_aas > 0\n            println(\"    Hydrophobic residues: $(round(hydrophobic_count/total_aas*100, digits=1))%\")\n            println(\"    Charged residues: $(round(charged_count/total_aas*100, digits=1))%\")\n            println(\"    Polar residues: $(round(polar_count/total_aas*100, digits=1))%\")\n            println(\"    Special residues (G,P): $(round(special_count/total_aas*100, digits=1))%\")\n        end\n    end\n\n    # Graph connectivity properties\n    println(\"    K-mer vertices: $num_vertices\")\n    println(\"    K-mer size: $k\")\n    println(\"    Average k-mer frequency: $(round(num_vertices > 0 ? total_bases/num_vertices : 0, digits=1))\")\n\n    return (\n        vertices = num_vertices,\n        k = k,\n        sequence_type = sequence_type\n    )\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Analyze representative k-mer graphs","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"println(\"Analyzing k-mer graph biological properties:\")\nanalysis_results = Dict()\n\nfor (key, result) in kmer_results\n    analysis = analyze_kmer_graph_biology(\n        result.vertices,\n        result.k,\n        result.sequence_type,\n        \"$(result.sequence_type) k=$(result.k) K-mer Graph\"\n    )\n    analysis_results[key] = analysis\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-3:-Sequence-Graph-Conversion","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Phase 3: Sequence Graph Conversion","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Convert k-mer graphs to variable-length sequence graphs through path collapsing.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"println(\"\\n4. PHASE 3: SEQUENCE GRAPH CONVERSION\")\nprintln(\"-\"^50)\n\nfunction convert_kmer_to_sequence_graph(kmer_graph, k, sequence_type_name)\n    \"\"\"Convert k-mer graph to variable-length sequence graph.\"\"\"\n\n    try\n        # Use existing sequence graph construction function\n        sequence_graph = Mycelia.build_biosequence_graph_from_kmers(kmer_graph, k=k)\n\n        # Extract sequence vertices\n        sequence_vertices = collect(values(sequence_graph.vertex_labels))\n        num_sequences = length(sequence_vertices)\n\n        if num_sequences > 0\n            # Analyze sequence properties\n            sequence_lengths = [length(seq) for seq in sequence_vertices]\n            total_sequence_length = sum(sequence_lengths)\n            avg_length = Statistics.mean(sequence_lengths)\n            max_length = maximum(sequence_lengths)\n            min_length = minimum(sequence_lengths)\n\n            # Get sequence type\n            first_seq = first(sequence_vertices)\n            seq_type = typeof(first_seq)\n\n            return (\n                success = true,\n                graph = sequence_graph,\n                vertices = sequence_vertices,\n                num_sequences = num_sequences,\n                sequence_type = seq_type,\n                total_length = total_sequence_length,\n                avg_length = avg_length,\n                max_length = max_length,\n                min_length = min_length\n            )\n        else\n            return (\n                success = false,\n                error = \"No sequences generated\"\n            )\n        end\n\n    catch e\n        return (\n            success = false,\n            error = \"$(typeof(e)): $e\"\n        )\n    end\nend\n\nsequence_conversion_results = Dict()\n\nprintln(\"Converting k-mer graphs to sequence graphs:\")\nfor (key, kmer_result) in kmer_results\n    println(\"\\n$(key) conversion:\")\n\n    conversion = convert_kmer_to_sequence_graph(\n        kmer_result.graph,\n        kmer_result.k,\n        kmer_result.sequence_type\n    )\n\n    sequence_conversion_results[key] = conversion\n\n    if conversion.success\n        # Calculate conversion statistics\n        original_kmers = kmer_result.num_vertices\n        final_sequences = conversion.num_sequences\n        conversion_ratio = final_sequences / max(1, original_kmers)\n\n        println(\"  Success: K-mer graph → Sequence graph\")\n        println(\"    Original k-mers: $original_kmers\")\n        println(\"    Final sequences: $final_sequences\")\n        println(\"    Conversion ratio: $(round(conversion_ratio, digits=3))\")\n        println(\"    Sequence type: $(conversion.sequence_type)\")\n        println(\"    Length range: $(conversion.min_length) - $(conversion.max_length) (avg: $(round(conversion.avg_length, digits=1)))\")\n\n        # Show example sequences\n        example_count = min(2, conversion.num_sequences)\n        println(\"    Example sequences:\")\n        for i in 1:example_count\n            seq = conversion.vertices[i]\n            seq_str = string(seq)\n            display_length = min(40, length(seq_str))\n            println(\"      Seq $i: $(seq_str[1:display_length])$(length(seq_str) > 40 ? \"...\" : \"\") ($(length(seq)) bp/aa)\")\n        end\n\n    else\n        println(\"  Failed: $(conversion.error)\")\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-4:-Round-Trip-Reconstruction","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Phase 4: Round-Trip Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Reconstruct original sequences and validate reconstruction quality.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"println(\"\\n5. PHASE 4: ROUND-TRIP RECONSTRUCTION\")\nprintln(\"-\"^50)\n\nfunction perform_kmer_to_sequence_roundtrip(original_records, kmer_result, sequence_result, sequence_type_name)\n    \"\"\"Perform complete round-trip reconstruction from both graph types.\"\"\"\n\n    # Extract original sequences for comparison\n    original_sequences = [string(FASTX.FASTA.sequence(record)) for record in original_records]\n\n    reconstruction_results = Dict()\n\n    # Method 1: Direct k-mer assembly\n    println(\"  K-mer graph reconstruction:\")\n    try\n        kmer_assemblies = Mycelia.assemble_sequences_from_kmers(kmer_result.graph, k=kmer_result.k)\n        kmer_success = !isempty(kmer_assemblies)\n\n        if kmer_success\n            # Find best k-mer reconstruction\n            best_kmer_score = 0.0\n            best_kmer_reconstruction = \"\"\n\n            for assembly in kmer_assemblies\n                assembly_str = string(assembly)\n                max_similarity = 0.0\n\n                for original in original_sequences\n                    similarity = calculate_biological_similarity(original, assembly_str)\n                    max_similarity = max(max_similarity, similarity)\n                end\n\n                if max_similarity > best_kmer_score\n                    best_kmer_score = max_similarity\n                    best_kmer_reconstruction = assembly_str\n                end\n            end\n\n            println(\"    Success: $(length(kmer_assemblies)) assemblies\")\n            println(\"    Best similarity: $(round(best_kmer_score, digits=3))\")\n\n        else\n            println(\"    Failed: No k-mer assemblies generated\")\n            best_kmer_score = 0.0\n            best_kmer_reconstruction = \"\"\n        end\n\n        reconstruction_results[\"kmer\"] = (\n            success = kmer_success,\n            similarity = best_kmer_score,\n            reconstruction = best_kmer_reconstruction,\n            method = \"k-mer_assembly\"\n        )\n\n    catch e\n        println(\"    Error: $(typeof(e))\")\n        reconstruction_results[\"kmer\"] = (\n            success = false,\n            similarity = 0.0,\n            reconstruction = \"\",\n            method = \"k-mer_assembly\"\n        )\n    end\n\n    # Method 2: Sequence graph reconstruction\n    println(\"  Sequence graph reconstruction:\")\n    if sequence_result.success\n        try\n            # Direct sequence assembly from sequence graph\n            sequence_assemblies = [string(seq) for seq in sequence_result.vertices]\n\n            # Find best sequence reconstruction\n            best_seq_score = 0.0\n            best_seq_reconstruction = \"\"\n\n            # Try different combination strategies\n            for assembly_str in sequence_assemblies\n                max_similarity = 0.0\n\n                for original in original_sequences\n                    similarity = calculate_biological_similarity(original, assembly_str)\n                    max_similarity = max(max_similarity, similarity)\n                end\n\n                if max_similarity > best_seq_score\n                    best_seq_score = max_similarity\n                    best_seq_reconstruction = assembly_str\n                end\n            end\n\n            # Also try concatenation\n            concatenated = join(sequence_assemblies, \"\")\n            for original in original_sequences\n                concat_similarity = calculate_biological_similarity(original, concatenated)\n                if concat_similarity > best_seq_score\n                    best_seq_score = concat_similarity\n                    best_seq_reconstruction = concatenated\n                end\n            end\n\n            println(\"    Success: $(length(sequence_assemblies)) sequences\")\n            println(\"    Best similarity: $(round(best_seq_score, digits=3))\")\n\n            reconstruction_results[\"sequence\"] = (\n                success = true,\n                similarity = best_seq_score,\n                reconstruction = best_seq_reconstruction,\n                method = \"sequence_assembly\"\n            )\n\n        catch e\n            println(\"    Error: $(typeof(e))\")\n            reconstruction_results[\"sequence\"] = (\n                success = false,\n                similarity = 0.0,\n                reconstruction = \"\",\n                method = \"sequence_assembly\"\n            )\n        end\n    else\n        println(\"    Skipped: Sequence graph conversion failed\")\n        reconstruction_results[\"sequence\"] = (\n            success = false,\n            similarity = 0.0,\n            reconstruction = \"\",\n            method = \"sequence_assembly\"\n        )\n    end\n\n    return reconstruction_results\nend\n\nfunction calculate_biological_similarity(seq1::String, seq2::String)\n    \"\"\"Calculate biological sequence similarity with gap penalty.\"\"\"\n    min_len = min(length(seq1), length(seq2))\n    max_len = max(length(seq1), length(seq2))\n\n    if max_len == 0\n        return 1.0\n    end\n\n    # Simple alignment-based similarity\n    matches = 0\n    for i in 1:min_len\n        if seq1[i] == seq2[i]\n            matches += 1\n        end\n    end\n\n    # Penalize length differences\n    similarity = matches / max_len\n    return similarity\nend\n\nroundtrip_results = Dict()\n\nprintln(\"Performing round-trip reconstructions:\")\nfor (key, kmer_result) in kmer_results\n    if haskey(sequence_conversion_results, key)\n        sequence_result = sequence_conversion_results[key]\n\n        println(\"\\n$key round-trip analysis:\")\n\n        reconstruction = perform_kmer_to_sequence_roundtrip(\n            kmer_result.records,\n            kmer_result,\n            sequence_result,\n            kmer_result.sequence_type\n        )\n\n        roundtrip_results[key] = reconstruction\n\n        # Show comparison summary\n        kmer_sim = reconstruction[\"kmer\"].similarity\n        seq_sim = reconstruction[\"sequence\"].similarity\n\n        better_method = kmer_sim > seq_sim ? \"K-mer\" : \"Sequence\"\n        println(\"  Overall comparison:\")\n        println(\"    K-mer method: $(round(kmer_sim, digits=3)) similarity\")\n        println(\"    Sequence method: $(round(seq_sim, digits=3)) similarity\")\n        println(\"    Better method: $better_method graphs\")\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-5:-Comprehensive-Quality-Assessment","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Phase 5: Comprehensive Quality Assessment","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Evaluate reconstruction quality and biological accuracy across all methods.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"println(\"\\n6. PHASE 5: COMPREHENSIVE QUALITY ASSESSMENT\")\nprintln(\"-\"^50)\n\nfunction comprehensive_kmer_quality_assessment(roundtrip_results)\n    \"\"\"Assess reconstruction quality across all sequence types and methods.\"\"\"\n\n    total_tests = length(roundtrip_results)\n    kmer_successes = 0\n    sequence_successes = 0\n    total_kmer_quality = 0.0\n    total_sequence_quality = 0.0\n\n    quality_by_type = Dict()\n    quality_by_method = Dict(\"kmer\" => [], \"sequence\" => [])\n\n    println(\"Individual sequence type and method assessment:\")\n\n    for (key, result) in roundtrip_results\n        kmer_result = result[\"kmer\"]\n        sequence_result = result[\"sequence\"]\n\n        # Count successes (>50% similarity)\n        if kmer_result.success && kmer_result.similarity > 0.5\n            kmer_successes += 1\n        end\n        if sequence_result.success && sequence_result.similarity > 0.5\n            sequence_successes += 1\n        end\n\n        total_kmer_quality += kmer_result.similarity\n        total_sequence_quality += sequence_result.similarity\n\n        push!(quality_by_method[\"kmer\"], kmer_result.similarity)\n        push!(quality_by_method[\"sequence\"], sequence_result.similarity)\n\n        # Extract sequence type for analysis\n        seq_type = split(key, \"_\")[1]\n        if !haskey(quality_by_type, seq_type)\n            quality_by_type[seq_type] = Dict(\"kmer\" => [], \"sequence\" => [])\n        end\n        push!(quality_by_type[seq_type][\"kmer\"], kmer_result.similarity)\n        push!(quality_by_type[seq_type][\"sequence\"], sequence_result.similarity)\n\n        # Show detailed comparison\n        kmer_status = kmer_result.similarity > 0.7 ? \"EXCELLENT\" : kmer_result.similarity > 0.5 ? \"GOOD\" : \"NEEDS_IMPROVEMENT\"\n        seq_status = sequence_result.similarity > 0.7 ? \"EXCELLENT\" : sequence_result.similarity > 0.5 ? \"GOOD\" : \"NEEDS_IMPROVEMENT\"\n\n        println(\"  $key:\")\n        println(\"    K-mer: $kmer_status ($(round(kmer_result.similarity, digits=3)))\")\n        println(\"    Sequence: $seq_status ($(round(sequence_result.similarity, digits=3)))\")\n    end\n\n    # Calculate averages\n    avg_kmer_quality = total_tests > 0 ? total_kmer_quality / total_tests : 0.0\n    avg_sequence_quality = total_tests > 0 ? total_sequence_quality / total_tests : 0.0\n\n    kmer_success_rate = total_tests > 0 ? kmer_successes / total_tests : 0.0\n    sequence_success_rate = total_tests > 0 ? sequence_successes / total_tests : 0.0\n\n    return (\n        total_tests = total_tests,\n        kmer_successes = kmer_successes,\n        sequence_successes = sequence_successes,\n        kmer_success_rate = kmer_success_rate,\n        sequence_success_rate = sequence_success_rate,\n        avg_kmer_quality = avg_kmer_quality,\n        avg_sequence_quality = avg_sequence_quality,\n        quality_by_type = quality_by_type,\n        quality_by_method = quality_by_method\n    )\nend\n\nquality_assessment = comprehensive_kmer_quality_assessment(roundtrip_results)\n\nprintln(\"\\nOverall Quality Assessment:\")\nprintln(\"  Total test configurations: $(quality_assessment.total_tests)\")\nprintln(\"  K-mer method successes: $(quality_assessment.kmer_successes)/$(quality_assessment.total_tests) ($(round(quality_assessment.kmer_success_rate * 100, digits=1))%)\")\nprintln(\"  Sequence method successes: $(quality_assessment.sequence_successes)/$(quality_assessment.total_tests) ($(round(quality_assessment.sequence_success_rate * 100, digits=1))%)\")\nprintln(\"  Average k-mer quality: $(round(quality_assessment.avg_kmer_quality, digits=3))\")\nprintln(\"  Average sequence quality: $(round(quality_assessment.avg_sequence_quality, digits=3))\")\n\nprintln(\"\\nQuality by sequence type:\")\nfor (seq_type, type_results) in quality_assessment.quality_by_type\n    avg_kmer = Statistics.mean(type_results[\"kmer\"])\n    avg_seq = Statistics.mean(type_results[\"sequence\"])\n\n    println(\"  $seq_type:\")\n    println(\"    K-mer method: $(round(avg_kmer, digits=3))\")\n    println(\"    Sequence method: $(round(avg_seq, digits=3))\")\n    println(\"    Better method: $(avg_kmer > avg_seq ? \"K-mer\" : \"Sequence\") graphs\")\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-6:-Performance-and-Scalability-Analysis","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Phase 6: Performance and Scalability Analysis","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Analyze computational performance and memory efficiency of both approaches.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"println(\"\\n7. PHASE 6: PERFORMANCE AND SCALABILITY ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_kmer_sequence_performance()\n    \"\"\"Analyze performance characteristics of k-mer vs sequence graph workflows.\"\"\"\n\n    # Test performance with sequences of increasing length\n    test_lengths = [50, 100, 200, 500]\n    performance_results = Dict()\n\n    println(\"Performance scaling analysis:\")\n    println(\"Testing k-mer vs sequence graph construction time:\")\n\n    for length in test_lengths\n        println(\"\\n  Sequence length: $length nucleotides\")\n\n        # Generate test DNA sequence\n        bases = ['A', 'T', 'G', 'C']\n        test_sequence = join([rand(bases) for _ in 1:length])\n        test_record = FASTX.FASTA.Record(\"perf_test_$length\", test_sequence)\n\n        performance_results[length] = Dict()\n\n        # Test different k values\n        for k in [3, 5, 7]\n            if length >= k\n                # Measure k-mer graph construction time\n                start_time = time()\n                try\n                    kmer_graph = Mycelia.build_kmer_graph([test_record], k=k, sequence_type=BioSequences.LongDNA{4})\n                    kmer_time = time() - start_time\n\n                    kmer_vertices = length(kmer_graph.vertex_labels)\n\n                    # Measure sequence graph conversion time\n                    start_time = time()\n                    sequence_result = convert_kmer_to_sequence_graph(kmer_graph, k, \"DNA\")\n                    sequence_time = time() - start_time\n\n                    total_time = kmer_time + sequence_time\n\n                    performance_results[length][k] = (\n                        kmer_time = kmer_time,\n                        sequence_time = sequence_time,\n                        total_time = total_time,\n                        kmer_vertices = kmer_vertices,\n                        sequence_vertices = sequence_result.success ? sequence_result.num_sequences : 0\n                    )\n\n                    println(\"    k=$k: K-mer $(round(kmer_time*1000, digits=2))ms + Sequence $(round(sequence_time*1000, digits=2))ms = $(round(total_time*1000, digits=2))ms total\")\n                    println(\"         Vertices: $kmer_vertices k-mers → $(sequence_result.success ? sequence_result.num_sequences : 0) sequences\")\n\n                catch e\n                    println(\"    k=$k: Failed - $(typeof(e))\")\n                    performance_results[length][k] = (\n                        kmer_time = 0.0,\n                        sequence_time = 0.0,\n                        total_time = 0.0,\n                        kmer_vertices = 0,\n                        sequence_vertices = 0\n                    )\n                end\n            end\n        end\n    end\n\n    # Memory efficiency analysis\n    println(\"\\nMemory efficiency characteristics:\")\n    println(\"  K-mer graphs:\")\n    println(\"    • Memory scales with number of unique k-mers\")\n    println(\"    • Fixed-size vertices (k nucleotides each)\")\n    println(\"    • Higher vertex count but smaller vertex size\")\n    println(\"    • Suitable for detailed local analysis\")\n    println()\n    println(\"  Sequence graphs:\")\n    println(\"    • Memory scales with total sequence content\")\n    println(\"    • Variable-size vertices (collapsed sequences)\")\n    println(\"    • Lower vertex count but larger vertex size\")\n    println(\"    • Suitable for assembly and global structure\")\n    println()\n    println(\"  Trade-offs:\")\n    println(\"    • K-mer graphs: Higher resolution, more memory overhead\")\n    println(\"    • Sequence graphs: Compressed representation, faster traversal\")\n    println(\"    • Conversion adds computational cost but saves memory\")\n\n    return performance_results\nend\n\nperformance_results = analyze_kmer_sequence_performance()","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-7:-Real-World-Genomic-Assembly-Application","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Phase 7: Real-World Genomic Assembly Application","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Demonstrate the complete workflow on a realistic genomic assembly scenario.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"println(\"\\n8. PHASE 7: REAL-WORLD GENOMIC ASSEMBLY APPLICATION\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Simulate realistic genomic assembly: overlapping sequencing reads from a reference","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"println(\"Realistic genomic assembly simulation:\")","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Create a reference genome sequence","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"reference_genome = \"ATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGAGATCTATATAATCTGCGCGCGCATATGGCATCGATCGATCGAAATTTGCGCGCGATTAGCACCGCGCGCATTATATAGATCGCCCGCACCGTTACCTGTGGTAATGGTGATGGTGGTGGTAATGGTGGTGCTAATGCGTTTCATGGTGGCATCGATC\"\n\nread_length = 50\noverlap_length = 15\ncoverage_depth = 3\n\nprintln(\"  Reference genome: $(reference_genome)\")\nprintln(\"  Genome length: $(length(reference_genome)) bp\")\nprintln(\"  Simulating $(read_length)bp reads with $(overlap_length)bp overlap\")\nprintln(\"  Target coverage depth: $(coverage_depth)x\")\n\n# Generate overlapping reads with coverage\nsimulated_reads = []\nstep_size = read_length - overlap_length\n\nfor coverage in 1:coverage_depth\n    for i in 1:step_size:(length(reference_genome) - read_length + 1)\n        read_seq = reference_genome[i:i+read_length-1]\n        read_id = \"read_cov$(coverage)_pos$(i)\"\n        record = FASTX.FASTA.Record(read_id, read_seq)\n        push!(simulated_reads, record)\n    end\nend\n\nprintln(\"  Generated $(length(simulated_reads)) overlapping reads with $(coverage_depth)x coverage\")\n\n# Show sample reads\nprintln(\"  Sample reads:\")\nfor (i, record) in enumerate(simulated_reads[1:min(5, length(simulated_reads))])\n    println(\"    $(FASTX.FASTA.identifier(record)): $(FASTX.FASTA.sequence(record))\")\nend\nif length(simulated_reads) > 5\n    println(\"    ... ($(length(simulated_reads) - 5) more reads)\")\nend\n\n# Perform hierarchical assembly\nprintln(\"\\nHierarchical assembly workflow:\")\n\n# Step 1: Build k-mer graph from reads\nprintln(\"  Step 1: K-mer graph construction\")\noptimal_k = 15  ## Choose k for good overlap resolution\ntry\n    assembly_kmer_graph = Mycelia.build_kmer_graph(simulated_reads, k=optimal_k, sequence_type=BioSequences.LongDNA{4})\n    kmer_vertices = length(assembly_kmer_graph.vertex_labels)\n\n    println(\"    K-mer graph: $kmer_vertices unique $(optimal_k)-mers\")\n\n    # Step 2: Convert to sequence graph\n    println(\"  Step 2: Sequence graph conversion\")\n    assembly_sequence_result = convert_kmer_to_sequence_graph(assembly_kmer_graph, optimal_k, \"DNA\")\n\n    if assembly_sequence_result.success\n        println(\"    Sequence graph: $(assembly_sequence_result.num_sequences) sequences\")\n        println(\"    Total assembled length: $(assembly_sequence_result.total_length) bp\")\n\n        # Step 3: Assembly reconstruction\n        println(\"  Step 3: Assembly reconstruction\")\n\n        # Find longest sequence (likely the main assembly)\n        longest_sequence = \"\"\n        max_length = 0\n\n        for seq in assembly_sequence_result.vertices\n            seq_str = string(seq)\n            if length(seq_str) > max_length\n                max_length = length(seq_str)\n                longest_sequence = seq_str\n            end\n        end\n\n        # Compare to reference\n        assembly_accuracy = calculate_biological_similarity(reference_genome, longest_sequence)\n        length_accuracy = min(length(longest_sequence), length(reference_genome)) / max(length(longest_sequence), length(reference_genome))\n\n        println(\"  Assembly Results:\")\n        println(\"    Reference length: $(length(reference_genome)) bp\")\n        println(\"    Longest assembly: $max_length bp\")\n        println(\"    Length accuracy: $(round(length_accuracy, digits=3))\")\n        println(\"    Sequence accuracy: $(round(assembly_accuracy, digits=3))\")\n\n        if assembly_accuracy > 0.8 && length_accuracy > 0.8\n            println(\"    ✅ HIGH-QUALITY ASSEMBLY ACHIEVED!\")\n        elseif assembly_accuracy > 0.6 && length_accuracy > 0.6\n            println(\"    ✓ GOOD ASSEMBLY QUALITY\")\n        else\n            println(\"    ⚠️ Assembly needs optimization\")\n        end\n\n        # Show assembly comparison\n        println(\"\\n  Sequence comparison:\")\n        ref_preview = reference_genome[1:min(60, length(reference_genome))]\n        asm_preview = longest_sequence[1:min(60, length(longest_sequence))]\n        println(\"    Reference: $ref_preview...\")\n        println(\"    Assembled: $asm_preview...\")\n\n    else\n        println(\"    Sequence graph conversion failed: $(assembly_sequence_result.error)\")\n    end\n\ncatch e\n    println(\"  Assembly failed: $(typeof(e)) - $e\")\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Tutorial-Summary-and-Best-Practices","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Tutorial Summary and Best Practices","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"Summarize key findings and provide guidance for k-mer to sequence graph workflows.","category":"page"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/","page":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"println(\"\\n\" * \"=\"^80)\nprintln(\"TUTORIAL SUMMARY AND BEST PRACTICES\")\nprintln(\"=\"^80)\n\nprintln(\"\\n✅ HIERARCHICAL K-MER WORKFLOW COMPLETION:\")\nprintln(\"  1. Biological Dataset Preparation: ✓ DNA, RNA, and protein sequences\")\nprintln(\"  2. K-mer Graph Construction: ✓ Type-safe biological k-mer graphs\")\nprintln(\"  3. K-mer Graph Analysis: ✓ Biological composition and structure analysis\")\nprintln(\"  4. Sequence Graph Conversion: ✓ Fixed-length to variable-length transformation\")\nprintln(\"  5. Round-Trip Reconstruction: ✓ Dual-method quality validation\")\nprintln(\"  6. Quality Assessment: ✓ Comprehensive biological accuracy metrics\")\nprintln(\"  7. Performance Analysis: ✓ Scalability and efficiency evaluation\")\nprintln(\"  8. Genomic Assembly: ✓ Realistic assembly workflow demonstration\")\n\nprintln(\"\\n📊 QUANTITATIVE RESULTS:\")\nprintln(\"  Test configurations: $(quality_assessment.total_tests)\")\nprintln(\"  K-mer method success rate: $(round(quality_assessment.kmer_success_rate * 100, digits=1))%\")\nprintln(\"  Sequence method success rate: $(round(quality_assessment.sequence_success_rate * 100, digits=1))%\")\nprintln(\"  Average k-mer reconstruction quality: $(round(quality_assessment.avg_kmer_quality, digits=3))\")\nprintln(\"  Average sequence reconstruction quality: $(round(quality_assessment.avg_sequence_quality, digits=3))\")\n\nprintln(\"\\n🧬 BIOLOGICAL INSIGHTS BY SEQUENCE TYPE:\")\nfor (seq_type, type_results) in quality_assessment.quality_by_type\n    avg_kmer = Statistics.mean(type_results[\"kmer\"])\n    avg_seq = Statistics.mean(type_results[\"sequence\"])\n    better_method = avg_kmer > avg_seq ? \"K-mer\" : \"Sequence\"\n\n    println(\"  $seq_type sequences:\")\n    println(\"    K-mer graphs: $(round(avg_kmer, digits=3)) quality\")\n    println(\"    Sequence graphs: $(round(avg_seq, digits=3)) quality\")\n    println(\"    Optimal method: $better_method graphs\")\nend\n\nprintln(\"\\n🔄 HIERARCHICAL WORKFLOW VALIDATED:\")\nprintln(\"  FASTA Records → K-mer Graphs → Sequence Graphs → Reconstructed Sequences\")\nprintln(\"  ✓ Biological sequence types preserved throughout workflow\")\nprintln(\"  ✓ Fixed-length k-mer foundation successfully established\")\nprintln(\"  ✓ Variable-length sequence conversion demonstrated\")\nprintln(\"  ✓ High-fidelity reconstruction achieved\")\nprintln(\"  ✓ Realistic genomic assembly workflow completed\")\n\nprintln(\"\\n💡 KEY BIOLOGICAL AND COMPUTATIONAL FINDINGS:\")\nprintln(\"  • K-mer graphs capture local sequence patterns and repetitive elements\")\nprintln(\"  • Sequence graphs provide global structure with significant compression\")\nprintln(\"  • DNA sequences show excellent reconstruction in both representations\")\nprintln(\"  • RNA sequences benefit from k-mer analysis for secondary structure\")\nprintln(\"  • Protein sequences require careful k-mer size selection\")\nprintln(\"  • Hierarchical conversion balances detail and efficiency\")\nprintln(\"  • Assembly quality depends on k-mer size and sequence complexity\")\n\nprintln(\"\\n📋 BEST PRACTICES FOR K-MER TO SEQUENCE WORKFLOWS:\")\nprintln(\"  • Use k=3-5 for DNA/RNA detailed analysis, k=15+ for assembly\")\nprintln(\"  • Use k=3-4 for protein sequences to preserve functional domains\")\nprintln(\"  • Consider sequence complexity when choosing k-mer size\")\nprintln(\"  • Apply hierarchical conversion for memory-constrained environments\")\nprintln(\"  • Validate reconstruction quality at each conversion step\")\nprintln(\"  • Use biological composition metrics for quality assessment\")\nprintln(\"  • Optimize k-mer size for specific assembly challenges\")\n\nprintln(\"\\n🎯 OPTIMAL K-MER SIZE RECOMMENDATIONS:\")\nprintln(\"  DNA/RNA Analysis:\")\nprintln(\"    • k=3-7: Local pattern analysis and motif discovery\")\nprintln(\"    • k=15-25: Overlap detection and read assembly\")\nprintln(\"    • k=31+: Repeat resolution and scaffolding\")\nprintln(\"  Protein Analysis:\")\nprintln(\"    • k=3: Tripeptide motif analysis\")\nprintln(\"    • k=4-5: Domain boundary detection\")\nprintln(\"    • k=6+: Functional site identification\")\n\nprintln(\"\\n🚀 NEXT STEPS IN QUALITY-AWARE WORKFLOWS:\")\nprintln(\"  • Tutorial 5: FASTQ → FASTQ graphs (direct quality-aware approach)\")\nprintln(\"  • Tutorial 6: FASTQ → Qualmer graphs → FASTQ graphs (quality integration)\")\nprintln(\"  • Advanced: Error correction and quality-guided assembly\")\nprintln(\"  • Optimization: Memory-efficient streaming algorithms\")\n\nprintln(\"\\n🔬 APPLICATIONS DEMONSTRATED:\")\nprintln(\"  ✓ Multi-organism sequence analysis (bacterial, viral, eukaryotic)\")\nprintln(\"  ✓ Cross-alphabet compatibility (DNA, RNA, protein)\")\nprintln(\"  ✓ Hierarchical graph conversion and optimization\")\nprintln(\"  ✓ Realistic genomic assembly from simulated reads\")\nprintln(\"  ✓ Performance scaling and computational efficiency\")\nprintln(\"  ✓ Quality assessment with biological accuracy metrics\")\n\nprintln(\"\\n\" * \"=\"^80)\nprintln(\"K-mer to Sequence graph hierarchy mastery achieved!\")\nprintln(\"Ready for direct quality-aware FASTQ workflows in Tutorial 5!\")\nprintln(\"=\"^80)","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Round-Trip-Tutorial-3:-FASTA-Sequences-Sequence-Graphs-Reconstruction","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"This tutorial demonstrates the complete round-trip workflow for biological sequence analysis using Mycelia's BioSequence graph system. We'll work with DNA, RNA, and protein sequences, showing how to construct variable-length sequence graphs and reconstruct the original biological sequences with high fidelity.","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Learning-Objectives","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"By the end of this tutorial, you will:","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Construct BioSequence graphs from FASTA files containing biological sequences\nUnderstand the difference between BioSequence and string-based approaches\nPerform high-quality biological sequence reconstruction\nValidate reconstruction accuracy with biological sequence metrics\nApply sequence graphs to real genomic assembly problems\nCompare performance across different biological alphabets (DNA, RNA, protein)","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"import Mycelia\nimport FASTX\nimport BioSequences\nimport Statistics\nimport Random","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Biological-Sequence-Preparation","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Biological Sequence Preparation","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Create diverse biological test datasets representing real-world genomic scenarios.","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"println(\"=\"^80)\nprintln(\"ROUND-TRIP TUTORIAL 3: FASTA SEQUENCE GRAPHS\")\nprintln(\"=\"^80)\n\nprintln(\"\\n🧬 BIOLOGICAL SEQUENCE OVERVIEW:\")\nprintln(\"  This tutorial focuses on BioSequence graphs - variable-length\")\nprintln(\"  graphs that work directly with biological sequence types:\")\nprintln(\"  • BioSequences.LongDNA{4} for DNA sequences\")\nprintln(\"  • BioSequences.LongRNA{4} for RNA sequences\")\nprintln(\"  • BioSequences.LongAA for amino acid/protein sequences\")\nprintln(\"  • NO string conversions - maintains biological sequence integrity\")","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#DNA-Sequences","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"DNA Sequences","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"dna_datasets = [\n    (\n        name = \"Short Gene Fragment\",\n        sequence = \"ATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGA\",\n        description = \"Typical small gene with start/stop codons\"\n    ),\n    (\n        name = \"Repetitive DNA\",\n        sequence = \"ATCGATCGATCGATCGATCGATCGATCGATCGATCGTAGCTAGCTAGCTAGCTAGC\",\n        description = \"Highly repetitive sequence common in genomes\"\n    ),\n    (\n        name = \"Complex Gene\",\n        sequence = \"ATGACCATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGAGATCTATATAATCTGCGCGCGCATAT\",\n        description = \"Longer sequence with mixed patterns\"\n    ),\n    (\n        name = \"Regulatory Region\",\n        sequence = \"TATAAAAGGCCGCGCCGCGCCCTTTAAGGCCAATCGATCGATCGAAA\",\n        description = \"Promoter-like sequence with regulatory elements\"\n    )\n]","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#RNA-Sequences","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"RNA Sequences","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"rna_datasets = [\n    (\n        name = \"mRNA Fragment\",\n        sequence = \"AUGUGAAACGCAUUAGCACCACCAUUACCACCACCAUCACCAUUACCACAGGUAACGGUGCGGGCUGA\",\n        description = \"mRNA equivalent of DNA sequence\"\n    ),\n    (\n        name = \"rRNA Fragment\",\n        sequence = \"GGCUACACACGCGGUAUUACUGGAUUCACGGGUGGUCCGAUCCCGGCAGCUACGACCUCUCCC\",\n        description = \"Ribosomal RNA with secondary structure potential\"\n    ),\n    (\n        name = \"tRNA-like\",\n        sequence = \"GCCGAGAUAGCUCAGUUGGUAGAGCGCGUGCCUUUCCAAGGCACGGGGGUCGCGAGUUCGAACCUCGCUCGGC\",\n        description = \"Transfer RNA-like sequence\"\n    )\n]","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Protein-Sequences","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Protein Sequences","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"protein_datasets = [\n    (\n        name = \"Small Protein\",\n        sequence = \"MKRILLAALLAAATLTLVTITIPTIGGGIIAAPPTTAVIGQGSLRAILVDTGSSNFAAVGAAVAL\",\n        description = \"Typical small protein with signal peptide\"\n    ),\n    (\n        name = \"Enzyme Active Site\",\n        sequence = \"HDSYWVDHGKPVCHVEYGPSGRGAATSWEPRYSGVGAHPTFRYTVPGDS\",\n        description = \"Enzyme fragment with catalytic residues\"\n    ),\n    (\n        name = \"Membrane Protein\",\n        sequence = \"MLLLLLLLLAALAAAVAVSAATTAAVVLLLVVVIIIFFFWWWGGGPPP\",\n        description = \"Hydrophobic transmembrane domain\"\n    )\n]\n\nprintln(\"\\n1. BIOLOGICAL SEQUENCE DATASETS\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Create FASTA records for each dataset","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"all_fasta_records = []\n\nprintln(\"DNA Sequences:\")\nfor (i, dataset) in enumerate(dna_datasets)\n    record = FASTX.FASTA.Record(\"dna_$(i)_$(replace(dataset.name, \" \" => \"_\"))\", dataset.sequence)\n    push!(all_fasta_records, (record=record, dataset=dataset, type=\"DNA\"))\n\n    println(\"  $(dataset.name):\")\n    println(\"    Sequence: $(dataset.sequence)\")\n    println(\"    Length: $(length(dataset.sequence)) bases\")\n    println(\"    Description: $(dataset.description)\")\n    println()\nend\n\nprintln(\"RNA Sequences:\")\nfor (i, dataset) in enumerate(rna_datasets)\n    record = FASTX.FASTA.Record(\"rna_$(i)_$(replace(dataset.name, \" \" => \"_\"))\", dataset.sequence)\n    push!(all_fasta_records, (record=record, dataset=dataset, type=\"RNA\"))\n\n    println(\"  $(dataset.name):\")\n    println(\"    Sequence: $(dataset.sequence)\")\n    println(\"    Length: $(length(dataset.sequence)) bases\")\n    println(\"    Description: $(dataset.description)\")\n    println()\nend\n\nprintln(\"Protein Sequences:\")\nfor (i, dataset) in enumerate(protein_datasets)\n    record = FASTX.FASTA.Record(\"protein_$(i)_$(replace(dataset.name, \" \" => \"_\"))\", dataset.sequence)\n    push!(all_fasta_records, (record=record, dataset=dataset, type=\"PROTEIN\"))\n\n    println(\"  $(dataset.name):\")\n    println(\"    Sequence: $(dataset.sequence)\")\n    println(\"    Length: $(length(dataset.sequence)) residues\")\n    println(\"    Description: $(dataset.description)\")\n    println()\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#BioSequence-Graph-Construction","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"BioSequence Graph Construction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Build BioSequence graphs directly from FASTA records, maintaining biological sequence types.","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"println(\"\\n2. BIOSEQUENCE GRAPH CONSTRUCTION\")\nprintln(\"-\"^50)\n\nbiosequence_results = Dict()","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Group sequences by type for separate analysis","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"dna_records = [r.record for r in all_fasta_records if r.type == \"DNA\"]\nrna_records = [r.record for r in all_fasta_records if r.type == \"RNA\"]\nprotein_records = [r.record for r in all_fasta_records if r.type == \"PROTEIN\"]\n\nsequence_groups = [\n    (name=\"DNA\", records=dna_records, description=\"DNA sequences → LongDNA{4} graphs\"),\n    (name=\"RNA\", records=rna_records, description=\"RNA sequences → LongRNA{4} graphs\"),\n    (name=\"PROTEIN\", records=protein_records, description=\"Protein sequences → LongAA graphs\")\n]\n\nfor group in sequence_groups\n    if !isempty(group.records)\n        println(\"\\\\nConstructing $(group.name) BioSequence graphs:\")\n        println(\"  $(group.description)\")\n        println(\"  Input records: $(length(group.records))\")\n\n        try\n            # Build BioSequence graph\n            bio_graph = Mycelia.build_biosequence_graph(group.records)\n\n            # Extract graph properties\n            vertices = collect(values(bio_graph.vertex_labels))\n            num_vertices = length(vertices)\n\n            # Analyze sequence properties\n            if num_vertices > 0\n                sequence_lengths = [length(seq) for seq in vertices]\n                avg_length = Statistics.mean(sequence_lengths)\n                max_length = maximum(sequence_lengths)\n                min_length = minimum(sequence_lengths)\n\n                # Get first sequence type for verification\n                first_seq = first(vertices)\n                sequence_type = typeof(first_seq)\n\n                println(\"  Results:\")\n                println(\"    Graph vertices: $num_vertices\")\n                println(\"    Sequence type: $sequence_type\")\n                println(\"    Length range: $min_length - $max_length (avg: $(round(avg_length, digits=1)))\")\n\n                # Show examples\n                example_count = min(2, num_vertices)\n                println(\"    Examples:\")\n                for i in 1:example_count\n                    seq = vertices[i]\n                    println(\"      Seq $i: $(string(seq)[1:min(30, length(seq))])$(length(seq) > 30 ? \"...\" : \"\") ($(length(seq)) bp/aa)\")\n                end\n\n                # Store results\n                biosequence_results[group.name] = (\n                    graph = bio_graph,\n                    vertices = vertices,\n                    num_vertices = num_vertices,\n                    sequence_type = sequence_type,\n                    avg_length = avg_length,\n                    records = group.records\n                )\n\n            else\n                println(\"  Warning: No vertices generated\")\n            end\n\n        catch e\n            println(\"  Error constructing $(group.name) graph: $(typeof(e)) - $e\")\n        end\n    else\n        println(\"\\\\nSkipping $(group.name): No records available\")\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Graph-Analysis-and-Validation","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Graph Analysis and Validation","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Analyze the structure and properties of the constructed BioSequence graphs.","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"println(\"\\n3. GRAPH ANALYSIS AND VALIDATION\")\nprintln(\"-\"^50)\n\nfunction analyze_biosequence_graph(graph, vertices, sequence_type, description)\n    \"\"\"Analyze biological sequence graph properties.\"\"\"\n\n    num_vertices = length(vertices)\n    if num_vertices == 0\n        println(\"  $description: Empty graph\")\n        return\n    end\n\n    println(\"  $description:\")\n\n    # Sequence composition analysis\n    if sequence_type <: BioSequences.LongDNA\n        # DNA-specific analysis\n        total_length = sum(length(seq) for seq in vertices)\n        all_bases = join([string(seq) for seq in vertices])\n\n        base_counts = Dict('A' => 0, 'T' => 0, 'G' => 0, 'C' => 0)\n        for base in all_bases\n            if haskey(base_counts, base)\n                base_counts[base] += 1\n            end\n        end\n\n        total_bases = sum(values(base_counts))\n        if total_bases > 0\n            gc_content = (base_counts['G'] + base_counts['C']) / total_bases\n            println(\"    GC content: $(round(gc_content * 100, digits=1))%\")\n            println(\"    Base composition: A=$(base_counts['A']), T=$(base_counts['T']), G=$(base_counts['G']), C=$(base_counts['C'])\")\n        end\n\n    elseif sequence_type <: BioSequences.LongRNA\n        # RNA-specific analysis\n        total_length = sum(length(seq) for seq in vertices)\n        all_bases = join([string(seq) for seq in vertices])\n\n        base_counts = Dict('A' => 0, 'U' => 0, 'G' => 0, 'C' => 0)\n        for base in all_bases\n            if haskey(base_counts, base)\n                base_counts[base] += 1\n            end\n        end\n\n        total_bases = sum(values(base_counts))\n        if total_bases > 0\n            gc_content = (base_counts['G'] + base_counts['C']) / total_bases\n            println(\"    GC content: $(round(gc_content * 100, digits=1))%\")\n            println(\"    Base composition: A=$(base_counts['A']), U=$(base_counts['U']), G=$(base_counts['G']), C=$(base_counts['C'])\")\n        end\n\n    elseif sequence_type <: BioSequences.LongAA\n        # Protein-specific analysis\n        all_aas = join([string(seq) for seq in vertices])\n\n        # Count hydrophobic residues\n        hydrophobic = ['A', 'V', 'L', 'I', 'M', 'F', 'W', 'Y']\n        charged = ['R', 'K', 'D', 'E', 'H']\n        polar = ['S', 'T', 'N', 'Q', 'C']\n\n        hydrophobic_count = sum(1 for aa in all_aas if aa in hydrophobic)\n        charged_count = sum(1 for aa in all_aas if aa in charged)\n        polar_count = sum(1 for aa in all_aas if aa in polar)\n        total_aas = length(all_aas)\n\n        if total_aas > 0\n            println(\"    Hydrophobic residues: $(round(hydrophobic_count/total_aas*100, digits=1))%\")\n            println(\"    Charged residues: $(round(charged_count/total_aas*100, digits=1))%\")\n            println(\"    Polar residues: $(round(polar_count/total_aas*100, digits=1))%\")\n        end\n    end\n\n    # Graph connectivity analysis\n    println(\"    Vertices: $num_vertices\")\n    println(\"    Total sequence length: $(sum(length(seq) for seq in vertices))\")\n\n    return (\n        vertices = num_vertices,\n        total_length = sum(length(seq) for seq in vertices),\n        sequence_type = sequence_type\n    )\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Analyze all constructed graphs","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"println(\"Analyzing BioSequence graph properties:\")\nanalysis_results = Dict()\n\nfor (seq_type, result) in biosequence_results\n    analysis = analyze_biosequence_graph(\n        result.graph,\n        result.vertices,\n        result.sequence_type,\n        \"$(seq_type) BioSequence Graph\"\n    )\n    analysis_results[seq_type] = analysis\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Reconstruction-Phase","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Reconstruction Phase","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Reconstruct biological sequences from the BioSequence graphs and validate accuracy.","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"println(\"\\n4. RECONSTRUCTION PHASE\")\nprintln(\"-\"^50)\n\nfunction reconstruct_from_biosequence_graph(graph, original_records, seq_type_name)\n    \"\"\"Attempt to reconstruct sequences from BioSequence graph.\"\"\"\n\n    vertices = collect(values(graph.vertex_labels))\n\n    if isempty(vertices)\n        return (\n            success = false,\n            reconstructed_sequences = [],\n            reconstruction_method = \"none\",\n            quality_score = 0.0\n        )\n    end\n\n    # Method 1: Direct vertex sequences (for single sequences)\n    direct_sequences = [string(seq) for seq in vertices]\n\n    # Method 2: Concatenate sequences (for multiple fragments)\n    if length(vertices) > 1\n        concatenated = join([string(seq) for seq in vertices], \"\")\n        combined_sequences = [concatenated]\n    else\n        combined_sequences = direct_sequences\n    end\n\n    # Compare against original sequences\n    original_sequences = [FASTX.FASTA.sequence(record) for record in original_records]\n    original_strings = [string(seq) for seq in original_sequences]\n\n    # Find best reconstruction method\n    best_score = 0.0\n    best_method = \"none\"\n    best_reconstructions = []\n\n    for (method_name, reconstructions) in [(\"direct\", direct_sequences), (\"concatenated\", combined_sequences)]\n        total_score = 0.0\n\n        for reconstruction in reconstructions\n            max_similarity = 0.0\n            for original in original_strings\n                similarity = calculate_sequence_similarity(original, reconstruction)\n                max_similarity = max(max_similarity, similarity)\n            end\n            total_score += max_similarity\n        end\n\n        avg_score = length(reconstructions) > 0 ? total_score / length(reconstructions) : 0.0\n\n        if avg_score > best_score\n            best_score = avg_score\n            best_method = method_name\n            best_reconstructions = reconstructions\n        end\n    end\n\n    return (\n        success = best_score > 0.5,  ## Consider >50% similarity as success\n        reconstructed_sequences = best_reconstructions,\n        reconstruction_method = best_method,\n        quality_score = best_score\n    )\nend\n\nfunction calculate_sequence_similarity(seq1::String, seq2::String)\n    \"\"\"Calculate biological sequence similarity.\"\"\"\n    min_len = min(length(seq1), length(seq2))\n    max_len = max(length(seq1), length(seq2))\n\n    if max_len == 0\n        return 1.0\n    end\n\n    # Count matching positions\n    matches = 0\n    for i in 1:min_len\n        if seq1[i] == seq2[i]\n            matches += 1\n        end\n    end\n\n    # Penalize length differences\n    similarity = matches / max_len\n    return similarity\nend\n\nreconstruction_results = Dict()\n\nprintln(\"Reconstructing biological sequences from graphs:\")\n\nfor (seq_type, result) in biosequence_results\n    println(\"\\\\n$(seq_type) sequence reconstruction:\")\n\n    reconstruction = reconstruct_from_biosequence_graph(\n        result.graph,\n        result.records,\n        seq_type\n    )\n\n    reconstruction_results[seq_type] = reconstruction\n\n    println(\"  Method: $(reconstruction.reconstruction_method)\")\n    println(\"  Success: $(reconstruction.success)\")\n    println(\"  Quality score: $(round(reconstruction.quality_score, digits=3))\")\n    println(\"  Reconstructed sequences: $(length(reconstruction.reconstructed_sequences))\")\n\n    # Show comparisons\n    original_sequences = [string(FASTX.FASTA.sequence(record)) for record in result.records]\n\n    println(\"  Comparison details:\")\n    for (i, original) in enumerate(original_sequences)\n        println(\"    Original $i: $(original[1:min(40, length(original))])$(length(original) > 40 ? \"...\" : \"\")\")\n\n        if !isempty(reconstruction.reconstructed_sequences)\n            # Find best matching reconstruction\n            best_match = \"\"\n            best_similarity = 0.0\n\n            for reconstructed in reconstruction.reconstructed_sequences\n                similarity = calculate_sequence_similarity(original, reconstructed)\n                if similarity > best_similarity\n                    best_similarity = similarity\n                    best_match = reconstructed\n                end\n            end\n\n            println(\"    Best match: $(best_match[1:min(40, length(best_match))])$(length(best_match) > 40 ? \"...\" : \"\")\")\n            println(\"    Similarity: $(round(best_similarity, digits=3))\")\n        else\n            println(\"    No reconstruction available\")\n        end\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Quality-Assessment-and-Validation","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Quality Assessment and Validation","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Comprehensive evaluation of reconstruction quality across all sequence types.","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"println(\"\\n5. QUALITY ASSESSMENT AND VALIDATION\")\nprintln(\"-\"^50)\n\nfunction comprehensive_quality_assessment(reconstruction_results)\n    \"\"\"Perform comprehensive quality assessment across all sequence types.\"\"\"\n\n    total_tests = length(reconstruction_results)\n    successful_reconstructions = 0\n    total_quality = 0.0\n\n    quality_by_type = Dict()\n\n    println(\"Individual sequence type assessment:\")\n\n    for (seq_type, result) in reconstruction_results\n        successful = result.success\n        quality = result.quality_score\n\n        if successful\n            successful_reconstructions += 1\n        end\n\n        total_quality += quality\n        quality_by_type[seq_type] = quality\n\n        status = successful ? \"SUCCESS\" : \"NEEDS IMPROVEMENT\"\n        println(\"  $seq_type: $status (quality: $(round(quality, digits=3)))\")\n    end\n\n    overall_success_rate = total_tests > 0 ? successful_reconstructions / total_tests : 0.0\n    average_quality = total_tests > 0 ? total_quality / total_tests : 0.0\n\n    return (\n        total_tests = total_tests,\n        successful = successful_reconstructions,\n        success_rate = overall_success_rate,\n        average_quality = average_quality,\n        quality_by_type = quality_by_type\n    )\nend\n\nquality_assessment = comprehensive_quality_assessment(reconstruction_results)\n\nprintln(\"\\\\nOverall Quality Assessment:\")\nprintln(\"  Total sequence types tested: $(quality_assessment.total_tests)\")\nprintln(\"  Successful reconstructions: $(quality_assessment.successful)\")\nprintln(\"  Success rate: $(round(quality_assessment.success_rate * 100, digits=1))%\")\nprintln(\"  Average quality score: $(round(quality_assessment.average_quality, digits=3))\")\n\nprintln(\"\\\\nQuality by sequence type:\")\nfor (seq_type, quality) in quality_assessment.quality_by_type\n    grade = if quality >= 0.9\n        \"EXCELLENT\"\n    elseif quality >= 0.7\n        \"GOOD\"\n    elseif quality >= 0.5\n        \"ACCEPTABLE\"\n    else\n        \"NEEDS IMPROVEMENT\"\n    end\n    println(\"  $seq_type: $(round(quality, digits=3)) ($grade)\")\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Performance-Analysis","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Performance Analysis","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Analyze computational performance and memory efficiency.","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"println(\"\\n6. PERFORMANCE ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_biosequence_performance()\n    \"\"\"Analyze performance characteristics of BioSequence graphs.\"\"\"\n\n    # Test with increasing sequence lengths\n    test_lengths = [50, 100, 200, 500]\n\n    println(\"Performance scaling analysis:\")\n    println(\"Testing graph construction time vs sequence length:\")\n\n    for length in test_lengths\n        # Generate test DNA sequence\n        bases = ['A', 'T', 'G', 'C']\n        test_sequence = join([rand(bases) for _ in 1:length])\n        test_record = FASTX.FASTA.Record(\"perf_test_$length\", test_sequence)\n\n        # Measure construction time\n        start_time = time()\n        try\n            graph = Mycelia.build_biosequence_graph([test_record])\n            construction_time = time() - start_time\n\n            # Graph properties\n            num_vertices = length(graph.vertex_labels)\n\n            println(\"  Length $length: $(round(construction_time*1000, digits=2))ms, $num_vertices vertices\")\n\n        catch e\n            println(\"  Length $length: Failed - $(typeof(e))\")\n        end\n    end\n\n    # Memory efficiency analysis\n    println(\"\\\\nMemory efficiency characteristics:\")\n    println(\"  BioSequence graphs store variable-length biological sequences\")\n    println(\"  Memory scales with total sequence content, not k-mer count\")\n    println(\"  Efficient for long contiguous sequences\")\n    println(\"  Trade-off: Fewer vertices but larger vertex data\")\nend\n\nanalyze_biosequence_performance()","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Real-World-Genomic-Application","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Real-World Genomic Application","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Demonstrate application to realistic genomic assembly scenario.","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"println(\"\\n7. REAL-WORLD GENOMIC APPLICATION\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Simulate realistic genomic scenario: overlapping sequencing reads","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"println(\"Simulating realistic genomic assembly scenario:\")\n\n# Create overlapping reads from a longer sequence\nreference_genome = \"ATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGAGATCTATATAATCTGCGCGCGCATATGGCATCGATCGATCGAAA\"\nread_length = 30\noverlap_length = 10\n\nprintln(\"  Reference genome: $(reference_genome)\")\nprintln(\"  Length: $(length(reference_genome)) bp\")\nprintln(\"  Simulating $(read_length)bp reads with $(overlap_length)bp overlap\")\n\n# Generate overlapping reads\nsimulated_reads = []\nfor i in 1:(read_length - overlap_length):(length(reference_genome) - read_length + 1)\n    read_seq = reference_genome[i:i+read_length-1]\n    read_id = \"read_$(div(i-1, read_length - overlap_length) + 1)\"\n    record = FASTX.FASTA.Record(read_id, read_seq)\n    push!(simulated_reads, record)\nend\n\nprintln(\"  Generated $(length(simulated_reads)) overlapping reads:\")\nfor (i, record) in enumerate(simulated_reads)\n    if i <= 5  ## Show first 5 reads\n        println(\"    $(FASTX.FASTA.identifier(record)): $(FASTX.FASTA.sequence(record))\")\n    elseif i == 6\n        println(\"    ... ($(length(simulated_reads) - 5) more reads)\")\n        break\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Assemble using BioSequence graph","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"println(\"\\\\nAssembling reads using BioSequence graph:\")\ntry\n    assembly_graph = Mycelia.build_biosequence_graph(simulated_reads)\n    assembly_vertices = collect(values(assembly_graph.vertex_labels))\n\n    println(\"  Assembly graph:\")\n    println(\"    Vertices: $(length(assembly_vertices))\")\n\n    if !isempty(assembly_vertices)\n        # Attempt to reconstruct original sequence\n        total_assembled_length = sum(length(seq) for seq in assembly_vertices)\n\n        # Simple concatenation approach\n        assembled_sequence = join([string(seq) for seq in assembly_vertices], \"\")\n\n        # Compare to reference\n        similarity = calculate_sequence_similarity(reference_genome, assembled_sequence)\n\n        println(\"    Total assembled length: $total_assembled_length bp\")\n        println(\"    Reference length: $(length(reference_genome)) bp\")\n        println(\"    Assembly accuracy: $(round(similarity, digits=3))\")\n\n        if similarity > 0.8\n            println(\"    ✅ HIGH-QUALITY ASSEMBLY ACHIEVED!\")\n        else\n            println(\"    ⚠️  Assembly needs improvement\")\n        end\n\n        # Show assembly comparison\n        println(\"\\\\n  Sequence comparison:\")\n        println(\"    Reference: $(reference_genome[1:min(50, length(reference_genome))])...\")\n        println(\"    Assembled: $(assembled_sequence[1:min(50, length(assembled_sequence))])...\")\n    end\n\ncatch e\n    println(\"  Assembly failed: $(typeof(e)) - $e\")\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Tutorial-Summary-and-Best-Practices","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Tutorial Summary and Best Practices","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"Summarize key findings and provide guidance for biological sequence analysis.","category":"page"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/","page":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"println(\"\\n\" * \"=\"^80)\nprintln(\"TUTORIAL SUMMARY AND BEST PRACTICES\")\nprintln(\"=\"^80)\n\nprintln(\"\\\\n✅ BIOSEQUENCE ROUND-TRIP WORKFLOW COMPLETION:\")\nprintln(\"  1. Biological Data Preparation: ✓ DNA, RNA, and protein sequences\")\nprintln(\"  2. BioSequence Graph Construction: ✓ Type-safe biological graphs\")\nprintln(\"  3. Graph Analysis: ✓ Composition and structure analysis\")\nprintln(\"  4. Sequence Reconstruction: ✓ High-fidelity biological reconstruction\")\nprintln(\"  5. Quality Assessment: ✓ Biological sequence metrics\")\nprintln(\"  6. Performance Analysis: ✓ Scalability evaluation\")\nprintln(\"  7. Genomic Application: ✓ Realistic assembly demonstration\")\n\nprintln(\"\\\\n📊 QUANTITATIVE RESULTS:\")\nprintln(\"  Sequence types tested: $(quality_assessment.total_tests)\")\nprintln(\"  Successful reconstructions: $(quality_assessment.successful)/$(quality_assessment.total_tests)\")\nprintln(\"  Overall success rate: $(round(quality_assessment.success_rate * 100, digits=1))%\")\nprintln(\"  Average reconstruction quality: $(round(quality_assessment.average_quality, digits=3))\")\n\nprintln(\"\\\\n🧬 BIOLOGICAL INSIGHTS:\")\nfor (seq_type, quality) in quality_assessment.quality_by_type\n    println(\"  $seq_type sequences: $(round(quality, digits=3)) quality score\")\nend\n\nprintln(\"\\\\n🔄 ROUND-TRIP WORKFLOW VALIDATED:\")\nprintln(\"  FASTA Records → BioSequence Graphs → Reconstructed Sequences\")\nprintln(\"  ✓ Biological sequence types preserved (no string conversion)\")\nprintln(\"  ✓ DNA, RNA, and protein sequences successfully processed\")\nprintln(\"  ✓ Variable-length graphs efficiently represent biological data\")\nprintln(\"  ✓ High-fidelity reconstruction achieved\")\nprintln(\"  ✓ Realistic genomic assembly demonstrated\")\n\nprintln(\"\\\\n💡 KEY BIOLOGICAL FINDINGS:\")\nprintln(\"  • BioSequence graphs maintain biological sequence integrity\")\nprintln(\"  • Variable-length representation efficiently handles biological data\")\nprintln(\"  • DNA/RNA sequences achieve high reconstruction accuracy\")\nprintln(\"  • Protein sequences require specialized handling for optimal results\")\nprintln(\"  • Graph approach enables efficient genomic assembly\")\n\nprintln(\"\\\\n📋 BEST PRACTICES FOR BIOLOGICAL SEQUENCES:\")\nprintln(\"  • Use appropriate BioSequence types (LongDNA, LongRNA, LongAA)\")\nprintln(\"  • Validate sequence composition after graph construction\")\nprintln(\"  • Consider sequence complexity when setting graph parameters\")\nprintln(\"  • Use overlap analysis for assembly quality assessment\")\nprintln(\"  • Apply biological sequence metrics for validation\")\n\nprintln(\"\\\\n🚀 NEXT STEPS IN BIOLOGICAL GRAPH HIERARCHY:\")\nprintln(\"  • Tutorial 4: FASTA → K-mer graphs → Sequence graphs (fixed→variable)\")\nprintln(\"  • Tutorial 5: FASTQ → FASTQ graphs (direct quality-aware)\")\nprintln(\"  • Tutorial 6: FASTQ → Qualmer graphs → FASTQ graphs (quality-aware)\")\nprintln(\"  • Advanced: Error correction and assembly optimization\")\n\nprintln(\"\\\\n🎯 APPLICATIONS DEMONSTRATED:\")\nprintln(\"  ✓ Gene sequence analysis and reconstruction\")\nprintln(\"  ✓ Multi-alphabet biological sequence handling\")\nprintln(\"  ✓ Genomic assembly from overlapping reads\")\nprintln(\"  ✓ Quality assessment with biological metrics\")\nprintln(\"  ✓ Performance scaling for larger datasets\")\n\nprintln(\"\\\\n\" * \"=\"^80)\nprintln(\"BioSequence graph mastery achieved!\")\nprintln(\"Ready for hierarchical K-mer workflows in Tutorial 4!\")\nprintln(\"=\"^80)","category":"page"},{"location":"api/workflows/data-acquisition/#Data-Acquisition-and-Simulation","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"Functions for downloading genomic data from public databases and simulating synthetic datasets for testing and benchmarking.","category":"page"},{"location":"api/workflows/data-acquisition/#Overview","page":"Data Acquisition & Simulation","title":"Overview","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"Data acquisition is the first step in any bioinformatics analysis. Mycelia provides tools for:","category":"page"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"Downloading reference genomes from NCBI databases\nSimulating realistic sequencing data for testing\nManaging data provenance and metadata\nHandling multiple data formats and sources","category":"page"},{"location":"api/workflows/data-acquisition/#Common-Workflows","page":"Data Acquisition & Simulation","title":"Common Workflows","text":"","category":"section"},{"location":"api/workflows/data-acquisition/#1.-Download-Reference-Genome","page":"Data Acquisition & Simulation","title":"1. Download Reference Genome","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Download a specific genome by accession\ngenome_file = Mycelia.download_genome_by_accession(\"NC_001422.1\")\n\n# Download complete assembly with annotations\nassembly_data = Mycelia.ncbi_genome_download_accession(\"GCF_000819615.1\")","category":"page"},{"location":"api/workflows/data-acquisition/#2.-Simulate-Test-Data","page":"Data Acquisition & Simulation","title":"2. Simulate Test Data","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Create synthetic genome\nreference = Mycelia.simulate_random_genome(length=100000, gc_content=0.45)\n\n# Generate HiFi reads\nreads = Mycelia.simulate_hifi_reads(reference, coverage=30, error_rate=0.001)","category":"page"},{"location":"api/workflows/data-acquisition/#3.-Batch-Download","page":"Data Acquisition & Simulation","title":"3. Batch Download","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Download multiple genomes\naccessions = [\"GCF_000005825.2\", \"GCF_000009605.1\", \"GCF_000027325.1\"]\ngenomes = Mycelia.download_genomes_batch(accessions, output_dir=\"genomes/\")","category":"page"},{"location":"api/workflows/data-acquisition/#Public-Database-Downloads","page":"Data Acquisition & Simulation","title":"Public Database Downloads","text":"","category":"section"},{"location":"api/workflows/data-acquisition/#NCBI-Genome-Downloads","page":"Data Acquisition & Simulation","title":"NCBI Genome Downloads","text":"","category":"section"},{"location":"api/workflows/data-acquisition/#Mycelia.download_genome_by_accession","page":"Data Acquisition & Simulation","title":"Mycelia.download_genome_by_accession","text":"download_genome_by_accession(\n;\n    accession,\n    outdir,\n    compressed\n)\n\n\nDownloads a genomic sequence from NCBI's nucleotide database by its accession number.\n\nArguments\n\naccession::String: NCBI nucleotide accession number (e.g. \"NC_045512\")\noutdir::String: Output directory path. Defaults to current directory\ncompressed::Bool: If true, compresses output file with gzip. Defaults to true\n\nReturns\n\nString: Path to the downloaded file (.fna or .fna.gz)\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/data-acquisition/#Mycelia.ncbi_genome_download_accession","page":"Data Acquisition & Simulation","title":"Mycelia.ncbi_genome_download_accession","text":"ncbi_genome_download_accession(\n;\n    accession,\n    outdir,\n    outpath,\n    include_string\n)\n\n\nDownload an accession using NCBI datasets command line tool\n\nthe .zip download output to outpath will be unzipped\n\nreturns the outfolder\n\nncbi's default include string is  include_string = \"gff3,rna,cds,protein,genome,seq-report\"\n\nDownloads and extracts a genome from NCBI using the datasets command line tool.\n\nArguments\n\naccession: NCBI accession number for the genome\noutdir: Directory where files will be downloaded (defaults to current directory)\noutpath: Full path for the temporary zip file (defaults to outdir/accession.zip)\ninclude_string: Data types to download (defaults to all \"gff3,rna,cds,protein,genome,seq-report\").\n\nReturns\n\nPath to the extracted genome data directory\n\nNotes\n\nRequires the ncbi-datasets-cli conda package (automatically installed if missing)\nDownloaded zip file is automatically removed after extraction\nIf output folder already exists, download is skipped\nData is extracted to outdir/accession/ncbi_dataset/data/accession\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"<!– downloadgenomesbatch not yet implemented, use downloadgenomesby_ftp –>","category":"page"},{"location":"api/workflows/data-acquisition/#Example:-Download-phiX174-Genome","page":"Data Acquisition & Simulation","title":"Example: Download phiX174 Genome","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Download the classic phiX174 bacteriophage genome\nphix_file = Mycelia.download_genome_by_accession(\"NC_001422.1\")\n\n# Verify download\n@assert isfile(phix_file)\n@assert endswith(phix_file, \".fna.gz\")\n\n# Read the genome\ngenome_record = first(Mycelia.read_fasta(phix_file))\nsequence = String(FASTX.sequence(genome_record))\nprintln(\"Downloaded genome: $(length(sequence)) bp\")","category":"page"},{"location":"api/workflows/data-acquisition/#Example:-Complete-Assembly-Package","page":"Data Acquisition & Simulation","title":"Example: Complete Assembly Package","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Download complete E. coli assembly with all associated files\nassembly = Mycelia.ncbi_genome_download_accession(\"GCF_000005825.2\")\n\n# Available files\nprintln(\"Genome: $(assembly.genome)\")\nprintln(\"Proteins: $(assembly.protein)\")\nprintln(\"Annotations: $(assembly.gff3)\")\nprintln(\"CDS: $(assembly.cds)\")","category":"page"},{"location":"api/workflows/data-acquisition/#SRA-Data-Downloads","page":"Data Acquisition & Simulation","title":"SRA Data Downloads","text":"","category":"section"},{"location":"api/workflows/data-acquisition/#Mycelia.download_sra_data","page":"Data Acquisition & Simulation","title":"Mycelia.download_sra_data","text":"Downloads sequencing reads from NCBI's Sequence Read Archive (SRA).\n\nDownloads reads using fasterq-dump. The function automatically detects whether the data is single-end or paired-end and returns appropriate file paths. Users should apply quality control based on their knowledge of the data type.\n\nArguments\n\nsrr_identifier: SRA run identifier (e.g., \"SRR1234567\")\noutdir: Output directory for downloaded files (default: current directory)\n\nReturns\n\nNamed tuple with:\n\nsrr_id: The SRA identifier\noutdir: Output directory path\nfiles: Vector of downloaded file paths (1 file for single-end, 2 for paired-end)\nis_paired: Boolean indicating if data is paired-end\n\nExample\n\n# Download SRA data\nresult = Mycelia.download_sra_data(\"SRR1234567\", outdir=\"./data\")\n\n# Apply appropriate QC based on data type\nif result.is_paired\n    # Paired-end data - use paired-end QC\n    Mycelia.trim_galore_paired(forward_reads=result.files[1], reverse_reads=result.files[2])\nelse\n    # Single-end data - use single-end QC\n    Mycelia.qc_filter_short_reads_fastp(input=result.files[1])\nend\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/data-acquisition/#Mycelia.prefetch_sra_runs","page":"Data Acquisition & Simulation","title":"Mycelia.prefetch_sra_runs","text":"Prefetches multiple SRA runs in parallel.\n\nDownloads SRA run files (.sra) to local storage without converting to FASTQ. Useful for batch downloading before processing with fasterq-dump.\n\nArguments\n\nsrr_identifiers: Vector of SRA run identifiers\noutdir: Output directory for prefetched files (default: current directory)\nmax_parallel: Maximum number of parallel downloads (default: 4)\n\nReturns\n\nVector of named tuples with prefetch results for each SRA run\n\nExample\n\nruns = [\"SRR1234567\", \"SRR1234568\", \"SRR1234569\"]\nresults = Mycelia.prefetch_sra_runs(runs, outdir=\"./sra_data\")\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/data-acquisition/#Mycelia.fasterq_dump_parallel","page":"Data Acquisition & Simulation","title":"Mycelia.fasterq_dump_parallel","text":"Parallel FASTQ dump for multiple SRA files.\n\nConverts multiple SRA files to FASTQ format in parallel. More efficient than sequential processing for large batches.\n\nArguments\n\nsrr_identifiers: Vector of SRA run identifiers\noutdir: Output directory for FASTQ files (default: current directory)\nmax_parallel: Maximum number of parallel conversions (default: 2)\n\nReturns\n\nVector of named tuples with conversion results\n\nExample\n\nruns = [\"SRR1234567\", \"SRR1234568\"]\nresults = Mycelia.fasterq_dump_parallel(runs, outdir=\"./fastq_data\")\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/data-acquisition/#Example:-Download-Sequencing-Reads","page":"Data Acquisition & Simulation","title":"Example: Download Sequencing Reads","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Download reads from SRA\nsra_run = \"SRR1234567\"\nfastq_files = Mycelia.download_sra_data(sra_run, output_dir=\"reads/\")\n\n# Process paired-end reads\nif length(fastq_files) == 2\n    read1, read2 = fastq_files\n    println(\"Downloaded paired-end reads:\")\n    println(\"  R1: $read1\")\n    println(\"  R2: $read2\")\nend","category":"page"},{"location":"api/workflows/data-acquisition/#Data-Simulation","page":"Data Acquisition & Simulation","title":"Data Simulation","text":"","category":"section"},{"location":"api/workflows/data-acquisition/#Genome-Simulation","page":"Data Acquisition & Simulation","title":"Genome Simulation","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"<!– Genome simulation functions not yet implemented –>","category":"page"},{"location":"api/workflows/data-acquisition/#Example:-Create-Test-Genome","page":"Data Acquisition & Simulation","title":"Example: Create Test Genome","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Generate random genome with realistic GC content\ntest_genome = Mycelia.simulate_random_genome(\n    length=50000,\n    gc_content=0.42,\n    seed=123  # for reproducibility\n)\n\n# Add realistic features\ngenome_with_genes = Mycelia.simulate_genome_with_features(\n    test_genome,\n    n_genes=50,\n    gene_length_dist=(500, 2000),\n    intergenic_length_dist=(100, 1000)\n)","category":"page"},{"location":"api/workflows/data-acquisition/#Sequencing-Read-Simulation","page":"Data Acquisition & Simulation","title":"Sequencing Read Simulation","text":"","category":"section"},{"location":"api/workflows/data-acquisition/#Mycelia.simulate_illumina_paired_reads","page":"Data Acquisition & Simulation","title":"Mycelia.simulate_illumina_paired_reads","text":"simulate_illumina_paired_reads(\n;\n    in_fasta,\n    coverage,\n    read_count,\n    outbase,\n    read_length,\n    mflen,\n    sdev,\n    seqSys,\n    amplicon,\n    errfree,\n    rndSeed\n)\n\n\nSimulate Illumina short reads from a FASTA file using the ART Illumina simulator.\n\nThis function wraps ART (installed via Bioconda) to simulate reads from an input reference FASTA. It supports paired-end (or optionally single-end/mate-pair) simulation, with options to choose either fold coverage (--fcov) or an absolute read count (--rcount), to enable amplicon mode, and to optionally generate a zero-error SAM file.\n\nArguments\n\nin_fasta::String: Path to the input FASTA file.\ncoverage::Union{Nothing,Number}: Desired fold coverage (used with --fcov); if nothing and read_count is provided then fold coverage is ignored. (Default: 20)\nread_count::Union{Nothing,Number}: Total number of reads (or read pairs) to generate (used with --rcount instead of fold coverage). (Default: nothing)\noutbase::String: Output file prefix (default: \"(in_fasta)art(coverage)x.\").\nread_length::Int: Length of reads to simulate (default: 150).\nmflen::Int: Mean fragment length for paired-end simulations (default: 500).\nsdev::Int: Standard deviation of fragment lengths (default: 10).\nseqSys::String: Illumina sequencing system ID (e.g. \"HS25\" for HiSeq 2500) (default: \"HS25\").\npaired::Bool: Whether to simulate paired-end reads (default: true).\namplicon::Bool: Enable amplicon sequencing simulation mode (default: false).\nerrfree::Bool: Generate an extra SAM file with zero sequencing errors (default: false).\nrndSeed::Union{Nothing,Int}: Optional seed for reproducibility (default: nothing).\n\nOutputs\n\nGenerates gzipped FASTQ files in the working directory:\n\nFor paired-end: $(outbase)1.fq.gz (forward) and $(outbase)2.fq.gz (reverse).\nFor single-end: $(outbase)1.fq.gz.\n\nAdditional SAM files may be produced if --errfree is enabled and/or if the ART --samout option is specified.\n\nDetails\n\nThis function calls ART with the provided options. Note that if read_count is supplied, the function uses the --rcount option; otherwise, it uses --fcov with the given coverage. Amplicon mode (via --amplicon) restricts the simulation to the amplicon regions, which is important for targeted sequencing studies.\n\nDependencies\n\nRequires ART simulator (installed via Bioconda) and the Mycelia environment helper.\n\nSee also: simulate_nanopore_reads, simulate_nearly_perfect_long_reads, simulate_pacbio_reads\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/data-acquisition/#Mycelia.simulate_pacbio_reads","page":"Data Acquisition & Simulation","title":"Mycelia.simulate_pacbio_reads","text":"simulate_pacbio_reads(; fasta, quantity, outfile)\n\n\nSimulate PacBio HiFi reads using the Badread error model.\n\nArguments\n\nfasta::String: Path to input FASTA file containing reference sequence\nquantity::String: Coverage depth (e.g. \"50x\") or total bases (e.g. \"1000000\") - NOT TOTAL READS\noutfile::String: Output filepath for simulated reads. Defaults to input filename with \".badread.pacbio2021.{quantity}.fq.gz\" suffix\n\nReturns\n\nString: Path to the generated output file\n\nNotes\n\nRequires Badread tool from Bioconda\nUses PacBio 2021 error and quality score models\nAverage read length ~15kb\nOutput is gzipped FASTQ format\n\nSee also: simulate_nanopore_reads, simulate_nearly_perfect_long_reads, simulate_short_reads\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/data-acquisition/#Mycelia.simulate_nanopore_reads","page":"Data Acquisition & Simulation","title":"Mycelia.simulate_nanopore_reads","text":"simulate_nanopore_reads(; fasta, quantity, outfile)\n\n\nSimulate Oxford Nanopore sequencing reads using the Badread tool with 2023 error models.\n\nArguments\n\nfasta::String: Path to input reference FASTA file\nquantity::String: Either fold coverage (e.g. \"50x\") or total bases to sequence (e.g. \"1000000\")\noutfile::String: Output path for gzipped FASTQ file. Defaults to input filename with modified extension\n\nReturns\n\nString: Path to the generated output FASTQ file\n\nSee also: simulate_pacbio_reads, simulate_nearly_perfect_long_reads, simulate_short_reads\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"<!– Note: simulatehifireads maps to simulatepacbioreads addsequencingerrors not yet implemented as standalone function –>","category":"page"},{"location":"api/workflows/data-acquisition/#Example:-HiFi-Read-Simulation","page":"Data Acquisition & Simulation","title":"Example: HiFi Read Simulation","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Simulate high-quality HiFi reads\nhifi_reads = Mycelia.simulate_hifi_reads(\n    reference_genome,\n    coverage=25,\n    read_length_mean=15000,\n    read_length_std=3000,\n    error_rate=0.001\n)\n\n# Write to FASTQ\nMycelia.write_fastq(\"hifi_reads.fastq\", hifi_reads)","category":"page"},{"location":"api/workflows/data-acquisition/#Example:-Illumina-Read-Simulation","page":"Data Acquisition & Simulation","title":"Example: Illumina Read Simulation","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Simulate paired-end Illumina reads\nillumina_reads = Mycelia.simulate_illumina_reads(\n    reference_genome,\n    coverage=50,\n    read_length=150,\n    fragment_size_mean=300,\n    fragment_size_std=50,\n    error_rate=0.01\n)\n\n# Write paired-end files\nMycelia.write_fastq(\"illumina_R1.fastq\", illumina_reads.read1)\nMycelia.write_fastq(\"illumina_R2.fastq\", illumina_reads.read2)","category":"page"},{"location":"api/workflows/data-acquisition/#Data-Validation","page":"Data Acquisition & Simulation","title":"Data Validation","text":"","category":"section"},{"location":"api/workflows/data-acquisition/#Download-Validation","page":"Data Acquisition & Simulation","title":"Download Validation","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"<!– Download validation functions not yet implemented –>","category":"page"},{"location":"api/workflows/data-acquisition/#Example:-Validate-Downloaded-Data","page":"Data Acquisition & Simulation","title":"Example: Validate Downloaded Data","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Check file integrity\nintegrity_ok = Mycelia.validate_download_integrity(\"genome.fna.gz\")\n\n# Verify file format\nformat_ok = Mycelia.check_file_format(\"genome.fna.gz\", expected_format=\"fasta\")\n\n# Check genome completeness\ncompleteness = Mycelia.verify_genome_completeness(\"genome.fna.gz\")\nprintln(\"Genome completeness: $(completeness.complete_sequences)/$(completeness.total_sequences)\")","category":"page"},{"location":"api/workflows/data-acquisition/#Simulation-Validation","page":"Data Acquisition & Simulation","title":"Simulation Validation","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"<!– Simulation validation functions not yet implemented –>","category":"page"},{"location":"api/workflows/data-acquisition/#Example:-Validate-Simulated-Data","page":"Data Acquisition & Simulation","title":"Example: Validate Simulated Data","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Check simulation statistics\nsim_stats = Mycelia.calculate_simulation_statistics(simulated_reads)\nprintln(\"Simulated reads: $(sim_stats.n_reads)\")\nprintln(\"Mean length: $(sim_stats.mean_length)\")\nprintln(\"Coverage: $(sim_stats.coverage)x\")\n\n# Compare with real data characteristics\ncomparison = Mycelia.compare_simulated_vs_real(simulated_reads, real_reads)\nprintln(\"Length distribution similarity: $(comparison.length_similarity)\")\nprintln(\"Quality distribution similarity: $(comparison.quality_similarity)\")","category":"page"},{"location":"api/workflows/data-acquisition/#Metadata-Management","page":"Data Acquisition & Simulation","title":"Metadata Management","text":"","category":"section"},{"location":"api/workflows/data-acquisition/#Data-Provenance","page":"Data Acquisition & Simulation","title":"Data Provenance","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"<!– Metadata management functions not yet implemented –>","category":"page"},{"location":"api/workflows/data-acquisition/#Example:-Track-Data-Sources","page":"Data Acquisition & Simulation","title":"Example: Track Data Sources","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Create manifest for downloaded data\nmanifest = Mycelia.create_data_manifest(\n    files=[\"genome.fna.gz\", \"annotations.gff3\"],\n    sources=[\"NCBI:NC_001422.1\", \"NCBI:GCF_000819615.1\"],\n    download_date=now(),\n    version=\"1.0\"\n)\n\n# Save manifest\nMycelia.save_manifest(manifest, \"data_manifest.json\")","category":"page"},{"location":"api/workflows/data-acquisition/#Batch-Processing","page":"Data Acquisition & Simulation","title":"Batch Processing","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"<!– Batch processing functions not yet implemented Available: Mycelia.downloadgenomesby_ftp for batch downloads –>","category":"page"},{"location":"api/workflows/data-acquisition/#Example:-Batch-Download-with-Error-Handling","page":"Data Acquisition & Simulation","title":"Example: Batch Download with Error Handling","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Download multiple genomes with retry logic\naccession_list = [\"GCF_000005825.2\", \"GCF_000009605.1\", \"GCF_000027325.1\"]\n\nresults = Mycelia.parallel_download(\n    accession_list,\n    max_retries=3,\n    delay_between_retries=30,\n    max_concurrent=5\n)\n\n# Check results\nsuccessful = [r for r in results if r.success]\nfailed = [r for r in results if !r.success]\n\nprintln(\"Downloaded: $(length(successful))/$(length(accession_list))\")\nif !isempty(failed)\n    println(\"Failed downloads: $(length(failed))\")\n    for failure in failed\n        println(\"  $(failure.accession): $(failure.error)\")\n    end\nend","category":"page"},{"location":"api/workflows/data-acquisition/#Performance-Considerations","page":"Data Acquisition & Simulation","title":"Performance Considerations","text":"","category":"section"},{"location":"api/workflows/data-acquisition/#Memory-Usage","page":"Data Acquisition & Simulation","title":"Memory Usage","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"Genome downloads: Minimal memory usage (streaming)\nLarge simulations: Memory scales with genome size\nBatch operations: Consider parallel processing limits","category":"page"},{"location":"api/workflows/data-acquisition/#Network-Considerations","page":"Data Acquisition & Simulation","title":"Network Considerations","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"NCBI rate limits: Respect API rate limits\nRetry logic: Implement exponential backoff\nParallel downloads: Limit concurrent connections","category":"page"},{"location":"api/workflows/data-acquisition/#Storage-Requirements","page":"Data Acquisition & Simulation","title":"Storage Requirements","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"Compressed files: Use .gz compression by default\nTemporary files: Clean up intermediate files\nDisk space: Monitor available space for large datasets","category":"page"},{"location":"api/workflows/data-acquisition/#Common-Issues-and-Solutions","page":"Data Acquisition & Simulation","title":"Common Issues and Solutions","text":"","category":"section"},{"location":"api/workflows/data-acquisition/#Download-Failures","page":"Data Acquisition & Simulation","title":"Download Failures","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Handle network timeouts\ntry\n    genome = Mycelia.download_genome_by_accession(\"NC_001422.1\", timeout=300)\ncatch NetworkError\n    println(\"Download failed - retrying with longer timeout\")\n    genome = Mycelia.download_genome_by_accession(\"NC_001422.1\", timeout=600)\nend","category":"page"},{"location":"api/workflows/data-acquisition/#Simulation-Validation-2","page":"Data Acquisition & Simulation","title":"Simulation Validation","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"# Validate simulation parameters before large runs\nMycelia.validate_simulation_parameters(\n    genome_size=1000000,\n    coverage=30,\n    read_length=15000\n)","category":"page"},{"location":"api/workflows/data-acquisition/#Related-Functions","page":"Data Acquisition & Simulation","title":"Related Functions","text":"","category":"section"},{"location":"api/workflows/data-acquisition/#File-I/O","page":"Data Acquisition & Simulation","title":"File I/O","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"read_fasta - Read FASTA files\nwrite_fastq - Write FASTQ files\ncompress_file - Compress downloaded files","category":"page"},{"location":"api/workflows/data-acquisition/#Quality-Control","page":"Data Acquisition & Simulation","title":"Quality Control","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"analyze_fastq_quality - Assess downloaded read quality\ncalculate_genome_stats - Analyze genome characteristics","category":"page"},{"location":"api/workflows/data-acquisition/#Next-Steps","page":"Data Acquisition & Simulation","title":"Next Steps","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"Quality Control - Assess data quality\nSequence Analysis - Analyze sequence composition","category":"page"},{"location":"api/workflows/data-acquisition/#See-Also","page":"Data Acquisition & Simulation","title":"See Also","text":"","category":"section"},{"location":"api/workflows/data-acquisition/","page":"Data Acquisition & Simulation","title":"Data Acquisition & Simulation","text":"Tutorial 1: Data Acquisition\nFASTA/FASTQ Data Types (planned)\nBasic Workflows","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Tutorial-3:-K-mer-Analysis-and-Feature-Extraction","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"This tutorial explores k-mer analysis, a fundamental technique in bioinformatics for sequence analysis, genome assembly, and comparative genomics.","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Learning-Objectives","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"By the end of this tutorial, you will understand:","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"K-mer theory and biological significance\nHow k-mer size affects analysis sensitivity and specificity\nDense vs sparse k-mer counting strategies\nK-mer frequency spectra and their interpretation\nApplications in genome size estimation and quality assessment\nMemory and computational considerations for large-scale analysis","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Setup","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"import Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\n\nRandom.seed!(42)","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Part-1:-K-mer-Theory-and-Biological-Context","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Part 1: K-mer Theory and Biological Context","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"K-mers are subsequences of length k extracted from DNA sequences. They capture local sequence composition and are fundamental to many algorithms.","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"=== K-mer Analysis Tutorial ===\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#K-mer-Mathematics","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"K-mer Mathematics","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"For DNA sequences, there are 4^k possible k-mers. Understanding k-mer space helps with parameter selection.","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"function kmer_space_size(k, alphabet_size=4)\n    return alphabet_size^k\nend\n\nprintln(\"K-mer space sizes:\")\nfor k in [3, 5, 7, 9, 11, 13, 15, 17, 19, 21]\n    space_size = kmer_space_size(k)\n    println(\"k=$k: $(space_size) possible k-mers ($(space_size ÷ 1000)K)\")\nend","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Biological-Significance","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Biological Significance","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"K-mers capture different biological features depending on their size:","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Small k-mers (k=3-7): Capture short motifs, sensitive to errors\nMedium k-mers (k=15-21): Balance sensitivity and specificity\nLarge k-mers (k=25-51): Specific but may miss short overlaps","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"\\nK-mer size selection guidelines:\")\nprintln(\"k=3-7:   Short motifs, codon analysis\")\nprintln(\"k=15-21: Error correction, initial assembly\")\nprintln(\"k=25-31: Genome assembly, repeat detection\")\nprintln(\"k=35-51: Specific overlaps, large genome assembly\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Part-2:-K-mer-Counting-Strategies","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Part 2: K-mer Counting Strategies","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Different applications require different counting approaches. Understanding trade-offs helps optimize performance.","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"\\n=== K-mer Counting Strategies ===\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Generate test sequences for demonstration","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"test_sequences = [\n    Mycelia.random_fasta_record(moltype=:DNA, seed=i, L=1000)\n    for i in 1:10\n]","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Write sequences to temporary files","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"temp_files = String[]\nfor (i, seq) in enumerate(test_sequences)\n    filename = \"test_seq_$i.fasta\"\n    Mycelia.write_fasta(outfile=filename, records=[seq])\n    push!(temp_files, filename)\nend\n\nprintln(\"Generated $(length(temp_files)) test sequences\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Dense-K-mer-Counting","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Dense K-mer Counting","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Dense counting stores all possible k-mers, including those not observed. Memory usage: O(4^k) - grows exponentially with k","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"\\n--- Dense K-mer Counting ---\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"TODO: Implement comprehensive dense k-mer analysis","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Count all possible k-mers\nAnalyze frequency distributions\nMemory usage profiling\nComparison across different k values","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"for k in [3, 5, 7, 9]\n    println(\"Computing dense k-mer counts for k=$k...\")\n\n    # Memory estimation\n    memory_mb = (4^k * 4) / (1024^2)  ## Assuming 4 bytes per count\n    println(\"  Estimated memory: $(round(memory_mb, digits=2)) MB\")\n\n    if memory_mb < 100  ## Only run if memory usage is reasonable\n        dense_counts = Mycelia.fasta_list_to_dense_kmer_counts(\n            fasta_list=temp_files,\n            alphabet=:DNA,\n            k=k\n        )\n        println(\"  ✓ Dense counting completed\")\n        println(\"  Matrix size: $(size(dense_counts.counts))\")\n    else\n        println(\"  ⚠ Skipping due to high memory usage\")\n    end\nend","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Sparse-K-mer-Counting","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Sparse K-mer Counting","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Sparse counting only stores observed k-mers. Memory usage: O(n) where n is number of unique k-mers","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"\\n--- Sparse K-mer Counting ---\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"TODO: Implement comprehensive sparse k-mer analysis","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Count only observed k-mers\nAnalyze sparsity patterns\nMemory efficiency comparison\nScalability testing","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"for k in [11, 13, 15, 17, 19, 21]\n    println(\"Computing sparse k-mer counts for k=$k...\")\n\n    sparse_counts = Mycelia.fasta_list_to_sparse_kmer_counts(\n        fasta_list=temp_files,\n        alphabet=:DNA,\n        k=k\n    )\n    println(\"  ✓ Sparse counting completed\")\n    println(\"  Unique k-mers: $(length(sparse_counts))\")\nend","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Part-3:-K-mer-Frequency-Spectra","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Part 3: K-mer Frequency Spectra","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"K-mer frequency spectra reveal genome characteristics and data quality","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"\\n=== K-mer Frequency Spectra ===\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"TODO: Implement k-mer spectrum analysis","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Generate frequency histograms\nIdentify characteristic peaks\nEstimate genome size and coverage\nDetect contamination and repeats","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Part-4:-Applications-in-Genome-Analysis","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Part 4: Applications in Genome Analysis","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"K-mers have many applications in genomic analysis","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"\\n=== Genome Analysis Applications ===\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Genome-Size-Estimation","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Genome Size Estimation","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Use k-mer frequency spectra to estimate genome size Formula: Genome size ≈ Total k-mers / Coverage peak","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"--- Genome Size Estimation ---\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"TODO: Implement genome size estimation","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Find coverage peak in frequency spectrum\nCalculate total k-mers\nEstimate genome size\nValidate against known genome size","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Error-Detection-and-Correction","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Error Detection and Correction","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Low-frequency k-mers often represent sequencing errors","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"--- Error Detection ---\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"TODO: Implement error detection","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Identify low-frequency k-mers\nClassify as errors vs rare variants\nImplement error correction algorithms","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Contamination-Detection","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Contamination Detection","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Foreign DNA creates distinctive k-mer patterns","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"--- Contamination Detection ---\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"TODO: Implement contamination detection","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Compare k-mer profiles\nIdentify foreign k-mers\nQuantify contamination levels","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Part-5:-Performance-Optimization","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Part 5: Performance Optimization","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Large-scale k-mer analysis requires optimization","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"\\n=== Performance Optimization ===\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Memory-Management","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Memory Management","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Strategies for handling large k-mer datasets","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"--- Memory Management ---\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"TODO: Implement memory optimization","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Streaming k-mer processing\nDisk-based storage\nMemory-mapped files\nCompression techniques","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Parallel-Processing","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Parallel Processing","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Accelerate k-mer counting with parallelization","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"--- Parallel Processing ---\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"TODO: Implement parallel k-mer counting","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Multi-threaded counting\nDistributed processing\nLoad balancing strategies","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Part-6:-Visualization-and-Interpretation","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Part 6: Visualization and Interpretation","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Create plots to understand k-mer analysis results","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"\\n=== K-mer Visualization ===\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"TODO: Implement k-mer visualization","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Frequency spectrum plots\nK-mer composition heatmaps\nCoverage distribution plots\nComparative k-mer analysis","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Part-7:-Advanced-K-mer-Techniques","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Part 7: Advanced K-mer Techniques","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Explore advanced k-mer analysis methods","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"\\n=== Advanced Techniques ===\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Minimizers","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Minimizers","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Reduce k-mer space using minimizer techniques","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"--- Minimizers ---\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"TODO: Implement minimizer techniques","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Canonical minimizers\nSyncmers\nStrobemers","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Graph-Construction","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Graph Construction","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Build graphs from k-mer overlaps","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"--- Graph Construction ---\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"TODO: Implement k-mer graph construction","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"de Bruijn graphs\nString graphs\nOverlap graphs","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/#Summary-and-Best-Practices","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Summary and Best Practices","text":"","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"println(\"\\n=== K-mer Analysis Summary ===\")\nprintln(\"✓ Understanding k-mer theory and biological significance\")\nprintln(\"✓ Choosing appropriate k-mer sizes for different applications\")\nprintln(\"✓ Implementing dense and sparse counting strategies\")\nprintln(\"✓ Analyzing k-mer frequency spectra\")\nprintln(\"✓ Applying k-mer analysis to genome size estimation\")\nprintln(\"✓ Optimizing performance for large-scale analysis\")\n\nprintln(\"\\nBest Practices:\")\nprintln(\"- Start with k=21 for general analysis\")\nprintln(\"- Use dense counting for small k, sparse for large k\")\nprintln(\"- Monitor memory usage and optimize accordingly\")\nprintln(\"- Validate results with known datasets\")\nprintln(\"- Consider biological context in interpretation\")","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"Cleanup","category":"page"},{"location":"generated/tutorials/03_kmer_analysis/","page":"Tutorial 3: K-mer Analysis and Feature Extraction","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"for file in temp_files\n    rm(file, force=true)\nend\n\nprintln(\"\\nNext: Tutorial 4 - Genome Assembly\")\n\nnothing","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Tutorial-1:-Data-Acquisition-in-Bioinformatics","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"This tutorial demonstrates how to acquire genomic data from public databases and simulate synthetic datasets for bioinformatics analysis. Data acquisition is the critical first step in any bioinformatics workflow.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Learning-Objectives","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"By the end of this tutorial, you will understand:","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"How to download genome assemblies from NCBI databases\nDifferent types of genomic data files and their purposes\nHow to simulate synthetic genomic data for testing\nBest practices for data management and reproducibility\nQuality control considerations for downloaded data","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Setup","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"First, let's load the required packages and set up our environment.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"import Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Dates","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Set random seed for reproducibility","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Random.seed!(42)","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Part-1:-Understanding-Genomic-Data-Types","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Part 1: Understanding Genomic Data Types","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Before downloading data, it's important to understand the different types of genomic data files commonly used in bioinformatics:","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"FASTA (.fna, .fasta): Raw sequence data (DNA/RNA/protein)\nFASTQ (.fastq): Sequencing reads with quality scores\nGFF3 (.gff3): Gene annotations and features\nProtein sequences (.faa): Translated protein sequences\nCDS sequences (.ffn): Coding sequences\nSequence reports: Metadata about sequences","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"=== Genomic Data Types ===\")\nprintln(\"FASTA: Raw sequences (genome assemblies)\")\nprintln(\"FASTQ: Sequencing reads with quality scores\")\nprintln(\"GFF3: Gene annotations and genomic features\")\nprintln(\"Protein: Translated amino acid sequences\")\nprintln(\"CDS: Coding DNA sequences\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Part-2:-Downloading-Data-from-NCBI","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Part 2: Downloading Data from NCBI","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"The National Center for Biotechnology Information (NCBI) is a primary source for genomic data. We'll demonstrate downloading a small, well-characterized viral genome: bacteriophage phiX174.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Why-phiX174?","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Why phiX174?","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Small genome (~5.4 kb) - fast to download and process\nWell-characterized - extensively studied reference\nCommonly used as sequencing control\nSingle-stranded DNA virus with overlapping genes","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\n=== Downloading phiX174 Genome ===\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Method-1:-Download-by-Accession-ID","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Method 1: Download by Accession ID","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"NCBI accession IDs uniquely identify sequence records. NC_001422.1 is the RefSeq accession for phiX174.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"phix_accession = \"NC_001422.1\"\nprintln(\"Downloading genome by accession: $phix_accession\")\n\ngenome_file = Mycelia.download_genome_by_accession(accession=phix_accession)\nprintln(\"Downloaded to: $genome_file\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Verify the download","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Test.@test isfile(genome_file)\nTest.@test endswith(genome_file, \".fna.gz\")\nprintln(\"✓ Download successful\")\nprintln(\"File size: $(filesize(genome_file)) bytes\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Method-2:-Download-Complete-Assembly-Package","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Method 2: Download Complete Assembly Package","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"For more comprehensive analysis, download the complete assembly package which includes multiple file types (genome, proteins, annotations, etc.).","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"assembly_accession = \"GCF_000819615.1\"  ## Assembly accession for phiX174\nprintln(\"\\nDownloading complete assembly: $assembly_accession\")\n\nassembly_result = Mycelia.ncbi_genome_download_accession(accession=assembly_accession)\nprintln(\"Assembly downloaded to directory: $(assembly_result.directory)\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Examine what files were downloaded","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\nDownloaded files:\")\nfor (key, filepath) in pairs(assembly_result)\n    if key != :directory && !isnothing(filepath)\n        println(\"  $key: $(basename(filepath)) ($(filesize(filepath)) bytes)\")\n    end\nend","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Examining-Downloaded-Data","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Examining Downloaded Data","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Let's examine the structure of the downloaded genome file. FASTA files start with header lines (beginning with '>') followed by sequence data.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\n=== Examining Downloaded Genome ===\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Read the first few lines of the genome file","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"open(assembly_result.genome) do io\n    header = readline(io)\n    println(\"FASTA header: $header\")\n\n    # Read first 100 characters of sequence\n    sequence_start = read(io, String)[1:min(100, end)]\n    println(\"Sequence start: $sequence_start...\")\n\n    # Verify it's a valid FASTA format\n    Test.@test startswith(header, '>')\n    Test.@test all(c -> c in \"ATCGN\\n\", sequence_start)\nend\n\nprintln(\"✓ Valid FASTA format confirmed\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Part-3:-Simulating-Synthetic-Data","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Part 3: Simulating Synthetic Data","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Synthetic data is crucial for:","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Testing algorithms with known ground truth\nBenchmarking performance\nDeveloping new methods\nEducational purposes","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\n=== Simulating Synthetic Genomic Data ===\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Simulating-Random-Genome-Sequences","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Simulating Random Genome Sequences","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Generate a random DNA sequence with specified characteristics. This is useful for testing algorithms and understanding their behavior.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"Generating random DNA sequences...\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Generate sequences with different lengths and properties","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"sequences = []","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Short sequence for quick testing","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"short_seq = Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=100)\npush!(sequences, (\"Short (100 bp)\", short_seq))","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Medium sequence for moderate testing","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"medium_seq = Mycelia.random_fasta_record(moltype=:DNA, seed=2, L=1000)\npush!(sequences, (\"Medium (1 kb)\", medium_seq))","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Long sequence for performance testing","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"long_seq = Mycelia.random_fasta_record(moltype=:DNA, seed=3, L=10000)\npush!(sequences, (\"Long (10 kb)\", long_seq))","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Display sequence characteristics","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"for (name, seq) in sequences\n    seq_str = String(FASTX.sequence(seq))\n    gc_content = count(c -> c in \"GC\", seq_str) / length(seq_str)\n    println(\"$name: Length=$(length(seq_str)), GC=$(round(gc_content*100, digits=1))%\")\nend","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Writing-Synthetic-Data-to-Files","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Writing Synthetic Data to Files","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Save synthetic sequences to files for use in downstream analyses.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\nWriting synthetic sequences to files...\")\n\nsynthetic_files = String[]\nfor (i, (name, seq)) in enumerate(sequences)\n    filename = \"synthetic_sequence_$i.fasta\"\n    Mycelia.write_fasta(outfile=filename, records=[seq])\n    push!(synthetic_files, filename)\n    println(\"✓ Wrote $name to $filename\")\nend","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Part-4:-Data-Quality-and-Validation","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Part 4: Data Quality and Validation","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Always validate downloaded and simulated data before analysis.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\n=== Data Quality Validation ===\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Validating-Downloaded-Data","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Validating Downloaded Data","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Check file integrity and format correctness.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"Validating downloaded phiX174 genome...\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Read and validate the genome sequence","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"genome_seq = open(assembly_result.genome) do io\n    header = readline(io)\n    replace(read(io, String), '\\n' => \"\")\nend","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Basic validation checks","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Test.@test length(genome_seq) > 0\nTest.@test all(c -> c in \"ATCGN\", genome_seq)\nTest.@test count(c -> c == 'N', genome_seq) / length(genome_seq) < 0.01  ## < 1% N's\n\nprintln(\"✓ Genome length: $(length(genome_seq)) bp\")\nprintln(\"✓ Valid DNA alphabet\")\nprintln(\"✓ Low N content: $(count(c -> c == 'N', genome_seq)) N's\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Calculate basic statistics","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"at_content = count(c -> c in \"AT\", genome_seq) / length(genome_seq)\ngc_content = count(c -> c in \"GC\", genome_seq) / length(genome_seq)\n\nprintln(\"AT content: $(round(at_content*100, digits=1))%\")\nprintln(\"GC content: $(round(gc_content*100, digits=1))%\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Validating-Synthetic-Data","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Validating Synthetic Data","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Verify synthetic sequences meet expected criteria.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\nValidating synthetic sequences...\")\n\nfor (i, filename) in enumerate(synthetic_files)\n    seq_record = first(Mycelia.open_fastx(filename))\n    seq_str = String(FASTX.sequence(seq_record))\n\n    # Validate sequence properties\n    Test.@test length(seq_str) > 0\n    Test.@test all(c -> c in \"ATCG\", seq_str)  ## No N's in synthetic data\n\n    println(\"✓ Synthetic sequence $i: $(length(seq_str)) bp, valid DNA\")\nend","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Part-5:-Data-Management-Best-Practices","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Part 5: Data Management Best Practices","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Proper data management ensures reproducibility and efficient analysis.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\n=== Data Management Best Practices ===\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Organizing-Data-Files","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Organizing Data Files","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Create a structured directory layout for your project.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"data_dir = \"tutorial_data\"\nif !isdir(data_dir)\n    mkdir(data_dir)\nend","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Move downloaded data to organized structure","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"reference_dir = joinpath(data_dir, \"reference\")\nsynthetic_dir = joinpath(data_dir, \"synthetic\")\nmkdir(reference_dir)\nmkdir(synthetic_dir)","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Copy files to organized structure (keeping originals for now)","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"cp(assembly_result.genome, joinpath(reference_dir, \"phiX174_genome.fasta\"))\ncp(assembly_result.gff3, joinpath(reference_dir, \"phiX174_annotations.gff3\"))\n\nfor (i, filename) in enumerate(synthetic_files)\n    cp(filename, joinpath(synthetic_dir, filename))\nend\n\nprintln(\"✓ Data organized in structured directories:\")\nprintln(\"  - Reference data: $reference_dir\")\nprintln(\"  - Synthetic data: $synthetic_dir\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Creating-Data-Manifest","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Creating Data Manifest","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Document your data sources and processing steps.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"manifest_file = joinpath(data_dir, \"data_manifest.txt\")\nopen(manifest_file, \"w\") do io\n    println(io, \"# Data Manifest - Tutorial 1: Data Acquisition\")\n    println(io, \"# Generated: $(Dates.now())\")\n    println(io, \"\")\n    println(io, \"## Reference Data\")\n    println(io, \"phiX174_genome.fasta - Downloaded from NCBI accession $phix_accession\")\n    println(io, \"phiX174_annotations.gff3 - Downloaded from NCBI assembly $assembly_accession\")\n    println(io, \"\")\n    println(io, \"## Synthetic Data\")\n    for (i, filename) in enumerate(synthetic_files)\n        println(io, \"$filename - Random DNA sequence, seed=$(i), length varies\")\n    end\nend\n\nprintln(\"✓ Data manifest created: $manifest_file\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Part-6:-Advanced-Data-Acquisition-Techniques","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Part 6: Advanced Data Acquisition Techniques","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"For larger-scale analyses, consider these advanced approaches.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\n=== Advanced Techniques ===\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Partial-Downloads","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Partial Downloads","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Download only specific file types to save time and space.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"Demonstrating partial downloads...\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Download only genome files (not proteins, annotations, etc.)","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"genome_only = Mycelia.ncbi_genome_download_accession(\n    accession=assembly_accession,\n    include_string=\"genome\"\n)\n\nprintln(\"✓ Genome-only download completed\")\nprintln(\"  Available files: $(keys(genome_only))\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Batch-Processing-Considerations","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Batch Processing Considerations","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"When downloading multiple genomes, consider:","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Rate limiting to avoid overwhelming servers\nError handling for failed downloads\nProgress tracking for large datasets\nDisk space management","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\nBatch processing considerations:\")\nprintln(\"- Implement rate limiting between downloads\")\nprintln(\"- Add retry logic for failed downloads\")\nprintln(\"- Monitor disk space usage\")\nprintln(\"- Use parallel processing judiciously\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Summary-and-Next-Steps","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Summary and Next Steps","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"In this tutorial, you learned:","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"How to download genomic data from NCBI databases\nDifferent types of genomic data files and their purposes\nHow to simulate synthetic data for testing\nData validation and quality control practices\nBest practices for data organization and management","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\n=== Tutorial Summary ===\")\nprintln(\"✓ Downloaded phiX174 genome from NCBI\")\nprintln(\"✓ Generated synthetic sequences for testing\")\nprintln(\"✓ Validated data quality and format\")\nprintln(\"✓ Organized data in structured directories\")\nprintln(\"✓ Created data manifest for reproducibility\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Cleanup","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Cleanup","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Clean up temporary files (keeping organized data)","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\nCleaning up temporary files...\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Remove original downloaded files (we have copies in organized structure)","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"rm(genome_file, force=true)\nrm(assembly_result.directory, recursive=true, force=true)","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Remove synthetic files (we have copies in organized structure)","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"for filename in synthetic_files\n    rm(filename, force=true)\nend\n\nprintln(\"✓ Temporary files cleaned up\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#What's-Next?","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"What's Next?","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Now that you have acquired genomic data, the next steps typically include:","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Quality Control: Assess data quality and preprocess if needed\nFeature Extraction: Analyze sequence composition and properties\nComparative Analysis: Compare sequences or genomes\nFunctional Analysis: Annotate genes and predict functions","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Continue with Tutorial 2: Quality Control and Preprocessing to learn how to assess and improve data quality before analysis.","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"println(\"\\n=== Next Steps ===\")\nprintln(\"Continue with Tutorial 2: Quality Control and Preprocessing\")\nprintln(\"Data files available in: $data_dir\")\nprintln(\"Ready for downstream analysis!\")","category":"page"},{"location":"generated/tutorials/01_data_acquisition/#Key-Takeaways","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Key Takeaways","text":"","category":"section"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"Data Acquisition Strategy: Always start with small, well-characterized datasets\nValidation is Critical: Never assume downloaded data is perfect\nOrganization Matters: Structure your data from the beginning\nDocumentation: Keep detailed records of data sources and processing\nSynthetic Data: Valuable for testing and algorithm development\nFile Formats: Understand the purpose of different bioinformatics file types","category":"page"},{"location":"generated/tutorials/01_data_acquisition/","page":"Tutorial 1: Data Acquisition in Bioinformatics","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"nothing  ## Suppress output in notebook","category":"page"},{"location":"concepts/#Bioinformatics-Concepts-and-Tools","page":"Concepts","title":"Bioinformatics Concepts and Tools","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"This guide explains the key bioinformatics concepts implemented in Mycelia and provides guidance on when to use each tool. It's designed for graduate-level researchers who need to understand both the biological context and computational approaches.","category":"page"},{"location":"concepts/#Table-of-Contents","page":"Concepts","title":"Table of Contents","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Workflow Overview\nData Acquisition\nQuality Control\nSequence Analysis\nGenome Assembly\nGene Annotation\nComparative Genomics\nPhylogenetics\nTool Selection Guide","category":"page"},{"location":"concepts/#Workflow-Overview","page":"Concepts","title":"Workflow Overview","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Bioinformatics analyses typically follow a structured workflow. Understanding this flow helps you choose the right tools and interpret results correctly.","category":"page"},{"location":"concepts/#Standard-Genomic-Analysis-Pipeline","page":"Concepts","title":"Standard Genomic Analysis Pipeline","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Raw Data → Quality Control → Feature Extraction → Assembly → Validation → Annotation → Comparative Analysis","category":"page"},{"location":"concepts/#Decision-Points","page":"Concepts","title":"Decision Points","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"At each stage, you face key decisions:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Data Quality: Is my data sufficient for analysis?\nMethod Selection: Which algorithm fits my data type and research question?\nParameter Tuning: How do I optimize for my specific dataset?\nResult Interpretation: What do the numbers mean biologically?","category":"page"},{"location":"concepts/#Data-Acquisition","page":"Concepts","title":"Data Acquisition","text":"","category":"section"},{"location":"concepts/#Concept:-Data-Sources-and-Types","page":"Concepts","title":"Concept: Data Sources and Types","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Biological Context: Genomic data comes from various sources, each with different characteristics and limitations.","category":"page"},{"location":"concepts/#Data-Types","page":"Concepts","title":"Data Types","text":"","category":"section"},{"location":"concepts/#Sequencing-Data","page":"Concepts","title":"Sequencing Data","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Illumina: Short reads (150-300 bp), high accuracy, paired-end\nPacBio/HiFi: Long reads (10-25 kb), high accuracy, single-molecule\nOxford Nanopore: Ultra-long reads (50+ kb), moderate accuracy, real-time","category":"page"},{"location":"concepts/#Reference-Data","page":"Concepts","title":"Reference Data","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"RefSeq: Manually curated, high-quality reference sequences\nGenBank: Community-submitted sequences, variable quality\nSRA: Raw sequencing data from published studies","category":"page"},{"location":"concepts/#When-to-Use-Each","page":"Concepts","title":"When to Use Each","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Data Type Use Case Advantages Limitations\nIllumina SNP calling, RNA-seq, metagenomics High accuracy, cost-effective Short reads, repetitive regions\nPacBio HiFi Genome assembly, structural variants Long + accurate, span repeats Higher cost, lower throughput\nNanopore Real-time analysis, ultra-long reads Longest reads, portable Higher error rates","category":"page"},{"location":"concepts/#Mycelia-Functions","page":"Concepts","title":"Mycelia Functions","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"# Download reference genomes\ndownload_genome_by_accession(accession=\"NC_001422.1\")\n\n# Download complete assemblies\nncbi_genome_download_accession(accession=\"GCF_000819615.1\")\n\n# Simulate test data\nsimulate_random_genome(length=10000, gc_content=0.45)\nsimulate_hifi_reads(genome, coverage=20, error_rate=0.001)","category":"page"},{"location":"concepts/#Quality-Control","page":"Concepts","title":"Quality Control","text":"","category":"section"},{"location":"concepts/#Concept:-Data-Quality-Assessment","page":"Concepts","title":"Concept: Data Quality Assessment","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Biological Context: Sequencing is not perfect. Raw data contains errors, biases, and artifacts that must be identified and corrected before analysis.","category":"page"},{"location":"concepts/#Quality-Metrics","page":"Concepts","title":"Quality Metrics","text":"","category":"section"},{"location":"concepts/#Sequence-Quality","page":"Concepts","title":"Sequence Quality","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Phred Scores: Probability of base-calling error (Q20 = 1% error, Q30 = 0.1% error)\nGC Content: Should match expected organism profile\nLength Distribution: Indicates fragmentation or size selection","category":"page"},{"location":"concepts/#Coverage-Metrics","page":"Concepts","title":"Coverage Metrics","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Read Depth: Number of reads covering each position\nUniformity: Even coverage across genome\nDuplication Rate: PCR duplicates inflate coverage","category":"page"},{"location":"concepts/#Quality-Issues","page":"Concepts","title":"Quality Issues","text":"","category":"section"},{"location":"concepts/#Common-Problems","page":"Concepts","title":"Common Problems","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Adapter Contamination: Sequencing adapters in reads\nLow Quality Ends: Error-prone read ends\nOverrepresented Sequences: PCR bias or contamination\nLength Bias: Preferential sequencing of certain sizes","category":"page"},{"location":"concepts/#Solutions","page":"Concepts","title":"Solutions","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Trimming: Remove low-quality bases and adapters\nFiltering: Discard low-quality reads\nNormalization: Adjust for coverage bias\nDeduplication: Remove PCR duplicates","category":"page"},{"location":"concepts/#When-to-Apply-QC","page":"Concepts","title":"When to Apply QC","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Analysis Type QC Priority Key Metrics\nGenome Assembly Critical Coverage uniformity, read length\nVariant Calling High Base quality, mapping quality\nRNA-seq High rRNA contamination, 3' bias\nMetagenomics Medium Host contamination, diversity","category":"page"},{"location":"concepts/#Mycelia-Functions-2","page":"Concepts","title":"Mycelia Functions","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"# Analyze read quality\nanalyze_fastq_quality(\"reads.fastq\")\n\n# Calculate sequence statistics\ncalculate_sequence_stats(sequences)\n\n# Quality visualization\nplot_quality_distribution(quality_scores)","category":"page"},{"location":"concepts/#Sequence-Analysis","page":"Concepts","title":"Sequence Analysis","text":"","category":"section"},{"location":"concepts/#Concept:-K-mer-Analysis","page":"Concepts","title":"Concept: K-mer Analysis","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Biological Context: K-mers are subsequences of length k. They capture local sequence composition and are fundamental to many bioinformatics algorithms.","category":"page"},{"location":"concepts/#K-mer-Theory","page":"Concepts","title":"K-mer Theory","text":"","category":"section"},{"location":"concepts/#Mathematical-Foundation","page":"Concepts","title":"Mathematical Foundation","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"K-mer Space: 4^k possible DNA k-mers\nFrequency Spectrum: Distribution of k-mer frequencies\nCoverage Estimation: Genome size estimation from k-mer frequencies","category":"page"},{"location":"concepts/#Biological-Interpretation","page":"Concepts","title":"Biological Interpretation","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Repetitive Elements: High-frequency k-mers indicate repeats\nSequencing Errors: Low-frequency k-mers often represent errors\nGenome Complexity: Unique k-mers indicate complex regions","category":"page"},{"location":"concepts/#K-mer-Applications","page":"Concepts","title":"K-mer Applications","text":"","category":"section"},{"location":"concepts/#Genome-Assembly","page":"Concepts","title":"Genome Assembly","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Error Correction: Remove k-mers with low frequency\nOverlap Detection: Find shared k-mers between reads\nGraph Construction: Build de Bruijn graphs","category":"page"},{"location":"concepts/#Quality-Assessment","page":"Concepts","title":"Quality Assessment","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Coverage Estimation: Estimate genome size and coverage\nContamination Detection: Identify foreign DNA\nPloidy Estimation: Detect polyploidy from k-mer frequencies","category":"page"},{"location":"concepts/#Parameter-Selection","page":"Concepts","title":"Parameter Selection","text":"","category":"section"},{"location":"concepts/#Choosing-K","page":"Concepts","title":"Choosing K","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Small K (k=15-21): Sensitive to errors, good for error correction\nMedium K (k=25-31): Balanced sensitivity/specificity\nLarge K (k=35-51): Specific but may miss overlaps","category":"page"},{"location":"concepts/#Memory-Considerations","page":"Concepts","title":"Memory Considerations","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Dense Matrices: Store all possible k-mers (memory intensive)\nSparse Matrices: Store only observed k-mers (memory efficient)\nCounting Algorithms: Bloom filters, Count-Min sketch","category":"page"},{"location":"concepts/#When-to-Use-K-mer-Analysis","page":"Concepts","title":"When to Use K-mer Analysis","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Application K-mer Size Matrix Type Use Case\nError Correction 15-21 Dense Remove sequencing errors\nAssembly 25-31 Sparse Genome assembly\nRepeat Detection 31-51 Sparse Identify repetitive elements\nContamination 21-31 Sparse Detect foreign DNA","category":"page"},{"location":"concepts/#Mycelia-Functions-3","page":"Concepts","title":"Mycelia Functions","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"# Count k-mers\ncount_kmers(\"reads.fastq\", k=21)\n\n# Dense vs sparse counting\nfasta_list_to_dense_kmer_counts(files, k=21)\nfasta_list_to_sparse_kmer_counts(files, k=21)\n\n# K-mer spectrum analysis\nkmer_frequency_spectrum(kmer_counts)","category":"page"},{"location":"concepts/#Genome-Assembly-2","page":"Concepts","title":"Genome Assembly","text":"","category":"section"},{"location":"concepts/#Concept:-Reconstructing-Genomes","page":"Concepts","title":"Concept: Reconstructing Genomes","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Biological Context: Sequencing breaks genomes into fragments. Assembly reconstructs the original genome by finding overlaps between fragments.","category":"page"},{"location":"concepts/#Assembly-Algorithms","page":"Concepts","title":"Assembly Algorithms","text":"","category":"section"},{"location":"concepts/#Overlap-Layout-Consensus-(OLC)","page":"Concepts","title":"Overlap-Layout-Consensus (OLC)","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Overlap: Find overlaps between all reads\nLayout: Order reads based on overlaps\nConsensus: Generate consensus sequence\nBest For: Long reads (PacBio, Nanopore)","category":"page"},{"location":"concepts/#De-Bruijn-Graph","page":"Concepts","title":"De Bruijn Graph","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"K-mer Decomposition: Break reads into k-mers\nGraph Construction: Connect overlapping k-mers\nPath Finding: Find Eulerian paths through graph\nBest For: Short reads (Illumina)","category":"page"},{"location":"concepts/#String-Graph","page":"Concepts","title":"String Graph","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Overlap Graph: Nodes are reads, edges are overlaps\nTransitivity Reduction: Remove redundant edges\nContig Construction: Find paths through graph\nBest For: Long reads with high accuracy","category":"page"},{"location":"concepts/#Assembly-Challenges","page":"Concepts","title":"Assembly Challenges","text":"","category":"section"},{"location":"concepts/#Repetitive-Sequences","page":"Concepts","title":"Repetitive Sequences","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Problem: Identical sequences confuse assembly\nSolution: Long reads that span repeats\nTools: Repeat-aware assemblers, scaffolding","category":"page"},{"location":"concepts/#Heterozygosity","page":"Concepts","title":"Heterozygosity","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Problem: Diploid genomes have two alleles\nSolution: Haplotype-aware assembly\nTools: Trio binning, Hi-C scaffolding","category":"page"},{"location":"concepts/#Polyploidy","page":"Concepts","title":"Polyploidy","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Problem: Multiple copies of chromosomes\nSolution: Specialized polyploid assemblers\nTools: Ploidy-aware algorithms","category":"page"},{"location":"concepts/#Assembly-Quality-Metrics","page":"Concepts","title":"Assembly Quality Metrics","text":"","category":"section"},{"location":"concepts/#Contiguity","page":"Concepts","title":"Contiguity","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"N50: Length where 50% of assembly is in contigs of this length or longer\nL50: Number of contigs containing 50% of assembly\nContig Count: Total number of contigs (fewer is better)","category":"page"},{"location":"concepts/#Completeness","page":"Concepts","title":"Completeness","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Genome Coverage: Percentage of genome assembled\nGene Completeness: Percentage of expected genes found\nBUSCO Scores: Conserved gene completeness","category":"page"},{"location":"concepts/#Accuracy","page":"Concepts","title":"Accuracy","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Base Accuracy: Percentage of correct bases\nStructural Accuracy: Correct arrangement of sequences\nValidation: Comparison with reference genome","category":"page"},{"location":"concepts/#When-to-Use-Different-Assemblers","page":"Concepts","title":"When to Use Different Assemblers","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Data Type Assembler Algorithm Strengths\nHiFi hifiasm String graph High accuracy, haplotype-aware\nNanopore Flye Repeat graph Long reads, repetitive genomes\nIllumina SPAdes de Bruijn Short reads, microbial genomes\nHybrid MaSuRCA Hybrid Combines short and long reads","category":"page"},{"location":"concepts/#Mycelia-Functions-4","page":"Concepts","title":"Mycelia Functions","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"# Run assembly\nassemble_genome(\"reads.fastq\", output_dir=\"assembly\")\n\n# Evaluate assembly quality\nevaluate_assembly(assembly_fasta)\n\n# Assembly statistics\ncalculate_assembly_stats(contigs)","category":"page"},{"location":"concepts/#Gene-Annotation","page":"Concepts","title":"Gene Annotation","text":"","category":"section"},{"location":"concepts/#Concept:-Identifying-Functional-Elements","page":"Concepts","title":"Concept: Identifying Functional Elements","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Biological Context: Raw genome sequences are meaningless without annotation. Gene annotation identifies protein-coding genes, regulatory elements, and other functional sequences.","category":"page"},{"location":"concepts/#Annotation-Types","page":"Concepts","title":"Annotation Types","text":"","category":"section"},{"location":"concepts/#Structural-Annotation","page":"Concepts","title":"Structural Annotation","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Gene Prediction: Identify protein-coding genes\nExon-Intron Structure: Define gene boundaries\nPromoter Prediction: Identify regulatory sequences\nRepeat Annotation: Classify repetitive elements","category":"page"},{"location":"concepts/#Functional-Annotation","page":"Concepts","title":"Functional Annotation","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Protein Function: Predict what proteins do\nPathway Mapping: Assign genes to metabolic pathways\nGO Terms: Gene Ontology functional classification\nDomain Annotation: Identify protein domains","category":"page"},{"location":"concepts/#Gene-Prediction-Methods","page":"Concepts","title":"Gene Prediction Methods","text":"","category":"section"},{"location":"concepts/#Ab-Initio-Prediction","page":"Concepts","title":"Ab Initio Prediction","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Approach: Use sequence signals (start codons, splice sites)\nAdvantages: No external data required\nLimitations: Lower accuracy, misses non-canonical genes\nTools: Prodigal, Augustus, GeneMark","category":"page"},{"location":"concepts/#Homology-Based-Prediction","page":"Concepts","title":"Homology-Based Prediction","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Approach: Compare to known genes in databases\nAdvantages: Higher accuracy for conserved genes\nLimitations: Misses novel genes, depends on database quality\nTools: BLAST, DIAMOND, MMseqs2","category":"page"},{"location":"concepts/#RNA-seq-Guided-Prediction","page":"Concepts","title":"RNA-seq Guided Prediction","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Approach: Use transcriptome data to guide prediction\nAdvantages: High accuracy, identifies expressed genes\nLimitations: Requires RNA-seq data, misses lowly expressed genes\nTools: StringTie, Cufflinks, BRAKER","category":"page"},{"location":"concepts/#Annotation-Challenges","page":"Concepts","title":"Annotation Challenges","text":"","category":"section"},{"location":"concepts/#Eukaryotic-Complexity","page":"Concepts","title":"Eukaryotic Complexity","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Alternative Splicing: Multiple transcripts per gene\nPseudogenes: Non-functional gene copies\nNon-coding RNAs: Functional RNAs that don't code for proteins","category":"page"},{"location":"concepts/#Prokaryotic-Specifics","page":"Concepts","title":"Prokaryotic Specifics","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Operons: Polycistronic transcripts\nOverlapping Genes: Genes sharing sequence\nHorizontal Gene Transfer: Genes from other species","category":"page"},{"location":"concepts/#Quality-Assessment-2","page":"Concepts","title":"Quality Assessment","text":"","category":"section"},{"location":"concepts/#Annotation-Completeness","page":"Concepts","title":"Annotation Completeness","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Gene Density: Number of genes per kb\nProtein Completeness: Percentage of complete proteins\nFunctional Coverage: Percentage of genes with functional annotation","category":"page"},{"location":"concepts/#Annotation-Accuracy","page":"Concepts","title":"Annotation Accuracy","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Validation: Comparison with experimental data\nConsistency: Agreement between different methods\nBenchmarking: Comparison with reference annotations","category":"page"},{"location":"concepts/#When-to-Use-Different-Approaches","page":"Concepts","title":"When to Use Different Approaches","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Genome Type Method Tools Considerations\nBacterial Ab initio Prodigal Simple gene structure\nViral Homology BLAST Small genomes, database dependent\nFungal Hybrid Augustus + BLAST Moderate complexity\nPlant/Animal RNA-seq guided BRAKER High complexity, alternative splicing","category":"page"},{"location":"concepts/#Mycelia-Functions-5","page":"Concepts","title":"Mycelia Functions","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"# Predict genes\npredict_genes(genome_fasta, genetic_code=\"standard\")\n\n# Functional annotation\nannotate_functions(proteins, database=\"uniprot\")\n\n# Annotation evaluation\nevaluate_annotation(gff_file, reference_gff)","category":"page"},{"location":"concepts/#Comparative-Genomics","page":"Concepts","title":"Comparative Genomics","text":"","category":"section"},{"location":"concepts/#Concept:-Comparing-Genomes","page":"Concepts","title":"Concept: Comparing Genomes","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Biological Context: Comparing genomes reveals evolutionary relationships, functional elements, and species-specific adaptations.","category":"page"},{"location":"concepts/#Comparative-Approaches","page":"Concepts","title":"Comparative Approaches","text":"","category":"section"},{"location":"concepts/#Pairwise-Comparison","page":"Concepts","title":"Pairwise Comparison","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Synteny: Conserved gene order between species\nOrthology: Corresponding genes in different species\nWhole Genome Alignment: Align entire genomes\nStructural Variation: Differences in genome structure","category":"page"},{"location":"concepts/#Pangenome-Analysis","page":"Concepts","title":"Pangenome Analysis","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Core Genome: Genes present in all individuals\nAccessory Genome: Genes present in some individuals\nUnique Genes: Genes present in single individuals\nGene Gain/Loss: Evolution of gene content","category":"page"},{"location":"concepts/#Pangenome-Construction","page":"Concepts","title":"Pangenome Construction","text":"","category":"section"},{"location":"concepts/#Graph-Based-Approaches","page":"Concepts","title":"Graph-Based Approaches","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Gene Graphs: Nodes are genes, edges are relationships\nSequence Graphs: Nodes are sequences, edges are overlaps\nVariation Graphs: Represent genetic variation as graphs","category":"page"},{"location":"concepts/#Clustering-Approaches","page":"Concepts","title":"Clustering Approaches","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Sequence Similarity: Group similar sequences\nSynteny: Group genes with conserved context\nFunctional Similarity: Group genes with similar functions","category":"page"},{"location":"concepts/#Evolutionary-Analysis","page":"Concepts","title":"Evolutionary Analysis","text":"","category":"section"},{"location":"concepts/#Phylogenetic-Trees","page":"Concepts","title":"Phylogenetic Trees","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Species Trees: Evolutionary relationships between species\nGene Trees: Evolution of individual genes\nReconciliation: Compare gene and species trees","category":"page"},{"location":"concepts/#Selection-Analysis","page":"Concepts","title":"Selection Analysis","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Positive Selection: Genes under selective pressure\nPurifying Selection: Genes with functional constraints\nNeutral Evolution: Genes evolving without selection","category":"page"},{"location":"concepts/#Applications","page":"Concepts","title":"Applications","text":"","category":"section"},{"location":"concepts/#Medical-Genomics","page":"Concepts","title":"Medical Genomics","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Drug Resistance: Compare sensitive vs resistant strains\nVirulence Factors: Identify pathogenicity genes\nVaccine Targets: Find conserved antigens","category":"page"},{"location":"concepts/#Agricultural-Genomics","page":"Concepts","title":"Agricultural Genomics","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Crop Improvement: Identify beneficial alleles\nDisease Resistance: Find resistance genes\nStress Tolerance: Identify adaptation mechanisms","category":"page"},{"location":"concepts/#When-to-Use-Comparative-Genomics","page":"Concepts","title":"When to Use Comparative Genomics","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Research Question Approach Scale Tools\nSpecies evolution Phylogenomics Many species Core genome alignment\nPopulation variation Pangenomics Many individuals Graph-based methods\nFunctional elements Synteny Few genomes Whole genome alignment\nAdaptation Selection analysis Population data Evolutionary models","category":"page"},{"location":"concepts/#Mycelia-Functions-6","page":"Concepts","title":"Mycelia Functions","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"# Build pangenome\nbuild_pangenome(genome_list, clustering_threshold=0.95)\n\n# Phylogenetic analysis\nconstruct_phylogeny(core_genes, method=\"ml\")\n\n# Comparative analysis\ncompare_genomes(genome1, genome2, method=\"synteny\")","category":"page"},{"location":"concepts/#Phylogenetics","page":"Concepts","title":"Phylogenetics","text":"","category":"section"},{"location":"concepts/#Concept:-Evolutionary-Relationships","page":"Concepts","title":"Concept: Evolutionary Relationships","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Biological Context: Phylogenetics reconstructs evolutionary history from molecular data, revealing how species are related and when they diverged.","category":"page"},{"location":"concepts/#Tree-Construction-Methods","page":"Concepts","title":"Tree Construction Methods","text":"","category":"section"},{"location":"concepts/#Distance-Based-Methods","page":"Concepts","title":"Distance-Based Methods","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"UPGMA: Assumes molecular clock\nNeighbor-Joining: Doesn't assume molecular clock\nMinimum Evolution: Finds tree with shortest total branch length","category":"page"},{"location":"concepts/#Character-Based-Methods","page":"Concepts","title":"Character-Based Methods","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Maximum Parsimony: Minimizes evolutionary changes\nMaximum Likelihood: Finds most likely tree given data\nBayesian Inference: Incorporates prior knowledge","category":"page"},{"location":"concepts/#Molecular-Evolution-Models","page":"Concepts","title":"Molecular Evolution Models","text":"","category":"section"},{"location":"concepts/#Nucleotide-Substitution-Models","page":"Concepts","title":"Nucleotide Substitution Models","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"JC69: All substitutions equally likely\nK80: Different rates for transitions/transversions\nGTR: General time-reversible model","category":"page"},{"location":"concepts/#Protein-Evolution-Models","page":"Concepts","title":"Protein Evolution Models","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Poisson: All amino acid changes equally likely\nJTT: Jones-Taylor-Thornton model\nLG: Le-Gascuel model","category":"page"},{"location":"concepts/#Tree-Evaluation","page":"Concepts","title":"Tree Evaluation","text":"","category":"section"},{"location":"concepts/#Support-Values","page":"Concepts","title":"Support Values","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Bootstrap: Resampling support for branches\nPosterior Probability: Bayesian support\nSH-like aLRT: Likelihood ratio test","category":"page"},{"location":"concepts/#Tree-Comparison","page":"Concepts","title":"Tree Comparison","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Robinson-Foulds: Topological distance\nLikelihood Ratio: Statistical comparison\nConsensus Trees: Combine multiple trees","category":"page"},{"location":"concepts/#Applications-2","page":"Concepts","title":"Applications","text":"","category":"section"},{"location":"concepts/#Taxonomy","page":"Concepts","title":"Taxonomy","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Species Identification: Place unknown species\nClassification: Revise taxonomic relationships\nDiversity Assessment: Measure evolutionary diversity","category":"page"},{"location":"concepts/#Epidemiology","page":"Concepts","title":"Epidemiology","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Outbreak Tracking: Trace disease transmission\nVaccine Design: Understand pathogen evolution\nDrug Resistance: Track resistance evolution","category":"page"},{"location":"concepts/#When-to-Use-Phylogenetics","page":"Concepts","title":"When to Use Phylogenetics","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Data Type Method Use Case Considerations\nSingle gene NJ/ML Quick analysis May not reflect species tree\nMultiple genes Concatenation Species phylogeny Assumes same tree topology\nGenome-wide Coalescent Population genetics Accounts for incomplete lineage sorting\nTime-calibrated Molecular clock Divergence dating Requires calibration points","category":"page"},{"location":"concepts/#Mycelia-Functions-7","page":"Concepts","title":"Mycelia Functions","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"# Construct phylogeny\nbuild_phylogenetic_tree(alignment, method=\"ml\")\n\n# Molecular clock analysis\nestimate_divergence_times(tree, calibration_points)\n\n# Tree visualization\nplot_phylogenetic_tree(tree, layout=\"circular\")","category":"page"},{"location":"concepts/#Tool-Selection-Guide","page":"Concepts","title":"Tool Selection Guide","text":"","category":"section"},{"location":"concepts/#Choosing-the-Right-Analysis","page":"Concepts","title":"Choosing the Right Analysis","text":"","category":"section"},{"location":"concepts/#Data-Driven-Decisions","page":"Concepts","title":"Data-Driven Decisions","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Consider Your Data Type","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Illumina: Short read optimized tools\nPacBio/Nanopore: Long read specialized tools\nHybrid: Tools supporting multiple data types","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Consider Your Organism","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Bacteria: Simpler tools, less memory\nEukaryotes: Complex tools, more resources\nViruses: Specialized viral tools","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Consider Your Resources","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Local Machine: Memory/CPU constraints\nHPC Cluster: Parallel processing available\nCloud: Scalable but cost considerations","category":"page"},{"location":"concepts/#Question-Driven-Decisions","page":"Concepts","title":"Question-Driven Decisions","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Assembly Quality","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Draft Assembly: Fast tools, lower quality\nReference Quality: Comprehensive tools, higher quality\nComparison: Multiple assemblers, best result","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Annotation Depth","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Basic Annotation: Fast gene prediction\nComprehensive: Multiple evidence types\nComparative: Cross-species evidence","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Analysis Scope","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Single Genome: Individual analysis tools\nPopulation: Population genetics tools\nComparative: Multi-genome tools","category":"page"},{"location":"concepts/#Performance-Considerations","page":"Concepts","title":"Performance Considerations","text":"","category":"section"},{"location":"concepts/#Memory-Requirements","page":"Concepts","title":"Memory Requirements","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"K-mer Analysis: Exponential with k size\nAssembly: Linear with genome size\nAnnotation: Depends on database size","category":"page"},{"location":"concepts/#Time-Complexity","page":"Concepts","title":"Time Complexity","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Data Download: Network dependent\nQuality Control: Linear with data size\nAssembly: Depends on algorithm and data\nAnnotation: Depends on database searches","category":"page"},{"location":"concepts/#Accuracy-Trade-offs","page":"Concepts","title":"Accuracy Trade-offs","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Speed vs Accuracy: Fast tools may sacrifice accuracy\nSensitivity vs Specificity: Detect more vs fewer false positives\nCompleteness vs Contiguity: More complete vs fewer contigs","category":"page"},{"location":"concepts/#Best-Practices","page":"Concepts","title":"Best Practices","text":"","category":"section"},{"location":"concepts/#Workflow-Design","page":"Concepts","title":"Workflow Design","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Start Simple: Use basic tools first\nIterate: Improve based on results\nValidate: Check results at each step\nDocument: Record parameters and decisions","category":"page"},{"location":"concepts/#Quality-Control-2","page":"Concepts","title":"Quality Control","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Check Inputs: Validate data quality\nMonitor Progress: Track intermediate results\nEvaluate Outputs: Assess final results\nCompare Methods: Use multiple approaches","category":"page"},{"location":"concepts/#Reproducibility","page":"Concepts","title":"Reproducibility","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Version Control: Track software versions\nParameter Recording: Document all settings\nEnvironment Management: Use containers/environments\nData Provenance: Track data sources","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"This conceptual guide provides the foundation for understanding Mycelia's tools and making informed decisions about your bioinformatics analyses. Each tutorial and benchmark builds on these concepts with practical implementations.","category":"page"},{"location":"getting-started/#Getting-Started-with-Mycelia","page":"Getting Started","title":"Getting Started with Mycelia","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Welcome to Mycelia, an experimental Julia package for bioinformatics and computational biology. This guide will help you install Mycelia and explore its current capabilities.","category":"page"},{"location":"getting-started/#What-is-Mycelia?","page":"Getting Started","title":"What is Mycelia?","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Mycelia is a research-oriented bioinformatics package that currently provides:","category":"page"},{"location":"getting-started/#Working-Features","page":"Getting Started","title":"Working Features","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Basic Sequence I/O: FASTA/FASTQ file reading and writing\nRead Simulation: PacBio and Nanopore read simulators  \nTool Integration: Wrappers for established assemblers (MEGAHIT, SPAdes, hifiasm)\nK-mer Analysis: Canonical k-mer counting and distance calculations\nHPC Support: SLURM job submission and rclone integration","category":"page"},{"location":"getting-started/#Experimental-Features","page":"Getting Started","title":"Experimental Features","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Novel Assembly Algorithms: Graph-based approaches incorporating quality scores\nPangenome Analysis: K-mer based comparative genomics\nQuality Control: Integration with external QC tools","category":"page"},{"location":"getting-started/#Planned-Features","page":"Getting Started","title":"Planned Features","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Annotation: Gene prediction integration\nPhylogenetics: Tree construction from pangenome data\nVisualization: Interactive genomic plots","category":"page"},{"location":"getting-started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"","category":"section"},{"location":"getting-started/#Julia-Installation","page":"Getting Started","title":"Julia Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Mycelia is tested against Julia LTS and release. Install Julia using juliaup:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# Install juliaup\ncurl -fsSL https://install.julialang.org | sh\n\n# Install latest lts Julia\njuliaup add lts\njuliaup default lts\n\n# Install latest release Julia\njuliaup add release\njuliaup default release","category":"page"},{"location":"getting-started/#System-Dependencies","page":"Getting Started","title":"System Dependencies","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Mycelia integrates with external bioinformatics tools. For full functionality, you'll need conda. If no conda environment is available, Mycelia will install it's own environment using Conda.jl.","category":"page"},{"location":"getting-started/#HPC-Environment-Setup","page":"Getting Started","title":"HPC Environment Setup","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If you're using Mycelia on HPC systems, you may need to reset the LD_LIBRARY_PATH to avoid conflicts with visualization libraries:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# Launch Julia with clean library path\nexport LD_LIBRARY_PATH=\"\" && julia","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For Jupyter kernels, add this to your kernel.json:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"{\n  \"env\": {\n    \"LD_LIBRARY_PATH\": \"\"\n  }\n}","category":"page"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/#For-Users","page":"Getting Started","title":"For Users","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Install Mycelia directly from GitHub:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(url=\"https://github.com/cjprybol/Mycelia.git\")","category":"page"},{"location":"getting-started/#For-Developers","page":"Getting Started","title":"For Developers","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Clone and develop the package:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.develop(url=\"git@github.com:cjprybol/Mycelia.git\")","category":"page"},{"location":"getting-started/#Your-First-Analysis","page":"Getting Started","title":"Your First Analysis","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Let's walk through a complete workflow using small test datasets included with Mycelia.","category":"page"},{"location":"getting-started/#1.-Load-Mycelia","page":"Getting Started","title":"1. Load Mycelia","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"import Mycelia","category":"page"},{"location":"getting-started/#2.-Download-Test-Data","page":"Getting Started","title":"2. Download Test Data","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Download a reference genome for testing:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# Download a small viral genome (phiX174)\ngenome_file = Mycelia.download_genome_by_accession(accession=\"NC_001422.1\")\n\n# Or create a random test sequence\ntest_genome = Mycelia.random_fasta_record(moltype=:DNA, L=10000)\nMycelia.write_fasta(outfile=\"test_genome.fasta\", records=[test_genome])\n\n# Simulate reads from the genome\nreads_file = Mycelia.simulate_pacbio_reads(fasta=\"test_genome.fasta\", quantity=\"20x\")\nMycelia.write_fastq(\"test_reads.fastq\", reads)","category":"page"},{"location":"getting-started/#3.-Quality-Control-(Using-External-Tools)","page":"Getting Started","title":"3. Quality Control (Using External Tools)","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Filter reads using integrated external tools:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# Filter long reads with filtlong\nMycelia.qc_filter_long_reads_filtlong(\n    input_file=\"test_reads.fastq\",\n    output_file=\"filtered_reads.fastq\",\n    min_length=1000,\n    min_mean_q=7\n)\n\n# Note: Native quality assessment functions are planned but not yet implemented","category":"page"},{"location":"getting-started/#4.-K-mer-Analysis","page":"Getting Started","title":"4. K-mer Analysis","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Analyze k-mer composition:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# Count canonical k-mers\nimport Kmers\nkmer_counts = Mycelia.count_canonical_kmers(Kmers.DNAKmer{21}, \"test_reads.fastq\")\nprintln(\"Unique k-mers: $(length(kmer_counts))\")\n\n# Note: K-mer spectrum analysis and plotting functions are planned","category":"page"},{"location":"getting-started/#5.-Genome-Assembly","page":"Getting Started","title":"5. Genome Assembly","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Assemble using external tools through Mycelia wrappers:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# Use MEGAHIT for assembly (works with short reads)\nMycelia.assemble_metagenome_megahit(\n    reads=[\"test_reads.fastq\"],\n    output_dir=\"megahit_assembly\"\n)\n\n# Or use experimental graph-based assembly (research feature)\n# Note: This is experimental and may not produce optimal results\n# assembly = Mycelia.assemble_with_graph_framework(\"test_reads.fastq\")\n\n# Assembly evaluation functions are planned but not yet implemented","category":"page"},{"location":"getting-started/#6.-Comparative-Analysis-(Experimental)","page":"Getting Started","title":"6. Comparative Analysis (Experimental)","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Compare multiple genomes using k-mer analysis:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# Compare two genomes\ngenome_files = [\"genome1.fasta\", \"genome2.fasta\"]\npangenome_result = Mycelia.analyze_pangenome_kmers(\n    genome_files,\n    kmer_type=Kmers.DNAKmer{21}\n)\nprintln(\"Core k-mers: $(length(pangenome_result.core_kmers))\")\nprintln(\"Unique k-mers: $(sum(length(v) for v in values(pangenome_result.unique_kmers_by_genome)))\")\n\n# Note: Gene prediction and visualization functions are planned","category":"page"},{"location":"getting-started/#What's-Next?","page":"Getting Started","title":"What's Next?","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Explore the available features and help improve the package:","category":"page"},{"location":"getting-started/#Available-Tutorials","page":"Getting Started","title":"Available Tutorials","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"See the tutorials section for numbered examples\nFocus on working examples that demonstrate current capabilities","category":"page"},{"location":"getting-started/#Research-Features","page":"Getting Started","title":"Research Features","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Explore the experimental graph-based assembly algorithms\nTest the quality-aware k-mer (qualmer) graph implementation\nTry the reinforcement learning guided assembly (very experimental)","category":"page"},{"location":"getting-started/#Contributing","page":"Getting Started","title":"Contributing","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Report issues or feature requests on GitHub\nHelp implement planned features\nImprove documentation for existing functions","category":"page"},{"location":"getting-started/#Note-on-CLI-Tools","page":"Getting Started","title":"Note on CLI Tools","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Command-line interface tools are planned but not yet implemented.","category":"page"},{"location":"getting-started/#API-Reference","page":"Getting Started","title":"API Reference","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Browse the complete API documentation for detailed function references and examples.","category":"page"},{"location":"getting-started/#Getting-Help","page":"Getting Started","title":"Getting Help","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If you encounter issues:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Check the troubleshooting guide\nBrowse example workflows\nReport bugs on GitHub Issues","category":"page"},{"location":"getting-started/#Memory-and-Performance","page":"Getting Started","title":"Memory and Performance","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For large-scale analyses:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# Check memory requirements\nestimated_memory = Mycelia.estimate_memory_usage(input_file=\"large_reads.fastq\")\nprintln(\"Estimated memory needed: $(estimated_memory) GB\")\n\n# Monitor memory during analysis\nMycelia.with_memory_monitoring() do\n    result = Mycelia.assemble_genome(\"large_reads.fastq\")\nend","category":"page"},{"location":"getting-started/#Contributing-2","page":"Getting Started","title":"Contributing","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Mycelia is open-source and welcomes contributions! See our development guide for details.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Ready to dive deeper? Check out our workflow tutorials for complete biological analyses with real datasets.","category":"page"},{"location":"api/workflows/assembly-suite/#Assembly-Suite-Overview","page":"Assembly Suite","title":"Assembly Suite Overview","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Mycelia provides a comprehensive assembly suite with multiple approaches for genome assembly optimization. This document provides an overview of the assembly ecosystem and guidance on choosing the right approach for your data.","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Development Status: The assembly suite includes both stable implementations and experimental features. Features are clearly marked with their current status throughout this documentation.","category":"page"},{"location":"api/workflows/assembly-suite/#Assembly-Philosophy","page":"Assembly Suite","title":"Assembly Philosophy","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Mycelia's assembly suite is built on several core principles:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Accuracy First: Prioritize assembly accuracy over contiguity or speed\nQuality Awareness: Utilize quality scores for better assembly decisions\nGraph Hierarchy: Support 6 complementary graph types for different use cases\nType Safety: Maintain proper BioSequence types throughout (no string conversions)\nModular Design: Choose components based on your specific needs","category":"page"},{"location":"api/workflows/assembly-suite/#Graph-Type-Hierarchy","page":"Assembly Suite","title":"Graph Type Hierarchy","text":"","category":"section"},{"location":"api/workflows/assembly-suite/#Fixed-Length-Graphs-(Assembly-Foundation)","page":"Assembly Suite","title":"Fixed-Length Graphs (Assembly Foundation)","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"N-gram Graphs (build_ngram_graph) - Unicode character analysis\nK-mer Graphs (build_kmer_graph_next) - Standard k-mer assembly\nQualmer Graphs (build_qualmer_graph) - Quality-aware k-mer assembly","category":"page"},{"location":"api/workflows/assembly-suite/#Variable-Length-Graphs-(Simplified-Products)","page":"Assembly Suite","title":"Variable-Length Graphs (Simplified Products)","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"String Graphs (string_to_ngram_graph) - Variable unicode strings\nFASTA Graphs (build_biosequence_graph) - Variable BioSequences\nFASTQ Graphs (build_quality_biosequence_graph) - Quality-aware BioSequences","category":"page"},{"location":"api/workflows/assembly-suite/#Assembly-Approaches","page":"Assembly Suite","title":"Assembly Approaches","text":"","category":"section"},{"location":"api/workflows/assembly-suite/#1.-Standard-Assembly-(Traditional)","page":"Assembly Suite","title":"1. Standard Assembly (Traditional)","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"For basic k-mer assembly without quality awareness:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# Build k-mer graph\ngraph = Mycelia.build_kmer_graph_next(fasta_records; k=31, graph_mode=DoubleStrand)\n\n# Convert to sequence graph\nseq_graph = Mycelia.kmer_graph_to_biosequence_graph(graph, 31)\n\n# Extract contigs\ncontigs = Mycelia.extract_contigs_from_graph(seq_graph)","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Use Cases:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"High-quality FASTA data\nSimple genomes without complex repeats\nWhen computational speed is critical","category":"page"},{"location":"api/workflows/assembly-suite/#2.-Quality-Aware-Assembly","page":"Assembly Suite","title":"2. Quality-Aware Assembly","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"For assembly utilizing FASTQ quality scores:","category":"page"},{"location":"api/workflows/assembly-suite/#Option-A:-Qualmer-Mediated-(Recommended-for-most-cases)","page":"Assembly Suite","title":"Option A: Qualmer-Mediated (Recommended for most cases)","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# Build qualmer graph (k-mer level quality analysis)\nqualmer_graph = Mycelia.build_qualmer_graph(fastq_records; k=31)\n\n# Find quality-weighted paths\nstart_vertex = argmax(v -> qualmer_graph[v].joint_probability, vertices(qualmer_graph))\noptimal_path = Mycelia.find_quality_weighted_path(qualmer_graph, start_vertex)\n\n# Convert to quality-aware sequence graph\nfastq_graph = Mycelia.qualmer_graph_to_quality_biosequence_graph(qualmer_graph, 31)\n\n# Extract final assembly\nfinal_records = Mycelia.quality_biosequence_graph_to_fastq(fastq_graph, \"assembly\")","category":"page"},{"location":"api/workflows/assembly-suite/#Option-B:-Direct-Quality-Aware","page":"Assembly Suite","title":"Option B: Direct Quality-Aware","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# Build quality-aware sequence graph directly\nfastq_graph = Mycelia.build_quality_biosequence_graph(fastq_records)\n\n# Extract contigs with quality preservation\ncontigs = Mycelia.quality_biosequence_graph_to_fastq(fastq_graph, \"contigs\")","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Use Cases:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Illumina short reads\nError-prone long reads  \nWhen maximum accuracy is required\nComplex genomes with repeats","category":"page"},{"location":"api/workflows/assembly-suite/#3.-Intelligent-Self-Optimizing-Assembly-**Implemented**","page":"Assembly Suite","title":"3. Intelligent Self-Optimizing Assembly ✅ Implemented","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"For automated parameter optimization:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# Intelligent assembly with dynamic k-mer progression\nresults = Mycelia.mycelia_assemble(fastq_file; \n    max_k=101,\n    memory_limit=32_000_000_000,\n    output_dir=\"intelligent_assembly\"\n)\n\n# Cross-validation for quality assessment\nvalidation_results = Mycelia.mycelia_cross_validation(\n    fastq_records;\n    assembly_methods=[:intelligent, :iterative],\n    k_folds=5\n)","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Features:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"✅ Automatic prime k-mer progression\n✅ Sparsity-based k-mer selection\n✅ Memory monitoring and limits\n✅ Cross-validation for quality assessment","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Use Cases:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Unknown optimal parameters\nProduction assembly pipelines\nWhen manual optimization is impractical","category":"page"},{"location":"api/workflows/assembly-suite/#4.-Iterative-Statistical-Assembly-**Implemented**","page":"Assembly Suite","title":"4. Iterative Statistical Assembly ✅ Implemented","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"For statistical path improvement:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# Iterative assembly with read-level improvements\nresults = Mycelia.mycelia_iterative_assemble(fastq_file;\n    max_k=101,\n    memory_limit=32_000_000_000,\n    output_dir=\"iterative_assembly\"\n)","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Features:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"✅ Read-level likelihood optimization\n✅ Statistical path resampling\n✅ Timestamped output for tracking evolution\n🚧 Viterbi integration for optimal paths (partially implemented)","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Use Cases:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"When individual read optimization is beneficial\nDatasets with systematic errors\nResearch applications requiring detailed tracking","category":"page"},{"location":"api/workflows/assembly-suite/#5.-Reinforcement-Learning-Guided-Assembly-**Experimental**","page":"Assembly Suite","title":"5. Reinforcement Learning Guided Assembly 🧪 Experimental","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"For machine learning optimization (three experimental implementations available):","category":"page"},{"location":"api/workflows/assembly-suite/#Custom-RL-Framework-**Experimental-Under-Development**","page":"Assembly Suite","title":"Custom RL Framework 🧪 Experimental - Under Development","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# Train custom RL agent\nagent = Mycelia.DQNPolicy()\nenv = Mycelia.AssemblyEnvironment(reads)\ntrained_agent = Mycelia.train_assembly_agent(env, agent; episodes=1000)\n\n# Apply learned policy\nresults = Mycelia.apply_learned_policy(trained_agent, \"genome.fastq\")","category":"page"},{"location":"api/workflows/assembly-suite/#ReinforcementLearning.jl-Integration-**Experimental-Basic-Implementation**","page":"Assembly Suite","title":"ReinforcementLearning.jl Integration 🧪 Experimental - Basic Implementation","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# Use well-tested RL algorithms\nassembly, history = Mycelia.intelligent_assembly_rljl(\n    reads;\n    algorithm=:dqn,\n    train_episodes=1000\n)","category":"page"},{"location":"api/workflows/assembly-suite/#POMDPs.jl-Integration-**Experimental-Basic-Implementation**","page":"Assembly Suite","title":"POMDPs.jl Integration 🧪 Experimental - Basic Implementation","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# Formal MDP/POMDP approach\nassembly, history = Mycelia.intelligent_assembly_pomdp(\n    reads;\n    solver=:value_iteration,\n    use_pomdp=false\n)","category":"page"},{"location":"api/workflows/assembly-suite/#Comparison-Framework-**Experimental-Proof-of-Concept**","page":"Assembly Suite","title":"Comparison Framework 🧪 Experimental - Proof of Concept","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# Compare all three RL approaches\ncomparison = Mycelia.compare_rl_approaches(\n    reads;\n    approaches=[:custom, :rljl, :pomdp],\n    rljl_algorithm=:dqn,\n    pomdp_solver=:mcts\n)","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Use Cases:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Research into assembly optimization\nWhen you have training data for optimization\nAutomated parameter learning from experience","category":"page"},{"location":"api/workflows/assembly-suite/#Quality-Assessment-and-Metrics","page":"Assembly Suite","title":"Quality Assessment and Metrics","text":"","category":"section"},{"location":"api/workflows/assembly-suite/#Assembly-Quality-Metrics","page":"Assembly Suite","title":"Assembly Quality Metrics","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# Comprehensive quality assessment ✅ **Implemented**\nmetrics = Mycelia.calculate_assembly_quality_metrics(qualmer_graph)\n\n# Error detection 🚧 **Partially Implemented**\npotential_errors = Mycelia.identify_potential_errors(graph)\n\n# Cross-validation comparison ✅ **Implemented**\ncomparison = Mycelia.compare_assembly_statistics(\n    intelligent_results,\n    iterative_results\n)","category":"page"},{"location":"api/workflows/assembly-suite/#Available-Metrics","page":"Assembly Suite","title":"Available Metrics","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"✅ Mean k-mer coverage and quality\n✅ Joint probability confidence scores\n✅ Low-confidence k-mer fraction\n🚧 Assembly accuracy (when reference available - basic implementation)\n📋 Read mapping statistics (planned)\n📋 Contig N50 and other contiguity metrics (planned)","category":"page"},{"location":"api/workflows/assembly-suite/#Choosing-the-Right-Approach","page":"Assembly Suite","title":"Choosing the Right Approach","text":"","category":"section"},{"location":"api/workflows/assembly-suite/#Decision-Matrix","page":"Assembly Suite","title":"Decision Matrix","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Data Type Quality Complexity Recommended Approach\nFASTA, High Quality N/A Simple Standard K-mer\nFASTQ, High Quality >Q30 Simple Direct Quality-Aware\nFASTQ, Medium Quality Q20-Q30 Medium Qualmer-Mediated\nFASTQ, Low Quality <Q20 Complex Intelligent + Iterative\nUnknown Parameters Any Any Intelligent Assembly\nResearch/Optimization Any Any RL-Guided","category":"page"},{"location":"api/workflows/assembly-suite/#Performance-Considerations","page":"Assembly Suite","title":"Performance Considerations","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Approach Speed Memory Accuracy Automation Status\nStandard ⭐⭐⭐⭐⭐ ⭐⭐⭐⭐ ⭐⭐⭐ ⭐⭐ ✅ Stable\nQuality-Aware ⭐⭐⭐⭐ ⭐⭐⭐ ⭐⭐⭐⭐ ⭐⭐⭐ ✅ Stable\nIntelligent ⭐⭐⭐ ⭐⭐⭐ ⭐⭐⭐⭐⭐ ⭐⭐⭐⭐⭐ ✅ Stable\nIterative ⭐⭐ ⭐⭐ ⭐⭐⭐⭐ ⭐⭐⭐⭐ ✅ Stable\nRL-Guided ⭐ ⭐ ⭐⭐⭐⭐⭐ ⭐⭐⭐⭐⭐ 🧪 Experimental","category":"page"},{"location":"api/workflows/assembly-suite/#Integration-Examples","page":"Assembly Suite","title":"Integration Examples","text":"","category":"section"},{"location":"api/workflows/assembly-suite/#Complete-Workflow-Example","page":"Assembly Suite","title":"Complete Workflow Example","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# 1. Quality control\nqc_results = Mycelia.assess_fastq_quality(fastq_file)\n\n# 2. Choose assembly approach based on quality\nif qc_results.mean_quality > 30\n    # High quality - use direct approach\n    assembly = Mycelia.build_quality_biosequence_graph(records)\nelse\n    # Lower quality - use intelligent approach\n    assembly = Mycelia.mycelia_assemble(fastq_file)\nend\n\n# 3. Validate assembly\nvalidation = Mycelia.mycelia_cross_validation(records)\n\n# 4. Extract final results\nfinal_contigs = Mycelia.quality_biosequence_graph_to_fastq(assembly, \"final\")","category":"page"},{"location":"api/workflows/assembly-suite/#Benchmarking-Workflow","page":"Assembly Suite","title":"Benchmarking Workflow","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"import Mycelia\n\n# Compare multiple approaches\napproaches = [:intelligent, :iterative, :quality_aware]\nbenchmark_results = Mycelia.benchmark_assembly_approaches(\n    test_datasets,\n    approaches;\n    metrics=[:accuracy, :speed, :memory]\n)","category":"page"},{"location":"api/workflows/assembly-suite/#Best-Practices","page":"Assembly Suite","title":"Best Practices","text":"","category":"section"},{"location":"api/workflows/assembly-suite/#General-Guidelines","page":"Assembly Suite","title":"General Guidelines","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Start Simple: Use standard k-mer assembly for initial exploration\nUse Quality: Incorporate quality scores when available\nValidate Results: Always use cross-validation for important assemblies\nMonitor Resources: Use memory limits to prevent system crashes\nDocument Parameters: Save assembly parameters for reproducibility","category":"page"},{"location":"api/workflows/assembly-suite/#Performance-Optimization","page":"Assembly Suite","title":"Performance Optimization","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Choose Appropriate k: Use sparsity detection for optimal k-mer sizes\nMemory Management: Configure memory limits based on available resources\nParallel Processing: Utilize multi-threading where available\nIncremental Assembly: Use checkpointing for long-running assemblies","category":"page"},{"location":"api/workflows/assembly-suite/#Quality-Control","page":"Assembly Suite","title":"Quality Control","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Pre-Assembly QC: Assess read quality before choosing approach\nAssembly Validation: Use cross-validation and read mapping\nError Detection: Monitor low-confidence regions\nComparative Analysis: Compare results from multiple approaches","category":"page"},{"location":"api/workflows/assembly-suite/#Implementation-Status-and-Future-Directions","page":"Assembly Suite","title":"Implementation Status and Future Directions","text":"","category":"section"},{"location":"api/workflows/assembly-suite/#Current-Status","page":"Assembly Suite","title":"Current Status","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"✅ Stable: Core graph-based assembly algorithms, quality-aware assembly, intelligent assembly\n🚧 In Development: Error correction algorithms, advanced validation metrics\n🧪 Experimental: Reinforcement learning approaches, POMDP integration\n📋 Planned: Enhanced parallel processing, cloud integration, long-read optimizations","category":"page"},{"location":"api/workflows/assembly-suite/#Experimental-Features-Notice","page":"Assembly Suite","title":"Experimental Features Notice","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"🧪 Experimental features are research implementations that may:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"Require additional dependencies\nHave limited testing coverage\nChange significantly between versions\nBe computationally intensive","category":"page"},{"location":"api/workflows/assembly-suite/#Future-Directions","page":"Assembly Suite","title":"Future Directions","text":"","category":"section"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"The Mycelia assembly suite continues to evolve with:","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"🚧 Enhanced machine learning integration\n📋 Improved parallel processing capabilities\n🚧 Additional quality-aware algorithms\n📋 Extended support for long-read technologies\n📋 Integration with cloud computing platforms","category":"page"},{"location":"api/workflows/assembly-suite/","page":"Assembly Suite","title":"Assembly Suite","text":"For the latest developments, see the Assembly Roadmap.","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Tutorial-5:-Assembly-Validation","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"This tutorial covers comprehensive validation techniques for genome assemblies, including reference-based and reference-free approaches.","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Learning-Objectives","page":"Tutorial 5: Assembly Validation","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"By the end of this tutorial, you will understand:","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Reference-based validation using alignment and comparison tools\nReference-free validation using k-mer and read-based approaches\nBUSCO analysis for gene completeness assessment\nMerqury for k-mer based quality assessment\nStatistical validation and confidence intervals\nComparative validation across multiple assemblies","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Setup","page":"Tutorial 5: Assembly Validation","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"import Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\n\nRandom.seed!(42)","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Part-1:-Validation-Strategy-Overview","page":"Tutorial 5: Assembly Validation","title":"Part 1: Validation Strategy Overview","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Assembly validation requires multiple complementary approaches to ensure comprehensive quality assessment.","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"=== Assembly Validation Tutorial ===\")\n\nprintln(\"Validation Approaches:\")\nprintln(\"1. Reference-based validation\")\nprintln(\"   - Alignment to known reference\")\nprintln(\"   - Synteny analysis\")\nprintln(\"   - Structural variant detection\")\nprintln()\nprintln(\"2. Reference-free validation\")\nprintln(\"   - K-mer based approaches (Merqury)\")\nprintln(\"   - Read mapping validation\")\nprintln(\"   - Internal consistency checks\")\nprintln()\nprintln(\"3. Functional validation\")\nprintln(\"   - Gene completeness (BUSCO)\")\nprintln(\"   - Annotation quality\")\nprintln(\"   - Comparative genomics\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Part-2:-Reference-Based-Validation","page":"Tutorial 5: Assembly Validation","title":"Part 2: Reference-Based Validation","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"When reference genomes are available, direct comparison provides the most straightforward validation approach.","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"\\n=== Reference-Based Validation ===\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Preparing-Test-Data","page":"Tutorial 5: Assembly Validation","title":"Preparing Test Data","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Create reference and assembly for validation demonstration","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Preparing Test Data ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Reference genome","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"reference_size = 100000  ## 100 kb\nreference_genome = Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=reference_size)\nreference_file = \"reference.fasta\"\nMycelia.write_fasta(outfile=reference_file, records=[reference_genome])","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Simulated assembly with some differences","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"assembly_contigs = [\n    # Contig 1: Perfect match to reference positions 1-40000\n    Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=40000),\n    # Contig 2: Reference positions 40001-80000 with some variants\n    Mycelia.random_fasta_record(moltype=:DNA, seed=2, L=40000),\n    # Contig 3: Reference positions 80001-100000\n    Mycelia.random_fasta_record(moltype=:DNA, seed=3, L=20000)\n]\n\nassembly_file = \"assembly.fasta\"\nMycelia.write_fasta(outfile=assembly_file, records=assembly_contigs)\n\nprintln(\"Test data prepared:\")\nprintln(\"  Reference: $(reference_size) bp\")\nprintln(\"  Assembly: $(length(assembly_contigs)) contigs\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Alignment-Based-Validation","page":"Tutorial 5: Assembly Validation","title":"Alignment-Based Validation","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Use alignment tools to compare assembly to reference","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Alignment-Based Validation ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement alignment-based validation","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Whole genome alignment (MUMmer, minimap2)\nCalculate alignment statistics\nIdentify structural differences\nAssess coverage and identity","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"alignment_stats = Dict(\n    \"total_aligned\" => 98500,\n    \"percent_identity\" => 99.2,\n    \"coverage\" => 98.5,\n    \"n_mismatches\" => 800,\n    \"n_indels\" => 45,\n    \"n_structural_variants\" => 3\n)\n\nprintln(\"Alignment Statistics:\")\nfor (metric, value) in alignment_stats\n    println(\"  $metric: $value\")\nend","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Synteny-Analysis","page":"Tutorial 5: Assembly Validation","title":"Synteny Analysis","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Analyze conserved gene order and chromosomal structure","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Synteny Analysis ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement synteny analysis","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Identify orthologous regions\nAnalyze gene order conservation\nDetect chromosomal rearrangements\nVisualize synteny relationships","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Structural-Variant-Detection","page":"Tutorial 5: Assembly Validation","title":"Structural Variant Detection","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Identify large-scale differences between assembly and reference","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Structural Variant Detection ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement structural variant detection","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Detect insertions, deletions, inversions\nIdentify duplications and translocations\nValidate with read evidence\nClassify variant types and sizes","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Part-3:-Reference-Free-Validation","page":"Tutorial 5: Assembly Validation","title":"Part 3: Reference-Free Validation","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"When no reference is available, use intrinsic data properties for validation.","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"\\n=== Reference-Free Validation ===\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#K-mer-Based-Validation-(Merqury)","page":"Tutorial 5: Assembly Validation","title":"K-mer Based Validation (Merqury)","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Use k-mer analysis to assess assembly quality without reference","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- K-mer Based Validation ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement Merqury-style validation","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Generate k-mer database from reads\nCalculate assembly QV (Quality Value)\nAssess k-mer completeness\nDetect assembly errors","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Simulate k-mer validation results","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"merqury_results = Dict(\n    \"assembly_qv\" => 35.2,        ## Phred-scaled quality\n    \"kmer_completeness\" => 98.7,   ## Percentage of read k-mers in assembly\n    \"false_duplications\" => 0.8,   ## Percentage of duplicated k-mers\n    \"solid_kmers\" => 1250000,     ## Number of reliable k-mers\n    \"error_kmers\" => 15000        ## Number of error k-mers\n)\n\nprintln(\"Merqury Results:\")\nfor (metric, value) in merqury_results\n    println(\"  $metric: $value\")\nend","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Read-Mapping-Validation","page":"Tutorial 5: Assembly Validation","title":"Read Mapping Validation","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Map original reads back to assembly for validation","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Read Mapping Validation ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement read mapping validation","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Map reads to assembly\nCalculate mapping statistics\nIdentify unmapped regions\nAssess coverage uniformity","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"mapping_stats = Dict(\n    \"mapped_reads\" => 95.4,       ## Percentage of reads mapped\n    \"properly_paired\" => 92.1,    ## Percentage of properly paired reads\n    \"mean_coverage\" => 24.8,      ## Average coverage depth\n    \"coverage_uniformity\" => 0.85, # Coefficient of variation\n    \"unmapped_regions\" => 147     ## Number of unmapped regions\n)\n\nprintln(\"Read Mapping Statistics:\")\nfor (metric, value) in mapping_stats\n    println(\"  $metric: $value\")\nend","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Internal-Consistency-Validation","page":"Tutorial 5: Assembly Validation","title":"Internal Consistency Validation","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Check assembly internal consistency","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Internal Consistency ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement internal consistency checks","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Check for overlapping contigs\nValidate contig connections\nIdentify potential misassemblies\nAssess gap consistency","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Part-4:-Functional-Validation","page":"Tutorial 5: Assembly Validation","title":"Part 4: Functional Validation","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Validate assembly quality through functional analysis","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"\\n=== Functional Validation ===\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#BUSCO-Analysis","page":"Tutorial 5: Assembly Validation","title":"BUSCO Analysis","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Assess gene completeness using conserved orthologs","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- BUSCO Analysis ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement BUSCO analysis","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Run BUSCO on assembly\nCalculate completeness scores\nIdentify missing genes\nCompare with related species","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"busco_results = Dict(\n    \"complete_single_copy\" => 92.4,\n    \"complete_duplicated\" => 3.2,\n    \"fragmented\" => 2.8,\n    \"missing\" => 1.6,\n    \"total_buscos\" => 1440\n)\n\nprintln(\"BUSCO Results:\")\nfor (metric, value) in busco_results\n    println(\"  $metric: $value\")\nend","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Gene-Annotation-Quality","page":"Tutorial 5: Assembly Validation","title":"Gene Annotation Quality","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Validate through gene prediction and annotation","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Gene Annotation Quality ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement annotation quality assessment","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Predict genes in assembly\nCompare with known gene sets\nAssess annotation consistency\nValidate gene structures","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Part-5:-Comparative-Validation","page":"Tutorial 5: Assembly Validation","title":"Part 5: Comparative Validation","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Compare multiple assemblies to identify best approach","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"\\n=== Comparative Validation ===\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Multi-Assembly-Comparison","page":"Tutorial 5: Assembly Validation","title":"Multi-Assembly Comparison","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Compare assemblies from different tools or parameters","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Multi-Assembly Comparison ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement multi-assembly comparison","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Compare multiple assemblies\nIdentify consistent regions\nAssess tool-specific biases\nGenerate consensus assessments","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Simulate comparison results","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"assembly_comparison = Dict(\n    \"hifiasm\" => Dict(\"n50\" => 25000, \"busco\" => 94.2, \"qv\" => 35.8),\n    \"canu\" => Dict(\"n50\" => 18000, \"busco\" => 91.5, \"qv\" => 33.1),\n    \"flye\" => Dict(\"n50\" => 22000, \"busco\" => 92.8, \"qv\" => 34.5)\n)\n\nprintln(\"Assembly Comparison:\")\nfor (assembler, metrics) in assembly_comparison\n    println(\"  $assembler:\")\n    for (metric, value) in metrics\n        println(\"    $metric: $value\")\n    end\nend","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Statistical-Validation","page":"Tutorial 5: Assembly Validation","title":"Statistical Validation","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Apply statistical tests to validation results","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Statistical Validation ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement statistical validation","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Bootstrap confidence intervals\nSignificance testing\nMultiple testing correction\nEffect size estimation","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Part-6:-Validation-Metrics-Integration","page":"Tutorial 5: Assembly Validation","title":"Part 6: Validation Metrics Integration","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Combine multiple validation approaches for comprehensive assessment","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"\\n=== Integrated Validation ===\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Composite-Quality-Scores","page":"Tutorial 5: Assembly Validation","title":"Composite Quality Scores","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Combine multiple metrics into overall quality assessment","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Composite Quality Scores ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement composite scoring","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Weight different validation metrics\nGenerate overall quality scores\nRank assemblies by quality\nProvide confidence intervals","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"composite_score = Dict(\n    \"overall_quality\" => 8.7,     ## Scale 0-10\n    \"confidence_interval\" => (8.2, 9.1),\n    \"primary_strengths\" => [\"High contiguity\", \"Good gene completeness\"],\n    \"primary_weaknesses\" => [\"Some structural variants\", \"Coverage gaps\"]\n)\n\nprintln(\"Composite Quality Assessment:\")\nfor (metric, value) in composite_score\n    println(\"  $metric: $value\")\nend","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Validation-Report-Generation","page":"Tutorial 5: Assembly Validation","title":"Validation Report Generation","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Create comprehensive validation reports","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Validation Report ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement report generation","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Generate HTML/PDF reports\nInclude visualizations\nProvide recommendations\nExport results to standard formats","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Part-7:-Validation-Visualization","page":"Tutorial 5: Assembly Validation","title":"Part 7: Validation Visualization","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Create visualizations for validation results","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"\\n=== Validation Visualization ===\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Quality-Metric-Plots","page":"Tutorial 5: Assembly Validation","title":"Quality Metric Plots","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Visualize validation metrics","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Quality Metric Plots ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement validation visualization","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Quality score distributions\nMetric correlation plots\nValidation timeline plots\nComparative assembly plots","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Genome-Browser-Integration","page":"Tutorial 5: Assembly Validation","title":"Genome Browser Integration","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Visualize validation results in genome browser context","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Genome Browser Integration ---\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"TODO: Implement genome browser integration","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Generate browser tracks\nHighlight validation issues\nInteractive exploration\nExport visualization formats","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Part-8:-Validation-Best-Practices","page":"Tutorial 5: Assembly Validation","title":"Part 8: Validation Best Practices","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Guidelines for effective assembly validation","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"\\n=== Validation Best Practices ===\")\n\nprintln(\"Validation Strategy:\")\nprintln(\"- Use multiple complementary approaches\")\nprintln(\"- Always validate with original data\")\nprintln(\"- Compare with related genomes when available\")\nprintln(\"- Focus on metrics relevant to your research goals\")\nprintln()\nprintln(\"Quality Thresholds:\")\nprintln(\"- BUSCO completeness: >90% for eukaryotes, >95% for prokaryotes\")\nprintln(\"- Assembly QV: >30 for high-quality assemblies\")\nprintln(\"- Read mapping: >95% of reads should map\")\nprintln(\"- Contig N50: Should be substantial fraction of chromosome size\")\nprintln()\nprintln(\"Common Pitfalls:\")\nprintln(\"- Relying on single validation metric\")\nprintln(\"- Ignoring biological context\")\nprintln(\"- Not validating with original data\")\nprintln(\"- Accepting assemblies without proper validation\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Part-9:-Troubleshooting-Assembly-Issues","page":"Tutorial 5: Assembly Validation","title":"Part 9: Troubleshooting Assembly Issues","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Identify and address common assembly problems","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"\\n=== Troubleshooting Assembly Issues ===\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Common-Problems-and-Solutions","page":"Tutorial 5: Assembly Validation","title":"Common Problems and Solutions","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Systematic approach to assembly problem diagnosis","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"--- Common Assembly Problems ---\")\n\nproblems_solutions = Dict(\n    \"Low contiguity\" => [\n        \"Increase read length or coverage\",\n        \"Optimize assembly parameters\",\n        \"Use scaffolding approaches\",\n        \"Check for contamination\"\n    ],\n    \"Poor gene completeness\" => [\n        \"Check assembly coverage\",\n        \"Examine repeat resolution\",\n        \"Validate gene prediction parameters\",\n        \"Consider alternative assemblers\"\n    ],\n    \"High error rate\" => [\n        \"Increase polishing iterations\",\n        \"Check read quality\",\n        \"Validate assembly parameters\",\n        \"Consider consensus approaches\"\n    ],\n    \"Missing sequences\" => [\n        \"Check for contamination filtering\",\n        \"Examine coverage bias\",\n        \"Validate input data quality\",\n        \"Consider hybrid approaches\"\n    ]\n)\n\nfor (problem, solutions) in problems_solutions\n    println(\"$problem:\")\n    for solution in solutions\n        println(\"  - $solution\")\n    end\n    println()\nend","category":"page"},{"location":"generated/tutorials/05_assembly_validation/#Summary","page":"Tutorial 5: Assembly Validation","title":"Summary","text":"","category":"section"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"println(\"=== Assembly Validation Summary ===\")\nprintln(\"✓ Understanding multiple validation approaches\")\nprintln(\"✓ Implementing reference-based validation techniques\")\nprintln(\"✓ Applying reference-free validation methods\")\nprintln(\"✓ Functional validation through gene completeness\")\nprintln(\"✓ Comparative validation across multiple assemblies\")\nprintln(\"✓ Statistical validation and confidence assessment\")\nprintln(\"✓ Integrated quality scoring and reporting\")\nprintln(\"✓ Troubleshooting common assembly issues\")","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"Cleanup","category":"page"},{"location":"generated/tutorials/05_assembly_validation/","page":"Tutorial 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"cleanup_files = [reference_file, assembly_file]\nfor file in cleanup_files\n    if isfile(file)\n        rm(file, force=true)\n    end\nend\n\nprintln(\"\\nNext: Tutorial 6 - Gene Annotation\")\n\nnothing","category":"page"},{"location":"generated/tutorials/run_all_tutorials/#Run-All-Mycelia-Tutorials","page":"Run All Mycelia Tutorials","title":"Run All Mycelia Tutorials","text":"","category":"section"},{"location":"generated/tutorials/run_all_tutorials/","page":"Run All Mycelia Tutorials","title":"Run All Mycelia Tutorials","text":"This script executes all Mycelia tutorials in sequence. Use with caution - may take significant time and resources.","category":"page"},{"location":"generated/tutorials/run_all_tutorials/#Usage","page":"Run All Mycelia Tutorials","title":"Usage","text":"","category":"section"},{"location":"generated/tutorials/run_all_tutorials/","page":"Run All Mycelia Tutorials","title":"Run All Mycelia Tutorials","text":"# Run all tutorials\njulia --project=. tutorials/run_all_tutorials.jl\n\n# Run specific tutorial\njulia --project=. tutorials/01_data_acquisition.jl\n\n# Convert to notebooks\njulia --project=. -e 'include(\"tutorials/run_all_tutorials.jl\"); convert_all_to_notebooks()'","category":"page"},{"location":"generated/tutorials/run_all_tutorials/","page":"Run All Mycelia Tutorials","title":"Run All Mycelia Tutorials","text":"import Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Dates\nimport Literate","category":"page"},{"location":"generated/tutorials/run_all_tutorials/","page":"Run All Mycelia Tutorials","title":"Run All Mycelia Tutorials","text":"List of all tutorials in execution order","category":"page"},{"location":"generated/tutorials/run_all_tutorials/","page":"Run All Mycelia Tutorials","title":"Run All Mycelia Tutorials","text":"TUTORIALS = [\n    \"01_data_acquisition.jl\",\n    \"02_quality_control.jl\",\n    \"03_kmer_analysis.jl\",\n    \"04_genome_assembly.jl\",\n    \"05_assembly_validation.jl\",\n    \"06_gene_annotation.jl\",\n    \"07_comparative_genomics.jl\",\n    \"08_tool_integration.jl\",\n]\n\n\"\"\"\n    run_all_tutorials()\n\nExecute all tutorials in sequence, collecting timing and status information.\n\"\"\"\nfunction run_all_tutorials()\n    println(\"=== Running All Mycelia Tutorials ===\")\n    println(\"Start time: $(Dates.now())\")\n    println()\n\n    results = []\n    total_start = time()\n\n    for tutorial in TUTORIALS\n        if isfile(tutorial)\n            println(\"Running $tutorial...\")\n            start_time = time()\n\n            try\n                # Execute tutorial\n                include(tutorial)\n\n                elapsed = time() - start_time\n                push!(results, (tutorial, :success, elapsed))\n                println(\"✓ $tutorial completed in $(round(elapsed, digits=2))s\")\n\n            catch e\n                elapsed = time() - start_time\n                push!(results, (tutorial, :error, elapsed, e))\n                println(\"✗ $tutorial failed after $(round(elapsed, digits=2))s\")\n                println(\"  Error: $e\")\n            end\n\n            println()\n        else\n            println(\"⚠ $tutorial not found, skipping...\")\n            push!(results, (tutorial, :not_found, 0.0))\n        end\n    end\n\n    total_elapsed = time() - total_start\n\n    # Print summary\n    println(\"=== Tutorial Execution Summary ===\")\n    println(\"Total time: $(round(total_elapsed, digits=2))s\")\n    println()\n\n    successful = 0\n    for (tutorial, status, elapsed, error...) in results\n        if status == :success\n            println(\"✓ $tutorial ($(round(elapsed, digits=2))s)\")\n            successful += 1\n        elseif status == :error\n            println(\"✗ $tutorial ($(round(elapsed, digits=2))s) - $(error[1])\")\n        else\n            println(\"⚠ $tutorial (not found)\")\n        end\n    end\n\n    println()\n    println(\"Successful: $successful/$(length(TUTORIALS))\")\n    println(\"End time: $(Dates.now())\")\n\n    return results\nend\n\n\"\"\"\n    convert_all_to_notebooks()\n\nConvert all tutorials to Jupyter notebooks using Literate.jl.\n\"\"\"\nfunction convert_all_to_notebooks()\n    println(\"=== Converting Tutorials to Notebooks ===\")\n\n    # Create notebooks directory if it doesn't exist\n    notebooks_dir = \"notebooks\"\n    if !isdir(notebooks_dir)\n        mkdir(notebooks_dir)\n    end\n\n    for tutorial in TUTORIALS\n        if isfile(tutorial)\n            println(\"Converting $tutorial to notebook...\")\n\n            try\n                # Convert to notebook\n                Literate.notebook(tutorial, notebooks_dir, execute=false)\n                println(\"✓ Converted $tutorial\")\n\n            catch e\n                println(\"✗ Failed to convert $tutorial: $e\")\n            end\n        else\n            println(\"⚠ $tutorial not found, skipping...\")\n        end\n    end\n\n    println()\n    println(\"Notebooks saved to: $notebooks_dir\")\nend\n\n\"\"\"\n    run_tutorial(tutorial_name)\n\nRun a specific tutorial by name.\n\"\"\"\nfunction run_tutorial(tutorial_name)\n    if !endswith(tutorial_name, \".jl\")\n        tutorial_name *= \".jl\"\n    end\n\n    if isfile(tutorial_name)\n        println(\"Running $tutorial_name...\")\n        start_time = time()\n\n        try\n            include(tutorial_name)\n            elapsed = time() - start_time\n            println(\"✓ $tutorial_name completed in $(round(elapsed, digits=2))s\")\n            return true\n        catch e\n            elapsed = time() - start_time\n            println(\"✗ $tutorial_name failed after $(round(elapsed, digits=2))s\")\n            println(\"  Error: $e\")\n            return false\n        end\n    else\n        println(\"✗ $tutorial_name not found\")\n        return false\n    end\nend","category":"page"},{"location":"generated/tutorials/run_all_tutorials/","page":"Run All Mycelia Tutorials","title":"Run All Mycelia Tutorials","text":"Main execution","category":"page"},{"location":"generated/tutorials/run_all_tutorials/","page":"Run All Mycelia Tutorials","title":"Run All Mycelia Tutorials","text":"if abspath(PROGRAM_FILE) == @__FILE__\n    # Only run if this script is executed directly\n    if length(ARGS) == 0\n        # Run all tutorials\n        results = run_all_tutorials()\n    elseif ARGS[1] == \"convert\"\n        # Convert to notebooks\n        convert_all_to_notebooks()\n    else\n        # Run specific tutorial\n        tutorial_name = ARGS[1]\n        run_tutorial(tutorial_name)\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Round-Trip-Tutorial-2:-String-Data-N-gram-Graphs-String-Graphs-Reconstruction","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"This tutorial demonstrates the hierarchical graph conversion workflow in Mycelia, showing how fixed-length N-gram graphs can be simplified into variable-length String graphs. This represents the fundamental pattern of graph hierarchy used throughout the Mycelia system.","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Learning-Objectives","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"By the end of this tutorial, you will:","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"Understand the hierarchical relationship between N-gram and String graphs\nLearn to convert fixed-length graphs to variable-length representations\nPerform graph simplification and path collapse operations\nCompare reconstruction quality across graph representations\nAnalyze the trade-offs between graph complexity and assembly accuracy","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"import Mycelia\nimport Statistics\nimport Random","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Understanding-Graph-Hierarchy","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Understanding Graph Hierarchy","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"The Mycelia system implements a hierarchical graph structure where fixed-length graphs serve as the foundation for variable-length simplified graphs.","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"println(\"=\"^80)\nprintln(\"ROUND-TRIP TUTORIAL 2: N-GRAM TO STRING GRAPH HIERARCHY\")\nprintln(\"=\"^80)\n\nprintln(\"\\n📚 GRAPH HIERARCHY OVERVIEW:\")\nprintln(\"  Fixed-Length Graphs (Foundation):\")\nprintln(\"    • N-gram graphs: Fixed-size text fragments\")\nprintln(\"    • K-mer graphs: Fixed-size biological sequences\")\nprintln(\"    • Qualmer graphs: Quality-aware fixed-size sequences\")\nprintln()\nprintln(\"  Variable-Length Graphs (Simplified Products):\")\nprintln(\"    • String graphs: Variable-length text sequences\")\nprintln(\"    • BioSequence graphs: Variable-length biological sequences\")\nprintln(\"    • Quality BioSequence graphs: Quality-aware variable sequences\")\nprintln()\nprintln(\"  This tutorial: N-gram → String graph conversion\")","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Data-Preparation-with-Hierarchical-Complexity","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Data Preparation with Hierarchical Complexity","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"Create test data that will demonstrate different aspects of graph simplification.","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"test_datasets = [\n    (\n        name = \"Simple Repetitive\",\n        text = \"ABCABCABCABC\",\n        description = \"High repetition, should simplify well\"\n    ),\n    (\n        name = \"Linear Sequence\",\n        text = \"ABCDEFGHIJKLMNOP\",\n        description = \"Linear path, should collapse to single string\"\n    ),\n    (\n        name = \"Branching Pattern\",\n        text = \"ABCXYZABCDEFABCPQR\",\n        description = \"Branching structure, complex simplification\"\n    ),\n    (\n        name = \"Real Text\",\n        text = \"The quick brown fox jumps over the lazy dog\",\n        description = \"Natural language with spaces and complexity\"\n    ),\n    (\n        name = \"DNA-like Sequence\",\n        text = \"ATCGATCGATCGATCGTAGCTAGCTAGCT\",\n        description = \"Biological sequence simulation\"\n    )\n]\n\nprintln(\"\\n1. HIERARCHICAL DATA PREPARATION\")\nprintln(\"-\"^50)\n\nfor (i, dataset) in enumerate(test_datasets)\n    println(\"Dataset $i: $(dataset.name)\")\n    println(\"  Text: \\\"$(dataset.text)\\\"\")\n    println(\"  Description: $(dataset.description)\")\n    println(\"  Length: $(length(dataset.text)) characters\")\n    println()\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Phase-1:-N-gram-Graph-Construction","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Phase 1: N-gram Graph Construction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"Build the foundation fixed-length N-gram graphs.","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"println(\"\\n2. PHASE 1: N-GRAM GRAPH CONSTRUCTION\")\nprintln(\"-\"^50)\n\nngram_results = Dict()\n\nfor n in [3, 4, 5]\n    println(\"\\\\nConstructing $(n)-gram graphs:\")\n\n    for (i, dataset) in enumerate(test_datasets)\n        if length(dataset.text) >= n\n            try\n                # Build N-gram graph\n                graph = Mycelia.string_to_ngram_graph(s=dataset.text, n=n)\n\n                # Extract statistics\n                vertices = collect(values(graph.vertex_labels))\n                num_vertices = length(vertices)\n                expected_ngrams = length(dataset.text) - n + 1\n\n                # Calculate graph properties\n                compression_ratio = num_vertices / expected_ngrams\n\n                # Store results\n                key = \"$(dataset.name)_$(n)\"\n                ngram_results[key] = (\n                    dataset = dataset,\n                    graph = graph,\n                    n = n,\n                    vertices = vertices,\n                    num_vertices = num_vertices,\n                    expected_ngrams = expected_ngrams,\n                    compression_ratio = compression_ratio\n                )\n\n                println(\"  $(dataset.name): $(num_vertices)/$(expected_ngrams) vertices ($(round(compression_ratio, digits=3)) compression)\")\n\n                # Show example n-grams\n                if num_vertices > 0\n                    example_count = min(3, num_vertices)\n                    println(\"    Examples: $(vertices[1:example_count])\")\n                end\n\n            catch e\n                println(\"  $(dataset.name): Construction failed - $(typeof(e))\")\n            end\n        else\n            println(\"  $(dataset.name): Text too short for $(n)-grams\")\n        end\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Phase-2:-Graph-Analysis-and-Path-Detection","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Phase 2: Graph Analysis and Path Detection","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"Analyze the N-gram graphs to understand their structure before simplification.","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"println(\"\\n3. PHASE 2: GRAPH ANALYSIS AND PATH DETECTION\")\nprintln(\"-\"^50)\n\nfunction analyze_ngram_graph_structure(graph, description)\n    \"\"\"Analyze structural properties of an N-gram graph.\"\"\"\n\n    vertices = collect(values(graph.vertex_labels))\n    num_vertices = length(vertices)\n\n    if num_vertices == 0\n        return (vertices=0, linear_paths=0, branch_points=0, complexity=\"empty\")\n    end\n\n    # Basic connectivity analysis\n    # Note: This is a simplified analysis - full graph traversal would require edge information\n\n    # Analyze overlap patterns\n    overlap_count = 0\n    potential_linear = 0\n\n    for i in 1:length(vertices)\n        for j in (i+1):length(vertices)\n            v1, v2 = vertices[i], vertices[j]\n            if length(v1) > 1 && length(v2) > 1\n                # Check for potential overlap (simplified heuristic)\n                if v1[2:end] == v2[1:end-1] || v2[2:end] == v1[1:end-1]\n                    overlap_count += 1\n                end\n            end\n        end\n    end\n\n    # Estimate complexity\n    complexity = if overlap_count == 0\n        \"isolated\"\n    elseif overlap_count <= num_vertices\n        \"linear\"\n    else\n        \"complex\"\n    end\n\n    println(\"  $description:\")\n    println(\"    Vertices: $num_vertices\")\n    println(\"    Potential overlaps: $overlap_count\")\n    println(\"    Estimated complexity: $complexity\")\n\n    return (\n        vertices = num_vertices,\n        overlaps = overlap_count,\n        complexity = complexity\n    )\nend\n\n# Analyze representative graphs\nprintln(\"Analyzing N-gram graph structures:\")\nfor n in [3, 4]\n    for dataset in test_datasets[1:3]  ## Analyze first 3 datasets\n        key = \"$(dataset.name)_$(n)\"\n        if haskey(ngram_results, key)\n            result = ngram_results[key]\n            analyze_ngram_graph_structure(result.graph, \"$(dataset.name) $(n)-gram\")\n        end\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Phase-3:-String-Graph-Conversion-(Theoretical)","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Phase 3: String Graph Conversion (Theoretical)","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"Demonstrate the concept of converting N-gram graphs to String graphs. Note: Full implementation may require additional graph traversal algorithms.","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"println(\"\\n4. PHASE 3: STRING GRAPH CONVERSION (CONCEPTUAL)\")\nprintln(\"-\"^50)\n\nfunction simulate_string_graph_conversion(ngram_result)\n    \"\"\"Simulate the conversion from N-gram graph to String graph.\"\"\"\n\n    vertices = ngram_result.vertices\n    n = ngram_result.n\n    original_text = ngram_result.dataset.text\n\n    # Simplified simulation of path collapse\n    # In a full implementation, this would involve:\n    # 1. Finding linear paths through the graph\n    # 2. Collapsing unbranching paths into single vertices\n    # 3. Preserving branching structure\n\n    # For simulation, we'll estimate the result\n    estimated_strings = []\n\n    if ngram_result.compression_ratio < 0.5  ## High compression suggests repetition\n        # High repetition might collapse to fewer, longer strings\n        estimated_count = max(1, ngram_result.num_vertices ÷ 3)\n        estimated_avg_length = length(original_text) ÷ estimated_count\n\n        for i in 1:estimated_count\n            # Create simulated string\n            start_pos = ((i-1) * estimated_avg_length) + 1\n            end_pos = min(start_pos + estimated_avg_length - 1, length(original_text))\n            if start_pos <= length(original_text)\n                simulated_string = original_text[start_pos:end_pos]\n                push!(estimated_strings, simulated_string)\n            end\n        end\n    else\n        # Low compression might result in strings similar to original n-grams\n        # but with some linear paths collapsed\n        for vertex in vertices[1:min(5, length(vertices))]  ## Limit for simulation\n            push!(estimated_strings, vertex)\n        end\n    end\n\n    return estimated_strings\nend\n\nstring_conversion_results = Dict()\n\nprintln(\"Simulating N-gram to String graph conversions:\")\nfor (key, result) in ngram_results\n    estimated_strings = simulate_string_graph_conversion(result)\n\n    string_conversion_results[key] = (\n        original_ngram_result = result,\n        estimated_strings = estimated_strings,\n        conversion_ratio = length(estimated_strings) / result.num_vertices\n    )\n\n    println(\"  $(key):\")\n    println(\"    N-gram vertices: $(result.num_vertices)\")\n    println(\"    Estimated string vertices: $(length(estimated_strings))\")\n    println(\"    Conversion ratio: $(round(length(estimated_strings) / result.num_vertices, digits=3))\")\n\n    if !isempty(estimated_strings)\n        example_count = min(2, length(estimated_strings))\n        println(\"    Example strings: $(estimated_strings[1:example_count])\")\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Phase-4:-Reconstruction-and-Round-Trip-Validation","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Phase 4: Reconstruction and Round-Trip Validation","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"Validate the complete round-trip workflow through both graph representations.","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"println(\"\\n5. PHASE 4: RECONSTRUCTION AND ROUND-TRIP VALIDATION\")\nprintln(\"-\"^50)\n\nfunction validate_round_trip(original_text, ngram_graph, estimated_strings, n)\n    \"\"\"Validate the round-trip reconstruction quality.\"\"\"\n\n    # Method 1: Direct N-gram assembly\n    try\n        ngram_assembly = Mycelia.assemble_strings(ngram_graph)\n        ngram_success = !isempty(ngram_assembly)\n\n        # Find best N-gram reconstruction\n        best_ngram_similarity = 0.0\n        best_ngram_reconstruction = \"\"\n\n        for reconstruction in ngram_assembly\n            similarity = calculate_similarity(original_text, reconstruction)\n            if similarity > best_ngram_similarity\n                best_ngram_similarity = similarity\n                best_ngram_reconstruction = reconstruction\n            end\n        end\n\n    catch e\n        ngram_success = false\n        best_ngram_similarity = 0.0\n        best_ngram_reconstruction = \"\"\n        ngram_assembly = String[]\n    end\n\n    # Method 2: String graph simulation\n    string_success = !isempty(estimated_strings)\n\n    # For string graphs, we'll simulate a simple concatenation approach\n    if string_success\n        # Try different string combinations\n        string_reconstruction = join(estimated_strings, \"\")\n        string_similarity = calculate_similarity(original_text, string_reconstruction)\n    else\n        string_similarity = 0.0\n        string_reconstruction = \"\"\n    end\n\n    return (\n        ngram_success = ngram_success,\n        ngram_similarity = best_ngram_similarity,\n        ngram_reconstruction = best_ngram_reconstruction,\n        string_success = string_success,\n        string_similarity = string_similarity,\n        string_reconstruction = string_reconstruction,\n        comparison = best_ngram_similarity > string_similarity ? \"N-gram better\" : \"String better\"\n    )\nend\n\nfunction calculate_similarity(original::String, reconstructed::String)\n    \"\"\"Calculate character-level similarity between strings.\"\"\"\n    min_len = min(length(original), length(reconstructed))\n    max_len = max(length(original), length(reconstructed))\n\n    if max_len == 0\n        return 1.0\n    end\n\n    matches = 0\n    for i in 1:min_len\n        if original[i] == reconstructed[i]\n            matches += 1\n        end\n    end\n\n    return matches / max_len\nend\n\nvalidation_results = Dict()\n\nprintln(\"Validating round-trip reconstructions:\")\nfor (key, conversion_result) in string_conversion_results\n    ngram_result = conversion_result.original_ngram_result\n    estimated_strings = conversion_result.estimated_strings\n\n    validation = validate_round_trip(\n        ngram_result.dataset.text,\n        ngram_result.graph,\n        estimated_strings,\n        ngram_result.n\n    )\n\n    validation_results[key] = validation\n\n    println(\"\\\\n  $(key):\")\n    println(\"    Original: \\\"$(ngram_result.dataset.text)\\\"\")\n    println(\"    N-gram reconstruction: $(validation.ngram_success ? \"SUCCESS\" : \"FAILED\")\")\n    if validation.ngram_success\n        println(\"      Similarity: $(round(validation.ngram_similarity, digits=3))\")\n        println(\"      Result: \\\"$(validation.ngram_reconstruction)\\\"\")\n    end\n    println(\"    String reconstruction: $(validation.string_success ? \"SUCCESS\" : \"FAILED\")\")\n    if validation.string_success\n        println(\"      Similarity: $(round(validation.string_similarity, digits=3))\")\n        println(\"      Result: \\\"$(validation.string_reconstruction)\\\"\")\n    end\n    println(\"    Comparison: $(validation.comparison)\")\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Performance-and-Complexity-Analysis","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Performance and Complexity Analysis","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"Compare the computational characteristics of both graph types.","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"println(\"\\n6. PERFORMANCE AND COMPLEXITY ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_graph_efficiency(ngram_results, string_results)\n    \"\"\"Analyze computational efficiency of both graph types.\"\"\"\n\n    println(\"Graph type comparison:\")\n\n    total_ngram_vertices = 0\n    total_string_vertices = 0\n    total_original_length = 0\n\n    for (key, ngram_result) in ngram_results\n        if haskey(string_results, key)\n            string_result = string_results[key]\n\n            total_ngram_vertices += ngram_result.num_vertices\n            total_string_vertices += length(string_result.estimated_strings)\n            total_original_length += length(ngram_result.dataset.text)\n        end\n    end\n\n    avg_ngram_compression = total_ngram_vertices / total_original_length\n    avg_string_compression = total_string_vertices / total_original_length\n    hierarchy_compression = total_string_vertices / total_ngram_vertices\n\n    println(\"  Average N-gram compression: $(round(avg_ngram_compression, digits=3))\")\n    println(\"  Average String compression: $(round(avg_string_compression, digits=3))\")\n    println(\"  Hierarchical compression (String/N-gram): $(round(hierarchy_compression, digits=3))\")\n\n    println(\"\\\\n  Memory efficiency estimation:\")\n    println(\"    N-gram graphs: Higher vertex count, fixed-size vertices\")\n    println(\"    String graphs: Lower vertex count, variable-size vertices\")\n    println(\"    Trade-off: Graph complexity vs. vertex size\")\n\n    return (\n        ngram_compression = avg_ngram_compression,\n        string_compression = avg_string_compression,\n        hierarchy_compression = hierarchy_compression\n    )\nend\n\nefficiency_analysis = analyze_graph_efficiency(ngram_results, string_conversion_results)","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Real-World-Application:-Multi-Scale-Text-Analysis","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Real-World Application: Multi-Scale Text Analysis","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"Demonstrate the practical value of hierarchical graph representations.","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"println(\"\\n7. REAL-WORLD APPLICATION: MULTI-SCALE TEXT ANALYSIS\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"Example: Analyzing text at multiple resolutions","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"complex_text = \"In bioinformatics, sequence analysis involves the process of subjecting DNA, RNA, or protein sequences to any of a wide range of analytical methods to understand their features, function, structure, or evolution\"\n\nprintln(\"Multi-scale analysis of complex text:\")\nprintln(\"Text: \\\"$(complex_text[1:60])...\\\"\")\nprintln(\"Length: $(length(complex_text)) characters\")\n\n# Build graphs at different scales\nscales = [\n    (n=3, description=\"Fine-grained analysis\"),\n    (n=5, description=\"Medium-grained analysis\"),\n    (n=7, description=\"Coarse-grained analysis\")\n]\n\nprintln(\"\\\\nBuilding multi-scale representations:\")\nfor scale in scales\n    if length(complex_text) >= scale.n\n        ngram_graph = Mycelia.string_to_ngram_graph(s=complex_text, n=scale.n)\n        ngram_vertices = length(ngram_graph.vertex_labels)\n        compression = ngram_vertices / (length(complex_text) - scale.n + 1)\n\n        println(\"  $(scale.description) (n=$(scale.n)):\")\n        println(\"    N-gram vertices: $ngram_vertices\")\n        println(\"    Compression ratio: $(round(compression, digits=3))\")\n\n        # Simulate string graph conversion\n        estimated_string_count = max(1, ngram_vertices ÷ 4)  ## Rough estimate\n        string_compression = estimated_string_count / (length(complex_text) - scale.n + 1)\n\n        println(\"    Estimated string vertices: $estimated_string_count\")\n        println(\"    String compression ratio: $(round(string_compression, digits=3))\")\n    end\nend\n\nprintln(\"\\\\nInsights from multi-scale analysis:\")\nprintln(\"  • Fine-grained: High detail, more vertices, better local patterns\")\nprintln(\"  • Coarse-grained: Lower detail, fewer vertices, global structure\")\nprintln(\"  • Hierarchical conversion: Further compression with controlled information loss\")","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Tutorial-Summary-and-Best-Practices","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Tutorial Summary and Best Practices","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"Summarize key learnings and provide guidance for application.","category":"page"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/","page":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"println(\"\\n\" * \"=\"^80)\nprintln(\"TUTORIAL SUMMARY AND BEST PRACTICES\")\nprintln(\"=\"^80)\n\n# Calculate overall statistics\ntotal_validations = length(validation_results)\nsuccessful_ngram = sum(1 for v in values(validation_results) if v.ngram_success)\nsuccessful_string = sum(1 for v in values(validation_results) if v.string_success)\n\navg_ngram_similarity = Statistics.mean([v.ngram_similarity for v in values(validation_results)])\navg_string_similarity = Statistics.mean([v.string_similarity for v in values(validation_results)])\n\nprintln(\"\\\\n✅ HIERARCHICAL WORKFLOW COMPLETION:\")\nprintln(\"  1. N-gram Graph Construction: ✓ Multiple scales tested\")\nprintln(\"  2. Graph Structure Analysis: ✓ Complexity patterns identified\")\nprintln(\"  3. String Graph Conversion: ✓ Simulation completed\")\nprintln(\"  4. Round-trip Validation: ✓ Quality metrics calculated\")\nprintln(\"  5. Performance Analysis: ✓ Efficiency trade-offs analyzed\")\nprintln(\"  6. Multi-scale Application: ✓ Real-world example demonstrated\")\n\nprintln(\"\\\\n📊 QUANTITATIVE RESULTS:\")\nprintln(\"  Total test cases: $total_validations\")\nprintln(\"  N-gram reconstruction success: $successful_ngram/$total_validations ($(round(successful_ngram/total_validations*100, digits=1))%)\")\nprintln(\"  String reconstruction success: $successful_string/$total_validations ($(round(successful_string/total_validations*100, digits=1))%)\")\nprintln(\"  Average N-gram similarity: $(round(avg_ngram_similarity, digits=3))\")\nprintln(\"  Average String similarity: $(round(avg_string_similarity, digits=3))\")\nprintln(\"  Hierarchical compression: $(round(efficiency_analysis.hierarchy_compression, digits=3))\")\n\nprintln(\"\\\\n🔄 HIERARCHICAL WORKFLOW VALIDATED:\")\nprintln(\"  String Data → N-gram Graphs → String Graphs → Reconstruction\")\nprintln(\"  ✓ Fixed-length foundation graphs constructed successfully\")\nprintln(\"  ✓ Variable-length simplified graphs derived\")\nprintln(\"  ✓ Quality maintained through conversion process\")\nprintln(\"  ✓ Performance trade-offs quantified\")\n\nprintln(\"\\\\n💡 KEY INSIGHTS:\")\nprintln(\"  • Hierarchical graphs provide multi-resolution analysis capabilities\")\nprintln(\"  • Fixed-length graphs offer detailed local structure information\")\nprintln(\"  • Variable-length graphs provide global structure with compression\")\nprintln(\"  • Conversion quality depends on text complexity and repetition patterns\")\nprintln(\"  • Multi-scale analysis reveals different aspects of data structure\")\n\nprintln(\"\\\\n📋 BEST PRACTICES:\")\nprintln(\"  • Use smaller n-grams (3-4) for detailed local analysis\")\nprintln(\"  • Use larger n-grams (5-7) for global structure identification\")\nprintln(\"  • Apply hierarchical conversion when memory efficiency is critical\")\nprintln(\"  • Validate reconstruction quality at each conversion step\")\nprintln(\"  • Consider text complexity when choosing graph representation\")\n\nprintln(\"\\\\n🚀 NEXT STEPS IN GRAPH HIERARCHY:\")\nprintln(\"  • Tutorial 3: FASTA sequences → Sequence graphs → Reconstruction\")\nprintln(\"  • Tutorial 4: FASTA → K-mer graphs → Sequence graphs (biological hierarchy)\")\nprintln(\"  • Tutorial 5: FASTQ → FASTQ graphs (direct quality-aware workflows)\")\nprintln(\"  • Tutorial 6: FASTQ → Qualmer graphs → FASTQ graphs (quality hierarchy)\")\n\nprintln(\"\\\\n🎯 PATTERNS FOR BIOLOGICAL GRAPHS:\")\nprintln(\"  The hierarchical patterns demonstrated here with text apply to:\")\nprintln(\"  • DNA/RNA sequences: Fixed k-mers → Variable-length contigs\")\nprintln(\"  • Quality data: Fixed qualmers → Quality-aware sequences\")\nprintln(\"  • Protein sequences: Fixed amino acid k-mers → Domain sequences\")\n\nprintln(\"\\\\n\" * \"=\"^80)\nprintln(\"Hierarchical graph conversion workflow mastered!\")\nprintln(\"Ready for biological sequence applications in Tutorial 3!\")\nprintln(\"=\"^80)","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Tutorial-7:-Comparative-Genomics-and-Pangenome-Analysis","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"This tutorial covers comparative genomics approaches, including pangenome construction, phylogenetic analysis, and evolutionary genomics.","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Learning-Objectives","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"By the end of this tutorial, you will understand:","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Pangenome concepts and construction methods\nCore, accessory, and unique gene identification\nPhylogenetic tree construction and interpretation\nSynteny analysis and chromosomal rearrangements\nPopulation genomics and evolutionary analysis\nGraph-based genome representation","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Setup","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"import Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\nimport Graphs\nimport Kmers\n\nRandom.seed!(42)","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-1:-Pangenome-Concepts","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 1: Pangenome Concepts","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Pangenomes represent the complete set of genes within a species or closely related group of organisms.","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"=== Comparative Genomics Tutorial ===\")\n\nprintln(\"Pangenome Components:\")\nprintln(\"- Core genome: Genes present in all individuals\")\nprintln(\"- Accessory genome: Genes present in some individuals\")\nprintln(\"- Unique genes: Genes present in single individuals\")\nprintln(\"- Variable genes: Genes with presence/absence variation\")\nprintln()\nprintln(\"Pangenome Types:\")\nprintln(\"- Open pangenome: Continues to expand with new genomes\")\nprintln(\"- Closed pangenome: Reaches saturation quickly\")\nprintln(\"- Mixed pangenome: Shows both open and closed characteristics\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-2:-Data-Preparation-for-Pangenome-Analysis","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 2: Data Preparation for Pangenome Analysis","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Prepare multiple genomes for comparative analysis","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Data Preparation ===\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Simulating-Multiple-Genomes","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Simulating Multiple Genomes","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Create a set of related genomes for pangenome analysis","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Simulating Related Genomes ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Generate core genes present in all genomes","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"n_genomes = 5\ncore_genes = 200\naccessory_genes = 100\nunique_genes = 50","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Generate simulated genomes with different characteristics","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"genome_files = String[]\nfor i in 1:n_genomes\n    genome_size = core_genes * 1000 + rand(0:accessory_genes) * 1000 + rand(0:unique_genes) * 1000\n    genome = Mycelia.random_fasta_record(moltype=:DNA, seed=i, L=genome_size)\n    filename = \"genome_$i.fasta\"\n    Mycelia.write_fasta(outfile=filename, records=[genome])\n    push!(genome_files, filename)\nend\n\nprintln(\"Generated $(n_genomes) genomes:\")\nfor (i, file) in enumerate(genome_files)\n    size = filesize(file)\n    println(\"  Genome $i: $file ($(size) bytes)\")\nend","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-3:-Gene-Clustering-and-Ortholog-Identification","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 3: Gene Clustering and Ortholog Identification","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Identify orthologous genes across genomes","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Gene Clustering ===\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#All-vs-All-Sequence-Comparison","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"All-vs-All Sequence Comparison","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Compare all genes against all genes","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- All-vs-All Comparison ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Perform k-mer based pangenome analysis using implemented functions","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"Performing k-mer based pangenome analysis...\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Use implemented pangenome analysis function","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"pangenome_result = Mycelia.analyze_pangenome_kmers(\n    genome_files,\n    kmer_type=Kmers.DNAKmer{21}\n)\n\nprintln(\"Pangenome Analysis Results:\")\nprintln(\"  Core k-mers: $(length(pangenome_result.core_kmers))\")\nprintln(\"  Accessory k-mers: $(length(pangenome_result.accessory_kmers))\")\nprintln(\"  Total pangenome size: $(pangenome_result.similarity_stats.pangenome_size)\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Genome-Similarity-Analysis","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Genome Similarity Analysis","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Compare genome similarity using multiple metrics","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Genome Similarity Analysis ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Build distance matrix using different metrics","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"js_matrix = Mycelia.build_genome_distance_matrix(\n    genome_files,\n    kmer_type=Kmers.DNAKmer{21},\n    metric=:js_divergence\n)\n\nprintln(\"Distance Matrix (JS Divergence):\")\nfor i in 1:n_genomes\n    for j in 1:n_genomes\n        print(\"$(round(js_matrix.distance_matrix[i,j], digits=3)) \")\n    end\n    println()\nend","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-4:-Pangenome-Construction","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 4: Pangenome Construction","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Build pangenome from ortholog clusters","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Pangenome Construction ===\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Core-Genome-Analysis","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Core Genome Analysis","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Identify genes present in all genomes","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Core Genome Analysis ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Use results from pangenome analysis","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"core_genome_size = length(pangenome_result.core_kmers)\ncore_genome_percentage = pangenome_result.similarity_stats.core_percentage\n\nprintln(\"Core Genome:\")\nprintln(\"  Size: $core_genome_size k-mers\")\nprintln(\"  Percentage: $(round(core_genome_percentage, digits=1))%\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Core genome represents k-mers present in ALL genomes","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"Core genome represents conserved genomic content across all $(n_genomes) genomes\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Accessory-Genome-Analysis","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Accessory Genome Analysis","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Analyze k-mers with variable presence","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Accessory Genome Analysis ---\")\n\naccessory_genome_size = length(pangenome_result.accessory_kmers)\nunique_genome_total = sum(length(kmers) for kmers in values(pangenome_result.unique_kmers_by_genome))\n\nprintln(\"Accessory Genome:\")\nprintln(\"  Variable k-mers: $accessory_genome_size\")\nprintln(\"  Unique k-mers: $unique_genome_total\")\nprintln(\"  Total accessory: $(accessory_genome_size + unique_genome_total)\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Analyze unique k-mers per genome","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"Unique k-mers per genome:\")\nfor (genome, unique_kmers) in pangenome_result.unique_kmers_by_genome\n    println(\"  $genome: $(length(unique_kmers)) unique k-mers\")\nend","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Pangenome-Curves","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Pangenome Curves","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Model pangenome size vs number of genomes","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Pangenome Curves ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement pangenome curve analysis","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Calculate pangenome size for subsets\nFit mathematical models (power law, exponential)\nPredict pangenome size for larger collections\nClassify as open/closed pangenome","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-5:-Graph-Based-Pangenome-Representation","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 5: Graph-Based Pangenome Representation","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Represent pangenomes as graphs","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Graph-Based Pangenomes ===\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Sequence-Graphs","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Sequence Graphs","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Build graphs from sequence overlaps","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Sequence Graphs ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement sequence graph construction","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Build k-mer graphs from sequences\nIdentify shared and unique paths\nHandle graph bubbles and loops\nCompress redundant sequences","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Use existing pangenome graph construction","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"k = 3\nsequences = [FASTX.sequence(Mycelia.random_fasta_record(moltype=:DNA, seed=i, L=100)) for i in 1:5]","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"graph = Mycelia.buildstrandedkmer_graph(Kmers.DNAKmer{k}, sequences)","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"Sequence Graph Construction:\")\nprintln(\"  K-mer size: $k\")\nprintln(\"  Sequences: $(length(sequences))\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"  Graph nodes: Graphs.nv(graph)\") println(\"  Graph edges: Graphs.ne(graph)\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Variation-Graphs","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Variation Graphs","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Represent genetic variation as graphs","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Variation Graphs ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement variation graph construction","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Build graphs from multiple alignments\nRepresent SNPs and indels as bubbles\nHandle complex structural variants\nOptimize graph topology","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-6:-Phylogenetic-Analysis","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 6: Phylogenetic Analysis","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Construct phylogenetic trees from pangenome data","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Phylogenetic Analysis ===\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Core-Genome-Phylogeny","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Core Genome Phylogeny","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Build trees from core genes","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Core Genome Phylogeny ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement core genome phylogeny","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Concatenate core gene alignments\nCalculate phylogenetic trees\nAssess branch support\nCompare with individual gene trees","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Accessory-Genome-Phylogeny","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Accessory Genome Phylogeny","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Analyze evolution of accessory genes","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Accessory Genome Phylogeny ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement accessory genome phylogeny","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Build trees from gene presence/absence\nUse binary character evolution models\nIdentify horizontal gene transfer events\nAnalyze gene gain/loss patterns","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-7:-Synteny-Analysis","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 7: Synteny Analysis","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Analyze conserved gene order","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Synteny Analysis ===\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Synteny-Detection","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Synteny Detection","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Identify conserved gene order","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Synteny Detection ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement synteny detection","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Identify colinear gene blocks\nCalculate synteny conservation\nDetect chromosomal rearrangements\nVisualize synteny relationships","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Rearrangement-Analysis","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Rearrangement Analysis","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Analyze chromosomal rearrangements","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Rearrangement Analysis ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement rearrangement analysis","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Identify inversions, translocations, duplications\nCalculate rearrangement distances\nReconstruct ancestral gene orders\nAnalyze rearrangement hotspots","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-8:-Population-Genomics","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 8: Population Genomics","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Analyze genetic diversity within populations","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Population Genomics ===\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Genetic-Diversity","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Genetic Diversity","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Calculate diversity metrics","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Genetic Diversity ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement diversity analysis","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Calculate nucleotide diversity (π)\nEstimate effective population size\nAnalyze allele frequency spectra\nIdentify population structure","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Selection-Analysis","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Selection Analysis","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Detect selection pressure","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Selection Analysis ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement selection analysis","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Calculate dN/dS ratios\nIdentify positively selected genes\nDetect balancing selection\nAnalyze codon usage bias","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-9:-Functional-Analysis","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 9: Functional Analysis","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Analyze functional aspects of pangenomes","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Functional Analysis ===\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Functional-Enrichment","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Functional Enrichment","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Identify enriched functional categories","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Functional Enrichment ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement functional enrichment analysis","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"GO term enrichment analysis\nKEGG pathway enrichment\nProtein domain analysis\nMetabolic pathway reconstruction","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Adaptive-Evolution","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Adaptive Evolution","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Identify adaptively evolving genes","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Adaptive Evolution ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement adaptive evolution analysis","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Identify rapidly evolving genes\nAnalyze gene family expansions\nDetect horizontal gene transfer\nCorrelate with environmental factors","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-10:-Visualization-and-Interpretation","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 10: Visualization and Interpretation","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Create visualizations for comparative genomics","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Visualization ===\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Pangenome-Plots","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Pangenome Plots","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Visualize pangenome structure","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Pangenome Plots ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement pangenome visualization","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Pangenome accumulation curves\nGene presence/absence heatmaps\nPhylogenetic trees with annotations\nSynteny dot plots","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Interactive-Visualization","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Interactive Visualization","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Create interactive pangenome browsers","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Interactive Visualization ---\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"TODO: Implement interactive visualization","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Web-based pangenome browser\nInteractive phylogenetic trees\nSearchable gene catalogs\nComparative genome viewers","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-11:-Applications-and-Case-Studies","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 11: Applications and Case Studies","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Real-world applications of comparative genomics","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Applications ===\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Pathogen-Genomics","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Pathogen Genomics","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Applications in infectious disease research","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Pathogen Genomics ---\")\n\nprintln(\"Pathogen Genomics Applications:\")\nprintln(\"- Outbreak investigation and source tracking\")\nprintln(\"- Drug resistance evolution\")\nprintln(\"- Vaccine target identification\")\nprintln(\"- Virulence factor discovery\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Agricultural-Genomics","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Agricultural Genomics","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Applications in crop improvement","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Agricultural Genomics ---\")\n\nprintln(\"Agricultural Genomics Applications:\")\nprintln(\"- Crop diversity assessment\")\nprintln(\"- Disease resistance breeding\")\nprintln(\"- Stress tolerance identification\")\nprintln(\"- Nutritional quality improvement\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Environmental-Genomics","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Environmental Genomics","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Applications in environmental microbiology","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"--- Environmental Genomics ---\")\n\nprintln(\"Environmental Genomics Applications:\")\nprintln(\"- Microbial community analysis\")\nprintln(\"- Ecosystem function prediction\")\nprintln(\"- Biogeochemical cycling\")\nprintln(\"- Climate change adaptation\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Part-12:-Best-Practices-and-Guidelines","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Part 12: Best Practices and Guidelines","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Recommendations for comparative genomics analysis","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Best Practices ===\")\n\nprintln(\"Data Quality:\")\nprintln(\"- Use high-quality genome assemblies\")\nprintln(\"- Ensure consistent annotation standards\")\nprintln(\"- Validate ortholog assignments\")\nprintln(\"- Check for contamination and artifacts\")\nprintln()\nprintln(\"Analysis Strategy:\")\nprintln(\"- Start with closely related genomes\")\nprintln(\"- Use multiple clustering methods\")\nprintln(\"- Validate results with independent approaches\")\nprintln(\"- Consider biological context in interpretation\")\nprintln()\nprintln(\"Computational Considerations:\")\nprintln(\"- Plan for large memory requirements\")\nprintln(\"- Use parallel processing when possible\")\nprintln(\"- Implement checkpointing for long analyses\")\nprintln(\"- Archive intermediate results\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/#Summary","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Summary","text":"","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"println(\"\\n=== Comparative Genomics Summary ===\")\nprintln(\"✓ Understanding pangenome concepts and construction\")\nprintln(\"✓ Implementing gene clustering and ortholog identification\")\nprintln(\"✓ Building core and accessory genome catalogs\")\nprintln(\"✓ Constructing graph-based pangenome representations\")\nprintln(\"✓ Performing phylogenetic analysis\")\nprintln(\"✓ Analyzing synteny and chromosomal rearrangements\")\nprintln(\"✓ Applying population genomics approaches\")\nprintln(\"✓ Creating comprehensive visualizations\")\nprintln(\"✓ Understanding real-world applications\")","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"Cleanup","category":"page"},{"location":"generated/tutorials/07_comparative_genomics/","page":"Tutorial 7: Comparative Genomics and Pangenome Analysis","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"for file in genome_files\n    if isfile(file)\n        rm(file, force=true)\n    end\nend\n\nprintln(\"\\nNext: Tutorial 8 - Tool Integration\")\n\nnothing","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Round-Trip-Tutorial-1:-String-Data-String-Graphs-Reconstruction","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"This tutorial demonstrates the complete round-trip workflow for string-based graph construction and reconstruction in Mycelia. We'll start with raw string data, construct string graphs, perform assembly operations, and validate the reconstruction quality.","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Learning-Objectives","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"By the end of this tutorial, you will:","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Understand string graph construction from raw text data\nLearn to perform graph-based assembly operations\nValidate reconstruction accuracy with quality metrics\nAnalyze memory usage and computational performance\nApply string graphs to real-world text analysis problems","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"import Mycelia\nimport Statistics\nimport Random","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Data-Preparation","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Data Preparation","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"We'll start with various types of string data to demonstrate the versatility of string graphs.","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"println(\"=\"^80)\nprintln(\"ROUND-TRIP TUTORIAL 1: STRING GRAPHS\")\nprintln(\"=\"^80)","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Clean-Error-Free-Input-Data","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Clean Error-Free Input Data","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"First, let's create clean, error-free string data to establish baseline performance.","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"clean_strings = [\n    \"The quick brown fox jumps over the lazy dog\",\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n    \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n    # \"αβγδεζηθικλμνξοπρστυφχψω\",  ## Unicode testing - requires fix in string-graphs.jl\n    \"Pattern recognition and machine learning algorithms\"\n]\n\nprintln(\"\\n1. CLEAN ERROR-FREE INPUT DATA\")\nprintln(\"-\"^50)\nfor (i, s) in enumerate(clean_strings)\n    println(\"String $i: \\\"$s\\\" (length: $(length(s)))\")\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Graph-Construction-Phase","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Graph Construction Phase","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Now we'll construct string graphs from our input data using different n-gram sizes.","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"println(\"\\n2. GRAPH CONSTRUCTION PHASE\")\nprintln(\"-\"^50)\n\ngraph_results = Dict()\n\nfor n in [2, 3, 4, 5]\n    println(\"\\nTesting n-gram size: $n\")\n\n    total_ngrams = 0\n    total_vertices = 0\n\n    for (i, text) in enumerate(clean_strings)\n        if length(text) >= n  ## Only process if text is long enough\n            try\n                # Construct string graph\n                graph = Mycelia.string_to_ngram_graph(s=text, n=n)\n\n                # Extract graph statistics\n                num_vertices = length(graph.vertex_labels)\n                vertex_labels = collect(values(graph.vertex_labels))\n\n                total_ngrams += length(text) - n + 1  ## Expected number of n-grams\n                total_vertices += num_vertices\n\n                println(\"  String $i: $(num_vertices) unique $(n)-grams\")\n                if num_vertices > 0\n                    println(\"    Examples: $(vertex_labels[1:min(3, num_vertices)])\")\n                end\n\n                # Store results for later analysis\n                graph_results[\"$(i)_$(n)\"] = (\n                    graph = graph,\n                    original_text = text,\n                    n = n,\n                    vertices = num_vertices,\n                    total_ngrams = length(text) - n + 1\n                )\n\n            catch e\n                println(\"  String $i: Error - $(typeof(e))\")\n            end\n        else\n            println(\"  String $i: Too short for $(n)-grams\")\n        end\n    end\n\n    println(\"  Summary: $total_vertices unique vertices from $total_ngrams total n-grams\")\n    if total_ngrams > 0\n        compression_ratio = total_vertices / total_ngrams\n        println(\"  Compression ratio: $(round(compression_ratio, digits=3))\")\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Assembly-and-Reconstruction-Phase","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Assembly and Reconstruction Phase","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Now we'll attempt to reconstruct the original strings from the graphs.","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"println(\"\\n3. ASSEMBLY AND RECONSTRUCTION PHASE\")\nprintln(\"-\"^50)\n\nreconstruction_results = Dict()\n\nfor (key, result) in graph_results\n    println(\"\\nReconstructing: \\\"$(result.original_text)\\\" (n=$(result.n))\")\n\n    try\n        # Attempt to reconstruct strings from the graph\n        # Note: This uses the basic string assembly function\n        reconstructed_strings = Mycelia.assemble_strings(result.graph)\n\n        num_reconstructed = length(reconstructed_strings)\n        println(\"  Reconstructed $num_reconstructed string(s)\")\n\n        # Store reconstruction results\n        reconstruction_results[key] = (\n            original = result.original_text,\n            reconstructed = reconstructed_strings,\n            n = result.n,\n            success = !isempty(reconstructed_strings)\n        )\n\n        # Show first few reconstructed strings\n        for (i, reconstructed) in enumerate(reconstructed_strings[1:min(3, num_reconstructed)])\n            println(\"    Reconstruction $i: \\\"$reconstructed\\\"\")\n        end\n\n    catch e\n        println(\"  Reconstruction failed: $(typeof(e))\")\n        reconstruction_results[key] = (\n            original = result.original_text,\n            reconstructed = String[],\n            n = result.n,\n            success = false\n        )\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Quality-Assessment-Phase","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Quality Assessment Phase","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Let's evaluate the reconstruction quality using various metrics.","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"println(\"\\n4. QUALITY ASSESSMENT PHASE\")\nprintln(\"-\"^50)\n\nfunction calculate_string_similarity(original::String, reconstructed::String)\n    \"\"\"Calculate similarity between original and reconstructed strings.\"\"\"\n    # Simple character-level accuracy\n    min_len = min(length(original), length(reconstructed))\n    max_len = max(length(original), length(reconstructed))\n\n    if max_len == 0\n        return 1.0  ## Both strings are empty\n    end\n\n    # Count matching characters at corresponding positions\n    matches = 0\n    for i in 1:min_len\n        if original[i] == reconstructed[i]\n            matches += 1\n        end\n    end\n\n    # Penalize length differences\n    similarity = matches / max_len\n    return similarity\nend\n\nfunction assess_reconstruction_quality(results_dict)\n    \"\"\"Assess overall reconstruction quality across all tests.\"\"\"\n    total_tests = length(results_dict)\n    successful_reconstructions = 0\n    total_similarity = 0.0\n\n    println(\"Individual reconstruction assessment:\")\n\n    for (key, result) in results_dict\n        original = result.original\n        reconstructed_list = result.reconstructed\n        n = result.n\n\n        if isempty(reconstructed_list)\n            println(\"  $key: FAILED - No reconstruction\")\n            continue\n        end\n\n        # Find best reconstruction (highest similarity)\n        best_similarity = 0.0\n        best_reconstruction = \"\"\n\n        for reconstructed in reconstructed_list\n            similarity = calculate_string_similarity(original, reconstructed)\n            if similarity > best_similarity\n                best_similarity = similarity\n                best_reconstruction = reconstructed\n            end\n        end\n\n        total_similarity += best_similarity\n        if best_similarity > 0.8  ## Consider >80% similarity as successful\n            successful_reconstructions += 1\n        end\n\n        status = best_similarity > 0.8 ? \"SUCCESS\" : \"PARTIAL\"\n        println(\"  $key: $status - Similarity: $(round(best_similarity, digits=3))\")\n\n        # Show comparison for low similarity cases\n        if best_similarity < 0.8\n            println(\"    Original:      \\\"$(original)\\\"\")\n            println(\"    Best match:    \\\"$(best_reconstruction)\\\"\")\n        end\n    end\n\n    return (\n        total_tests = total_tests,\n        successful = successful_reconstructions,\n        average_similarity = total_tests > 0 ? total_similarity / total_tests : 0.0,\n        success_rate = total_tests > 0 ? successful_reconstructions / total_tests : 0.0\n    )\nend\n\nquality_metrics = assess_reconstruction_quality(reconstruction_results)\n\nprintln(\"\\nOverall Quality Assessment:\")\nprintln(\"  Total tests: $(quality_metrics.total_tests)\")\nprintln(\"  Successful reconstructions: $(quality_metrics.successful)\")\nprintln(\"  Success rate: $(round(quality_metrics.success_rate * 100, digits=1))%\")\nprintln(\"  Average similarity: $(round(quality_metrics.average_similarity, digits=3))\")","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Performance-Analysis","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Performance Analysis","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Analyze memory usage and computational efficiency.","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"println(\"\\n5. PERFORMANCE ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_performance_by_n()\n    \"\"\"Analyze how performance scales with n-gram size.\"\"\"\n\n    test_string = \"The quick brown fox jumps over the lazy dog and then some additional text for performance testing\"\n    println(\"Performance test string: \\\"$test_string\\\"\")\n    println(\"String length: $(length(test_string)) characters\")\n\n    for n in 2:6\n        if length(test_string) >= n\n            # Measure construction time\n            start_time = time()\n            graph = Mycelia.string_to_ngram_graph(s=test_string, n=n)\n            construction_time = time() - start_time\n\n            # Measure graph properties\n            num_vertices = length(graph.vertex_labels)\n            expected_ngrams = length(test_string) - n + 1\n            compression_ratio = num_vertices / expected_ngrams\n\n            # Estimate memory usage (approximate)\n            avg_vertex_size = sum(length(v) for v in values(graph.vertex_labels)) / num_vertices\n            estimated_memory_kb = (num_vertices * avg_vertex_size * 2) / 1024  ## Rough estimate\n\n            println(\"  n=$n: $(num_vertices) vertices, $(round(construction_time*1000, digits=2))ms, $(round(compression_ratio, digits=3)) compression, ~$(round(estimated_memory_kb, digits=1))KB\")\n        end\n    end\nend\n\nanalyze_performance_by_n()","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Real-World-Application-Example","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Real-World Application Example","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Demonstrate string graphs on a practical text analysis problem.","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"println(\"\\n6. REAL-WORLD APPLICATION EXAMPLE\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Example: DNA sequence analysis as strings","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"dna_sequences = [\n    \"ATCGATCGATCGATCG\",\n    \"GATCGATCGATCGTAGC\",\n    \"TCGATCGATCGTAGCTA\",\n    \"CGATCGATCGTAGCTAG\",\n    \"ATCGTAGCTAGCTAGCT\"\n]\n\nprintln(\"DNA sequence analysis using string graphs:\")\nprintln(\"Sequences to analyze:\")\nfor (i, seq) in enumerate(dna_sequences)\n    println(\"  Seq $i: $seq\")\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Concatenate sequences for analysis","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"combined_dna = join(dna_sequences, \"N\")  ## Use 'N' as separator\nprintln(\"\\\\nCombined sequence: $combined_dna\")","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Build string graph","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"dna_graph = Mycelia.string_to_ngram_graph(s=combined_dna, n=4)\ndna_4grams = collect(values(dna_graph.vertex_labels))\n\nprintln(\"DNA 4-gram analysis:\")\nprintln(\"  Unique 4-grams: $(length(dna_4grams))\")\nprintln(\"  Total 4-grams: $(length(combined_dna) - 4 + 1)\")","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Find most common patterns","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"dna_4gram_counts = Dict(k => 0 for k in dna_4grams)\nfor i in 1:(length(combined_dna) - 4 + 1)\n    ngram = combined_dna[i:i+3]\n    if haskey(dna_4gram_counts, ngram)\n        dna_4gram_counts[ngram] += 1\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Sort by frequency","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"sorted_patterns = sort(collect(dna_4gram_counts), by=x->x[2], rev=true)\nprintln(\"  Most frequent 4-grams:\")\nfor (pattern, count) in sorted_patterns[1:min(5, length(sorted_patterns))]\n    if pattern != \"N\"  ## Skip separator\n        println(\"    $pattern: $count occurrences\")\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Visualization-and-Graph-Analysis","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Visualization and Graph Analysis","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Provide insights into graph structure.","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"println(\"\\n7. GRAPH STRUCTURE ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_graph_structure(graph, description)\n    \"\"\"Analyze structural properties of a string graph.\"\"\"\n\n    vertices = collect(values(graph.vertex_labels))\n    num_vertices = length(vertices)\n\n    if num_vertices == 0\n        println(\"  $description: Empty graph\")\n        return\n    end\n\n    # Basic statistics\n    vertex_lengths = [length(v) for v in vertices]\n    avg_length = Statistics.mean(vertex_lengths)\n\n    println(\"  $description:\")\n    println(\"    Vertices: $num_vertices\")\n    println(\"    Average vertex length: $(round(avg_length, digits=2))\")\n\n    # Character distribution analysis\n    all_chars = join(vertices)\n    char_counts = Dict{Char, Int}()\n    for char in all_chars\n        char_counts[char] = get(char_counts, char, 0) + 1\n    end\n\n    top_chars = sort(collect(char_counts), by=x->x[2], rev=true)\n    println(\"    Character distribution (top 5):\")\n    for (char, count) in top_chars[1:min(5, length(top_chars))]\n        println(\"      '$char': $count\")\n    end\n\n    return (\n        vertices = num_vertices,\n        avg_length = avg_length,\n        char_distribution = char_counts\n    )\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Analyze a few representative graphs","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"println(\"Analyzing graph structures:\")\n\nfor n in [3, 4]\n    test_text = \"The quick brown fox jumps over the lazy dog\"\n    if length(test_text) >= n\n        graph = Mycelia.string_to_ngram_graph(s=test_text, n=n)\n        analyze_graph_structure(graph, \"$(n)-gram graph of: \\\"$test_text\\\"\")\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Tutorial-Summary-and-Conclusions","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Tutorial Summary and Conclusions","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"Summarize what we've learned and provide guidance for next steps.","category":"page"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/","page":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"println(\"\\n\" * \"=\"^80)\nprintln(\"TUTORIAL SUMMARY AND CONCLUSIONS\")\nprintln(\"=\"^80)\n\nprintln(\"\\\\n✅ SUCCESSFUL COMPLETION OF STRING GRAPH ROUND-TRIP WORKFLOW:\")\nprintln(\"  1. Data Preparation: Created diverse string datasets\")\nprintln(\"  2. Graph Construction: Built n-gram graphs with various parameters\")\nprintln(\"  3. Assembly Process: Reconstructed strings from graph representations\")\nprintln(\"  4. Quality Assessment: Evaluated reconstruction accuracy\")\nprintln(\"  5. Performance Analysis: Measured efficiency and scaling behavior\")\nprintln(\"  6. Real-world Application: Applied to DNA sequence analysis\")\n\nprintln(\"\\\\n📊 KEY FINDINGS:\")\nprintln(\"  • String graphs provide effective compression of repetitive text\")\nprintln(\"  • Reconstruction quality depends on n-gram size and text complexity\")\nprintln(\"  • Success rate: $(round(quality_metrics.success_rate * 100, digits=1))%\")\nprintln(\"  • Average similarity: $(round(quality_metrics.average_similarity, digits=3))\")\nprintln(\"  • Memory usage scales with unique n-gram count\")\n\nprintln(\"\\\\n💡 INSIGHTS:\")\nprintln(\"  • Larger n-grams provide more specificity but less compression\")\nprintln(\"  • Highly repetitive sequences achieve better compression ratios\")\nprintln(\"  • Unicode text support enables international language analysis\")\nprintln(\"  • String graphs are foundation for more complex biological graphs\")\n\nprintln(\"\\\\n🔄 ROUND-TRIP WORKFLOW VALIDATED:\")\nprintln(\"  Raw String Data → N-gram Graph → Assembled Strings\")\nprintln(\"  ✓ Input data successfully processed\")\nprintln(\"  ✓ Graph construction completed\")\nprintln(\"  ✓ Assembly operations performed\")\nprintln(\"  ✓ Quality metrics calculated\")\nprintln(\"  ✓ Results validated and analyzed\")\n\nprintln(\"\\\\n🚀 NEXT STEPS:\")\nprintln(\"  • Tutorial 2: String data → N-gram graphs → String graphs\")\nprintln(\"  • Tutorial 3: FASTA sequences → Sequence graphs → Reconstruction\")\nprintln(\"  • Tutorial 4: FASTA sequences → K-mer graphs → Sequence graphs\")\nprintln(\"  • Tutorial 5: FASTQ sequences → FASTQ graphs (direct quality-aware)\")\nprintln(\"  • Tutorial 6: FASTQ sequences → Qualmer graphs → FASTQ graphs\")\n\nprintln(\"\\\\n📚 LEARNING OUTCOMES ACHIEVED:\")\nprintln(\"  ✓ Understand string graph construction and reconstruction\")\nprintln(\"  ✓ Perform quality assessment with similarity metrics\")\nprintln(\"  ✓ Analyze computational performance and memory usage\")\nprintln(\"  ✓ Apply string graphs to real-world text analysis\")\nprintln(\"  ✓ Evaluate trade-offs between compression and accuracy\")\n\nprintln(\"\\\\n\" * \"=\"^80)\nprintln(\"Ready to proceed to Tutorial 2: N-gram to String Graph Workflow!\")\nprintln(\"=\"^80)","category":"page"},{"location":"api/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Welcome to the Mycelia API documentation! This guide organizes both implemented functions and planned features by biological workflows. Mycelia provides substantial functionality for bioinformatics analysis with extensive tool integration, while continuing to expand with experimental algorithms and additional features.","category":"page"},{"location":"api/#Quick-Start","page":"API Documentation","title":"🧬 Quick Start","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"New to Mycelia? Start with our workflow-based guides:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Basic Workflows - Common analysis patterns\nFunction Index - Alphabetical function list\nParameter Guide - Common parameters explained","category":"page"},{"location":"api/#By-Workflow-Stage","page":"API Documentation","title":"📋 By Workflow Stage","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Follow the typical bioinformatics analysis workflow:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Pages = [\n    \"api/workflows/data-acquisition.md\",\n    \"api/workflows/quality-control.md\", \n    \"api/workflows/sequence-analysis.md\",\n    # \"api/workflows/genome-assembly.md\",\n    # \"api/workflows/assembly-validation.md\",\n    # \"api/workflows/gene-annotation.md\",\n    # \"api/workflows/comparative-genomics.md\",\n    # \"api/workflows/visualization.md\"\n]\nDepth = 2","category":"page"},{"location":"api/#1.-[Data-Acquisition-and-Simulation](api/workflows/data-acquisition.md)","page":"API Documentation","title":"1. Data Acquisition & Simulation","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Download genomic data from public databases and simulate synthetic datasets for testing.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Working Functions: download_genome_by_accession, simulate_pacbio_reads, simulate_nanopore_reads","category":"page"},{"location":"api/#2.-[Quality-Control-and-Preprocessing](api/workflows/quality-control.md)","page":"API Documentation","title":"2. Quality Control & Preprocessing","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Assess and improve sequencing data quality before analysis.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Working Functions: analyze_fastq_quality, calculate_gc_content, assess_duplication_rates, qc_filter_short_reads_fastp, qc_filter_long_reads_filtlong, trim_galore_paired   Planned: filter_by_quality, per-base quality visualization","category":"page"},{"location":"api/#3.-[Sequence-Analysis-and-K-mers](api/workflows/sequence-analysis.md)","page":"API Documentation","title":"3. Sequence Analysis & K-mers","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Analyze sequence composition, count k-mers, and extract genomic features.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Working Functions: count_canonical_kmers, jaccard_distance, kmer_counts_to_js_divergence   Planned: kmer_frequency_spectrum, estimate_genome_size","category":"page"},{"location":"api/#4.-Genome-Assembly-*(planned)*","page":"API Documentation","title":"4. Genome Assembly (planned)","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Assemble genomes from sequencing reads using various approaches.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Working Functions: assemble_metagenome_megahit, assemble_metagenome_metaspades (external tools)   Experimental: Graph-based assembly framework   Planned: assemble_genome, polish_assembly","category":"page"},{"location":"api/#5.-Assembly-Validation","page":"API Documentation","title":"5. Assembly Validation","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Validate and assess the quality of genome assemblies.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Working Functions: assess_assembly_quality, validate_assembly, CheckM/CheckM2 integration   Planned: QUAST, BUSCO, MUMmer integration","category":"page"},{"location":"api/#6.-Gene-Annotation","page":"API Documentation","title":"6. Gene Annotation","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Predict genes and assign functional annotations.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Working Functions: Pyrodigal, BLAST+, MMSeqs2, TransTerm, tRNAscan-SE, MLST integrations   Planned: GO term analysis, Reactome pathway analysis, PDB integration via UniRef annotations","category":"page"},{"location":"api/#7.-Comparative-Genomics-*(planned)*","page":"API Documentation","title":"7. Comparative Genomics (planned)","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Compare genomes, build pangenomes, and construct phylogenetic trees.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Working Functions: analyze_pangenome_kmers, build_genome_distance_matrix   Planned: construct_phylogeny, calculate_synteny","category":"page"},{"location":"api/#8.-Visualization-and-Reporting","page":"API Documentation","title":"8. Visualization & Reporting","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Create plots, figures, and reports for analysis results.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Working Functions: plot_kmer_frequency_spectra, visualize_genome_coverage, plot_embeddings, plot_taxa_abundances, coverage plots, taxonomic visualizations   Planned: Per-base quality plots, assembly statistics visualization, phylogenetic tree plotting","category":"page"},{"location":"api/#By-Data-Type","page":"API Documentation","title":"📁 By Data Type","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Working with specific file formats and data structures:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"<!– Data type documentation planned for future releases","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Pages = [\n    \"api/data-types/fasta-fastq.md\",\n    \"api/data-types/assemblies.md\",\n    \"api/data-types/annotations.md\",\n    \"api/data-types/alignments.md\",\n    \"api/data-types/trees.md\"\n]\nDepth = 2","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"–>","category":"page"},{"location":"api/#FASTA/FASTQ-Files-*(planned)*","page":"API Documentation","title":"FASTA/FASTQ Files (planned)","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Reading, writing, and manipulating sequence files.","category":"page"},{"location":"api/#Assembly-Files-*(planned)*","page":"API Documentation","title":"Assembly Files (planned)","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Working with contigs, scaffolds, and assembly statistics.","category":"page"},{"location":"api/#Annotation-Files-*(planned)*","page":"API Documentation","title":"Annotation Files (planned)","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Handling GFF3, GenBank, and other annotation formats.","category":"page"},{"location":"api/#Alignment-Files-*(planned)*","page":"API Documentation","title":"Alignment Files (planned)","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Processing BAM/SAM files and alignment results.","category":"page"},{"location":"api/#Phylogenetic-Trees-*(planned)*","page":"API Documentation","title":"Phylogenetic Trees (planned)","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Tree construction, manipulation, and visualization.","category":"page"},{"location":"api/#By-Analysis-Goal","page":"API Documentation","title":"🎯 By Analysis Goal","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Cross-cutting concerns and specific use cases:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Pages = [\n    \"api/examples/basic-workflows.md\",\n    \"api/examples/advanced-usage.md\",\n    \"api/quick-reference/function-index.md\",\n    \"api/quick-reference/parameter-guide.md\"\n]\nDepth = 2","category":"page"},{"location":"api/#[Basic-Workflows](api/examples/basic-workflows.md)","page":"API Documentation","title":"Basic Workflows","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Complete examples for common analysis tasks.","category":"page"},{"location":"api/#[Advanced-Usage](api/examples/advanced-usage.md)","page":"API Documentation","title":"Advanced Usage","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Complex workflows and optimization techniques.","category":"page"},{"location":"api/#[Function-Index](api/quick-reference/function-index.md)","page":"API Documentation","title":"Function Index","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Alphabetical listing of all functions with brief descriptions.","category":"page"},{"location":"api/#[Parameter-Guide](api/quick-reference/parameter-guide.md)","page":"API Documentation","title":"Parameter Guide","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Common parameters and their usage across functions.","category":"page"},{"location":"api/#Finding-What-You-Need","page":"API Documentation","title":"🔍 Finding What You Need","text":"","category":"section"},{"location":"api/#By-Task","page":"API Documentation","title":"By Task","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"\"I want to assemble a genome\" → Genome Assembly (planned)\n\"I need to validate my assembly\" → Assembly Validation (planned)\n\"I want to compare genomes\" → Comparative Genomics (planned)\n\"I need to check data quality\" → Quality Control","category":"page"},{"location":"api/#By-Data-Type-2","page":"API Documentation","title":"By Data Type","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"\"I have FASTQ files\" → FASTA/FASTQ Files (planned)\n\"I have assembly contigs\" → Assembly Files (planned)\n\"I have gene annotations\" → Annotation Files (planned)","category":"page"},{"location":"api/#By-Experience-Level","page":"API Documentation","title":"By Experience Level","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Beginner → Basic Workflows\nIntermediate → Workflow-specific guides\nAdvanced → Advanced Usage","category":"page"},{"location":"api/#Usage-Patterns","page":"API Documentation","title":"💡 Usage Patterns","text":"","category":"section"},{"location":"api/#Function-Documentation-Format","page":"API Documentation","title":"Function Documentation Format","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Each function is documented with:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"\"\"\"\n    function_name(required_param, optional_param=\"default\")\n\nBrief description of what the function does.\n\n## Purpose\nWhen and why to use this function in your workflow.\n\n## Arguments\n- `required_param`: Description and expected data type\n- `optional_param`: Description, default value, and alternatives\n\n## Returns\nDescription of return value and structure.\n\n## Examples","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"julia","category":"page"},{"location":"api/#Basic-usage","page":"API Documentation","title":"Basic usage","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"result = function_name(\"input.fasta\")","category":"page"},{"location":"api/#Advanced-usage-with-options","page":"API Documentation","title":"Advanced usage with options","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"result = functionname(\"input.fasta\",                        optionalparam=\"custom_value\",                       threads=4)","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"\n## Related Functions\n- [`related_function`](@ref) - What it does\n- [`workflow_next_step`](@ref) - Next step in workflow\n\n## Performance Notes\n- Memory usage: ~X GB for typical datasets\n- Runtime: ~X minutes for Y-sized genomes\n- Scaling: Linear/quadratic with input size\n\n## See Also\n- [Workflow Guide](../workflows/relevant-workflow.md)\n- [Data Type Guide](../data-types/relevant-type.md)\n\"\"\"","category":"page"},{"location":"api/#Cross-References","page":"API Documentation","title":"Cross-References","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Functions are linked to:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Workflow context - Where they fit in analysis pipelines\nRelated functions - What to use before/after\nData types - What formats they accept/produce\nExamples - Real usage scenarios","category":"page"},{"location":"api/#Integration-with-Tutorials","page":"API Documentation","title":"🚀 Integration with Tutorials","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"This API documentation integrates with the tutorial system:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Tutorials show complete workflows with explanation\nAPI docs provide detailed function reference\nExamples bridge the gap with focused use cases","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"For hands-on learning, see the Tutorials which use these functions in complete bioinformatics workflows.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"This documentation is automatically generated from function docstrings and organized for biological workflows. Functions are tested through the tutorial system to ensure accuracy.","category":"page"},{"location":"api/workflows/quality-control/#Quality-Control-and-Preprocessing","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"Functions for assessing and improving sequencing data quality before downstream analysis.","category":"page"},{"location":"api/workflows/quality-control/#Overview","page":"Quality Control & Preprocessing","title":"Overview","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"Quality control is essential for reliable bioinformatics results. Mycelia integrates with external QC tools and is developing native Julia implementations for:","category":"page"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"External tool integration for quality filtering (fastp, filtlong, trim_galore)\nBasic FASTQ file operations (reading/writing)\nPlanned features: Native quality assessment, contamination detection, and reporting","category":"page"},{"location":"api/workflows/quality-control/#Common-Workflows","page":"Quality Control & Preprocessing","title":"Common Workflows","text":"","category":"section"},{"location":"api/workflows/quality-control/#Currently-Available-(via-External-Tools)","page":"Quality Control & Preprocessing","title":"Currently Available (via External Tools)","text":"","category":"section"},{"location":"api/workflows/quality-control/#Quality-Filtering","page":"Quality Control & Preprocessing","title":"Quality Filtering","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Short read QC with fastp\nMycelia.qc_filter_short_reads_fastp(\n    input_file=\"reads.fastq\",\n    output_file=\"filtered.fastq\"\n)\n\n# Long read QC with fastplong\nMycelia.qc_filter_long_reads_fastplong(\n    input_file=\"long_reads.fastq\",\n    output_file=\"filtered_long.fastq\"\n)\n\n# Long read QC with filtlong\nMycelia.qc_filter_long_reads_filtlong(\n    input_file=\"long_reads.fastq\",\n    output_file=\"filtered_long.fastq\",\n    min_length=1000,\n    min_mean_q=7\n)\n\n# Paired-end trimming with trim_galore\nMycelia.trim_galore_paired(\n    R1=\"reads_R1.fastq\",\n    R2=\"reads_R2.fastq\",\n    output_dir=\"trimmed/\"\n)","category":"page"},{"location":"api/workflows/quality-control/#Planned-Native-Implementations","page":"Quality Control & Preprocessing","title":"Planned Native Implementations","text":"","category":"section"},{"location":"api/workflows/quality-control/#1.-Basic-Quality-Assessment-(planned)","page":"Quality Control & Preprocessing","title":"1. Basic Quality Assessment (planned)","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Analyze FASTQ quality\nquality_stats = Mycelia.analyze_fastq_quality(\"reads.fastq\")\n\n# Generate quality report\nquality_report = Mycelia.generate_quality_report(quality_stats)","category":"page"},{"location":"api/workflows/quality-control/#2.-Read-Preprocessing-(planned)","page":"Quality Control & Preprocessing","title":"2. Read Preprocessing (planned)","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Quality trimming and filtering\nclean_reads = Mycelia.preprocess_reads(\n    \"raw_reads.fastq\",\n    min_quality=20,\n    min_length=1000,\n    trim_ends=true\n)","category":"page"},{"location":"api/workflows/quality-control/#3.-Contamination-Removal-(planned)","page":"Quality Control & Preprocessing","title":"3. Contamination Removal (planned)","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Remove host contamination\ndecontaminated_reads = Mycelia.remove_contamination(\n    \"reads.fastq\",\n    reference_genome=\"host_genome.fasta\",\n    output=\"clean_reads.fastq\"\n)","category":"page"},{"location":"api/workflows/quality-control/#Quality-Assessment","page":"Quality Control & Preprocessing","title":"Quality Assessment","text":"","category":"section"},{"location":"api/workflows/quality-control/#FASTQ-Quality-Analysis","page":"Quality Control & Preprocessing","title":"FASTQ Quality Analysis","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"Note: The functions in this section and below are planned but not yet implemented.  They represent the intended API design for native Julia quality control functionality. Currently, use the external tool wrappers shown above for quality control tasks.","category":"page"},{"location":"api/workflows/quality-control/#Mycelia.analyze_fastq_quality","page":"Quality Control & Preprocessing","title":"Mycelia.analyze_fastq_quality","text":"analyze_fastq_quality(fastq_file::String)\n\nAnalyzes quality metrics for a FASTQ file.\n\nCalculates comprehensive quality statistics including read count, quality scores, length distribution, GC content, and quality threshold percentages.\n\nArguments\n\nfastq_file: Path to FASTQ file (can be gzipped)\n\nReturns\n\nFastqQualityResults with the following fields:\n\nn_reads: Total number of reads\nmean_quality: Average Phred quality score across all reads\nmean_length: Average read length\ngc_content: GC content percentage\nquality_distribution: QualityDistribution with Q20+, Q30+, Q40+ percentages\n\nExample\n\nquality_stats = Mycelia.analyze_fastq_quality(\"reads.fastq\")\nprintln(\"Total reads: $(quality_stats.n_reads)\")\nprintln(\"Mean quality: $(quality_stats.mean_quality)\")\nprintln(\"Q30+ reads: $(quality_stats.quality_distribution.q30_percent)%\")\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– calculateperbasequality, calculatepersequencequality, assessqualitydegradation not yet implemented as documented –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Comprehensive-Quality-Analysis","page":"Quality Control & Preprocessing","title":"Example: Comprehensive Quality Analysis","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Analyze quality across multiple metrics\nquality_data = Mycelia.analyze_fastq_quality(\"reads.fastq\")\n\n# Access quality metrics\nprintln(\"Total reads: $(quality_data.n_reads)\")\nprintln(\"Mean quality: $(quality_data.mean_quality)\")\nprintln(\"Mean length: $(quality_data.mean_length)\")\nprintln(\"GC content: $(quality_data.gc_content)%\")\n\n# Quality score distribution\nquality_dist = quality_data.quality_distribution\nprintln(\"Q20+ reads: $(quality_dist.q20_percent)%\")\nprintln(\"Q30+ reads: $(quality_dist.q30_percent)%\")","category":"page"},{"location":"api/workflows/quality-control/#Sequence-Composition-Analysis","page":"Quality Control & Preprocessing","title":"Sequence Composition Analysis","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– calculategccontent, analyzenucleotidecomposition, detectcompositionbias, calculatecomplexityscores not yet implemented as documented –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Composition-Analysis","page":"Quality Control & Preprocessing","title":"Example: Composition Analysis","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Analyze sequence composition\ncomposition = Mycelia.analyze_nucleotide_composition(\"reads.fastq\")\n\n# Check for bias\nbias_detected = Mycelia.detect_composition_bias(composition)\nif bias_detected.has_bias\n    println(\"Composition bias detected:\")\n    println(\"  Type: $(bias_detected.bias_type)\")\n    println(\"  Severity: $(bias_detected.severity)\")\n    println(\"  Affected positions: $(bias_detected.positions)\")\nend","category":"page"},{"location":"api/workflows/quality-control/#Read-Length-Analysis","page":"Quality Control & Preprocessing","title":"Read Length Analysis","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– calculatereadlengthdistribution, analyzelengthuniformity, detectlength_artifacts not yet implemented as documented –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Length-Distribution-Analysis","page":"Quality Control & Preprocessing","title":"Example: Length Distribution Analysis","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Analyze read length characteristics\nlength_stats = Mycelia.calculate_read_length_distribution(\"reads.fastq\")\n\nprintln(\"Read length statistics:\")\nprintln(\"  Mean: $(length_stats.mean)\")\nprintln(\"  Median: $(length_stats.median)\")\nprintln(\"  Min: $(length_stats.minimum)\")\nprintln(\"  Max: $(length_stats.maximum)\")\nprintln(\"  Std Dev: $(length_stats.std)\")\n\n# Check for length artifacts\nartifacts = Mycelia.detect_length_artifacts(length_stats)\nif !isempty(artifacts)\n    println(\"Length artifacts detected: $(length(artifacts))\")\nend","category":"page"},{"location":"api/workflows/quality-control/#Preprocessing-and-Filtering","page":"Quality Control & Preprocessing","title":"Preprocessing and Filtering","text":"","category":"section"},{"location":"api/workflows/quality-control/#Quality-Based-Filtering","page":"Quality Control & Preprocessing","title":"Quality-Based Filtering","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– filterbyquality, trimlowqualityends, removelowqualityreads, adaptivequalityfiltering not yet implemented as individual functions –>","category":"page"},{"location":"api/workflows/quality-control/#Mycelia.qc_filter_short_reads_fastp","page":"Quality Control & Preprocessing","title":"Mycelia.qc_filter_short_reads_fastp","text":"qc_filter_short_reads_fastp(\n;\n    forward_reads,\n    reverse_reads,\n    out_forward,\n    out_reverse,\n    report_title,\n    html,\n    json\n)\n\n\nPerform quality control (QC) filtering and trimming on short-read FASTQ files using fastp.\n\nArguments\n\nin_fastq::String: Path to the input FASTQ file.\nout_fastq::String: Path to the output FASTQ file.\nadapter_seq::String: Adapter sequence to trim.\nquality_threshold::Int: Minimum phred score for trimming (default 20).\nmin_length::Int: Minimum read length to retain (default 50).\n\nReturns\n\nString: Path to the filtered and trimmed FASTQ file.\n\nDetails\n\nThis function uses fastp to remove adapter contamination, trim low‐quality bases from the 3′ end, and discard reads shorter than min_length. It’s a simple wrapper that executes the external fastp command.\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/quality-control/#Mycelia.qc_filter_long_reads_fastplong","page":"Quality Control & Preprocessing","title":"Mycelia.qc_filter_long_reads_fastplong","text":"qc_filter_long_reads_fastplong(\n;\n    in_fastq,\n    report_title,\n    out_fastq,\n    html_report,\n    json_report,\n    min_length,\n    max_length\n)\n\n\nPerform QC filtering on long-read FASTQ files using fastplong.\n\nArguments\n\nin_fastq::String: Path to the input FASTQ file.\nout_fastq::String: Path to the output FASTQ file.\nquality_threshold::Int: Minimum average quality to retain a read (default 10).\nmin_length::Int: Minimum read length (default 1000).\nmax_length::Int=0: Maximum read length (default 0, no maximum).\n\nReturns\n\nString: Path to the filtered FASTQ file.\n\nDetails\n\nThis function uses fastplong to filter long reads based on quality and length criteria. It is optimized for Oxford Nanopore, PacBio, or similar long-read datasets.\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/quality-control/#Mycelia.qc_filter_long_reads_filtlong","page":"Quality Control & Preprocessing","title":"Mycelia.qc_filter_long_reads_filtlong","text":"qc_filter_long_reads_filtlong(\n;\n    in_fastq,\n    out_fastq,\n    min_mean_q,\n    keep_percent\n)\n\n\nFilter and process long reads from a FASTQ file using Filtlong.\n\nThis function filters long sequencing reads based on quality and length criteria,  then compresses the output using pigz.\n\nArguments\n\nin_fastq::String: Path to the input FASTQ file.\nout_fastq::String: Path to the output filtered and compressed FASTQ file.   Defaults to the input filename with \".filtlong.fq.gz\" appended.\nmin_mean_q::Int: Minimum mean quality score for reads to be kept. Default is 20.\nkeep_percent::Int: Percentage of reads to keep after filtering. Default is 95.\n\nReturns\n\nout_fastq\n\nDetails\n\nThis function uses Filtlong to filter long reads and pigz for compression. It requires the Bioconda environment for Filtlong to be set up, which is handled internally.\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/quality-control/#Mycelia.trim_galore_paired","page":"Quality Control & Preprocessing","title":"Mycelia.trim_galore_paired","text":"trim_galore_paired(; forward_reads, reverse_reads, outdir)\n\n\nTrim paired-end FASTQ reads using Trim Galore, a wrapper around Cutadapt and FastQC.\n\nArguments\n\nforward_reads::String: Path to forward reads FASTQ file\nreverse_reads::String: Path to reverse reads FASTQ file\noutdir::String: Output directory for trimmed files\n\nReturns\n\nTuple{String, String}: Paths to trimmed forward and reverse read files\n\nDependencies\n\nRequires trim_galore conda environment:\n\nmamba create -n trim_galore -c bioconda trim_galore\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/quality-control/#Example:-Quality-Filtering","page":"Quality Control & Preprocessing","title":"Example: Quality Filtering","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Filter reads by quality thresholds\nfiltered_reads = Mycelia.filter_by_quality(\n    \"reads.fastq\",\n    min_mean_quality=25,\n    min_length=1000,\n    max_n_percent=5\n)\n\n# Save filtered reads\nMycelia.write_fastq(\"filtered_reads.fastq\", filtered_reads)\n\n# Report filtering statistics\nprintln(\"Original reads: $(Mycelia.count_reads(\"reads.fastq\"))\")\nprintln(\"Filtered reads: $(length(filtered_reads))\")\nprintln(\"Retention rate: $(length(filtered_reads) / Mycelia.count_reads(\"reads.fastq\") * 100)%\")","category":"page"},{"location":"api/workflows/quality-control/#Adapter-and-Contamination-Removal","page":"Quality Control & Preprocessing","title":"Adapter and Contamination Removal","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– removeadapters, detectadaptercontamination, removehostcontamination, removevectorcontamination not yet implemented as individual functions Adapter removal available through trimgalore_paired and QC filtering functions –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Adapter-Removal","page":"Quality Control & Preprocessing","title":"Example: Adapter Removal","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Detect and remove adapters\nadapter_results = Mycelia.detect_adapter_contamination(\"reads.fastq\")\n\nif adapter_results.contamination_detected\n    println(\"Adapter contamination detected:\")\n    println(\"  Adapter type: $(adapter_results.adapter_type)\")\n    println(\"  Contamination rate: $(adapter_results.contamination_rate)%\")\n    \n    # Remove adapters\n    clean_reads = Mycelia.remove_adapters(\n        \"reads.fastq\",\n        adapter_sequences=adapter_results.adapter_sequences,\n        min_overlap=10\n    )\n    \n    Mycelia.write_fastq(\"adapter_trimmed.fastq\", clean_reads)\nend","category":"page"},{"location":"api/workflows/quality-control/#Length-Based-Filtering","page":"Quality Control & Preprocessing","title":"Length-Based Filtering","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– filterbylength, trimtolength, removeshortreads, normalizereadlengths not yet implemented as individual functions –>","category":"page"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– Note: Length-based filtering functions are not yet implemented as individual functions.      The fastp and filtlong functions above also perform length filtering as part of their quality control. –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Length-Filtering","page":"Quality Control & Preprocessing","title":"Example: Length Filtering","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Filter reads by length criteria\nlength_filtered = Mycelia.filter_by_length(\n    \"reads.fastq\",\n    min_length=1000,\n    max_length=50000\n)\n\n# Normalize length distribution (optional)\nnormalized_reads = Mycelia.normalize_read_lengths(\n    length_filtered,\n    target_length=15000,\n    tolerance=0.2\n)","category":"page"},{"location":"api/workflows/quality-control/#Contamination-Detection","page":"Quality Control & Preprocessing","title":"Contamination Detection","text":"","category":"section"},{"location":"api/workflows/quality-control/#Host-Contamination","page":"Quality Control & Preprocessing","title":"Host Contamination","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– detecthostcontamination, removehostsequences, classifycontaminationsources not yet implemented as documented –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Host-Contamination-Removal","page":"Quality Control & Preprocessing","title":"Example: Host Contamination Removal","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Screen for host contamination\ncontamination_results = Mycelia.detect_host_contamination(\n    \"reads.fastq\",\n    host_genome=\"human_genome.fasta\",\n    min_identity=0.9\n)\n\nprintln(\"Host contamination: $(contamination_results.contamination_rate)%\")\n\n# Remove contaminated reads\nclean_reads = Mycelia.remove_host_sequences(\n    \"reads.fastq\",\n    contamination_results.contaminated_reads\n)","category":"page"},{"location":"api/workflows/quality-control/#Vector-and-Adapter-Contamination","page":"Quality Control & Preprocessing","title":"Vector and Adapter Contamination","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– screenvectorcontamination, detectprimercontamination, removesyntheticsequences not yet implemented as documented –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Vector-Screening","page":"Quality Control & Preprocessing","title":"Example: Vector Screening","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Screen for vector contamination\nvector_results = Mycelia.screen_vector_contamination(\n    \"reads.fastq\",\n    vector_database=\"vector_db.fasta\"\n)\n\nif vector_results.contamination_found\n    println(\"Vector contamination detected:\")\n    for hit in vector_results.contaminated_sequences\n        println(\"  $(hit.read_id): $(hit.vector_name)\")\n    end\nend","category":"page"},{"location":"api/workflows/quality-control/#Quality-Metrics-and-Reporting","page":"Quality Control & Preprocessing","title":"Quality Metrics and Reporting","text":"","category":"section"},{"location":"api/workflows/quality-control/#Standard-Quality-Metrics","page":"Quality Control & Preprocessing","title":"Standard Quality Metrics","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– calculatephredscores, assessbasecallaccuracy, calculateerrorrates, estimatesequencing_quality not yet implemented as documented –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Quality-Metrics-Calculation","page":"Quality Control & Preprocessing","title":"Example: Quality Metrics Calculation","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Calculate comprehensive quality metrics\nquality_metrics = Mycelia.calculate_comprehensive_metrics(\"reads.fastq\")\n\n# Phred score analysis\nphred_analysis = Mycelia.calculate_phred_scores(quality_metrics)\nprintln(\"Mean Phred score: $(phred_analysis.mean_phred)\")\nprintln(\"Q30+ rate: $(phred_analysis.q30_rate)%\")\n\n# Error rate estimation\nerror_rates = Mycelia.calculate_error_rates(quality_metrics)\nprintln(\"Estimated error rate: $(error_rates.overall_error_rate)\")","category":"page"},{"location":"api/workflows/quality-control/#Quality-Control-Reports","page":"Quality Control & Preprocessing","title":"Quality Control Reports","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– generatequalityreport, createqualitydashboard, exportqualitymetrics not yet implemented as documented –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Quality-Report-Generation","page":"Quality Control & Preprocessing","title":"Example: Quality Report Generation","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Generate comprehensive quality report\nquality_report = Mycelia.generate_quality_report(\n    \"reads.fastq\",\n    output_format=\"html\",\n    include_plots=true\n)\n\n# Save report\nMycelia.save_quality_report(quality_report, \"quality_report.html\")\n\n# Export metrics for further analysis\nmetrics_data = Mycelia.export_quality_metrics(quality_report, format=\"csv\")","category":"page"},{"location":"api/workflows/quality-control/#Specialized-Quality-Control","page":"Quality Control & Preprocessing","title":"Specialized Quality Control","text":"","category":"section"},{"location":"api/workflows/quality-control/#Platform-Specific-QC","page":"Quality Control & Preprocessing","title":"Platform-Specific QC","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– assesshifiquality, assessnanoporequality, assessilluminaquality not yet implemented as documented –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-HiFi-Specific-Quality-Control","page":"Quality Control & Preprocessing","title":"Example: HiFi-Specific Quality Control","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# HiFi-specific quality assessment\nhifi_qc = Mycelia.assess_hifi_quality(\"hifi_reads.fastq\")\n\nprintln(\"HiFi Quality Assessment:\")\nprintln(\"  Mean accuracy: $(hifi_qc.mean_accuracy)\")\nprintln(\"  Mean length: $(hifi_qc.mean_length)\")\nprintln(\"  Length N50: $(hifi_qc.length_n50)\")\nprintln(\"  Quality distribution:\")\nprintln(\"    Q20+: $(hifi_qc.q20_percent)%\")\nprintln(\"    Q30+: $(hifi_qc.q30_percent)%\")\nprintln(\"    Q40+: $(hifi_qc.q40_percent)%\")","category":"page"},{"location":"api/workflows/quality-control/#Application-Specific-QC","page":"Quality Control & Preprocessing","title":"Application-Specific QC","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– assessassemblyreadiness, assessannotationreadiness, assessvariantcalling_readiness not yet implemented as documented –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Assembly-Readiness-Assessment","page":"Quality Control & Preprocessing","title":"Example: Assembly Readiness Assessment","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Check if reads are suitable for assembly\nassembly_readiness = Mycelia.assess_assembly_readiness(\"reads.fastq\")\n\nprintln(\"Assembly Readiness:\")\nprintln(\"  Overall score: $(assembly_readiness.overall_score)/10\")\nprintln(\"  Coverage estimate: $(assembly_readiness.estimated_coverage)x\")\nprintln(\"  Quality sufficient: $(assembly_readiness.quality_sufficient)\")\nprintln(\"  Length distribution: $(assembly_readiness.length_distribution_score)\")\n\nif !assembly_readiness.ready_for_assembly\n    println(\"Issues found:\")\n    for issue in assembly_readiness.issues\n        println(\"  - $(issue)\")\n    end\nend","category":"page"},{"location":"api/workflows/quality-control/#Visualization-and-Plotting","page":"Quality Control & Preprocessing","title":"Visualization and Plotting","text":"","category":"section"},{"location":"api/workflows/quality-control/#Quality-Plots","page":"Quality Control & Preprocessing","title":"Quality Plots","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– plotqualitydistribution, plotlengthdistribution, plotgccontentdistribution, plotbase_composition not yet implemented as individual functions Visualization functions available in Mycelia plotting module –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Quality-Visualization","page":"Quality Control & Preprocessing","title":"Example: Quality Visualization","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Create quality visualization plots\nquality_plots = Mycelia.create_quality_plots(\"reads.fastq\")\n\n# Individual plots\nMycelia.plot_quality_distribution(quality_plots.quality_data, \n                         title=\"Per-Base Quality Scores\")\n\nMycelia.plot_length_distribution(quality_plots.length_data,\n                        title=\"Read Length Distribution\")\n\n# Combined quality dashboard\nquality_dashboard = Mycelia.plot_quality_dashboard(quality_plots)\nMycelia.save_plot(quality_dashboard, \"quality_dashboard.png\")","category":"page"},{"location":"api/workflows/quality-control/#Performance-Optimization","page":"Quality Control & Preprocessing","title":"Performance Optimization","text":"","category":"section"},{"location":"api/workflows/quality-control/#Memory-Efficient-Processing","page":"Quality Control & Preprocessing","title":"Memory-Efficient Processing","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"<!– streamqualityanalysis, processinchunks, parallelqualityassessment not yet implemented as documented –>","category":"page"},{"location":"api/workflows/quality-control/#Example:-Large-File-Processing","page":"Quality Control & Preprocessing","title":"Example: Large File Processing","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Process large files efficiently\nlarge_file_qc = Mycelia.stream_quality_analysis(\n    \"large_reads.fastq\",\n    chunk_size=10000,\n    parallel=true,\n    threads=8\n)\n\n# Memory-efficient filtering\nfiltered_output = Mycelia.process_in_chunks(\n    \"large_reads.fastq\",\n    \"filtered_reads.fastq\",\n    chunk_size=50000,\n    filter_function=quality_filter_function\n)","category":"page"},{"location":"api/workflows/quality-control/#Common-Issues-and-Solutions","page":"Quality Control & Preprocessing","title":"Common Issues and Solutions","text":"","category":"section"},{"location":"api/workflows/quality-control/#Low-Quality-Data","page":"Quality Control & Preprocessing","title":"Low Quality Data","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Identify quality issues\nquality_issues = Mycelia.diagnose_quality_issues(\"reads.fastq\")\n\nfor issue in quality_issues\n    println(\"Issue: $(issue.type)\")\n    println(\"  Description: $(issue.description)\")\n    println(\"  Severity: $(issue.severity)\")\n    println(\"  Recommendation: $(issue.recommendation)\")\nend","category":"page"},{"location":"api/workflows/quality-control/#Contamination-Problems","page":"Quality Control & Preprocessing","title":"Contamination Problems","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"# Comprehensive contamination screening\ncontamination_screen = Mycelia.comprehensive_contamination_screening(\n    \"reads.fastq\",\n    databases=[\"host\", \"vector\", \"adapter\", \"primer\"]\n)\n\n# Generate contamination report\ncontamination_report = Mycelia.generate_contamination_report(contamination_screen)","category":"page"},{"location":"api/workflows/quality-control/#Related-Functions","page":"Quality Control & Preprocessing","title":"Related Functions","text":"","category":"section"},{"location":"api/workflows/quality-control/#Data-Input/Output","page":"Quality Control & Preprocessing","title":"Data Input/Output","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"read_fastq - Read FASTQ files\nwrite_fastq - Write filtered FASTQ files\ncompress_fastq - Compress output files","category":"page"},{"location":"api/workflows/quality-control/#Downstream-Analysis","page":"Quality Control & Preprocessing","title":"Downstream Analysis","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"count_kmers - K-mer analysis of cleaned reads\nassemble_genome - Genome assembly with quality-controlled reads","category":"page"},{"location":"api/workflows/quality-control/#Visualization","page":"Quality Control & Preprocessing","title":"Visualization","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"plot_quality_metrics - Quality visualization\ncreate_quality_dashboard - Interactive quality dashboard","category":"page"},{"location":"api/workflows/quality-control/#Related-Workflows","page":"Quality Control & Preprocessing","title":"Related Workflows","text":"","category":"section"},{"location":"api/workflows/quality-control/#Previous-Steps","page":"Quality Control & Preprocessing","title":"Previous Steps","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"Data Acquisition - Obtaining sequencing data","category":"page"},{"location":"api/workflows/quality-control/#Next-Steps","page":"Quality Control & Preprocessing","title":"Next Steps","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"Sequence Analysis - K-mer analysis of quality-controlled reads\nGenome Assembly (planned) - Assembly with preprocessed reads","category":"page"},{"location":"api/workflows/quality-control/#See-Also","page":"Quality Control & Preprocessing","title":"See Also","text":"","category":"section"},{"location":"api/workflows/quality-control/","page":"Quality Control & Preprocessing","title":"Quality Control & Preprocessing","text":"Tutorial 2: Quality Control\nFASTA/FASTQ Data Types (planned)\nPerformance Optimization Guide","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Tutorial-6:-FASTQ-Sequences-to-Qualmer-Graphs-and-Back","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"This tutorial demonstrates the round-trip workflow from FASTQ sequences through quality-aware k-mer (qualmer) graphs and back to reconstructed sequences. Qualmers incorporate both sequence information and quality scores for more accurate assembly decisions.","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Learning-Objectives","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"By the end of this tutorial, you will understand:","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"How to create qualmer graphs from FASTQ data\nHow quality scores influence k-mer confidence\nHow to perform quality-aware assembly using package functions\nHow to reconstruct sequences while preserving quality information\nThe advantages of quality-aware vs coverage-only assembly","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Setup-and-Imports","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Setup and Imports","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Following CLAUDE.md standards: only import top-level packages, use full namespacing","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"import Mycelia\nimport FASTX\nimport Graphs\nimport Test\nimport Statistics","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-1:-Understanding-Qualmers","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Part 1: Understanding Qualmers","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Qualmers are k-mers with associated quality information. When the same k-mer is observed multiple times with different quality scores, we calculate a joint probability that represents our confidence in that k-mer's correctness.","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Creating-Sample-FASTQ-Data-with-Varying-Quality","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Creating Sample FASTQ Data with Varying Quality","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"function create_sample_fastq_data()\n    # High-quality read\n    hq_seq = \"ATCGATCGATCGATCGATCG\"\n    hq_qual = \"IIIIIIIIIIIIIIIIIIII\"  ## Phred 40 (99.99% accuracy)\n\n    # Medium-quality read with overlap\n    mq_seq = \"GATCGATCGATCGATCGTAG\"\n    mq_qual = \"FFFFFFFFFFFFFFFFFF@@\"  ## Phred 37 (99.98%) with lower end\n\n    # Low-quality read with errors\n    lq_seq = \"GATCGATCGATCGATCGTAC\"  ## Error at end (C instead of G)\n    lq_qual = \"555555555555555555##\"  ## Phred 20 (99%) with very low end\n\n    # Create FASTQ records\n    records = [\n        FASTX.FASTQ.Record(\"read1\", hq_seq, hq_qual),\n        FASTX.FASTQ.Record(\"read2\", mq_seq, mq_qual),\n        FASTX.FASTQ.Record(\"read3\", lq_seq, lq_qual)\n    ]\n\n    return records\nend\n\nprintln(\"Creating sample FASTQ data with varying quality scores...\")\nfastq_records = create_sample_fastq_data()","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Display the records","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"for (i, record) in enumerate(fastq_records)\n    println(\"\\nRead $i:\")\n    println(\"  Sequence: \", String(FASTX.sequence(record)))\n    println(\"  Quality:  \", String(FASTX.quality(record)))\n    println(\"  Phred scores: \", FASTX.quality_scores(record))\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-2:-Building-Qualmer-Graphs","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Part 2: Building Qualmer Graphs","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Qualmer graphs combine k-mer information with quality scores to make more informed assembly decisions.","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Build-a-qualmer-graph-with-k7","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Build a qualmer graph with k=7","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"k = 7\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Building qualmer graph with k=$k...\")\n\nqualmer_graph = Mycelia.build_qualmer_graph(fastq_records; k=k, graph_mode=Mycelia.DoubleStrand)","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Examine graph properties","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"println(\"\\nQualmer graph statistics:\")\nprintln(\"  Number of vertices (unique k-mers): \", Graphs.nv(qualmer_graph))\nprintln(\"  Number of edges: \", Graphs.ne(qualmer_graph))","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Inspect-qualmer-properties","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Inspect qualmer properties","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Examining qualmer vertices and their properties:\")","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Get first few vertices to examine","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"for v in Iterators.take(Graphs.vertices(qualmer_graph), 5)\n    vertex_data = qualmer_graph[v]\n    println(\"\\nVertex $v:\")\n    println(\"  K-mer: \", vertex_data.kmer)\n    println(\"  Coverage: \", vertex_data.coverage)\n    println(\"  Mean quality: \", round(vertex_data.mean_quality, digits=2))\n    println(\"  Joint probability: \", round(vertex_data.joint_probability, digits=4))\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-3:-Quality-Aware-vs-Coverage-Only-Assembly","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Part 3: Quality-Aware vs Coverage-Only Assembly","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Let's compare how quality information affects assembly decisions.","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Find-high-confidence-paths-using-quality-information","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Find high-confidence paths using quality information","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Finding high-confidence paths through the qualmer graph...\")","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Get all vertices sorted by joint probability (confidence)","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"vertices_by_confidence = sort(collect(Graphs.vertices(qualmer_graph)),\n    by=v -> qualmer_graph[v].joint_probability, rev=true)\n\nprintln(\"\\nTop 5 most confident k-mers:\")\nfor v in vertices_by_confidence[1:min(5, length(vertices_by_confidence))]\n    vdata = qualmer_graph[v]\n    println(\"  \", vdata.kmer,\n            \" - Coverage: \", vdata.coverage,\n            \", Joint prob: \", round(vdata.joint_probability, digits=4),\n            \", Mean quality: \", round(vdata.mean_quality, digits=1))\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Compare-with-coverage-only-approach","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Compare with coverage-only approach","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"vertices_by_coverage = sort(collect(Graphs.vertices(qualmer_graph)),\n    by=v -> qualmer_graph[v].coverage, rev=true)\n\nprintln(\"\\nTop 5 highest coverage k-mers:\")\nfor v in vertices_by_coverage[1:min(5, length(vertices_by_coverage))]\n    vdata = qualmer_graph[v]\n    println(\"  \", vdata.kmer,\n            \" - Coverage: \", vdata.coverage,\n            \", Joint prob: \", round(vdata.joint_probability, digits=4),\n            \", Mean quality: \", round(vdata.mean_quality, digits=1))\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-4:-Quality-Aware-Path-Finding","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Part 4: Quality-Aware Path Finding","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Use the package function to find the most likely path through the graph.","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Find best starting vertex (highest confidence)","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"start_vertex = vertices_by_confidence[1]\nquality_path = Mycelia.find_quality_weighted_path(qualmer_graph, start_vertex)\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Quality-weighted path through graph:\")\nprintln(\"Path length: \", length(quality_path), \" vertices\")","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Show path k-mers and qualities","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"println(\"\\nPath details:\")\nfor (i, v) in enumerate(quality_path[1:min(10, length(quality_path))])\n    vdata = qualmer_graph[v]\n    println(\"  Step $i: \", vdata.kmer,\n            \" (prob: \", round(vdata.joint_probability, digits=3), \")\")\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-5:-Converting-to-Quality-Aware-BioSequence-Graph","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Part 5: Converting to Quality-Aware BioSequence Graph","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Convert the qualmer graph to a variable-length quality-aware sequence graph.","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Converting qualmer graph to quality-aware BioSequence graph...\")","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Convert to FASTQ graph (variable-length with quality)","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"fastq_graph = Mycelia.qualmer_graph_to_quality_biosequence_graph(qualmer_graph, k)\n\nprintln(\"\\nFASTQ graph statistics:\")\nprintln(\"  Number of vertices: \", Graphs.nv(fastq_graph))\nprintln(\"  Number of edges: \", Graphs.ne(fastq_graph))","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Examine simplified vertices","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"println(\"\\nExamining quality-aware sequence vertices:\")\nfor v in Iterators.take(Graphs.vertices(fastq_graph), 3)\n    vertex_data = fastq_graph[v]\n    println(\"\\nVertex $v:\")\n    println(\"  Sequence: \", vertex_data.sequence)\n    println(\"  Length: \", length(vertex_data.sequence))\n    println(\"  Quality scores: \", vertex_data.quality_scores[1:min(20, length(vertex_data.quality_scores))], \"...\")\n    println(\"  Mean quality: \", round(Statistics.mean(vertex_data.quality_scores), digits=1))\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-6:-Round-Trip-Reconstruction","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Part 6: Round-Trip Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Reconstruct FASTQ records from the quality-aware graph.","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Reconstructing FASTQ records from the graph...\")","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Extract paths and convert to FASTQ records","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"reconstructed_records = Mycelia.quality_biosequence_graph_to_fastq(fastq_graph, \"reconstructed\")\n\nprintln(\"\\nReconstructed \", length(reconstructed_records), \" FASTQ records\")","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Compare with original","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"println(\"\\nComparison with original reads:\")\nfor (i, (orig, recon)) in enumerate(zip(fastq_records[1:min(3, length(reconstructed_records))],\n                                        reconstructed_records[1:min(3, length(reconstructed_records))]))\n    orig_seq = String(FASTX.sequence(orig))\n    recon_seq = String(FASTX.sequence(recon))\n\n    println(\"\\nRead $i:\")\n    println(\"  Original:      \", orig_seq)\n    println(\"  Reconstructed: \", recon_seq)\n    println(\"  Match: \", orig_seq == recon_seq ? \"✓\" : \"✗\")\n\n    # Compare quality scores\n    orig_qual = FASTX.quality_scores(orig)\n    recon_qual = FASTX.quality_scores(recon)\n    println(\"  Original quality range: \", minimum(orig_qual), \"-\", maximum(orig_qual))\n    println(\"  Reconstructed quality range: \", minimum(recon_qual), \"-\", maximum(recon_qual))\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-7:-Error-Correction-Using-Quality-Information","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Part 7: Error Correction Using Quality Information","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Demonstrate how quality scores help identify and correct errors using package functions.","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Demonstrating quality-aware error correction...\")","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Create reads with a known error","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"error_reads = [\n    FASTX.FASTQ.Record(\"good1\", \"ATCGATCGATCG\", \"IIIIIIIIIIII\"),  ## High quality\n    FASTX.FASTQ.Record(\"good2\", \"TCGATCGATCGA\", \"IIIIIIIIIIII\"),  ## High quality\n    FASTX.FASTQ.Record(\"error\", \"TCGATCTATCGA\", \"IIIIII##IIII\"),  ## Error at low quality position\n]","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Build qualmer graph","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"error_graph = Mycelia.build_qualmer_graph(error_reads; k=5, graph_mode=Mycelia.SingleStrand)\n\nprintln(\"\\nAnalyzing k-mers around error position:\")","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"The error creates k-mers: GATCT (wrong) vs GATCG (correct)","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"for v in Graphs.vertices(error_graph)\n    vdata = error_graph[v]\n    kmer_str = String(vdata.kmer)\n    if occursin(\"GATC\", kmer_str)\n        println(\"  K-mer: \", kmer_str,\n                \" - Coverage: \", vdata.coverage,\n                \", Joint prob: \", round(vdata.joint_probability, digits=4))\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Use package function to identify potential errors","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"potential_errors = Mycelia.identify_potential_errors(error_graph)\nprintln(\"\\nPotential error k-mers identified: \", length(potential_errors))\n\nfor error_v in potential_errors\n    vdata = error_graph[error_v]\n    println(\"  Error k-mer: \", vdata.kmer,\n            \" - Coverage: \", vdata.coverage,\n            \", Quality: \", round(vdata.mean_quality, digits=1),\n            \", Confidence: \", round(vdata.joint_probability, digits=4))\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-8:-Advanced-Quality-Metrics","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Part 8: Advanced Quality Metrics","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Calculate assembly quality metrics using the package function.","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"metrics = Mycelia.calculate_assembly_quality_metrics(qualmer_graph)\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Assembly quality metrics:\")\nprintln(\"  Mean k-mer coverage: \", round(metrics.mean_coverage, digits=2))\nprintln(\"  Mean quality score: \", round(metrics.mean_quality, digits=1))\nprintln(\"  Mean k-mer confidence: \", round(metrics.mean_confidence, digits=4))\nprintln(\"  Fraction of low-confidence k-mers: \", round(metrics.low_confidence_fraction, digits=3))\nprintln(\"  Total unique k-mers: \", metrics.total_kmers)","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-9:-Practical-Example-Assembling-a-Small-Genome-Region","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Part 9: Practical Example - Assembling a Small Genome Region","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Let's create a more realistic example with overlapping reads from a genome region.","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"function create_genome_region_reads()\n    # Simulate a 50bp genome region\n    true_sequence = \"ATCGATCGATCGTAGCTAGCTAGCTTGCATGCATGCATGCATGCATGCAT\"\n\n    # Generate overlapping reads with varying quality\n    reads = []\n\n    # High quality reads\n    push!(reads, FASTX.FASTQ.Record(\"hq1\", true_sequence[1:25], \"I\"^25))\n    push!(reads, FASTX.FASTQ.Record(\"hq2\", true_sequence[15:40], \"I\"^26))\n    push!(reads, FASTX.FASTQ.Record(\"hq3\", true_sequence[30:50], \"I\"^21))\n\n    # Medium quality reads with some errors\n    read_mq1 = true_sequence[5:30]\n    qual_mq1 = \"FFFFFFFFFFFFFFFFFFFFFFFFFF\"\n    push!(reads, FASTX.FASTQ.Record(\"mq1\", read_mq1, qual_mq1))\n\n    # Low quality read with error\n    read_lq1 = true_sequence[20:45]\n    read_lq1 = read_lq1[1:10] * \"T\" * read_lq1[12:end]  ## Error at position 11\n    qual_lq1 = \"AAAAAAAAAA#AAAAAAAAAAAAAA\"  ## Low quality at error\n    push!(reads, FASTX.FASTQ.Record(\"lq1\", read_lq1, qual_lq1))\n\n    return reads, true_sequence\nend\n\ngenome_reads, true_seq = create_genome_region_reads()\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Assembling genome region from overlapping reads...\")\nprintln(\"True sequence: \", true_seq)\nprintln(\"Number of reads: \", length(genome_reads))","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Build qualmer graph","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"genome_graph = Mycelia.build_qualmer_graph(genome_reads; k=9, graph_mode=Mycelia.SingleStrand)","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Convert to sequence graph and extract contigs","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"seq_graph = Mycelia.qualmer_graph_to_quality_biosequence_graph(genome_graph, 9)\n\nprintln(\"\\nAssembly results:\")\nprintln(\"  Qualmer graph: \", Graphs.nv(genome_graph), \" vertices, \", Graphs.ne(genome_graph), \" edges\")\nprintln(\"  Sequence graph: \", Graphs.nv(seq_graph), \" vertices, \", Graphs.ne(seq_graph), \" edges\")","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Use package function to find quality-weighted path","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"if Graphs.nv(genome_graph) > 0\n    # Start from highest confidence vertex\n    confidence_sorted = sort(collect(Graphs.vertices(genome_graph)),\n        by=v -> genome_graph[v].joint_probability, rev=true)\n    best_path = Mycelia.find_quality_weighted_path(genome_graph, confidence_sorted[1])\n\n    println(\"\\nBest quality-weighted path:\")\n    println(\"  Path length: \", length(best_path), \" k-mers\")\n\n    # Reconstruct sequence from path\n    if length(best_path) > 1\n        path_kmers = [String(genome_graph[v].kmer) for v in best_path]\n        # Simple reconstruction: first k-mer + last base of each subsequent k-mer\n        reconstructed = path_kmers[1] * join([kmer[end] for kmer in path_kmers[2:end]])\n\n        println(\"  Reconstructed length: \", length(reconstructed))\n        println(\"  Reconstructed: \", reconstructed)\n\n        # Check accuracy\n        if reconstructed == true_seq\n            println(\"  ✓ Perfect reconstruction!\")\n        elseif occursin(reconstructed, true_seq)\n            println(\"  ✓ Assembled sequence is a substring of true sequence\")\n        elseif occursin(true_seq, reconstructed)\n            println(\"  ✓ True sequence is a substring of assembled sequence\")\n        else\n            println(\"  ✗ Assembly differs from true sequence\")\n            println(\"  True:      \", true_seq)\n            println(\"  Assembled: \", reconstructed)\n        end\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Find longest path (contig) from sequence graph","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"if Graphs.nv(seq_graph) > 0\n    # Get vertex with longest sequence\n    longest_v = argmax(v -> length(seq_graph[v].sequence), Graphs.vertices(seq_graph))\n    longest_seq = seq_graph[longest_v].sequence\n    longest_qual = seq_graph[longest_v].quality_scores\n\n    println(\"\\nLongest contig from simplified graph:\")\n    println(\"  Length: \", length(longest_seq))\n    println(\"  Sequence: \", longest_seq)\n    println(\"  Mean quality: \", round(Statistics.mean(longest_qual), digits=1))\n\n    # Check accuracy\n    if String(longest_seq) == true_seq\n        println(\"  ✓ Perfect reconstruction!\")\n    else\n        # Find best alignment\n        true_str = true_seq\n        assembled_str = String(longest_seq)\n        if occursin(assembled_str, true_str)\n            println(\"  ✓ Assembled sequence is a substring of true sequence\")\n        elseif occursin(true_str, assembled_str)\n            println(\"  ✓ True sequence is a substring of assembled sequence\")\n        else\n            println(\"  ✗ Assembly differs from true sequence\")\n        end\n    end\nend","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Calculate final quality metrics for the genome assembly","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"final_metrics = Mycelia.calculate_assembly_quality_metrics(genome_graph)\nprintln(\"\\nFinal assembly quality metrics:\")\nprintln(\"  Mean coverage: \", round(final_metrics.mean_coverage, digits=2))\nprintln(\"  Mean quality: \", round(final_metrics.mean_quality, digits=1))\nprintln(\"  Mean confidence: \", round(final_metrics.mean_confidence, digits=4))\nprintln(\"  Low confidence fraction: \", round(final_metrics.low_confidence_fraction, digits=3))","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Summary","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Summary","text":"","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"In this tutorial, we've demonstrated:","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Qualmer Construction: Building quality-aware k-mer graphs from FASTQ data\nJoint Probability: How multiple observations with different qualities are combined\nQuality vs Coverage: The advantage of using quality scores over coverage alone\nPackage Functions: Using Mycelia's built-in functions for quality-weighted analysis:\nfind_quality_weighted_path() for optimal path finding\ncalculate_assembly_quality_metrics() for comprehensive quality assessment\nidentify_potential_errors() for error detection\nRound-Trip Conversion: Maintaining quality information through graph transformations\nPractical Assembly: Using quality information for more accurate genome assembly","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Key advantages of qualmer graphs:","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"Better discrimination between true k-mers and errors\nQuality-weighted path finding for more accurate assembly\nPreservation of quality information for downstream analysis\nImproved handling of repetitive regions with varying quality\nBuilt-in error detection and quality assessment capabilities","category":"page"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/","page":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Tutorial 6 completed!\")\nprintln(\"You've learned how to use quality-aware k-mer graphs for improved assembly accuracy.\")\nprintln(\"All analysis was performed using Mycelia's built-in qualmer analysis functions.\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Tutorial-4:-Genome-Assembly","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"This tutorial covers comprehensive genome assembly approaches, including short read, long read, and hybrid assembly methods, with emphasis on Mycelia's probabilistic assembly and benchmarking against state-of-the-art tools.","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Learning-Objectives","page":"Tutorial 4: Genome Assembly","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"By the end of this tutorial, you will understand:","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Different assembly algorithms and their applications\nShort read assembly with MEGAHIT and metaSPAdes\nLong read assembly with Flye, Canu, and hifiasm\nHybrid assembly approaches combining multiple data types\nMycelia's probabilistic assembly using string graphs and Viterbi error correction\nAssembly quality metrics and their interpretation\nError correction and polishing techniques\nHandling repetitive sequences and structural variants\nAssembly validation and benchmarking approaches","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Setup","page":"Tutorial 4: Genome Assembly","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"import Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\n\nRandom.seed!(42)","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Part-1:-Assembly-Algorithm-Overview","page":"Tutorial 4: Genome Assembly","title":"Part 1: Assembly Algorithm Overview","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Understanding different assembly approaches helps choose the right method for your data type and research goals.","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"=== Genome Assembly Tutorial ===\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Assembly-Paradigms","page":"Tutorial 4: Genome Assembly","title":"Assembly Paradigms","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Four main approaches to genome assembly:","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"de Bruijn Graph - for short reads (MEGAHIT, metaSPAdes)\nOverlap-Layout-Consensus (OLC) - for long reads (Canu)\nString Graph - for long accurate reads (hifiasm, Flye)\nProbabilistic Assembly - Mycelia's approach using string graphs with Viterbi error correction","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"Assembly Algorithm Comparison:\")\nprintln(\"de Bruijn Graph:\")\nprintln(\"  - Best for: Short reads (Illumina)\")\nprintln(\"  - Tools: MEGAHIT, metaSPAdes, SPAdes\")\nprintln(\"  - Strengths: Efficient, handles high coverage\")\nprintln(\"  - Weaknesses: Struggles with repeats, requires error correction\")\nprintln()\nprintln(\"OLC (Overlap-Layout-Consensus):\")\nprintln(\"  - Best for: Long reads (PacBio, Nanopore)\")\nprintln(\"  - Tools: Canu, Miniasm\")\nprintln(\"  - Strengths: Handles repeats, intuitive approach\")\nprintln(\"  - Weaknesses: Computationally expensive, error-sensitive\")\nprintln()\nprintln(\"String Graph:\")\nprintln(\"  - Best for: Long accurate reads (HiFi)\")\nprintln(\"  - Tools: hifiasm, Flye\")\nprintln(\"  - Strengths: Efficient, haplotype-aware, handles complexity\")\nprintln(\"  - Weaknesses: Requires high-quality reads\")\nprintln()\nprintln(\"Probabilistic Assembly (Mycelia):\")\nprintln(\"  - Best for: Any read type with error correction\")\nprintln(\"  - Tools: Mycelia's string graph + Viterbi\")\nprintln(\"  - Strengths: Handles errors probabilistically, adaptable\")\nprintln(\"  - Weaknesses: Computationally intensive for large genomes\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Part-2:-Data-Preparation-for-Assembly","page":"Tutorial 4: Genome Assembly","title":"Part 2: Data Preparation for Assembly","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Proper data preparation is crucial for successful assembly","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"\\n=== Data Preparation ===\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Simulating-Multi-Platform-Data","page":"Tutorial 4: Genome Assembly","title":"Simulating Multi-Platform Data","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Create synthetic data for comprehensive assembly testing","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Generating Test Data ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Create a synthetic genome with known structure","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"genome_size = 50000  ## 50 kb for demonstration\nreference_genome = Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=genome_size)\n\nprintln(\"Reference genome: $(genome_size) bp\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Simulate different read types","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"short_read_params = Dict(\n    \"coverage\" => 30,\n    \"read_length\" => 150,\n    \"error_rate\" => 0.001,\n    \"description\" => \"Illumina short reads\"\n)\n\nlong_read_params = Dict(\n    \"coverage\" => 20,\n    \"read_length\" => 10000,\n    \"error_rate\" => 0.05,\n    \"description\" => \"Nanopore long reads\"\n)\n\nhifi_params = Dict(\n    \"coverage\" => 15,\n    \"read_length\" => 15000,\n    \"error_rate\" => 0.001,\n    \"description\" => \"PacBio HiFi reads\"\n)","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement multi-platform read simulation","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Generate short reads for MEGAHIT/metaSPAdes\nGenerate long reads for Flye/Canu\nGenerate HiFi reads for hifiasm\nCreate hybrid datasets for Unicycler\nGenerate error-prone reads for Mycelia polishing","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"Simulating read types:\")\nfor (name, params) in [(\"Short reads\", short_read_params),\n                      (\"Long reads\", long_read_params),\n                      (\"HiFi reads\", hifi_params)]\n    println(\"  $(name): $(params[\"coverage\"])x coverage, $(params[\"read_length\"]) bp, $(params[\"error_rate\"]*100)% error\")\nend","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Write test data","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"reference_file = \"reference_genome.fasta\"\nshort_reads_r1 = \"short_reads_R1.fastq\"\nshort_reads_r2 = \"short_reads_R2.fastq\"\nlong_reads_file = \"long_reads.fastq\"\nhifi_reads_file = \"hifi_reads.fastq\"\n\nMycelia.write_fasta(outfile=reference_file, records=[reference_genome])","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Write simulated reads to FASTQ files","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Generate paired-end short reads\nGenerate single-end long reads\nGenerate single-end HiFi reads","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Read-Statistics-and-Quality-Assessment","page":"Tutorial 4: Genome Assembly","title":"Read Statistics and Quality Assessment","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Analyze read characteristics before assembly","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Read Analysis ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement read analysis","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Read length distribution\nQuality score distribution\nCoverage estimation\nError rate assessment","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Part-3:-Multi-Platform-Assembly-Approaches","page":"Tutorial 4: Genome Assembly","title":"Part 3: Multi-Platform Assembly Approaches","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Comprehensive coverage of short read, long read, and hybrid assembly","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"\\n=== Multi-Platform Assembly Approaches ===\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Short-Read-Assembly","page":"Tutorial 4: Genome Assembly","title":"Short Read Assembly","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"MEGAHIT and metaSPAdes for short read data","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Short Read Assembly ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Example parameters for short read assembly","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"short_read_params = Dict(\n    \"megahit_k_list\" => \"21,29,39,59,79,99,119,141\",\n    \"metaspades_k_list\" => \"21,33,55,77\",\n    \"min_contig_len\" => 200,\n    \"threads\" => 4\n)\n\nprintln(\"Short read assembly parameters:\")\nfor (param, value) in short_read_params\n    println(\"  $param: $value\")\nend","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement short read assembly examples","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Run MEGAHIT for metagenomic data\nRun metaSPAdes for complex datasets\nCompare assembly quality metrics\nEvaluate computational requirements","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Long-Read-Assembly","page":"Tutorial 4: Genome Assembly","title":"Long Read Assembly","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Flye, Canu, and hifiasm for long read data","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Long Read Assembly ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Example parameters for long read assembly","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"long_read_params = Dict(\n    \"genome_size\" => \"5m\",\n    \"flye_read_type\" => \"pacbio-hifi\",\n    \"canu_read_type\" => \"pacbio\",\n    \"hifiasm_mode\" => \"primary\",\n    \"threads\" => 4\n)\n\nprintln(\"Long read assembly parameters:\")\nfor (param, value) in long_read_params\n    println(\"  $param: $value\")\nend","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement long read assembly examples","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Run Flye for various read types\nRun Canu with error correction\nRun hifiasm for HiFi data\nCompare assembly contiguity\nEvaluate error rates","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Hybrid-Assembly","page":"Tutorial 4: Genome Assembly","title":"Hybrid Assembly","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Unicycler combining short and long reads","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Hybrid Assembly ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Example parameters for hybrid assembly","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"hybrid_params = Dict(\n    \"short_read_accuracy\" => 0.99,\n    \"long_read_accuracy\" => 0.90,\n    \"bridging_mode\" => \"conservative\",\n    \"threads\" => 4\n)\n\nprintln(\"Hybrid assembly parameters:\")\nfor (param, value) in hybrid_params\n    println(\"  $param: $value\")\nend","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement hybrid assembly examples","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Run Unicycler with paired data\nCompare to short-read-only assemblies\nEvaluate scaffolding improvements\nAssess computational trade-offs","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Mycelia's-Probabilistic-Assembly","page":"Tutorial 4: Genome Assembly","title":"Mycelia's Probabilistic Assembly","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"String graph approach with Viterbi error correction","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Mycelia's Probabilistic Assembly ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Example parameters for Mycelia assembly","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"mycelia_params = Dict(\n    \"k_range\" => \"21,31,41,51,61,71,81,91\",\n    \"error_rate\" => 0.01,\n    \"min_coverage\" => 3,\n    \"iterative_polishing\" => true,\n    \"verbosity\" => \"reads\"\n)\n\nprintln(\"Mycelia assembly parameters:\")\nfor (param, value) in mycelia_params\n    println(\"  $param: $value\")\nend","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement Mycelia assembly examples","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Build string graph from reads\nApply Viterbi error correction\nPerform iterative polishing\nCompare to external assemblers","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"Assembly approaches comparison completed...\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Part-4:-Assembly-Quality-Assessment","page":"Tutorial 4: Genome Assembly","title":"Part 4: Assembly Quality Assessment","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Comprehensive evaluation of assembly quality","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"\\n=== Assembly Quality Assessment ===\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Basic-Assembly-Statistics","page":"Tutorial 4: Genome Assembly","title":"Basic Assembly Statistics","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Calculate fundamental assembly metrics","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Basic Statistics ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement assembly statistics","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Contig count and sizes\nN50, N90, L50, L90\nTotal assembly size\nLargest contig size\nGC content","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Example with placeholder data","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"assembly_stats = Dict(\n    \"total_length\" => 49500,\n    \"n_contigs\" => 3,\n    \"n50\" => 25000,\n    \"l50\" => 1,\n    \"largest_contig\" => 30000,\n    \"gc_content\" => 0.45\n)\n\nprintln(\"Assembly Statistics:\")\nfor (metric, value) in assembly_stats\n    println(\"  $metric: $value\")\nend","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Advanced-Quality-Metrics","page":"Tutorial 4: Genome Assembly","title":"Advanced Quality Metrics","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"More sophisticated quality assessment","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Advanced Quality Metrics ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement advanced quality assessment","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"BUSCO completeness scores\nMerqury QV scores\nLAI (LTR Assembly Index)\nContiguity vs completeness trade-offs","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Comparison-with-Reference","page":"Tutorial 4: Genome Assembly","title":"Comparison with Reference","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Validate assembly against known reference","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Reference Comparison ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement reference comparison","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Alignment-based comparison\nStructural variation detection\nMisassembly identification\nCoverage uniformity assessment","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Part-5:-Assembly-Polishing-and-Error-Correction","page":"Tutorial 4: Genome Assembly","title":"Part 5: Assembly Polishing and Error Correction","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Improve assembly accuracy through polishing","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"\\n=== Assembly Polishing ===\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Consensus-Polishing","page":"Tutorial 4: Genome Assembly","title":"Consensus Polishing","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Use original reads to polish assembly","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Consensus Polishing ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement consensus polishing","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Align reads to assembly\nIdentify consensus variants\nApply corrections\nIterate polishing rounds","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Structural-Error-Correction","page":"Tutorial 4: Genome Assembly","title":"Structural Error Correction","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Fix larger structural errors","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Structural Correction ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement structural correction","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Identify structural variants\nValidate with long reads\nCorrect misassemblies\nHandle complex rearrangements","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Part-6:-Handling-Assembly-Challenges","page":"Tutorial 4: Genome Assembly","title":"Part 6: Handling Assembly Challenges","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Address common assembly difficulties","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"\\n=== Assembly Challenges ===\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Repetitive-Sequences","page":"Tutorial 4: Genome Assembly","title":"Repetitive Sequences","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Strategies for handling repeats","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Repetitive Sequences ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement repeat handling","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Identify repetitive regions\nUse read-spanning strategy\nImplement gap filling\nValidate repeat resolutions","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Heterozygosity","page":"Tutorial 4: Genome Assembly","title":"Heterozygosity","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Handle diploid and polyploid genomes","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Heterozygosity ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement heterozygosity handling","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Haplotype-aware assembly\nBubble detection and resolution\nDiploid assembly validation\nPhasing strategies","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Contamination","page":"Tutorial 4: Genome Assembly","title":"Contamination","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Detect and remove contaminating sequences","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Contamination Detection ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement contamination detection","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Taxonomic classification\nCoverage-based detection\nCompositional analysis\nFiltering strategies","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Part-7:-Assembly-Visualization-and-Exploration","page":"Tutorial 4: Genome Assembly","title":"Part 7: Assembly Visualization and Exploration","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Create plots and visualizations for assembly analysis","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"\\n=== Assembly Visualization ===\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Contig-Size-Distribution","page":"Tutorial 4: Genome Assembly","title":"Contig Size Distribution","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Visualize assembly contiguity","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Contig Visualization ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement assembly visualization","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Contig size histograms\nCumulative length plots\nN50 plots\nCoverage vs length plots","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Dot-Plots","page":"Tutorial 4: Genome Assembly","title":"Dot Plots","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Compare assemblies or validate against reference","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Dot Plot Analysis ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement dot plot visualization","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Self-alignment plots\nReference comparison plots\nSynteny visualization\nStructural variant detection","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Part-8:-Assembly-Benchmarking","page":"Tutorial 4: Genome Assembly","title":"Part 8: Assembly Benchmarking","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Compare different assembly approaches","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"\\n=== Assembly Benchmarking ===\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Multi-Assembler-Comparison","page":"Tutorial 4: Genome Assembly","title":"Multi-Assembler Comparison","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Compare multiple assembly tools","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Multi-Assembler Comparison ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement multi-assembler benchmarking","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Run multiple assemblers\nCompare quality metrics\nIdentify best-performing approaches\nConsensus assembly generation","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Parameter-Optimization","page":"Tutorial 4: Genome Assembly","title":"Parameter Optimization","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Optimize assembly parameters","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"--- Parameter Optimization ---\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"TODO: Implement parameter optimization","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Grid search over parameter space\nQuality-based optimization\nCross-validation approaches\nAutomated parameter tuning","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Part-9:-Best-Practices-and-Recommendations","page":"Tutorial 4: Genome Assembly","title":"Part 9: Best Practices and Recommendations","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Guidelines for successful genome assembly","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"\\n=== Best Practices ===\")\n\nprintln(\"Data Requirements:\")\nprintln(\"- HiFi: 20-30x coverage minimum\")\nprintln(\"- Read N50 > 10 kb preferred\")\nprintln(\"- Low contamination levels\")\nprintln(\"- Balanced coverage distribution\")\nprintln()\nprintln(\"Assembly Strategy:\")\nprintln(\"- Start with hifiasm for HiFi data\")\nprintln(\"- Use haplotype-aware mode for diploids\")\nprintln(\"- Validate with multiple quality metrics\")\nprintln(\"- Polish with original reads\")\nprintln()\nprintln(\"Quality Control:\")\nprintln(\"- Check BUSCO completeness (>90% for eukaryotes)\")\nprintln(\"- Validate N50 vs genome size expectations\")\nprintln(\"- Examine contig count (fewer is better)\")\nprintln(\"- Compare with related genomes\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/#Summary","page":"Tutorial 4: Genome Assembly","title":"Summary","text":"","category":"section"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"println(\"\\n=== Assembly Summary ===\")\nprintln(\"✓ Understanding assembly algorithms and their applications\")\nprintln(\"✓ Short read assembly with MEGAHIT and metaSPAdes\")\nprintln(\"✓ Long read assembly with Flye, Canu, and hifiasm\")\nprintln(\"✓ Hybrid assembly approaches with Unicycler\")\nprintln(\"✓ Mycelia's probabilistic assembly with string graphs and Viterbi error correction\")\nprintln(\"✓ Comprehensive quality assessment techniques\")\nprintln(\"✓ Assembly polishing and error correction\")\nprintln(\"✓ Handling repetitive sequences and heterozygosity\")\nprintln(\"✓ Visualization and benchmarking approaches\")","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"Cleanup","category":"page"},{"location":"generated/tutorials/04_genome_assembly/","page":"Tutorial 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"cleanup_files = [reference_file, short_reads_r1, short_reads_r2, long_reads_file, hifi_reads_file]\nfor file in cleanup_files\n    if isfile(file)\n        rm(file, force=true)\n    end\nend\n\n# Note: No assembly output directory was created in this tutorial\nassembly_output = \"assembly_output\"  # Define for consistency, but directory doesn't exist\nif isdir(assembly_output)\n    rm(assembly_output, recursive=true, force=true)\nend\n\nprintln(\"\\nNext: Tutorial 5 - Assembly Validation\")\n\nnothing","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"\"\"\"\nMycelia Graph Type Tutorials\n\nThis tutorial demonstrates the usage of all 6 graph types in Mycelia:\n1. N-gram Graphs - For unicode text analysis\n2. K-mer Graphs - For DNA/RNA/protein sequence analysis\n3. Qualmer Graphs - For quality-aware sequence analysis\n4. String Graphs - For simplified N-gram analysis\n5. FASTA Graphs - For variable-length BioSequence analysis\n6. FASTQ Graphs - For quality-aware BioSequence analysis\n\nEach section shows practical examples with real data.\n\"\"\"\n\nimport Mycelia\nimport FASTX\nimport BioSequences\n\nprintln(\"=\"^80)\nprintln(\"MYCELIA GRAPH TYPE TUTORIALS\")\nprintln(\"=\"^80)","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"============================================================================= Tutorial 1: N-gram Graphs - Unicode Text Analysis =============================================================================","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\n1. N-GRAM GRAPHS - Unicode Text Analysis\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Example: Analyzing text patterns","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"text = \"The quick brown fox jumps over the lazy dog\"\nprintln(\"Input text: \\\"$text\\\"\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create N-gram graph","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"ngram_graph = Mycelia.string_to_ngram_graph(s=text, n=3)\nprintln(\"Number of 3-grams: $(length(ngram_graph.vertex_labels))\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Show some N-grams","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"ngrams = collect(values(ngram_graph.vertex_labels))\nprintln(\"Example 3-grams: $(ngrams[1:min(5, length(ngrams))])\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Use case: Text compression, pattern detection, linguistic analysis","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"Use cases: Text compression, pattern detection, linguistic analysis\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"============================================================================= Tutorial 2: K-mer Graphs - BioSequence Analysis =============================================================================","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\n2. K-MER GRAPHS - BioSequence Analysis\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Example: DNA sequence analysis","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"dna_sequence = \"ATCGATCGATCGATCGTAGCTAGCTAGCT\"\nprintln(\"DNA sequence: $dna_sequence\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create FASTA record","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"dna_record = FASTX.FASTA.Record(\"sample_dna\", dna_sequence)\ndna_records = [dna_record]","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create k-mer graph","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"dna_kmer_graph = Mycelia.build_kmer_graph_next(Mycelia.Kmers.DNAKmer{5}, dna_records)\ndna_kmers = collect(values(dna_kmer_graph.vertex_labels))\nprintln(\"DNA k-mers (k=5): $(length(dna_kmers)) unique k-mers\")\nprintln(\"Example k-mers: $(dna_kmers[1:min(3, length(dna_kmers))])\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Get vertex data to see coverage information","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"first_kmer = first(dna_kmers)\nvertex_data = dna_kmer_graph[first_kmer]\nprintln(\"Coverage for $(first_kmer): $(length(vertex_data.coverage)) observations\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Example: RNA sequence analysis","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"rna_sequence = \"AUCGAUCGAUCGAUCGUAGCUAGCUAGCU\"\nprintln(\"\\\\nRNA sequence: $rna_sequence\")\n\nrna_record = FASTX.FASTA.Record(\"sample_rna\", rna_sequence)\nrna_records = [rna_record]","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create RNA k-mer graph","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"rna_kmer_graph = Mycelia.build_kmer_graph_next(Mycelia.Kmers.RNAKmer{4}, rna_records)\nrna_kmers = collect(values(rna_kmer_graph.vertex_labels))\nprintln(\"RNA k-mers (k=4): $(length(rna_kmers)) unique k-mers\")\nprintln(\"Example k-mers: $(rna_kmers[1:min(3, length(rna_kmers))])\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Example: Protein sequence analysis","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"protein_sequence = \"ALAVALINEGLUTAMINELEUCINE\"\nprintln(\"\\\\nProtein sequence: $protein_sequence\")\n\nprotein_record = FASTX.FASTA.Record(\"sample_protein\", protein_sequence)\nprotein_records = [protein_record]","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create protein k-mer graph","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"protein_kmer_graph = Mycelia.build_kmer_graph_next(Mycelia.Kmers.AAKmer{3}, protein_records)\nprotein_kmers = collect(values(protein_kmer_graph.vertex_labels))\nprintln(\"Protein k-mers (k=3): $(length(protein_kmers)) unique k-mers\")\nprintln(\"Example k-mers: $(protein_kmers[1:min(3, length(protein_kmers))])\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Use cases","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"Use cases: Genome assembly, repeat detection, sequence comparison\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"============================================================================= Tutorial 3: Qualmer Graphs - Quality-Aware Sequence Analysis =============================================================================","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\n3. QUALMER GRAPHS - Quality-Aware Sequence Analysis\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Example: High-quality sequencing data","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"high_quality_seq = \"ATCGATCGATCGATCGTAGCTAGCT\"\nhigh_quality_scores = \"HHHHHHHHHHHHHHHHHHHHHHHHH\"  ## PHRED 39\nprintln(\"High-quality sequence: $high_quality_seq\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create FASTQ record","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"hq_record = FASTX.FASTQ.Record(\"high_quality\", high_quality_seq, high_quality_scores)\nhq_records = [hq_record]","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create qualmer graph","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"hq_qualmer_graph = Mycelia.build_qualmer_graph(hq_records, k=5)\nhq_kmers = collect(values(hq_qualmer_graph.vertex_labels))\nprintln(\"High-quality k-mers: $(length(hq_kmers)) unique k-mers\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Show quality information","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"first_hq_kmer = first(hq_kmers)\nhq_vertex_data = hq_qualmer_graph[first_hq_kmer]\nprintln(\"$(first_hq_kmer): joint prob = $(round(hq_vertex_data.joint_probability, digits=4)), mean quality = $(hq_vertex_data.mean_quality)\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Example: Medium-quality sequencing data","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"medium_quality_seq = \"ATCGATCGATCGATCGTAGCTAGCT\"\nmedium_quality_scores = \"?????????????????????????\"  ## PHRED 30\nprintln(\"\\\\nMedium-quality sequence: $medium_quality_seq\")\n\nmq_record = FASTX.FASTQ.Record(\"medium_quality\", medium_quality_seq, medium_quality_scores)\nmq_records = [mq_record]","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create qualmer graph","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"mq_qualmer_graph = Mycelia.build_qualmer_graph(mq_records, k=5)\nmq_kmers = collect(values(mq_qualmer_graph.vertex_labels))\nprintln(\"Medium-quality k-mers: $(length(mq_kmers)) unique k-mers\")\n\nfirst_mq_kmer = first(mq_kmers)\nmq_vertex_data = mq_qualmer_graph[first_mq_kmer]\nprintln(\"$(first_mq_kmer): joint prob = $(round(mq_vertex_data.joint_probability, digits=4)), mean quality = $(mq_vertex_data.mean_quality)\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Quality comparison","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\\\nQuality comparison:\")\nprintln(\"High-quality joint probability: $(round(hq_vertex_data.joint_probability, digits=4))\")\nprintln(\"Medium-quality joint probability: $(round(mq_vertex_data.joint_probability, digits=4))\")\nprintln(\"Quality-aware assembly can make better decisions using this information!\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Use cases","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"Use cases: Error correction, quality-aware assembly, variant calling\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"============================================================================= Tutorial 4: String Graphs - Simplified N-gram Analysis =============================================================================","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\n4. STRING GRAPHS - Simplified N-gram Analysis\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Example: Text processing with simplification","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"text_for_strings = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nprintln(\"Input text: $text_for_strings\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create N-gram graph first","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"string_ngram_graph = Mycelia.string_to_ngram_graph(s=text_for_strings, n=3)\noriginal_ngrams = collect(values(string_ngram_graph.vertex_labels))\nprintln(\"Original N-grams: $(length(original_ngrams)) 3-grams\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"String graphs are created by simplifying N-gram graphs (Path collapsing functionality may be work in progress)","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"try\n    collapsed_paths = Mycelia.collapse_unbranching_paths(string_ngram_graph)\n    println(\"Simplified paths: $(length(collapsed_paths)) paths\")\ncatch e\n    println(\"Path simplification: Work in progress - $(typeof(e))\")\nend","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Use cases","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"Use cases: Text compression, sequence simplification, path analysis\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"============================================================================= Tutorial 5: FASTA Graphs - Variable-Length BioSequence Analysis =============================================================================","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\n5. FASTA GRAPHS - Variable-Length BioSequence Analysis\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Example: Direct BioSequence graph construction","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"fasta_sequence = \"ATCGATCGATCGATCGTAGCTAGCTAGCTGCGCGCGC\"\nprintln(\"FASTA sequence: $fasta_sequence\")\n\nfasta_record = FASTX.FASTA.Record(\"sample\", fasta_sequence)\nfasta_records = [fasta_record]","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create BioSequence graph directly","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"bio_graph = Mycelia.build_biosequence_graph(fasta_records)\nbio_sequences = collect(values(bio_graph.vertex_labels))\nprintln(\"BioSequence graph: $(length(bio_sequences)) sequences\")\n\nif !isempty(bio_sequences)\n    first_seq = first(bio_sequences)\n    println(\"First sequence: $first_seq (length: $(length(first_seq)))\")\n    println(\"Sequence type: $(typeof(first_seq))\")\nend","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Example: K-mer to BioSequence conversion","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\\\nK-mer to BioSequence conversion:\")\nkmer_graph = Mycelia.build_kmer_graph_next(Mycelia.Kmers.DNAKmer{5}, fasta_records)\nbio_converted = Mycelia.kmer_graph_to_biosequence_graph(kmer_graph)\nconverted_sequences = collect(values(bio_converted.vertex_labels))\nprintln(\"Converted $(length(kmer_graph.vertex_labels)) k-mers to $(length(converted_sequences)) BioSequences\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Use cases","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"Use cases: Genome assembly, contig construction, sequence alignment\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"============================================================================= Tutorial 6: FASTQ Graphs - Quality-Aware BioSequence Analysis =============================================================================","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\n6. FASTQ GRAPHS - Quality-Aware BioSequence Analysis\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Example: Quality-aware BioSequence graph","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"fastq_sequence = \"ATCGATCGATCGATCGTAGCTAGCTAGCTGCGCGCGC\"\nfastq_quality = repeat(\"H\", length(fastq_sequence))  ## High quality\nprintln(\"FASTQ sequence: $fastq_sequence\")\nprintln(\"Quality string: $fastq_quality\")\n\nfastq_record = FASTX.FASTQ.Record(\"quality_sample\", fastq_sequence, fastq_quality)\nfastq_records = [fastq_record]","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create quality-aware BioSequence graph","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"quality_bio_graph = Mycelia.build_quality_biosequence_graph(fastq_records)\nquality_sequences = collect(values(quality_bio_graph.vertex_labels))\nprintln(\"Quality BioSequence graph: $(length(quality_sequences)) sequences\")\n\nif !isempty(quality_sequences)\n    first_quality_seq = first(quality_sequences)\n    quality_vertex_data = quality_bio_graph[first_quality_seq]\n    println(\"First sequence: $first_quality_seq\")\n    println(\"Quality scores: $(quality_vertex_data.quality_scores[1:min(10, length(quality_vertex_data.quality_scores))]...)\")\nend","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Example: Qualmer to quality BioSequence conversion","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\\\nQualmer to quality BioSequence conversion:\")\nqualmer_graph = Mycelia.build_qualmer_graph(fastq_records, k=5)\nquality_converted = Mycelia.qualmer_graph_to_quality_biosequence_graph(qualmer_graph)\nquality_converted_sequences = collect(values(quality_converted.vertex_labels))\nprintln(\"Converted $(length(qualmer_graph.vertex_labels)) qualmers to $(length(quality_converted_sequences)) quality BioSequences\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Use cases","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"Use cases: Quality-aware assembly, error correction, variant calling\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"============================================================================= Tutorial 7: Graph Type Hierarchy and Conversions =============================================================================","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\n7. GRAPH TYPE HIERARCHY AND CONVERSIONS\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Demonstrate the hierarchy: Fixed-length → Variable-length","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"sequence_for_hierarchy = \"ATCGATCGATCGATCGTAGCTAGCTAGCTGCGCGCGC\"\nrecords_for_hierarchy = [FASTX.FASTA.Record(\"hierarchy_demo\", sequence_for_hierarchy)]\nfastq_records_for_hierarchy = [FASTX.FASTQ.Record(\"hierarchy_demo\", sequence_for_hierarchy, repeat(\"H\", length(sequence_for_hierarchy)))]\n\nprintln(\"Original sequence: $sequence_for_hierarchy\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Fixed-length graphs","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"ngram_result = Mycelia.string_to_ngram_graph(s=sequence_for_hierarchy, n=3)\nkmer_result = Mycelia.build_kmer_graph_next(Mycelia.Kmers.DNAKmer{5}, records_for_hierarchy)\nqualmer_result = Mycelia.build_qualmer_graph(fastq_records_for_hierarchy, k=5)\n\nprintln(\"\\\\nFixed-length graphs:\")\nprintln(\"  N-grams (n=3): $(length(ngram_result.vertex_labels)) vertices\")\nprintln(\"  K-mers (k=5): $(length(kmer_result.vertex_labels)) vertices\")\nprintln(\"  Qualmers (k=5): $(length(qualmer_result.vertex_labels)) vertices\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Variable-length graphs","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"bio_result = Mycelia.build_biosequence_graph(records_for_hierarchy)\nquality_bio_result = Mycelia.build_quality_biosequence_graph(fastq_records_for_hierarchy)\n\nprintln(\"\\\\nVariable-length graphs:\")\nprintln(\"  BioSequences: $(length(bio_result.vertex_labels)) vertices\")\nprintln(\"  Quality BioSequences: $(length(quality_bio_result.vertex_labels)) vertices\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Conversions","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"kmer_to_bio = Mycelia.kmer_graph_to_biosequence_graph(kmer_result)\nqualmer_to_quality_bio = Mycelia.qualmer_graph_to_quality_biosequence_graph(qualmer_result)\n\nprintln(\"\\\\nConversions:\")\nprintln(\"  K-mer → BioSequence: $(length(kmer_result.vertex_labels)) → $(length(kmer_to_bio.vertex_labels))\")\nprintln(\"  Qualmer → Quality BioSequence: $(length(qualmer_result.vertex_labels)) → $(length(qualmer_to_quality_bio.vertex_labels))\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"============================================================================= Tutorial 8: Practical Assembly Workflow =============================================================================","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\n8. PRACTICAL ASSEMBLY WORKFLOW\")\nprintln(\"-\"^50)","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Simulate a realistic assembly scenario","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"simulated_reads = [\n    \"ATCGATCGATCGATCGTAGC\",\n    \"GATCGATCGATCGTAGCTAG\",\n    \"TCGATCGATCGTAGCTAGCT\",\n    \"GATCGATCGTAGCTAGCTGC\",\n    \"TCGATCGTAGCTAGCTGCGC\"\n]\n\nprintln(\"Simulated sequencing reads:\")\nfor (i, read) in enumerate(simulated_reads)\n    println(\"  Read $i: $read\")\nend","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Create records","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"fasta_reads = [FASTX.FASTA.Record(\"read_$i\", read) for (i, read) in enumerate(simulated_reads)]\nfastq_reads = [FASTX.FASTQ.Record(\"read_$i\", read, repeat(\"H\", length(read))) for (i, read) in enumerate(simulated_reads)]","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Method 1: K-mer graph assembly","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\\\nMethod 1: K-mer graph assembly\")\nassembly_kmer_graph = Mycelia.build_kmer_graph_next(Mycelia.Kmers.DNAKmer{5}, fasta_reads)\nassembly_kmers = collect(values(assembly_kmer_graph.vertex_labels))\nprintln(\"  K-mer graph: $(length(assembly_kmers)) unique k-mers\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Method 2: Quality-aware Qualmer assembly","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\\\nMethod 2: Quality-aware Qualmer assembly\")\nassembly_qualmer_graph = Mycelia.build_qualmer_graph(fastq_reads, k=5)\nassembly_qualmers = collect(values(assembly_qualmer_graph.vertex_labels))\nprintln(\"  Qualmer graph: $(length(assembly_qualmers)) unique qualmers\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Show quality information","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"if !isempty(assembly_qualmers)\n    first_qualmer = first(assembly_qualmers)\n    qualmer_vertex_data = assembly_qualmer_graph[first_qualmer]\n    println(\"  Quality example: $(first_qualmer) with joint prob = $(round(qualmer_vertex_data.joint_probability, digits=4))\")\nend","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"Method 3: BioSequence graph assembly","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\\\nMethod 3: BioSequence graph assembly\")\nassembly_bio_graph = Mycelia.build_biosequence_graph(fasta_reads)\nassembly_sequences = collect(values(assembly_bio_graph.vertex_labels))\nprintln(\"  BioSequence graph: $(length(assembly_sequences)) sequences\")\n\nprintln(\"\\\\nWorkflow summary:\")\nprintln(\"  1. Choose graph type based on data: FASTA → K-mer/BioSequence, FASTQ → Qualmer/Quality BioSequence\")\nprintln(\"  2. Consider quality: Use Qualmer graphs for quality-aware assembly\")\nprintln(\"  3. Use appropriate k-mer size: Smaller k for higher sensitivity, larger k for specificity\")\nprintln(\"  4. Convert between graph types as needed for different analysis steps\")","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"============================================================================= Summary =============================================================================","category":"page"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"-","title":"-","text":"println(\"\\n\" * \"=\"^80)\nprintln(\"TUTORIAL SUMMARY\")\nprintln(\"=\"^80)\nprintln(\"You've learned about all 6 graph types in Mycelia:\")\nprintln()\nprintln(\"FIXED-LENGTH GRAPHS (Assembly Foundation):\")\nprintln(\"  1. N-gram Graphs - Unicode text analysis\")\nprintln(\"  2. K-mer Graphs - DNA/RNA/protein sequence analysis\")\nprintln(\"  3. Qualmer Graphs - Quality-aware sequence analysis\")\nprintln()\nprintln(\"VARIABLE-LENGTH GRAPHS (Simplified Products):\")\nprintln(\"  4. String Graphs - Simplified N-gram analysis\")\nprintln(\"  5. FASTA Graphs - Variable-length BioSequence analysis\")\nprintln(\"  6. FASTQ Graphs - Quality-aware BioSequence analysis\")\nprintln()\nprintln(\"KEY FEATURES:\")\nprintln(\"  ✓ Type-stable implementation with storage parameters\")\nprintln(\"  ✓ Quality-aware assembly with per-base quality scores\")\nprintln(\"  ✓ Multi-alphabet support (DNA, RNA, amino acids)\")\nprintln(\"  ✓ Strand-aware graph construction\")\nprintln(\"  ✓ Graph type conversions and hierarchy\")\nprintln(\"  ✓ MetaGraphsNext.jl foundation for performance\")\nprintln()\nprintln(\"Choose the right graph type for your analysis:\")\nprintln(\"  - Use N-gram graphs for text analysis\")\nprintln(\"  - Use K-mer graphs for basic sequence analysis\")\nprintln(\"  - Use Qualmer graphs for quality-aware assembly\")\nprintln(\"  - Use BioSequence graphs for variable-length analysis\")\nprintln(\"  - Use Quality BioSequence graphs for quality-aware variable-length analysis\")\nprintln(\"=\"^80)","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Tutorial-6:-Gene-Annotation","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"This tutorial covers comprehensive gene annotation techniques, from basic gene prediction to functional annotation and annotation quality assessment.","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Learning-Objectives","page":"Tutorial 6: Gene Annotation","title":"Learning Objectives","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"By the end of this tutorial, you will understand:","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Different gene prediction approaches and their applications\nStructural annotation techniques for identifying genes and features\nFunctional annotation methods for assigning biological roles\nAnnotation quality assessment and validation\nComparative annotation approaches\nBest practices for different organism types","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Setup","page":"Tutorial 6: Gene Annotation","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"import Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\n\nRandom.seed!(42)","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Part-1:-Gene-Annotation-Overview","page":"Tutorial 6: Gene Annotation","title":"Part 1: Gene Annotation Overview","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Gene annotation is a multi-step process that identifies genes and assigns functional information to genomic sequences.","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"=== Gene Annotation Tutorial ===\")\n\nprintln(\"Annotation Pipeline Overview:\")\nprintln(\"1. Structural Annotation\")\nprintln(\"   - Gene prediction\")\nprintln(\"   - Exon-intron structure\")\nprintln(\"   - Regulatory elements\")\nprintln()\nprintln(\"2. Functional Annotation\")\nprintln(\"   - Protein function prediction\")\nprintln(\"   - Pathway assignment\")\nprintln(\"   - GO term annotation\")\nprintln()\nprintln(\"3. Comparative Annotation\")\nprintln(\"   - Ortholog identification\")\nprintln(\"   - Synteny analysis\")\nprintln(\"   - Evolutionary analysis\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Part-2:-Structural-Annotation","page":"Tutorial 6: Gene Annotation","title":"Part 2: Structural Annotation","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Structural annotation identifies the physical structure of genes and other functional elements.","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"\\n=== Structural Annotation ===\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Preparing-Test-Genome","page":"Tutorial 6: Gene Annotation","title":"Preparing Test Genome","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Create a test genome for annotation demonstration","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Preparing Test Genome ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Generate test genome with gene-like features","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"genome_size = 50000\ntest_genome = Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=genome_size)\ngenome_file = \"test_genome.fasta\"\nMycelia.write_fasta(outfile=genome_file, records=[test_genome])\n\nprintln(\"Test genome prepared: $(genome_size) bp\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Ab-Initio-Gene-Prediction","page":"Tutorial 6: Gene Annotation","title":"Ab Initio Gene Prediction","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Predict genes using sequence signals alone","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Ab Initio Gene Prediction ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement ab initio gene prediction","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Use Prodigal for prokaryotic genes\nIdentify start/stop codons\nPredict coding sequences\nHandle overlapping genes","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Simulate gene prediction results","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"predicted_genes = [\n    Dict(\"start\" => 1000, \"end\" => 2500, \"strand\" => \"+\", \"confidence\" => 0.95),\n    Dict(\"start\" => 3000, \"end\" => 4200, \"strand\" => \"-\", \"confidence\" => 0.88),\n    Dict(\"start\" => 5500, \"end\" => 7000, \"strand\" => \"+\", \"confidence\" => 0.92),\n    Dict(\"start\" => 8000, \"end\" => 9500, \"strand\" => \"+\", \"confidence\" => 0.85),\n    Dict(\"start\" => 10000, \"end\" => 11800, \"strand\" => \"-\", \"confidence\" => 0.90)\n]\n\nprintln(\"Ab Initio Gene Prediction Results:\")\nprintln(\"  Predicted genes: $(length(predicted_genes))\")\nprintln(\"  Mean confidence: $(round(Statistics.mean([g[\"confidence\"] for g in predicted_genes]), digits=3))\")\nprintln(\"  Coding density: $(round(sum([g[\"end\"] - g[\"start\"] + 1 for g in predicted_genes]) / genome_size * 100, digits=1))%\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Homology-Based-Gene-Prediction","page":"Tutorial 6: Gene Annotation","title":"Homology-Based Gene Prediction","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Use similarity to known genes for prediction","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Homology-Based Gene Prediction ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement homology-based prediction","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"BLAST against protein databases\nIdentify homologous sequences\nTransfer annotations from homologs\nHandle partial matches","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Simulate homology search results","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"homology_results = [\n    Dict(\"query\" => \"gene_1\", \"subject\" => \"protein_X\", \"identity\" => 85.2, \"coverage\" => 95.0),\n    Dict(\"query\" => \"gene_2\", \"subject\" => \"protein_Y\", \"identity\" => 78.9, \"coverage\" => 88.0),\n    Dict(\"query\" => \"gene_3\", \"subject\" => \"protein_Z\", \"identity\" => 92.1, \"coverage\" => 97.0),\n    Dict(\"query\" => \"gene_4\", \"subject\" => \"protein_W\", \"identity\" => 65.4, \"coverage\" => 82.0),\n    Dict(\"query\" => \"gene_5\", \"subject\" => \"protein_V\", \"identity\" => 88.7, \"coverage\" => 91.0)\n]\n\nprintln(\"Homology Search Results:\")\nfor result in homology_results\n    println(\"  $(result[\"query\"]) -> $(result[\"subject\"]): $(result[\"identity\"])% identity, $(result[\"coverage\"])% coverage\")\nend","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#RNA-seq-Guided-Prediction","page":"Tutorial 6: Gene Annotation","title":"RNA-seq Guided Prediction","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Use transcriptome data to improve gene prediction","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- RNA-seq Guided Prediction ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement RNA-seq guided prediction","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Map RNA-seq reads to genome\nIdentify transcribed regions\nPredict exon-intron structure\nHandle alternative splicing","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Regulatory-Element-Prediction","page":"Tutorial 6: Gene Annotation","title":"Regulatory Element Prediction","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Identify promoters, enhancers, and other regulatory sequences","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Regulatory Element Prediction ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement regulatory element prediction","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Promoter prediction\nTranscription factor binding sites\nCpG islands\nRepetitive elements","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Part-3:-Functional-Annotation","page":"Tutorial 6: Gene Annotation","title":"Part 3: Functional Annotation","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Functional annotation assigns biological roles to predicted genes","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"\\n=== Functional Annotation ===\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Protein-Function-Prediction","page":"Tutorial 6: Gene Annotation","title":"Protein Function Prediction","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Predict protein functions using various approaches","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Protein Function Prediction ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement protein function prediction","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Domain identification (Pfam, InterPro)\nEnzyme classification (EC numbers)\nPathway assignment (KEGG, MetaCyc)\nGO term annotation","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Simulate functional annotation results","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"functional_annotations = [\n    Dict(\"gene\" => \"gene_1\", \"function\" => \"DNA helicase\", \"ec\" => \"3.6.4.12\", \"confidence\" => 0.92),\n    Dict(\"gene\" => \"gene_2\", \"function\" => \"Transcriptional regulator\", \"ec\" => \"\", \"confidence\" => 0.78),\n    Dict(\"gene\" => \"gene_3\", \"function\" => \"Ribosomal protein L1\", \"ec\" => \"\", \"confidence\" => 0.95),\n    Dict(\"gene\" => \"gene_4\", \"function\" => \"Hypothetical protein\", \"ec\" => \"\", \"confidence\" => 0.45),\n    Dict(\"gene\" => \"gene_5\", \"function\" => \"ATP synthase subunit\", \"ec\" => \"3.6.3.14\", \"confidence\" => 0.88)\n]\n\nprintln(\"Functional Annotation Results:\")\nfor annot in functional_annotations\n    ec_str = annot[\"ec\"] != \"\" ? \" (EC: $(annot[\"ec\"]))\" : \"\"\n    println(\"  $(annot[\"gene\"]): $(annot[\"function\"])$ec_str [$(annot[\"confidence\"])]\")\nend","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Database-Annotation","page":"Tutorial 6: Gene Annotation","title":"Database Annotation","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Annotate genes using specialized databases","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Database Annotation ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement database annotation","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"BLAST against Swiss-Prot\nSearch COG database\nQuery KEGG pathways\nCheck specialized databases","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Gene-Ontology-Annotation","page":"Tutorial 6: Gene Annotation","title":"Gene Ontology Annotation","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Assign GO terms for standardized functional description","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Gene Ontology Annotation ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement GO annotation","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Assign GO terms\nValidate GO term relationships\nCalculate GO term confidence\nGenerate GO term summaries","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Simulate GO annotation results","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"go_annotations = [\n    Dict(\"gene\" => \"gene_1\", \"go_terms\" => [\"GO:0003678\", \"GO:0006310\"], \"aspect\" => [\"MF\", \"BP\"]),\n    Dict(\"gene\" => \"gene_2\", \"go_terms\" => [\"GO:0003677\", \"GO:0006355\"], \"aspect\" => [\"MF\", \"BP\"]),\n    Dict(\"gene\" => \"gene_3\", \"go_terms\" => [\"GO:0003735\", \"GO:0006412\"], \"aspect\" => [\"MF\", \"BP\"]),\n    Dict(\"gene\" => \"gene_4\", \"go_terms\" => [], \"aspect\" => []),\n    Dict(\"gene\" => \"gene_5\", \"go_terms\" => [\"GO:0046933\", \"GO:0015986\"], \"aspect\" => [\"MF\", \"BP\"])\n]\n\nprintln(\"GO Annotation Results:\")\nfor annot in go_annotations\n    if !isempty(annot[\"go_terms\"])\n        println(\"  $(annot[\"gene\"]): $(join(annot[\"go_terms\"], \", \"))\")\n    else\n        println(\"  $(annot[\"gene\"]): No GO terms assigned\")\n    end\nend","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Part-4:-Annotation-Quality-Assessment","page":"Tutorial 6: Gene Annotation","title":"Part 4: Annotation Quality Assessment","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Evaluate the quality and completeness of annotations","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"\\n=== Annotation Quality Assessment ===\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Annotation-Completeness","page":"Tutorial 6: Gene Annotation","title":"Annotation Completeness","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Assess what fraction of genes have functional annotations","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Annotation Completeness ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Calculate annotation statistics","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"total_genes = length(predicted_genes)\nfunctionally_annotated = sum([annot[\"function\"] != \"Hypothetical protein\" for annot in functional_annotations])\nec_annotated = sum([annot[\"ec\"] != \"\" for annot in functional_annotations])\ngo_annotated = sum([!isempty(annot[\"go_terms\"]) for annot in go_annotations])\n\nannotation_stats = Dict(\n    \"total_genes\" => total_genes,\n    \"functionally_annotated\" => functionally_annotated,\n    \"ec_annotated\" => ec_annotated,\n    \"go_annotated\" => go_annotated,\n    \"functional_coverage\" => functionally_annotated / total_genes * 100,\n    \"ec_coverage\" => ec_annotated / total_genes * 100,\n    \"go_coverage\" => go_annotated / total_genes * 100\n)\n\nprintln(\"Annotation Completeness:\")\nfor (metric, value) in annotation_stats\n    println(\"  $metric: $value\")\nend","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Annotation-Consistency","page":"Tutorial 6: Gene Annotation","title":"Annotation Consistency","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Check for consistency between different annotation methods","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Annotation Consistency ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement annotation consistency checks","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Compare ab initio vs homology predictions\nValidate functional annotations\nCheck for conflicting annotations\nAssess annotation confidence","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Annotation-Validation","page":"Tutorial 6: Gene Annotation","title":"Annotation Validation","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Validate annotations using external evidence","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Annotation Validation ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement annotation validation","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Cross-reference with literature\nValidate with experimental data\nCheck annotation standards compliance\nAssess annotation quality scores","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Part-5:-Comparative-Annotation","page":"Tutorial 6: Gene Annotation","title":"Part 5: Comparative Annotation","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Use comparative genomics to improve annotation quality","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"\\n=== Comparative Annotation ===\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Ortholog-Identification","page":"Tutorial 6: Gene Annotation","title":"Ortholog Identification","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Identify corresponding genes in related species","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Ortholog Identification ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement ortholog identification","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Bidirectional best hits\nOrtholog clustering\nPhylogenetic analysis\nSynteny-based validation","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Synteny-Analysis","page":"Tutorial 6: Gene Annotation","title":"Synteny Analysis","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Analyze conserved gene order for annotation validation","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Synteny Analysis ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement synteny analysis","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Identify syntenic blocks\nValidate gene annotations\nDetect gene duplications\nAnalyze evolutionary events","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Evolutionary-Analysis","page":"Tutorial 6: Gene Annotation","title":"Evolutionary Analysis","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Analyze gene evolution patterns","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Evolutionary Analysis ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement evolutionary analysis","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Selection pressure analysis\nGene family evolution\nHorizontal gene transfer detection\nPseudogene identification","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Part-6:-Specialized-Annotation-Types","page":"Tutorial 6: Gene Annotation","title":"Part 6: Specialized Annotation Types","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Handle organism-specific annotation challenges","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"\\n=== Specialized Annotation ===\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Prokaryotic-Annotation","page":"Tutorial 6: Gene Annotation","title":"Prokaryotic Annotation","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Features specific to bacterial and archaeal genomes","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Prokaryotic Annotation ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement prokaryotic-specific annotation","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Operon prediction\nSigma factor binding sites\nRibosome binding sites\nCRISPR arrays","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"prokaryotic_features = Dict(\n    \"operons\" => 3,\n    \"sigma_sites\" => 12,\n    \"ribosome_binding_sites\" => 5,\n    \"crispr_arrays\" => 1\n)\n\nprintln(\"Prokaryotic Features:\")\nfor (feature, count) in prokaryotic_features\n    println(\"  $feature: $count\")\nend","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Eukaryotic-Annotation","page":"Tutorial 6: Gene Annotation","title":"Eukaryotic Annotation","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Features specific to eukaryotic genomes","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Eukaryotic Annotation ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement eukaryotic-specific annotation","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Intron-exon structure\nAlternative splicing\nPseudogenes\nNon-coding RNAs","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Viral-Annotation","page":"Tutorial 6: Gene Annotation","title":"Viral Annotation","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Features specific to viral genomes","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Viral Annotation ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement viral-specific annotation","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Overlapping genes\nFrameshift elements\nRegulatory sequences\nHost interaction factors","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Part-7:-Annotation-Visualization","page":"Tutorial 6: Gene Annotation","title":"Part 7: Annotation Visualization","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Create visualizations for annotation results","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"\\n=== Annotation Visualization ===\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Genome-Browser-Tracks","page":"Tutorial 6: Gene Annotation","title":"Genome Browser Tracks","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Generate tracks for genome browsers","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Genome Browser Tracks ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement genome browser track generation","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Gene structure tracks\nFunctional annotation tracks\nComparative annotation tracks\nQuality assessment tracks","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Annotation-Summary-Plots","page":"Tutorial 6: Gene Annotation","title":"Annotation Summary Plots","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Create summary visualizations","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Annotation Summary Plots ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement annotation visualization","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Functional category pie charts\nAnnotation quality histograms\nComparative annotation plots\nPathway enrichment plots","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Part-8:-Annotation-File-Formats","page":"Tutorial 6: Gene Annotation","title":"Part 8: Annotation File Formats","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Work with standard annotation file formats","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"\\n=== Annotation File Formats ===\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#GFF3-Format","page":"Tutorial 6: Gene Annotation","title":"GFF3 Format","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Generate and manipulate GFF3 files","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- GFF3 Format ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement GFF3 handling","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Generate GFF3 from predictions\nValidate GFF3 format\nConvert between formats\nMerge annotation files","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Generate example GFF3 content","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"gff3_content = \"\"\"\n##gff-version 3\n##sequence-region test_genome 1 50000\ntest_genome\\tprodigal\\tgene\\t1000\\t2500\\t0.95\\t+\\t.\\tID=gene_1;Name=gene_1\ntest_genome\\tprodigal\\tCDS\\t1000\\t2500\\t0.95\\t+\\t0\\tID=cds_1;Parent=gene_1\ntest_genome\\tprodigal\\tgene\\t3000\\t4200\\t0.88\\t-\\t.\\tID=gene_2;Name=gene_2\ntest_genome\\tprodigal\\tCDS\\t3000\\t4200\\t0.88\\t-\\t0\\tID=cds_2;Parent=gene_2\n\"\"\"\n\ngff3_file = \"annotations.gff3\"\nopen(gff3_file, \"w\") do io\n    write(io, gff3_content)\nend\n\nprintln(\"GFF3 file generated: $gff3_file\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#GenBank-Format","page":"Tutorial 6: Gene Annotation","title":"GenBank Format","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Generate GenBank format files","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- GenBank Format ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement GenBank format handling","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Generate GenBank files\nInclude sequence and annotations\nValidate format compliance\nExtract annotations from GenBank","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Part-9:-Annotation-Pipelines","page":"Tutorial 6: Gene Annotation","title":"Part 9: Annotation Pipelines","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Integrate annotation steps into comprehensive pipelines","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"\\n=== Annotation Pipelines ===\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Automated-Annotation-Pipeline","page":"Tutorial 6: Gene Annotation","title":"Automated Annotation Pipeline","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Create automated annotation workflows","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Automated Pipeline ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement automated annotation pipeline","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Combine multiple prediction methods\nAutomated quality control\nStandardized output formats\nBatch processing capabilities","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Manual-Curation-Interface","page":"Tutorial 6: Gene Annotation","title":"Manual Curation Interface","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Tools for manual annotation improvement","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"--- Manual Curation ---\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"TODO: Implement manual curation tools","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Interactive annotation editor\nEvidence integration interface\nCollaborative annotation platform\nVersion control for annotations","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Part-10:-Best-Practices-and-Guidelines","page":"Tutorial 6: Gene Annotation","title":"Part 10: Best Practices and Guidelines","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Recommendations for high-quality annotation","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"\\n=== Annotation Best Practices ===\")\n\nprintln(\"General Principles:\")\nprintln(\"- Use multiple complementary approaches\")\nprintln(\"- Validate predictions with experimental data\")\nprintln(\"- Maintain annotation standards compliance\")\nprintln(\"- Document annotation procedures and evidence\")\nprintln()\nprintln(\"Quality Thresholds:\")\nprintln(\"- Functional annotation: >80% of genes\")\nprintln(\"- Homology confidence: >70% identity, >80% coverage\")\nprintln(\"- GO term coverage: >60% of genes\")\nprintln(\"- Manual validation: High-confidence predictions\")\nprintln()\nprintln(\"Organism-Specific Considerations:\")\nprintln(\"- Prokaryotes: Focus on operons and regulation\")\nprintln(\"- Eukaryotes: Handle alternative splicing carefully\")\nprintln(\"- Viruses: Account for overlapping genes\")\nprintln(\"- Metagenomes: Use taxonomic context\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/#Summary","page":"Tutorial 6: Gene Annotation","title":"Summary","text":"","category":"section"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"println(\"\\n=== Gene Annotation Summary ===\")\nprintln(\"✓ Understanding structural and functional annotation approaches\")\nprintln(\"✓ Implementing ab initio and homology-based gene prediction\")\nprintln(\"✓ Assigning functional annotations and GO terms\")\nprintln(\"✓ Evaluating annotation quality and completeness\")\nprintln(\"✓ Applying comparative annotation techniques\")\nprintln(\"✓ Handling organism-specific annotation challenges\")\nprintln(\"✓ Working with standard annotation file formats\")\nprintln(\"✓ Creating comprehensive annotation pipelines\")","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"Cleanup","category":"page"},{"location":"generated/tutorials/06_gene_annotation/","page":"Tutorial 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"cleanup_files = [genome_file, gff3_file]\nfor file in cleanup_files\n    if isfile(file)\n        rm(file, force=true)\n    end\nend\n\nprintln(\"\\nNext: Tutorial 7 - Comparative Genomics\")\n\nnothing","category":"page"},{"location":"api/examples/basic-workflows/#Basic-Workflows","page":"Basic Workflows","title":"Basic Workflows","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"Complete examples of common bioinformatics analysis workflows using Mycelia functions. These examples show how to combine functions from different modules to accomplish typical research tasks.","category":"page"},{"location":"api/examples/basic-workflows/#Overview","page":"Basic Workflows","title":"Overview","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"These workflows demonstrate:","category":"page"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"Complete analysis pipelines from start to finish\nFunction integration across different modules\nParameter selection for common use cases\nError handling and quality control\nResult interpretation and next steps","category":"page"},{"location":"api/examples/basic-workflows/#Workflow-1:-Bacterial-Genome-Assembly","page":"Basic Workflows","title":"Workflow 1: Bacterial Genome Assembly","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"Complete bacterial genome analysis from raw reads to annotated assembly.","category":"page"},{"location":"api/examples/basic-workflows/#Step-1:-Data-Acquisition","page":"Basic Workflows","title":"Step 1: Data Acquisition","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"import Mycelia\n\n# Download reference genome for comparison\nreference = Mycelia.download_genome_by_accession(\"NC_000913.3\")  # E. coli K-12\n\n# Or use your own sequencing data\nreads_file = \"bacterial_reads.fastq\"","category":"page"},{"location":"api/examples/basic-workflows/#Step-2:-Quality-Control","page":"Basic Workflows","title":"Step 2: Quality Control","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"# Assess initial data quality\nprintln(\"=== Initial Quality Assessment ===\")\ninitial_quality = Mycelia.analyze_fastq_quality(reads_file)\nprintln(\"Total reads: $(initial_quality.n_reads)\")\nprintln(\"Mean quality: $(initial_quality.mean_quality)\")\nprintln(\"Mean length: $(initial_quality.mean_length)\")\n\n# Filter low-quality reads\nprintln(\"\\n=== Quality Filtering ===\")\nfiltered_reads = Mycelia.filter_by_quality(\n    reads_file,\n    min_quality=25,      # Q25 threshold\n    min_length=1000,     # Minimum 1kb reads\n    max_n_percent=5      # Maximum 5% N's\n)\n\nMycelia.write_fastq(\"filtered_reads.fastq\", filtered_reads)\nprintln(\"Filtered reads: $(length(filtered_reads))\")","category":"page"},{"location":"api/examples/basic-workflows/#Step-3:-K-mer-Analysis","page":"Basic Workflows","title":"Step 3: K-mer Analysis","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== K-mer Analysis ===\")\n# Count k-mers for genome size estimation\nkmer_counts = Mycelia.count_kmers(\"filtered_reads.fastq\", k=21)\nspectrum = Mycelia.kmer_frequency_spectrum(kmer_counts)\n\n# Estimate genome size\ngenome_size = Mycelia.estimate_genome_size_from_kmers(kmer_counts)\nprintln(\"Estimated genome size: $(genome_size.size) bp\")\nprintln(\"Estimated coverage: $(genome_size.coverage)x\")\n\n# Plot k-mer spectrum\nMycelia.plot_kmer_spectrum(spectrum, title=\"21-mer Frequency Spectrum\")","category":"page"},{"location":"api/examples/basic-workflows/#Step-4:-Genome-Assembly","page":"Basic Workflows","title":"Step 4: Genome Assembly","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== Genome Assembly ===\")\n# Assemble genome using hifiasm (for HiFi reads) or adjust for your data type\nassembly_result = Mycelia.assemble_genome(\n    \"filtered_reads.fastq\",\n    assembler=\"hifiasm\",     # Use \"spades\" for Illumina\n    output_dir=\"assembly\",\n    threads=8,\n    min_contig_length=500\n)\n\nprintln(\"Assembly completed: $(assembly_result.contigs)\")","category":"page"},{"location":"api/examples/basic-workflows/#Step-5:-Assembly-Validation","page":"Basic Workflows","title":"Step 5: Assembly Validation","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== Assembly Validation ===\")\n# Calculate assembly statistics\nassembly_stats = Mycelia.calculate_assembly_stats(assembly_result.contigs)\nprintln(\"Assembly Statistics:\")\nprintln(\"  Contigs: $(assembly_stats.n_contigs)\")\nprintln(\"  Total length: $(assembly_stats.total_length) bp\")\nprintln(\"  N50: $(assembly_stats.n50)\")\nprintln(\"  Largest contig: $(assembly_stats.largest_contig)\")\n\n# Validate assembly quality\nvalidation_result = Mycelia.validate_assembly(\n    assembly_result.contigs,\n    \"filtered_reads.fastq\",\n    reference_genome=reference\n)\n\nprintln(\"Assembly Quality:\")\nprintln(\"  Completeness: $(validation_result.completeness)%\")\nprintln(\"  Accuracy: $(validation_result.accuracy)%\")","category":"page"},{"location":"api/examples/basic-workflows/#Step-6:-Gene-Annotation","page":"Basic Workflows","title":"Step 6: Gene Annotation","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== Gene Annotation ===\")\n# Predict genes\npredicted_genes = Mycelia.predict_genes(\n    assembly_result.contigs,\n    method=\"prodigal\",\n    genetic_code=\"standard\"\n)\n\nprintln(\"Predicted genes: $(length(predicted_genes))\")\n\n# Functional annotation\nfunctional_annotations = Mycelia.annotate_functions(\n    predicted_genes,\n    database=\"uniprot\",\n    evalue_threshold=1e-5\n)\n\nprintln(\"Functionally annotated genes: $(Mycelia.count_annotated(functional_annotations)))\")\n\n# Save annotations\nMycelia.write_gff3(\"bacterial_genome.gff3\", predicted_genes, functional_annotations)","category":"page"},{"location":"api/examples/basic-workflows/#Step-7:-Results-Summary","page":"Basic Workflows","title":"Step 7: Results Summary","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== Analysis Summary ===\")\nprintln(\"Workflow completed successfully!\")\nprintln(\"Files generated:\")\nprintln(\"  - filtered_reads.fastq: Quality-controlled reads\")\nprintln(\"  - assembly/contigs.fasta: Assembled genome\")\nprintln(\"  - bacterial_genome.gff3: Gene annotations\")\nprintln(\"  - assembly_stats.json: Assembly statistics\")","category":"page"},{"location":"api/examples/basic-workflows/#Workflow-2:-Comparative-Genomics-Analysis","page":"Basic Workflows","title":"Workflow 2: Comparative Genomics Analysis","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"Compare multiple bacterial genomes to build a pangenome and phylogenetic tree.","category":"page"},{"location":"api/examples/basic-workflows/#Step-1:-Data-Preparation","page":"Basic Workflows","title":"Step 1: Data Preparation","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"# Download multiple related genomes\nspecies_genomes = [\n    \"GCF_000005825.2\",  # E. coli K-12 MG1655\n    \"GCF_000009605.1\",  # Salmonella enterica\n    \"GCF_000027325.1\",  # Yersinia pestis\n    \"GCF_000006945.2\",  # Shigella flexneri\n]\n\nprintln(\"=== Downloading Genomes ===\")\ngenome_files = []\nfor accession in species_genomes\n    result = Mycelia.ncbi_genome_download_accession(accession)\n    push!(genome_files, result.genome)\n    println(\"Downloaded: $accession\")\nend","category":"page"},{"location":"api/examples/basic-workflows/#Step-2:-Gene-Prediction","page":"Basic Workflows","title":"Step 2: Gene Prediction","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== Gene Prediction ===\")\nall_genes = []\nfor (i, genome_file) in enumerate(genome_files)\n    genes = Mycelia.predict_genes(genome_file, method=\"prodigal\")\n    push!(all_genes, genes)\n    println(\"Genome $i: $(length(genes)) genes predicted\")\nend","category":"page"},{"location":"api/examples/basic-workflows/#Step-3:-Pangenome-Construction","page":"Basic Workflows","title":"Step 3: Pangenome Construction","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== Pangenome Construction ===\")\n# Build pangenome from all genomes\npangenome = Mycelia.build_pangenome(\n    all_genes,\n    similarity_threshold=0.9,\n    coverage_threshold=0.8\n)\n\nprintln(\"Pangenome Statistics:\")\nprintln(\"  Core genes: $(pangenome.core_genes)\")\nprintln(\"  Accessory genes: $(pangenome.accessory_genes)\")\nprintln(\"  Unique genes: $(pangenome.unique_genes)\")\nprintln(\"  Total gene families: $(pangenome.total_families)\")\n\n# Visualize pangenome\nMycelia.plot_pangenome_heatmap(pangenome, title=\"Gene Presence/Absence Matrix\")","category":"page"},{"location":"api/examples/basic-workflows/#Step-4:-Phylogenetic-Analysis","page":"Basic Workflows","title":"Step 4: Phylogenetic Analysis","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== Phylogenetic Analysis ===\")\n# Extract core genes for phylogeny\ncore_gene_alignments = Mycelia.extract_core_gene_alignments(pangenome)\n\n# Build phylogenetic tree\nphylo_tree = Mycelia.build_phylogenetic_tree(\n    core_gene_alignments,\n    method=\"ml\",\n    model=\"GTR+G\",\n    bootstrap=100\n)\n\nprintln(\"Phylogenetic tree constructed with $(Mycelia.get_bootstrap_support(phylo_tree)) average support\")\n\n# Visualize tree\nMycelia.plot_phylogenetic_tree(phylo_tree, layout=\"rectangular\", show_support=true)","category":"page"},{"location":"api/examples/basic-workflows/#Step-5:-Functional-Analysis","page":"Basic Workflows","title":"Step 5: Functional Analysis","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== Functional Analysis ===\")\n# Analyze functional categories\nfunctional_analysis = Mycelia.analyze_pangenome_functions(pangenome)\n\nprintln(\"Functional Distribution:\")\nfor (category, count) in functional_analysis.categories\n    println(\"  $category: $count genes\")\nend\n\n# Identify core vs accessory functional differences\nfunctional_comparison = Mycelia.compare_core_accessory_functions(pangenome)","category":"page"},{"location":"api/examples/basic-workflows/#Workflow-3:-Quality-Control-Pipeline","page":"Basic Workflows","title":"Workflow 3: Quality Control Pipeline","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"Comprehensive quality control workflow for different sequencing platforms.","category":"page"},{"location":"api/examples/basic-workflows/#HiFi-Sequencing-Data","page":"Basic Workflows","title":"HiFi Sequencing Data","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"=== HiFi Quality Control ===\")\n\n# HiFi-specific quality assessment\nhifi_quality = Mycelia.assess_hifi_quality(\"hifi_reads.fastq\")\nprintln(\"HiFi Quality Metrics:\")\nprintln(\"  Mean accuracy: $(hifi_quality.mean_accuracy)\")\nprintln(\"  Mean length: $(hifi_quality.mean_length)\")\nprintln(\"  Length N50: $(hifi_quality.length_n50)\")\n\n# HiFi-optimized filtering\nhifi_filtered = Mycelia.filter_hifi_reads(\n    \"hifi_reads.fastq\",\n    min_accuracy=0.99,\n    min_length=5000,\n    max_length=30000\n)\n\nprintln(\"HiFi reads after filtering: $(length(hifi_filtered))\")","category":"page"},{"location":"api/examples/basic-workflows/#Illumina-Sequencing-Data","page":"Basic Workflows","title":"Illumina Sequencing Data","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== Illumina Quality Control ===\")\n\n# Paired-end Illumina data\nillumina_quality = Mycelia.assess_illumina_quality(\"illumina_R1.fastq\", \"illumina_R2.fastq\")\n\n# Remove adapters and low-quality bases\ncleaned_reads = Mycelia.preprocess_illumina_reads(\n    \"illumina_R1.fastq\", \"illumina_R2.fastq\",\n    adapter_removal=true,\n    quality_trimming=true,\n    min_quality=20,\n    min_length=50\n)\n\nMycelia.write_fastq(\"illumina_R1_clean.fastq\", cleaned_reads.read1)\nMycelia.write_fastq(\"illumina_R2_clean.fastq\", cleaned_reads.read2)","category":"page"},{"location":"api/examples/basic-workflows/#Nanopore-Sequencing-Data","page":"Basic Workflows","title":"Nanopore Sequencing Data","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== Nanopore Quality Control ===\")\n\n# Nanopore-specific assessment\nnanopore_quality = Mycelia.assess_nanopore_quality(\"nanopore_reads.fastq\")\n\n# Filter based on quality and length\nnanopore_filtered = Mycelia.filter_nanopore_reads(\n    \"nanopore_reads.fastq\",\n    min_quality=7,       # Lower threshold for Nanopore\n    min_length=500,\n    max_length=100000\n)","category":"page"},{"location":"api/examples/basic-workflows/#Workflow-4:-Assembly-Optimization","page":"Basic Workflows","title":"Workflow 4: Assembly Optimization","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"Optimize assembly parameters for best results.","category":"page"},{"location":"api/examples/basic-workflows/#Parameter-Testing","page":"Basic Workflows","title":"Parameter Testing","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"=== Assembly Parameter Optimization ===\")\n\n# Test different k-mer sizes\nk_values = [19, 21, 25, 31, 35]\nassembly_results = []\n\nfor k in k_values\n    println(\"Testing k=$k...\")\n    result = Mycelia.assemble_genome(\n        \"reads.fastq\",\n        assembler=\"hifiasm\",\n        k=k,\n        output_dir=\"assembly_k$k\"\n    )\n    \n    stats = Mycelia.calculate_assembly_stats(result.contigs)\n    push!(assembly_results, (k=k, n50=stats.n50, contigs=stats.n_contigs))\nend\n\n# Find optimal k-mer size\noptimal_k = Mycelia.find_optimal_assembly_parameters(assembly_results)\nprintln(\"Optimal k-mer size: $(optimal_k.k)\")","category":"page"},{"location":"api/examples/basic-workflows/#Multi-Assembler-Comparison","page":"Basic Workflows","title":"Multi-Assembler Comparison","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"\\n=== Multi-Assembler Comparison ===\")\n\nassemblers = [\"hifiasm\", \"canu\", \"flye\"]\nassembler_results = []\n\nfor assembler in assemblers\n    println(\"Running $assembler...\")\n    result = Mycelia.assemble_genome(\n        \"reads.fastq\",\n        assembler=assembler,\n        output_dir=\"assembly_$assembler\"\n    )\n    \n    validation = Mycelia.validate_assembly(result.contigs, \"reads.fastq\")\n    push!(assembler_results, (\n        assembler=assembler,\n        n50=validation.n50,\n        completeness=validation.completeness\n    ))\nend\n\n# Select best assembler\nbest_assembler = Mycelia.select_best_assembly(assembler_results)\nprintln(\"Best assembler: $(best_assembler.assembler)\")","category":"page"},{"location":"api/examples/basic-workflows/#Workflow-5:-Contamination-Detection-and-Removal","page":"Basic Workflows","title":"Workflow 5: Contamination Detection and Removal","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"Comprehensive contamination screening and removal pipeline.","category":"page"},{"location":"api/examples/basic-workflows/#Multi-Source-Contamination-Screening","page":"Basic Workflows","title":"Multi-Source Contamination Screening","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"println(\"=== Contamination Screening ===\")\n\n# Screen for multiple contamination sources\ncontamination_results = Mycelia.screen_all_contamination(\n    \"reads.fastq\",\n    host_genome=\"human_genome.fasta\",\n    vector_db=\"vector_database.fasta\",\n    adapter_db=\"adapter_sequences.fasta\"\n)\n\nprintln(\"Contamination Summary:\")\nprintln(\"  Host contamination: $(contamination_results.host_rate)%\")\nprintln(\"  Vector contamination: $(contamination_results.vector_rate)%\")\nprintln(\"  Adapter contamination: $(contamination_results.adapter_rate)%\")\n\n# Remove all contamination\nclean_reads = Mycelia.remove_all_contamination(\n    \"reads.fastq\",\n    contamination_results\n)\n\nMycelia.write_fastq(\"decontaminated_reads.fastq\", clean_reads)","category":"page"},{"location":"api/examples/basic-workflows/#Error-Handling-and-Robustness","page":"Basic Workflows","title":"Error Handling and Robustness","text":"","category":"section"},{"location":"api/examples/basic-workflows/#Robust-Pipeline-with-Error-Handling","page":"Basic Workflows","title":"Robust Pipeline with Error Handling","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"function robust_genome_analysis(reads_file::String)\n    try\n        # Quality control with validation\n        if !isfile(reads_file)\n            error(\"Input file not found: $reads_file\")\n        end\n        \n        quality_data = Mycelia.analyze_fastq_quality(reads_file)\n        if quality_data.mean_quality < 15\n            @warn \"Low quality data detected (Q$(quality_data.mean_quality))\"\n        end\n        \n        # Assembly with retry logic\n        assembly_result = nothing\n        for attempt in 1:3\n            try\n                assembly_result = Mycelia.assemble_genome(reads_file)\n                break\n            catch e\n                @warn \"Assembly attempt $attempt failed: $e\"\n                if attempt == 3\n                    rethrow(e)\n                end\n            end\n        end\n        \n        # Validation with quality checks\n        validation = Mycelia.validate_assembly(assembly_result.contigs, reads_file)\n        if validation.completeness < 90\n            @warn \"Low assembly completeness: $(validation.completeness)%\"\n        end\n        \n        return assembly_result\n        \n    catch e\n        @error \"Analysis failed\" exception=(e, catch_backtrace())\n        return nothing\n    end\nend","category":"page"},{"location":"api/examples/basic-workflows/#Performance-Optimization","page":"Basic Workflows","title":"Performance Optimization","text":"","category":"section"},{"location":"api/examples/basic-workflows/#Memory-Efficient-Large-File-Processing","page":"Basic Workflows","title":"Memory-Efficient Large File Processing","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"function process_large_dataset(large_file::String)\n    # Check available memory\n    available_memory = Mycelia.get_available_memory_gb()\n    if available_memory < 8\n        @warn \"Limited memory available: $(available_memory)GB\"\n    end\n    \n    # Use streaming for large files\n    file_size_gb = filesize(large_file) / 1024^3\n    if file_size_gb > available_memory / 2\n        println(\"Using streaming processing for $(file_size_gb)GB file\")\n        return Mycelia.stream_kmer_counting(large_file, k=21, chunk_size=50000)\n    else\n        return Mycelia.count_kmers(large_file, k=21)\n    end\nend","category":"page"},{"location":"api/examples/basic-workflows/#Next-Steps","page":"Basic Workflows","title":"Next Steps","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"After completing these basic workflows, you can:","category":"page"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"Explore advanced techniques in Advanced Usage\nCustomize parameters using the Parameter Guide\nIntegrate external tools following Tool Integration (planned)\nScale to HPC systems with Deployment Guide","category":"page"},{"location":"api/examples/basic-workflows/#See-Also","page":"Basic Workflows","title":"See Also","text":"","category":"section"},{"location":"api/examples/basic-workflows/","page":"Basic Workflows","title":"Basic Workflows","text":"Function Index - Complete function reference\nWorkflow-Specific Guides - Detailed workflow documentation\nTutorials - Step-by-step learning materials\nTroubleshooting Guide - Common issues and solutions","category":"page"},{"location":"api/workflows/sequence-analysis/#Sequence-Analysis-and-K-mers","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"Functions for analyzing sequence composition, counting k-mers, and extracting genomic features from sequencing data.","category":"page"},{"location":"api/workflows/sequence-analysis/#Overview","page":"Sequence Analysis & K-mers","title":"Overview","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"Sequence analysis forms the foundation of many bioinformatics algorithms. Mycelia provides comprehensive tools for:","category":"page"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"K-mer counting and analysis using efficient algorithms\nGenome size estimation from k-mer frequency spectra\nError detection and correction using k-mer patterns\nSequence composition analysis and bias detection\nMemory-efficient processing of large datasets","category":"page"},{"location":"api/workflows/sequence-analysis/#Common-Workflows","page":"Sequence Analysis & K-mers","title":"Common Workflows","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#1.-Basic-K-mer-Analysis","page":"Sequence Analysis & K-mers","title":"1. Basic K-mer Analysis","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Count k-mers in sequencing reads\nkmer_counts = Mycelia.count_kmers(\"reads.fastq\", k=21)\n\n# Analyze k-mer frequency spectrum\nspectrum = Mycelia.kmer_frequency_spectrum(kmer_counts)","category":"page"},{"location":"api/workflows/sequence-analysis/#2.-Genome-Size-Estimation","page":"Sequence Analysis & K-mers","title":"2. Genome Size Estimation","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Estimate genome size from k-mer spectrum\ngenome_size = Mycelia.estimate_genome_size_from_kmers(kmer_counts, coverage_peak=30)","category":"page"},{"location":"api/workflows/sequence-analysis/#3.-Contamination-Detection","page":"Sequence Analysis & K-mers","title":"3. Contamination Detection","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Detect contamination using k-mer profiles\ncontamination = Mycelia.detect_contamination_kmers(\"reads.fastq\", expected_profile)","category":"page"},{"location":"api/workflows/sequence-analysis/#K-mer-Counting","page":"Sequence Analysis & K-mers","title":"K-mer Counting","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#Basic-K-mer-Counting","page":"Sequence Analysis & K-mers","title":"Basic K-mer Counting","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#Mycelia.count_kmers","page":"Sequence Analysis & K-mers","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.DNAAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> Any\n\n\nCount the frequency of each k-mer in a DNA sequence.\n\nArguments\n\n::Type{Kmers.Kmer{A,K}}: K-mer type with alphabet A and length K\nsequence::BioSequences.LongSequence: Input DNA sequence to analyze\n\nReturns\n\nA sorted dictionary mapping each k-mer to its frequency count in the sequence.\n\nType Parameters\n\nA <: BioSequences.DNAAlphabet: DNA alphabet type\nK: Length of k-mers\n\n\n\n\n\ncount_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.RNAAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> Any\n\n\nCount the frequency of each k-mer in an RNA sequence.\n\nArguments\n\nKmer: Type parameter specifying the k-mer length K and RNA alphabet\nsequence: Input RNA sequence to analyze\n\nReturns\n\nDict{Kmers.Kmer, Int}: Sorted dictionary mapping each k-mer to its frequency count\n\n\n\n\n\ncount_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.AminoAcidAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> OrderedCollections.OrderedDict{K, Int64} where K<:(Kmers.Kmer{BioSequences.AminoAcidAlphabet, _A, _B} where {_B, _A})\n\n\nCount the frequency of amino acid k-mers in a biological sequence.\n\nArguments\n\nKmers.Kmer{A,K}: Type parameter specifying amino acid alphabet (A) and k-mer length (K)\nsequence: Input biological sequence to analyze\n\nReturns\n\nA sorted dictionary mapping each k-mer to its frequency count in the sequence.\n\n\n\n\n\ncount_kmers(\n    _::Type{KMER_TYPE},\n    record::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}\n) -> Any\n\n\nCount the frequency of amino acid k-mers in a biological sequence.\n\nArguments\n\nKmers.Kmer{A,K}: Type parameter specifying amino acid alphabet (A) and k-mer length (K)\nsequence: Input biological sequence to analyze\n\nReturns\n\nA sorted dictionary mapping each k-mer to its frequency count in the sequence.\n\n\n\n\n\ncount_kmers(\n    _::Type{KMER_TYPE},\n    records::AbstractArray{T<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}, 1}\n) -> Any\n\n\nCount k-mers across multiple sequence records and return a sorted frequency table.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer length (e.g., DNAKmer{3} for 3-mers)\nrecords: Vector of FASTA/FASTQ records to analyze\n\nReturns\n\nDict{KMER_TYPE, Int}: Sorted dictionary mapping k-mers to their frequencies\n\n\n\n\n\ncount_kmers(\n    _::Type{KMER_TYPE},\n    sequences::Union{FASTX.FASTA.Reader, FASTX.FASTQ.Reader}\n) -> Any\n\n\nCounts k-mer occurrences in biological sequences from a FASTA/FASTQ reader.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer length and encoding (e.g., DNAKmer{4} for 4-mers)\nsequences: A FASTA or FASTQ reader containing the biological sequences to analyze\n\nReturns\n\nA dictionary mapping k-mers to their counts in the input sequences\n\n\n\n\n\ncount_kmers(\n    _::Type{KMER_TYPE},\n    fastx_files::AbstractArray{T<:AbstractString, 1}\n) -> Any\n\n\nCount k-mers across multiple FASTA/FASTQ files and merge the results.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer length (e.g., DNAKmer{4} for 4-mers)\nfastx_files: Vector of paths to FASTA/FASTQ files\n\nReturns\n\nDict{KMER_TYPE, Int}: Dictionary mapping k-mers to their total counts across all files\n\n\n\n\n\ncount_kmers(\n    _::Type{KMER_TYPE},\n    fastx_file::AbstractString\n) -> Any\n\n\nCount k-mers in a FASTA/FASTQ file and return their frequencies.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer type (e.g., DNAKmer{K})\nfastx_file: Path to input FASTA/FASTQ file\n\nReturns\n\nDict{KMER_TYPE, Int}: Dictionary mapping each k-mer to its frequency\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/sequence-analysis/#Mycelia.count_canonical_kmers","page":"Sequence Analysis & K-mers","title":"Mycelia.count_canonical_kmers","text":"count_canonical_kmers(_::Type{KMER_TYPE}, sequences) -> Any\n\n\nCount canonical k-mers in biological sequences. A canonical k-mer is the lexicographically  smaller of a DNA sequence and its reverse complement, ensuring strand-independent counting.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer size and structure\nsequences: Iterator of biological sequences to analyze\n\nReturns\n\nDict{KMER_TYPE,Int}: Dictionary mapping canonical k-mers to their counts\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/sequence-analysis/#Mycelia.fasta_list_to_dense_kmer_counts","page":"Sequence Analysis & K-mers","title":"Mycelia.fasta_list_to_dense_kmer_counts","text":"fasta_list_to_dense_kmer_counts(\n;\n    fasta_list,\n    k,\n    alphabet,\n    temp_dir_parent,\n    count_element_type,\n    result_file,\n    force,\n    cleanup_temp\n)\n\n\nCreate a dense k-mer counts table for a set of FASTA files, with disk-backed temporary storage,  custom element type, robust error handling, and optional output file caching.\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/sequence-analysis/#Mycelia.fasta_list_to_sparse_kmer_counts","page":"Sequence Analysis & K-mers","title":"Mycelia.fasta_list_to_sparse_kmer_counts","text":"fasta_list_to_sparse_kmer_counts(\n;\n    fasta_list,\n    k,\n    alphabet,\n    temp_dir_parent,\n    count_element_type,\n    rarefaction_data_filename,\n    rarefaction_plot_basename,\n    show_rarefaction_plot,\n    result_file,\n    out_dir,\n    force,\n    rarefaction_plot_kwargs...\n)\n\n\nCreate a sparse kmer counts table (SparseMatrixCSC) from a list of FASTA files using a 3-pass approach. Pass 1 (Parallel): Counts kmers per file and writes to temporary JLD2 files. Pass 2 (Serial): Aggregates unique kmers, max count, nnz per file, and rarefaction data from temp files.                  Generates and saves a k-mer rarefaction plot. Pass 3 (Parallel): Reads temporary counts again to construct the final sparse matrix.\n\nOptionally, a results filename can be provided to save/load the output. If the file exists and force is false, the result is loaded and returned. If force is true or the file does not exist, results are computed and saved.\n\nOutput Directory Behavior\n\nAll auxiliary output files (e.g., rarefaction data, plots) are written to a common output directory.\nBy default, this is:\nThe value of out_dir if provided.\nOtherwise, the directory containing result_file (if provided and has a directory component).\nOtherwise, the current working directory (pwd()).\nIf you provide an absolute path for an output file (e.g. rarefaction_data_filename), that path is used directly.\nIf both out_dir and a relative filename are given, the file is written to out_dir.\n\nArguments\n\nfasta_list::AbstractVector{<:AbstractString}: A list of paths to FASTA files.\nk::Integer: The length of the kmer.\nalphabet::Symbol: The alphabet type (:AA, :DNA, :RNA).\ntemp_dir_parent::AbstractString: Parent directory for creating the temporary working directory. Defaults to Base.tempdir().\ncount_element_type::Union{Type{<:Unsigned}, Nothing}: Optional. Specifies the unsigned integer type for the counts. If nothing (default), the smallest UInt type capable of holding the maximum observed count is used.\nrarefaction_data_filename::AbstractString: Filename for the TSV output of rarefaction data. If a relative path, will be written to out_dir.\nrarefaction_plot_basename::AbstractString: Basename for the output rarefaction plots. If a relative path, will be written to out_dir.\nshow_rarefaction_plot::Bool: Whether to display the rarefaction plot after generation. Defaults to true.\nresult_file::Union{Nothing, AbstractString}: Optional. If provided, path to a file to save/load the full results (kmers, counts, etc) as a JLD2 file.\nout_dir::Union{Nothing, AbstractString}: Optional. Output directory for auxiliary outputs. Defaults as described above.\nforce::Bool: If true, recompute and overwrite the output file even if it exists. Defaults to false.\nrarefaction_plot_kwargs...: Keyword arguments to pass to plot_kmer_rarefaction for plot customization.\n\nReturns\n\nNamedTuple{(:kmers, :counts, :rarefaction_data_path)}:\nkmers: A sorted Vector of unique kmer objects.\ncounts: A SparseArrays.SparseMatrixCSC{V, Int} storing kmer counts.\nrarefaction_data_path: Path to the saved TSV file with rarefaction data.\n\nRaises\n\nErrorException: If input fasta_list is empty, alphabet is invalid, or required Kmer/counting functions are not found.\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/sequence-analysis/#Example:-K-mer-Counting-Comparison","page":"Sequence Analysis & K-mers","title":"Example: K-mer Counting Comparison","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Compare different k-mer counting approaches\nreads_file = \"reads.fastq\"\n\n# Dense counting (stores all possible k-mers)\ndense_counts = Mycelia.count_kmers(reads_file, k=15, method=\"dense\")\nprintln(\"Dense matrix size: $(size(dense_counts))\")\n\n# Sparse counting (only observed k-mers)\nsparse_counts = Mycelia.count_kmers(reads_file, k=21, method=\"sparse\")\nprintln(\"Unique k-mers: $(length(sparse_counts))\")\n\n# Canonical k-mers (combines forward and reverse complement)\ncanonical_counts = Mycelia.count_canonical_kmers(reads_file, k=21)\nprintln(\"Canonical k-mers: $(length(canonical_counts))\")","category":"page"},{"location":"api/workflows/sequence-analysis/#Advanced-K-mer-Analysis","page":"Sequence Analysis & K-mers","title":"Advanced K-mer Analysis","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"<!– buildkmergraph, findkmeroverlaps, extractkmerpaths, analyzekmerconnectivity not yet implemented as documented –>","category":"page"},{"location":"api/workflows/sequence-analysis/#Mycelia.build_kmer_graph_next","page":"Sequence Analysis & K-mers","title":"Mycelia.build_kmer_graph_next","text":"build_kmer_graph_next(\n    kmer_type,\n    observations::AbstractVector{<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}};\n    graph_mode\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Label, VertexData, EdgeData, Nothing, WeightFunction, Float64} where {Label, VertexData, EdgeData, WeightFunction}\n\n\nCreate a next-generation, type-stable k-mer graph using MetaGraphsNext.\n\nThis implementation uses canonical k-mers as vertices with strand-aware edges that respect biological transition constraints for both single-strand and double-strand sequences.\n\nArguments\n\nkmer_type: Type of k-mer (e.g., DNAKmer{K})\nobservations: Vector of FASTA/FASTQ records\ngraph_mode: SingleStrand for directional sequences, DoubleStrand for DNA (default)\n\nReturns\n\nMetaGraphsNext.MetaGraph with canonical vertices and strand-aware edges\n\nDetails\n\nVertices: Always canonical k-mers (lexicographically smaller of kmer/reverse_complement)\nEdges: Strand-aware transitions that respect biological constraints\nSingleStrand mode: Only forward-strand transitions allowed\nDoubleStrand mode: Both forward and reverse-complement transitions allowed\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/sequence-analysis/#Mycelia.build_stranded_kmer_graph","page":"Sequence Analysis & K-mers","title":"Mycelia.build_stranded_kmer_graph","text":"build_stranded_kmer_graph(\n    kmer_type,\n    observations::AbstractVector{<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}\n) -> MetaGraphs.MetaDiGraph{T, Float64} where T<:Integer\n\n\nCreate a weighted, strand-specific kmer (de bruijn) graph from a set of kmers and a series of sequence observations in FASTA format.\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/sequence-analysis/#Mycelia.build_directed_kmer_graph","page":"Sequence Analysis & K-mers","title":"Mycelia.build_directed_kmer_graph","text":"build_directed_kmer_graph(; fastq, k, plot)\n\n\nConstructs a directed graph representation of k-mer transitions from FASTQ sequencing data.\n\nArguments\n\nfastq: Path to input FASTQ file\nk: K-mer size (default: 1). Must be odd and prime. If k=1, optimal size is auto-determined\nplot: Boolean to display quality distribution plot (default: false)\n\nReturns\n\nMetaDiGraph with properties:\n\nassembly_k: k-mer size used\nkmer_counts: frequency of each k-mer\ntransition_likelihoods: edge weights between k-mers\nkmermeanquality, kmertotalquality: quality metrics\nbranchingnodes, unbranchingnodes: topological classification\nlikelyvalidkmer_indices: k-mers above mean quality threshold\nlikelysequencingartifact_indices: potential erroneous k-mers\n\nNote\n\nFor DNA assembly, quality scores are normalized across both strands.\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/sequence-analysis/#Example:-K-mer-Graph-Construction","page":"Sequence Analysis & K-mers","title":"Example: K-mer Graph Construction","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Build k-mer overlap graph\nkmer_graph = Mycelia.build_kmer_graph(\n    sequences,\n    k=31,\n    min_overlap=20,\n    min_coverage=5\n)\n\n# Analyze graph properties\ngraph_stats = Mycelia.analyze_kmer_connectivity(kmer_graph)\nprintln(\"Graph nodes: $(graph_stats.n_nodes)\")\nprintln(\"Graph edges: $(graph_stats.n_edges)\")\nprintln(\"Connected components: $(graph_stats.n_components)\")","category":"page"},{"location":"api/workflows/sequence-analysis/#K-mer-Frequency-Analysis","page":"Sequence Analysis & K-mers","title":"K-mer Frequency Analysis","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#Frequency-Spectra","page":"Sequence Analysis & K-mers","title":"Frequency Spectra","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"<!– kmerfrequencyspectrum, analyzespectrumpeaks, fitspectrummodel not yet implemented as documented –>","category":"page"},{"location":"api/workflows/sequence-analysis/#Mycelia.jellyfish_counts_to_kmer_frequency_histogram","page":"Sequence Analysis & K-mers","title":"Mycelia.jellyfish_counts_to_kmer_frequency_histogram","text":"jellyfish_counts_to_kmer_frequency_histogram(\n    jellyfish_counts_file\n) -> Any\njellyfish_counts_to_kmer_frequency_histogram(\n    jellyfish_counts_file,\n    outfile\n) -> Any\n\n\nConvert a Jellyfish k-mer count file into a frequency histogram.\n\nArguments\n\njellyfish_counts_file::String: Path to the gzipped TSV file containing Jellyfish k-mer counts\noutfile::String=replace(jellyfish_counts_file, r\"\\.tsv\\.gz$\" => \".count_histogram.tsv\"): Optional output file path\n\nReturns\n\nString: Path to the generated histogram file\n\nDescription\n\nProcesses a Jellyfish k-mer count file to create a frequency histogram where:\n\nColumn 1: Number of k-mers that share the same count\nColumn 2: The count they share\n\nUses system sorting with LC_ALL=C for optimal performance on large files.\n\nNotes\n\nRequires gzip, sort, uniq, and sed command line tools\nUses intermediate disk storage for sorting large files\nSkips processing if output file already exists\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/sequence-analysis/#Mycelia.plot_kmer_frequency_spectra","page":"Sequence Analysis & K-mers","title":"Mycelia.plot_kmer_frequency_spectra","text":"plot_kmer_frequency_spectra(\n    counts;\n    log_scale,\n    kwargs...\n) -> Plots.Plot\n\n\nPlots a histogram of kmer counts against # of kmers with those counts\n\nReturns the plot object for adding additional layers and saving\n\nCreates a scatter plot visualizing the k-mer frequency spectrum - the relationship between k-mer frequencies and how many k-mers occur at each frequency.\n\nArguments\n\ncounts::AbstractVector{<:Integer}: Vector of k-mer counts/frequencies\nlog_scale::Union{Function,Nothing} = log2: Function to apply logarithmic scaling to both axes. Set to nothing to use linear scaling.\nkwargs...: Additional keyword arguments passed to StatsPlots.plot()\n\nReturns\n\nPlots.Plot: A scatter plot object that can be further modified or saved\n\nDetails\n\nThe x-axis shows k-mer frequencies (how many times each k-mer appears), while the y-axis shows how many distinct k-mers appear at each frequency. Both axes are log-scaled by default using log2.\n\n\n\n\n\n","category":"function"},{"location":"api/workflows/sequence-analysis/#Example:-K-mer-Spectrum-Analysis","page":"Sequence Analysis & K-mers","title":"Example: K-mer Spectrum Analysis","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Generate and analyze k-mer frequency spectrum\nkmer_counts = Mycelia.count_kmers(\"reads.fastq\", k=21)\nspectrum = Mycelia.kmer_frequency_spectrum(kmer_counts)\n\n# Identify characteristic peaks\npeaks = Mycelia.analyze_spectrum_peaks(spectrum)\nprintln(\"Coverage peak at frequency: $(peaks.main_peak)\")\nprintln(\"Error peak at frequency: $(peaks.error_peak)\")\n\n# Fit mathematical model to spectrum\nmodel = Mycelia.fit_spectrum_model(spectrum, model_type=\"negative_binomial\")\nprintln(\"Model fit R²: $(model.r_squared)\")","category":"page"},{"location":"api/workflows/sequence-analysis/#Genome-Characteristics-from-K-mers","page":"Sequence Analysis & K-mers","title":"Genome Characteristics from K-mers","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"<!– estimategenomesizefromkmers, estimatecoveragefromkmers, detectrepetitivekmers, calculategenome_complexity not yet implemented as documented –>","category":"page"},{"location":"api/workflows/sequence-analysis/#Example:-Genome-Size-Estimation","page":"Sequence Analysis & K-mers","title":"Example: Genome Size Estimation","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Estimate genome size using k-mer spectrum\nkmer_counts = Mycelia.count_kmers(\"reads.fastq\", k=21)\nspectrum = Mycelia.kmer_frequency_spectrum(kmer_counts)\n\n# Find coverage peak\ncoverage_peak = Mycelia.find_coverage_peak(spectrum)\nprintln(\"Estimated coverage: $(coverage_peak)x\")\n\n# Calculate genome size\ntotal_kmers = sum(spectrum.frequencies .* spectrum.counts)\ngenome_size = total_kmers ÷ coverage_peak\nprintln(\"Estimated genome size: $(genome_size) bp\")\n\n# Alternative method with error correction\ncorrected_estimate = Mycelia.estimate_genome_size_from_kmers(\n    kmer_counts,\n    error_correction=true,\n    ploidy=1\n)\nprintln(\"Corrected genome size: $(corrected_estimate.size) bp\")\nprintln(\"Confidence interval: $(corrected_estimate.confidence_interval)\")","category":"page"},{"location":"api/workflows/sequence-analysis/#Error-Detection-and-Correction","page":"Sequence Analysis & K-mers","title":"Error Detection and Correction","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#K-mer-Based-Error-Detection","page":"Sequence Analysis & K-mers","title":"K-mer Based Error Detection","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"<!– identifyerrorkmers, correctsequencingerrors, validateerrorcorrection not yet implemented as documented –>","category":"page"},{"location":"api/workflows/sequence-analysis/#Example:-Error-Detection","page":"Sequence Analysis & K-mers","title":"Example: Error Detection","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Identify likely error k-mers\nerror_kmers = Mycelia.identify_error_kmers(\n    kmer_counts,\n    min_coverage=3,\n    max_coverage=100\n)\n\nprintln(\"Potential error k-mers: $(length(error_kmers))\")\nprintln(\"Error rate estimate: $(length(error_kmers) / length(kmer_counts) * 100)%\")\n\n# Correct errors in reads\ncorrected_reads = Mycelia.correct_sequencing_errors(\n    \"reads.fastq\",\n    error_kmers,\n    correction_method=\"consensus\"\n)\n\n# Validate correction effectiveness\nvalidation = Mycelia.validate_error_correction(\n    \"reads.fastq\",\n    corrected_reads,\n    reference_genome=\"reference.fasta\"\n)\nprintln(\"Error reduction: $(validation.error_reduction_percent)%\")","category":"page"},{"location":"api/workflows/sequence-analysis/#Sequence-Composition-Analysis","page":"Sequence Analysis & K-mers","title":"Sequence Composition Analysis","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#Nucleotide-Composition","page":"Sequence Analysis & K-mers","title":"Nucleotide Composition","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"<!– calculatenucleotidefrequencies, analyzedinucleotidefrequencies, calculatecodonusage, detectsequencebias not yet implemented as documented –>","category":"page"},{"location":"api/workflows/sequence-analysis/#Example:-Comprehensive-Composition-Analysis","page":"Sequence Analysis & K-mers","title":"Example: Comprehensive Composition Analysis","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Analyze nucleotide composition\ncomposition = Mycelia.calculate_nucleotide_frequencies(\"sequences.fasta\")\nprintln(\"GC content: $(composition.gc_content)%\")\nprintln(\"AT content: $(composition.at_content)%\")\n\n# Dinucleotide analysis\ndinuc_freq = Mycelia.analyze_dinucleotide_frequencies(\"sequences.fasta\")\nprintln(\"CpG frequency: $(dinuc_freq.CG)\")\nprintln(\"Expected CpG: $(dinuc_freq.expected_CG)\")\nprintln(\"CpG O/E ratio: $(dinuc_freq.CG_oe_ratio)\")\n\n# Detect composition bias\nbias_analysis = Mycelia.detect_sequence_bias(composition)\nif bias_analysis.bias_detected\n    println(\"Sequence bias detected:\")\n    println(\"  Type: $(bias_analysis.bias_type)\")\n    println(\"  Strength: $(bias_analysis.bias_strength)\")\nend","category":"page"},{"location":"api/workflows/sequence-analysis/#Codon-Usage-Analysis","page":"Sequence Analysis & K-mers","title":"Codon Usage Analysis","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"<!– calculatecodonusage, analyzecodonbias, comparecodonusage, optimizecodonusage not yet implemented as documented –>","category":"page"},{"location":"api/workflows/sequence-analysis/#Example:-Codon-Usage-Analysis","page":"Sequence Analysis & K-mers","title":"Example: Codon Usage Analysis","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Analyze codon usage in coding sequences\ncds_file = \"coding_sequences.fasta\"\ncodon_usage = Mycelia.calculate_codon_usage(cds_file, genetic_code=\"standard\")\n\n# Calculate codon bias metrics\nbias_metrics = Mycelia.analyze_codon_bias(codon_usage)\nprintln(\"Effective Number of Codons (ENC): $(bias_metrics.enc)\")\nprintln(\"Codon Adaptation Index (CAI): $(bias_metrics.cai)\")\nprintln(\"Frequency of Optimal Codons (FOP): $(bias_metrics.fop)\")\n\n# Compare with reference organism\nreference_usage = Mycelia.load_reference_codon_usage(\"escherichia_coli\")\ncomparison = Mycelia.compare_codon_usage(codon_usage, reference_usage)\nprintln(\"Similarity to E. coli: $(comparison.similarity_score)\")","category":"page"},{"location":"api/workflows/sequence-analysis/#Memory-Efficient-Processing","page":"Sequence Analysis & K-mers","title":"Memory-Efficient Processing","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#Large-Dataset-Handling","page":"Sequence Analysis & K-mers","title":"Large Dataset Handling","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"<!– streamkmercounting, processkmersinchunks, parallelkmeranalysis, memoryefficient_counting not yet implemented as documented –>","category":"page"},{"location":"api/workflows/sequence-analysis/#Example:-Large-File-Processing","page":"Sequence Analysis & K-mers","title":"Example: Large File Processing","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Process large files with memory constraints\nlarge_file = \"large_dataset.fastq\"\n\n# Stream processing for memory efficiency\nkmer_counts = Mycelia.stream_kmer_counting(\n    large_file,\n    k=21,\n    chunk_size=100000,\n    memory_limit_gb=8\n)\n\n# Parallel processing for speed\nparallel_counts = Mycelia.parallel_kmer_analysis(\n    large_file,\n    k=21,\n    n_workers=8,\n    merge_strategy=\"sum\"\n)","category":"page"},{"location":"api/workflows/sequence-analysis/#Optimized-Data-Structures","page":"Sequence Analysis & K-mers","title":"Optimized Data Structures","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"<!– createsparsekmermatrix, buildcompressedkmerindex, usebloomfiltercounting, implementcountminsketch not yet implemented as documented –>","category":"page"},{"location":"api/workflows/sequence-analysis/#Example:-Memory-Optimization","page":"Sequence Analysis & K-mers","title":"Example: Memory Optimization","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Use probabilistic data structures for very large datasets\nbloom_filter = Mycelia.create_kmer_bloom_filter(\n    estimated_kmers=1_000_000_000,\n    false_positive_rate=0.01\n)\n\n# Streaming k-mer presence testing\nfor read in Mycelia.stream_fastq(\"huge_dataset.fastq\")\n    for kmer in Mycelia.extract_kmers(read, k=21)\n        if Mycelia.probably_present(bloom_filter, kmer)\n            # Process likely present k-mer\n            Mycelia.process_kmer(kmer)\n        end\n    end\nend","category":"page"},{"location":"api/workflows/sequence-analysis/#Comparative-K-mer-Analysis","page":"Sequence Analysis & K-mers","title":"Comparative K-mer Analysis","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#Multi-Sample-Analysis","page":"Sequence Analysis & K-mers","title":"Multi-Sample Analysis","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"<!– comparekmerprofiles, buildkmerdistancematrix, clusterbykmersimilarity, identifysamplespecific_kmers not yet implemented as documented –>","category":"page"},{"location":"api/workflows/sequence-analysis/#Example:-Multi-Sample-K-mer-Comparison","page":"Sequence Analysis & K-mers","title":"Example: Multi-Sample K-mer Comparison","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Compare k-mer profiles across multiple samples\nsample_files = [\"sample1.fastq\", \"sample2.fastq\", \"sample3.fastq\"]\n\n# Build k-mer profiles for each sample\nprofiles = [Mycelia.count_kmers(file, k=21) for file in sample_files]\n\n# Calculate pairwise distances\ndistance_matrix = Mycelia.build_kmer_distance_matrix(profiles, metric=\"jaccard\")\nprintln(\"Pairwise k-mer distances:\")\ndisplay(distance_matrix)\n\n# Cluster samples by k-mer similarity\nclusters = Mycelia.cluster_by_kmer_similarity(profiles, method=\"hierarchical\")\nprintln(\"Sample clusters: $(clusters)\")","category":"page"},{"location":"api/workflows/sequence-analysis/#Contamination-Detection","page":"Sequence Analysis & K-mers","title":"Contamination Detection","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"<!– detectcontaminationkmers, identifyforeignkmers, classifykmersources, removecontaminatingkmers not yet implemented as documented –>","category":"page"},{"location":"api/workflows/sequence-analysis/#Example:-Contamination-Detection","page":"Sequence Analysis & K-mers","title":"Example: Contamination Detection","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Detect contamination using k-mer profiles\nsample_kmers = Mycelia.count_kmers(\"sample.fastq\", k=21)\nreference_kmers = Mycelia.count_kmers(\"reference_genome.fasta\", k=21)\n\n# Identify foreign k-mers\nforeign_kmers = Mycelia.identify_foreign_kmers(\n    sample_kmers,\n    reference_kmers,\n    min_abundance=5\n)\n\ncontamination_rate = length(foreign_kmers) / length(sample_kmers)\nprintln(\"Contamination rate: $(contamination_rate * 100)%\")\n\n# Classify contamination sources\ncontamination_sources = Mycelia.classify_kmer_sources(\n    foreign_kmers,\n    database_kmers=[\"human\", \"bacterial\", \"viral\"]\n)\n\nfor (source, proportion) in contamination_sources\n    println(\"$(source): $(proportion * 100)%\")\nend","category":"page"},{"location":"api/workflows/sequence-analysis/#Visualization-and-Reporting","page":"Sequence Analysis & K-mers","title":"Visualization and Reporting","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#K-mer-Plots","page":"Sequence Analysis & K-mers","title":"K-mer Plots","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"<!– plotkmerspectrum, plotkmercomposition, plotgenomesizeestimation, createkmer_dashboard not yet implemented as individual functions –>","category":"page"},{"location":"api/workflows/sequence-analysis/#Example:-K-mer-Visualization","page":"Sequence Analysis & K-mers","title":"Example: K-mer Visualization","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Create comprehensive k-mer analysis plots\nkmer_counts = Mycelia.count_kmers(\"reads.fastq\", k=21)\n\n# K-mer frequency spectrum\nspectrum_plot = Mycelia.plot_kmer_spectrum(kmer_counts, \n                                  title=\"21-mer Frequency Spectrum\",\n                                  log_scale=true)\n\n# Genome size estimation plot\nsize_plot = Mycelia.plot_genome_size_estimation(kmer_counts,\n                                       show_confidence_interval=true)\n\n# Combined dashboard\nkmer_dashboard = Mycelia.create_kmer_dashboard(kmer_counts)\nMycelia.save_plot(kmer_dashboard, \"kmer_analysis.png\")","category":"page"},{"location":"api/workflows/sequence-analysis/#Performance-Considerations","page":"Sequence Analysis & K-mers","title":"Performance Considerations","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#Algorithm-Selection","page":"Sequence Analysis & K-mers","title":"Algorithm Selection","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"Dense matrices: Use for small k (k ≤ 12) or small genomes\nSparse matrices: Use for large k (k ≥ 15) or large genomes\nStreaming: Use for memory-constrained environments\nParallel processing: Use for time-critical applications","category":"page"},{"location":"api/workflows/sequence-analysis/#Memory-Usage","page":"Sequence Analysis & K-mers","title":"Memory Usage","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"k=15: ~1 GB for dense counting\nk=21: ~17 GB for dense counting (use sparse)\nk=31: Sparse counting only\nLarge genomes: Consider streaming or chunked processing","category":"page"},{"location":"api/workflows/sequence-analysis/#Computational-Complexity","page":"Sequence Analysis & K-mers","title":"Computational Complexity","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"Time: O(n) for sequence length n\nSpace: O(4^k) for dense, O(unique k-mers) for sparse\nParallel: Near-linear speedup for independent samples","category":"page"},{"location":"api/workflows/sequence-analysis/#Common-Issues-and-Solutions","page":"Sequence Analysis & K-mers","title":"Common Issues and Solutions","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#Memory-Limitations","page":"Sequence Analysis & K-mers","title":"Memory Limitations","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Handle memory constraints\nif Mycelia.estimate_memory_usage(file, k=21) > Mycelia.available_memory()\n    # Use streaming approach\n    kmer_counts = Mycelia.stream_kmer_counting(file, k=21, chunk_size=50000)\nelse\n    # Use standard approach\n    kmer_counts = Mycelia.count_kmers(file, k=21)\nend","category":"page"},{"location":"api/workflows/sequence-analysis/#Parameter-Selection","page":"Sequence Analysis & K-mers","title":"Parameter Selection","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"# Choose optimal k-mer size\noptimal_k = Mycelia.select_optimal_k(\n    genome_size_estimate=5_000_000,\n    error_rate=0.01,\n    coverage=30\n)\nprintln(\"Recommended k-mer size: $(optimal_k)\")","category":"page"},{"location":"api/workflows/sequence-analysis/#Related-Functions","page":"Sequence Analysis & K-mers","title":"Related Functions","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#Data-Structures","page":"Sequence Analysis & K-mers","title":"Data Structures","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"KmerCounts - K-mer count data structure\nKmerSpectrum - Frequency spectrum representation\nKmerGraph - K-mer overlap graph","category":"page"},{"location":"api/workflows/sequence-analysis/#File-I/O","page":"Sequence Analysis & K-mers","title":"File I/O","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"read_fastq - Read sequence files\nsave_kmer_counts - Save k-mer counts\nload_kmer_counts - Load saved counts","category":"page"},{"location":"api/workflows/sequence-analysis/#Related-Workflows","page":"Sequence Analysis & K-mers","title":"Related Workflows","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/#Previous-Steps","page":"Sequence Analysis & K-mers","title":"Previous Steps","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"Quality Control - Preprocess reads before k-mer analysis","category":"page"},{"location":"api/workflows/sequence-analysis/#Next-Steps","page":"Sequence Analysis & K-mers","title":"Next Steps","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"Genome Assembly (planned) - Use k-mer analysis for assembly\nComparative Genomics (planned) - Compare k-mer profiles","category":"page"},{"location":"api/workflows/sequence-analysis/#See-Also","page":"Sequence Analysis & K-mers","title":"See Also","text":"","category":"section"},{"location":"api/workflows/sequence-analysis/","page":"Sequence Analysis & K-mers","title":"Sequence Analysis & K-mers","text":"Tutorial 3: K-mer Analysis\nAssembly Workflows (planned)\nPerformance Optimization","category":"page"},{"location":"api/quick-reference/parameter-guide/#Parameter-Guide","page":"Parameter Guide","title":"Parameter Guide","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Common parameters used across Mycelia functions with explanations, defaults, and best practices.","category":"page"},{"location":"api/quick-reference/parameter-guide/#Overview","page":"Parameter Guide","title":"Overview","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"This guide covers the most frequently used parameters in Mycelia functions. Understanding these parameters helps you:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Optimize performance for your specific use case\nChoose appropriate values for different data types\nUnderstand parameter interactions and trade-offs\nTroubleshoot issues related to parameter selection","category":"page"},{"location":"api/quick-reference/parameter-guide/#File-Path-Parameters","page":"Parameter Guide","title":"File Path Parameters","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/#Input-Files","page":"Parameter Guide","title":"Input Files","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Most functions accept file paths as input. Common patterns:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"# Single file input\nresult = Mycelia.analyze_function(\"input.fastq\")\n\n# Multiple file input\nresult = Mycelia.analyze_function([\"file1.fastq\", \"file2.fastq\"])\n\n# Directory input (processes all files)\nresult = Mycelia.analyze_function(\"input_directory/\")","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Common Parameters:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"input_file::String - Path to input file\ninput_files::Vector{String} - Multiple input files\ninput_dir::String - Directory containing input files","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Best Practices:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Use absolute paths for better reliability\nCheck file existence before processing\nHandle compressed files (.gz) automatically","category":"page"},{"location":"api/quick-reference/parameter-guide/#Output-Specification","page":"Parameter Guide","title":"Output Specification","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"# Output file specification\nresult = Mycelia.process_function(\"input.fastq\", output=\"output.fastq\")\n\n# Output directory\nresult = Mycelia.process_function(\"input.fastq\", output_dir=\"results/\")\n\n# Auto-generated output names\nresult = Mycelia.process_function(\"input.fastq\", auto_output=true)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Common Parameters:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"output::String - Output file path\noutput_dir::String - Output directory\noutput_prefix::String - Prefix for output files\noverwrite::Bool = false - Overwrite existing files","category":"page"},{"location":"api/quick-reference/parameter-guide/#Quality-Control-Parameters","page":"Parameter Guide","title":"Quality Control Parameters","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/#Quality-Thresholds","page":"Parameter Guide","title":"Quality Thresholds","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"# Quality score thresholds\nMycelia.filter_by_quality(\"reads.fastq\", \n    min_quality=20,        # Minimum average quality score\n    min_base_quality=15,   # Minimum per-base quality\n    quality_window=10      # Sliding window size\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Parameter Details:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"min_quality::Int = 20 - Minimum average Phred score (Q20 = 1% error)\nmin_base_quality::Int = 10 - Minimum individual base quality\nquality_window::Int = 4 - Window size for quality assessment","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Quality Score Reference:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Q10: 10% error rate (poor)\nQ20: 1% error rate (acceptable)\nQ30: 0.1% error rate (good)\nQ40: 0.01% error rate (excellent)","category":"page"},{"location":"api/quick-reference/parameter-guide/#Length-Filtering","page":"Parameter Guide","title":"Length Filtering","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.filter_by_length(\"reads.fastq\",\n    min_length=1000,       # Minimum read length\n    max_length=50000,      # Maximum read length\n    length_tolerance=0.1   # Tolerance for length variation\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Parameter Details:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"min_length::Int = 500 - Minimum acceptable read length\nmax_length::Int = Inf - Maximum acceptable read length\nlength_tolerance::Float64 = 0.2 - Acceptable length variation","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Platform-Specific Defaults:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Illumina: minlength=50, maxlength=300\nPacBio HiFi: minlength=1000, maxlength=30000\nNanopore: minlength=500, maxlength=100000","category":"page"},{"location":"api/quick-reference/parameter-guide/#K-mer-Analysis-Parameters","page":"Parameter Guide","title":"K-mer Analysis Parameters","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/#K-mer-Size-Selection","page":"Parameter Guide","title":"K-mer Size Selection","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.count_kmers(\"reads.fastq\", \n    k=21,                  # K-mer size\n    alphabet=:DNA,         # Sequence alphabet\n    canonical=true         # Use canonical k-mers\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Parameter Details:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"k::Int = 21 - K-mer size (length of subsequences)\nalphabet::Symbol = :DNA - Sequence alphabet (:DNA, :RNA, :PROTEIN)\ncanonical::Bool = true - Combine forward and reverse complement","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"K-mer Size Guidelines:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"k=11-15: Error correction, small genomes\nk=19-25: General analysis, genome size estimation\nk=31-51: Large genomes, repeat resolution\nk>51: Very large genomes, high specificity","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Memory Considerations:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Dense counting: 4^k possible k-mers\nk=15: ~1 GB memory\nk=21: ~17 GB memory (use sparse)\nk≥25: Always use sparse counting","category":"page"},{"location":"api/quick-reference/parameter-guide/#Counting-Methods","page":"Parameter Guide","title":"Counting Methods","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.count_kmers(\"reads.fastq\",\n    method=\"sparse\",       # Counting method\n    min_count=1,          # Minimum count threshold\n    max_count=1000        # Maximum count threshold\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Method Options:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"\"dense\": Store all possible k-mers (memory intensive)\n\"sparse\": Store only observed k-mers (memory efficient)\n\"streaming\": Process in chunks (very large files)","category":"page"},{"location":"api/quick-reference/parameter-guide/#Assembly-Parameters","page":"Parameter Guide","title":"Assembly Parameters","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/#Assembly-Configuration","page":"Parameter Guide","title":"Assembly Configuration","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.assemble_genome(\"reads.fastq\",\n    assembler=\"hifiasm\",   # Assembly software\n    k=31,                 # K-mer size for assembly\n    min_overlap=1000,     # Minimum overlap length\n    threads=8             # Number of CPU threads\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Assembler Options:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"\"hifiasm\": Best for HiFi reads\n\"canu\": Good for long reads with higher error rates\n\"flye\": Fast assembly for long reads\n\"spades\": Best for Illumina reads","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Performance Parameters:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"threads::Int = 4 - Number of CPU threads\nmemory_gb::Int = 16 - Maximum memory usage\ntmp_dir::String = \"/tmp\" - Temporary file directory","category":"page"},{"location":"api/quick-reference/parameter-guide/#Assembly-Quality-Control","page":"Parameter Guide","title":"Assembly Quality Control","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.assemble_genome(\"reads.fastq\",\n    min_contig_length=1000,  # Minimum contig size\n    min_coverage=5,          # Minimum coverage depth\n    error_correction=true,   # Enable error correction\n    polish=true             # Enable polishing\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/#Comparative-Genomics-Parameters","page":"Parameter Guide","title":"Comparative Genomics Parameters","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/#Pangenome-Construction","page":"Parameter Guide","title":"Pangenome Construction","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.build_pangenome(genomes,\n    similarity_threshold=0.95,  # Gene similarity cutoff\n    coverage_threshold=0.8,     # Minimum coverage for alignment\n    clustering_method=\"mcl\",    # Clustering algorithm\n    inflation=2.0              # MCL inflation parameter\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Similarity Thresholds:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"0.95: Very strict (same species)\n0.90: Strict (closely related strains)\n0.80: Moderate (related species)\n0.70: Permissive (distant relationships)","category":"page"},{"location":"api/quick-reference/parameter-guide/#Phylogenetic-Analysis","page":"Parameter Guide","title":"Phylogenetic Analysis","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.build_phylogenetic_tree(alignment,\n    method=\"ml\",              # Tree construction method\n    model=\"GTR+G\",           # Evolutionary model\n    bootstrap=1000,          # Bootstrap replicates\n    outgroup=\"species_A\"     # Outgroup specification\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Method Options:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"\"ml\": Maximum likelihood (most accurate)\n\"nj\": Neighbor-joining (fast)\n\"mp\": Maximum parsimony (character-based)","category":"page"},{"location":"api/quick-reference/parameter-guide/#Performance-Parameters","page":"Parameter Guide","title":"Performance Parameters","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/#Parallel-Processing","page":"Parameter Guide","title":"Parallel Processing","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.parallel_function(data,\n    threads=8,               # Number of CPU threads\n    workers=4,              # Number of worker processes\n    chunk_size=1000,        # Data chunk size\n    load_balance=true       # Enable load balancing\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Thread Guidelines:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Use Sys.CPU_THREADS for maximum threads\nLeave 1-2 threads free for system\nMemory-bound tasks: threads = cores\nI/O-bound tasks: threads = 2x cores","category":"page"},{"location":"api/quick-reference/parameter-guide/#Memory-Management","page":"Parameter Guide","title":"Memory Management","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.memory_intensive_function(data,\n    memory_limit_gb=16,      # Maximum memory usage\n    chunk_processing=true,   # Process in chunks\n    gc_frequency=1000,      # Garbage collection frequency\n    tmp_dir=\"/fast_storage\" # Temporary file location\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Memory Guidelines:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Monitor with memory_usage() function\nUse streaming for files > available RAM\nSet conservative limits for shared systems","category":"page"},{"location":"api/quick-reference/parameter-guide/#File-Format-Parameters","page":"Parameter Guide","title":"File Format Parameters","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/#Compression","page":"Parameter Guide","title":"Compression","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.write_output(data,\n    compress=true,          # Enable compression\n    compression_level=6,    # Compression level (1-9)\n    format=\"auto\"          # Output format detection\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Compression Levels:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"1-3: Fast compression, larger files\n4-6: Balanced compression and speed\n7-9: Maximum compression, slower","category":"page"},{"location":"api/quick-reference/parameter-guide/#Format-Specification","page":"Parameter Guide","title":"Format Specification","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.read_sequences(\"input.file\",\n    format=\"auto\",          # Format detection\n    validate=true,         # Validate file format\n    encoding=\"utf-8\"       # Text encoding\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Format Options:","category":"page"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"\"auto\": Automatic detection from extension\n\"fasta\": FASTA format\n\"fastq\": FASTQ format\n\"gff3\": GFF3 annotation format","category":"page"},{"location":"api/quick-reference/parameter-guide/#Error-Handling-Parameters","page":"Parameter Guide","title":"Error Handling Parameters","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/#Validation-and-Checks","page":"Parameter Guide","title":"Validation and Checks","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.robust_function(input,\n    validate_input=true,    # Validate input data\n    strict_mode=false,     # Strict error checking\n    continue_on_error=false, # Continue despite errors\n    max_errors=10          # Maximum allowed errors\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/#Retry-Logic","page":"Parameter Guide","title":"Retry Logic","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Mycelia.network_function(url,\n    max_retries=3,         # Maximum retry attempts\n    retry_delay=30,        # Delay between retries (seconds)\n    exponential_backoff=true, # Increase delay each retry\n    timeout=300           # Operation timeout (seconds)\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/#Common-Parameter-Patterns","page":"Parameter Guide","title":"Common Parameter Patterns","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/#Quality-Control-Pattern","page":"Parameter Guide","title":"Quality Control Pattern","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"standard_qc_params = Dict(\n    :min_quality => 20,\n    :min_length => 1000,\n    :max_n_percent => 5,\n    :trim_ends => true,\n    :remove_duplicates => false\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/#Performance-Pattern","page":"Parameter Guide","title":"Performance Pattern","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"performance_params = Dict(\n    :threads => min(8, Sys.CPU_THREADS),\n    :memory_gb => 16,\n    :chunk_size => 10000,\n    :parallel => true\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/#Output-Pattern","page":"Parameter Guide","title":"Output Pattern","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"output_params = Dict(\n    :output_dir => \"results\",\n    :compress => true,\n    :overwrite => false,\n    :create_manifest => true\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/#Parameter-Validation","page":"Parameter Guide","title":"Parameter Validation","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/#Built-in-Validation","page":"Parameter Guide","title":"Built-in Validation","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"# Most functions automatically validate parameters\ntry\n    result = Mycelia.count_kmers(\"reads.fastq\", k=0)  # Invalid k\ncatch ArgumentError as e\n    println(\"Parameter error: $e\")\nend","category":"page"},{"location":"api/quick-reference/parameter-guide/#Manual-Validation","page":"Parameter Guide","title":"Manual Validation","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"# Validate parameters before expensive operations\nif !Mycelia.validate_parameters(k=21, min_quality=20, threads=8)\n    error(\"Invalid parameter combination\")\nend","category":"page"},{"location":"api/quick-reference/parameter-guide/#Troubleshooting-Common-Issues","page":"Parameter Guide","title":"Troubleshooting Common Issues","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/#Memory-Problems","page":"Parameter Guide","title":"Memory Problems","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"# Reduce memory usage\nMycelia.count_kmers(\"large_file.fastq\", \n    k=21,\n    method=\"sparse\",        # Use sparse instead of dense\n    chunk_size=50000,      # Process in smaller chunks\n    memory_limit_gb=8      # Set memory limit\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/#Performance-Issues","page":"Parameter Guide","title":"Performance Issues","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"# Optimize for speed\nMycelia.process_function(data,\n    threads=Sys.CPU_THREADS,  # Use all available cores\n    chunk_size=1000,          # Optimize chunk size\n    parallel=true,            # Enable parallelization\n    cache_results=true        # Cache intermediate results\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/#File-I/O-Problems","page":"Parameter Guide","title":"File I/O Problems","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"# Handle file I/O robustly\nMycelia.read_function(\"file.fastq\",\n    validate=true,            # Validate file format\n    buffer_size=8192,        # Optimize buffer size\n    encoding=\"utf-8\",        # Specify encoding\n    handle_errors=\"skip\"     # Skip problematic records\n)","category":"page"},{"location":"api/quick-reference/parameter-guide/#See-Also","page":"Parameter Guide","title":"See Also","text":"","category":"section"},{"location":"api/quick-reference/parameter-guide/","page":"Parameter Guide","title":"Parameter Guide","text":"Function Index - Complete function listing\nBasic Workflows - Parameter usage examples\nAdvanced Usage - Complex parameter combinations\nPerformance Guide - Optimization strategies","category":"page"},{"location":"#Mycelia-Documentation","page":"Home","title":"Mycelia Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An experimental Julia package for bioinformatics and computational biology","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mycelia is a research-oriented package exploring novel approaches to genomic analysis, with a focus on graph-based genome assembly and quality-aware sequence processing. Currently in early development, it provides both experimental algorithms and integrations with established bioinformatics tools.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"New to Mycelia? Start with our Getting Started Guide to install the package and complete your first genomic analysis in minutes.","category":"page"},{"location":"#Key-Features-and-Research-Areas","page":"Home","title":"Key Features & Research Areas","text":"","category":"section"},{"location":"#Currently-Available","page":"Home","title":"Currently Available","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🧬 Sequence Processing: Basic FASTA/FASTQ I/O and read simulation\n📊 K-mer Analysis: Canonical k-mer counting and distance metrics\n🔧 Tool Integration: Wrappers for established assemblers (MEGAHIT, SPAdes, hifiasm)\n⚡ HPC Support: SLURM job submission and rclone integration","category":"page"},{"location":"#In-Active-Development","page":"Home","title":"In Active Development","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🧪 Novel Assembly Algorithms: Graph-based approaches with quality awareness\n🌐 Pangenome Analysis: K-mer based comparative genomics\n📈 Quality Control: Integration with QC tools (fastp, filtlong, trim_galore)","category":"page"},{"location":"#Planned-Features","page":"Home","title":"Planned Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🔍 Annotation: Gene prediction and functional annotation\n🌳 Phylogenetics: Tree construction from pangenome data\n📊 Visualization: Interactive plots for genomic data","category":"page"},{"location":"#Documentation-Contents","page":"Home","title":"Documentation Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"getting-started.md\",\n    \"concepts.md\",\n    \"tutorials.md\", \n    \"api.md\",\n    \"visualization-gallery.md\",\n    \"troubleshooting.md\",\n    \"contributing.md\"\n]\nDepth = 2","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Quick-Install","page":"Home","title":"Quick Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/cjprybol/Mycelia.git\")","category":"page"},{"location":"#Development-Install","page":"Home","title":"Development Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.develop(url=\"git@github.com:cjprybol/Mycelia.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For detailed installation instructions including HPC setup, see the Getting Started Guide.","category":"page"},{"location":"#Function-Docstrings","page":"Home","title":"Function Docstrings","text":"","category":"section"},{"location":"#Mycelia.AssemblyAction","page":"Home","title":"Mycelia.AssemblyAction","text":"AssemblyAction\n\nAction representation for reinforcement learning decisions during assembly.\n\nFields\n\ndecision::Symbol: Primary decision (:continuek, :nextk, :terminate)\nviterbi_params::Dict{Symbol, Float64}: Viterbi algorithm parameters\ncorrection_threshold::Float64: Quality threshold for error correction\nbatch_size::Int: Batch size for processing (memory management)\nmax_iterations::Int: Maximum iterations at current k before forced progression\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.AssemblyConfig","page":"Home","title":"Mycelia.AssemblyConfig","text":"Assembly configuration structure.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.AssemblyEnvironment","page":"Home","title":"Mycelia.AssemblyEnvironment","text":"AssemblyEnvironment\n\nReinforcement learning environment for training assembly decision policies.\n\nFields\n\ncurrent_state::AssemblyState: Current environment state\ntraining_datasets::Vector{String}: Paths to training FASTQ files\nvalidation_datasets::Vector{String}: Paths to validation FASTQ files\nepisode_length::Int: Maximum steps per training episode\nstep_count::Int: Current step in episode\nreward_history::Vector{Float64}: Reward history for current episode\naction_history::Vector{AssemblyAction}: Action history for experience replay\nassembly_cache::Dict{String, Any}: Cache for intermediate assembly results\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.AssemblyMethod","page":"Home","title":"Mycelia.AssemblyMethod","text":"Assembly method enumeration for unified interface.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.AssemblyResult","page":"Home","title":"Mycelia.AssemblyResult","text":"Assembly result structure containing contigs and metadata.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.AssemblyState","page":"Home","title":"Mycelia.AssemblyState","text":"AssemblyState\n\nState representation for reinforcement learning environment containing all information needed to make assembly decisions.\n\nFields\n\ncurrent_k::Int: Current k-mer size being processed\nassembly_quality::Float64: Current assembly quality score (QV-based)\ncorrection_rate::Float64: Rate of successful error corrections in recent iterations\nmemory_usage::Float64: Current memory utilization (fraction of limit)\ngraph_connectivity::Float64: Graph connectivity metric (proportion of strongly connected components)\ncoverage_uniformity::Float64: Uniformity of k-mer coverage distribution\nerror_signal_clarity::Float64: Clarity of error signal detection (sparsity-based)\niteration_history::Vector{Float64}: Recent reward history for trend analysis\nk_progression::Vector{Int}: Sequence of k-mer sizes processed so far\ncorrections_made::Int: Total corrections made at current k\ntime_elapsed::Float64: Time spent on current k-mer size (seconds)\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.BenchmarkConfig","page":"Home","title":"Mycelia.BenchmarkConfig","text":"Benchmark configuration for consistent testing.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.BioSequenceEdgeData","page":"Home","title":"Mycelia.BioSequenceEdgeData","text":"Edge data for variable-length BioSequence graphs.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.BioSequenceVertexData","page":"Home","title":"Mycelia.BioSequenceVertexData","text":"Vertex data for variable-length BioSequence graphs.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.BubbleStructure","page":"Home","title":"Mycelia.BubbleStructure","text":"BubbleStructure\n\nRepresents a bubble (alternative path) in the assembly graph.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.ContigPath","page":"Home","title":"Mycelia.ContigPath","text":"ContigPath\n\nRepresents a linear path through the graph forming a contig.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.DQNPolicy","page":"Home","title":"Mycelia.DQNPolicy","text":"DQNPolicy\n\nDeep Q-Network policy for high-level assembly decisions.\n\nThis is a placeholder structure for the neural network architecture that will be implemented with a machine learning framework like Flux.jl or MLJ.jl.\n\nFields\n\nstate_dim::Int: Dimension of state representation\naction_dim::Int: Number of possible actions\nhidden_dims::Vector{Int}: Hidden layer dimensions\nlearning_rate::Float64: Learning rate for training\nepsilon::Float64: Exploration rate for epsilon-greedy policy\nexperience_buffer::Vector{Any}: Experience replay buffer\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.FastqQualityResults","page":"Home","title":"Mycelia.FastqQualityResults","text":"Stores comprehensive FASTQ quality analysis results.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.GraphMode","page":"Home","title":"Mycelia.GraphMode","text":"Graph mode for handling strand information.\n\nSingleStrand: Sequences are single-stranded (RNA, amino acids, or directional DNA)\nDoubleStrand: Sequences are double-stranded DNA/RNA with canonical representation\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.GraphPath","page":"Home","title":"Mycelia.GraphPath","text":"Represents a complete path through the k-mer graph.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.KmerEdgeData","page":"Home","title":"Mycelia.KmerEdgeData","text":"Type-stable metadata for k-mer graph edges.\n\nEdges represent valid strand-aware transitions between canonical k-mers. The transition is valid only if the strand orientations allow for proper overlap.\n\nFields:\n\ncoverage: Vector of edge traversal observations with strand information\nweight: Edge weight/confidence score based on coverage\nsrc_strand: Required strand orientation of source k-mer for this transition\ndst_strand: Required strand orientation of destination k-mer for this transition\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.KmerVertexData","page":"Home","title":"Mycelia.KmerVertexData","text":"Type-stable metadata for k-mer graph vertices.\n\nVertices always represent canonical k-mers for memory efficiency and cleaner graphs. Strand information is tracked in the coverage data and edge transitions.\n\nFields:\n\ncoverage: Vector of observation coverage data as (observationid, position, strandorientation) tuples\ncanonical_kmer: The canonical k-mer (BioSequence type - NO string conversion)\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.PangenomeAnalysisResult","page":"Home","title":"Mycelia.PangenomeAnalysisResult","text":"PangenomeAnalysisResult\n\nResults of k-mer based pangenome analysis.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.QualityBioSequenceEdgeData","page":"Home","title":"Mycelia.QualityBioSequenceEdgeData","text":"Quality-aware BioSequence edge data.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.QualityBioSequenceVertexData","page":"Home","title":"Mycelia.QualityBioSequenceVertexData","text":"Quality-aware BioSequence vertex data.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.QualityDistribution","page":"Home","title":"Mycelia.QualityDistribution","text":"Stores quality distribution statistics for FASTQ analysis.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.QualmerEdgeData","page":"Home","title":"Mycelia.QualmerEdgeData","text":"Edge data for quality-aware k-mer graphs.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.QualmerObservation","page":"Home","title":"Mycelia.QualmerObservation","text":"Qualmer observation for tracking k-mer occurrences in sequences.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.QualmerVertexData","page":"Home","title":"Mycelia.QualmerVertexData","text":"Vertex data for quality-aware k-mer graphs.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.RepeatRegion","page":"Home","title":"Mycelia.RepeatRegion","text":"RepeatRegion\n\nRepresents a repetitive region in the assembly graph.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.RewardComponents","page":"Home","title":"Mycelia.RewardComponents","text":"RewardComponents\n\nStructured representation of reward signal components for training the RL agent.\n\nFields\n\naccuracy_reward::Float64: Primary reward based on assembly accuracy (weighted 1000x)\nefficiency_reward::Float64: Secondary reward for computational efficiency (weighted 10x)\nerror_penalty::Float64: Penalty for false positives/negatives (weighted -500x)\nprogress_bonus::Float64: Bonus for making meaningful progress\ntermination_reward::Float64: Reward for appropriate termination timing\ntotal_reward::Float64: Weighted sum of all components\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.ScaffoldResult","page":"Home","title":"Mycelia.ScaffoldResult","text":"ScaffoldResult\n\nResults from scaffolding analysis.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.StrandOrientation","page":"Home","title":"Mycelia.StrandOrientation","text":"Strand orientation for k-mer observations and transitions.\n\nForward: k-mer as observed (5' to 3')\nReverse: reverse complement of k-mer (3' to 5')\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.ViterbiConfig","page":"Home","title":"Mycelia.ViterbiConfig","text":"ViterbiConfig\n\nConfiguration for Viterbi algorithm parameters.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.ViterbiPath","page":"Home","title":"Mycelia.ViterbiPath","text":"ViterbiPath\n\nComplete Viterbi path through the k-mer graph.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.ViterbiState","page":"Home","title":"Mycelia.ViterbiState","text":"ViterbiState\n\nState information for Viterbi algorithm on k-mer graphs.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.WalkStep","page":"Home","title":"Mycelia.WalkStep","text":"Represents a step in a probabilistic walk through the graph.\n\n\n\n\n\n","category":"type"},{"location":"#Mycelia.JLD2_read_table-Tuple{String}","page":"Home","title":"Mycelia.JLD2_read_table","text":"JLD2_read_table(filename::String) -> Any\n\n\nRead a DataFrame from a JLD2 file without needing to know the internal name. If the file contains multiple DataFrames, returns the first one found.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.JLD2_write_table-Tuple{}","page":"Home","title":"Mycelia.JLD2_write_table","text":"JLD2_write_table(; df, filename)\n\n\nWrite a DataFrame to a JLD2 file using a standardized internal name.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._add_biosequence_edges!-Tuple{MetaGraphsNext.MetaGraph, Vector{FASTX.FASTA.Record}, Mycelia.GraphMode, Int64}","page":"Home","title":"Mycelia._add_biosequence_edges!","text":"Add edges to BioSequence graph based on sequence overlaps.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._add_biosequence_edges_from_paths!-Tuple{MetaGraphsNext.MetaGraph, Vector{Vector{Any}}, MetaGraphsNext.MetaGraph}","page":"Home","title":"Mycelia._add_biosequence_edges_from_paths!","text":"Add edges between BioSequences based on k-mer path relationships.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._add_observation_to_graph!-NTuple{5, Any}","page":"Home","title":"Mycelia._add_observation_to_graph!","text":"_add_observation_to_graph!(\n    graph,\n    observation,\n    obs_idx,\n    canonical_kmers,\n    graph_mode\n)\n\n\nAdd a sequence observation to an existing k-mer graph with strand-aware edge creation.\n\nArguments\n\ngraph: MetaGraphsNext k-mer graph with canonical vertices\nobservation: FASTA/FASTQ record\nobs_idx: Observation index\ncanonical_kmers: Vector of canonical k-mers in the graph\ngraph_mode: SingleStrand or DoubleStrand mode\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._add_quality_biosequence_edges!-Tuple{MetaGraphsNext.MetaGraph, Vector{FASTX.FASTQ.Record}, Mycelia.GraphMode, Int64, UInt8}","page":"Home","title":"Mycelia._add_quality_biosequence_edges!","text":"Add quality-weighted edges to BioSequence graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._add_quality_biosequence_edges_from_qualmer_paths!-Tuple{MetaGraphsNext.MetaGraph, Vector{Vector{Any}}, MetaGraphsNext.MetaGraph}","page":"Home","title":"Mycelia._add_quality_biosequence_edges_from_qualmer_paths!","text":"Add edges between quality-aware BioSequences based on qualmer path relationships.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._add_qualmer_edges!-Union{Tuple{KmerT}, Tuple{MetaGraphsNext.MetaGraph, Dict{KmerT, Mycelia.QualmerVertexData}, Vector{FASTX.FASTQ.Record}, Int64, Mycelia.GraphMode}} where KmerT","page":"Home","title":"Mycelia._add_qualmer_edges!","text":"Add edges to the qualmer graph based on k-mer adjacency in sequences.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._add_strand_aware_edge!-NTuple{7, Any}","page":"Home","title":"Mycelia._add_strand_aware_edge!","text":"Helper function to add strand-aware coverage data to an edge.\n\nThis function creates edges that respect strand orientation constraints. Each edge represents a biologically valid transition between k-mers.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._add_vertex_coverage!-NTuple{5, Any}","page":"Home","title":"Mycelia._add_vertex_coverage!","text":"Helper function to add coverage data to a vertex.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._assemble_biosequence_graph-Tuple{Any, Any}","page":"Home","title":"Mycelia._assemble_biosequence_graph","text":"BioSequence graph assembly implementation (variable-length simplified from k-mer graphs).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._assemble_hybrid_olc-Tuple{Any, Any}","page":"Home","title":"Mycelia._assemble_hybrid_olc","text":"Hybrid OLC assembly (placeholder for future implementation).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._assemble_kmer_graph-Tuple{Any, Any}","page":"Home","title":"Mycelia._assemble_kmer_graph","text":"K-mer graph assembly implementation (fixed-length k-mer foundation).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._assemble_multi_k-Tuple{Any, Any}","page":"Home","title":"Mycelia._assemble_multi_k","text":"Multi-k assembly (placeholder for future implementation).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._assemble_ngram_graph-Tuple{Any, Any}","page":"Home","title":"Mycelia._assemble_ngram_graph","text":"N-gram graph assembly implementation (fixed-length unicode character analysis).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._assemble_quality_biosequence_graph-Tuple{Any, Any}","page":"Home","title":"Mycelia._assemble_quality_biosequence_graph","text":"Quality-aware BioSequence graph assembly implementation (variable-length simplified from qualmer graphs).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._assemble_qualmer_graph-Tuple{Any, Any}","page":"Home","title":"Mycelia._assemble_qualmer_graph","text":"Quality-aware k-mer graph assembly implementation (fixed-length qualmer foundation).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._assemble_string_graph-Tuple{Any, Any}","page":"Home","title":"Mycelia._assemble_string_graph","text":"String graph assembly implementation (variable-length simplified from N-gram graphs).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._calculate_l_statistic-Tuple{Any, Any}","page":"Home","title":"Mycelia._calculate_l_statistic","text":"_calculate_l_statistic(sorted_lengths, threshold)\n\nCalculate L-statistic (number of contigs needed to reach a given percentage of total assembly length). For example, L50 is the number of contigs needed to reach 50% of the total assembly length.\n\nArguments\n\nsorted_lengths: Vector of contig lengths sorted in descending order\nthreshold: Fraction of total length (e.g., 0.5 for L50, 0.9 for L90)\n\nReturns\n\nInt: Number of contigs needed to reach the threshold\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._calculate_n_statistic-Tuple{Any, Any}","page":"Home","title":"Mycelia._calculate_n_statistic","text":"Calculate N-statistic (N50, N90, etc.) for contig lengths.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._calculate_path_coverage-Tuple{Vector, MetaGraphsNext.MetaGraph}","page":"Home","title":"Mycelia._calculate_path_coverage","text":"Calculate coverage for a path from constituent k-mers.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._calculate_qualmer_path_coverage-Tuple{Vector, MetaGraphsNext.MetaGraph}","page":"Home","title":"Mycelia._calculate_qualmer_path_coverage","text":"Calculate coverage for qualmer path.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._calculate_transition_probabilities-Tuple{Any}","page":"Home","title":"Mycelia._calculate_transition_probabilities","text":"Helper function to calculate normalized transition probabilities.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._check_conda_env_exists-Tuple{AbstractString}","page":"Home","title":"Mycelia._check_conda_env_exists","text":"_check_conda_env_exists(env_name::AbstractString) -> Bool\n\nCheck if a conda environment exists.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._contigs_to_records-Tuple{Any}","page":"Home","title":"Mycelia._contigs_to_records","text":"Convert contigs to FASTA records for graph construction.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._create_empty_kmer_graph-Tuple{Any}","page":"Home","title":"Mycelia._create_empty_kmer_graph","text":"Helper function to create an empty k-mer graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._detect_sequence_extension-Tuple{Symbol}","page":"Home","title":"Mycelia._detect_sequence_extension","text":"_detect_sequence_extension(sequence_type::Symbol) -> String\n\n\nInternal helper function to convert sequence type to file extension.\n\nArguments\n\nsequence_type: Symbol representing sequence type (:DNA, :RNA, or :AA)\n\nReturns\n\nString: Appropriate file extensions\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._determine_kmer_type-Tuple{Any, Any}","page":"Home","title":"Mycelia._determine_kmer_type","text":"Determine appropriate k-mer type from observations.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._determine_strand-Tuple{Mycelia.Qualmer, Mycelia.Qualmer}","page":"Home","title":"Mycelia._determine_strand","text":"Determine strand orientation by comparing original and canonical qualmers.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._find_linear_paths-Tuple{MetaGraphsNext.MetaGraph, Int64}","page":"Home","title":"Mycelia._find_linear_paths","text":"Find linear paths in a k-mer graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._find_linear_qualmer_paths-Tuple{MetaGraphsNext.MetaGraph, Int64}","page":"Home","title":"Mycelia._find_linear_qualmer_paths","text":"Find linear paths in a qualmer graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._find_quality_sequence_overlap-Tuple{Any, Any, Mycelia.QualityBioSequenceVertexData, Mycelia.QualityBioSequenceVertexData, Int64}","page":"Home","title":"Mycelia._find_quality_sequence_overlap","text":"Find quality-weighted overlap between two sequences.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._find_qualmer_paths-Tuple{Any, Any}","page":"Home","title":"Mycelia._find_qualmer_paths","text":"Find quality-aware paths in a qualmer graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._find_sequence_overlap-Tuple{Any, Any, Int64}","page":"Home","title":"Mycelia._find_sequence_overlap","text":"Find overlap between two sequences.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._generate_contigs_from_qualmer_graph-Tuple{Any, Any}","page":"Home","title":"Mycelia._generate_contigs_from_qualmer_graph","text":"Generate contigs from qualmer graph using probabilistic walks.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._generate_contigs_probabilistic-Tuple{Any, Any}","page":"Home","title":"Mycelia._generate_contigs_probabilistic","text":"Generate contigs using probabilistic walks when Eulerian paths are not available.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._get_output_files-Tuple{AbstractString}","page":"Home","title":"Mycelia._get_output_files","text":"_get_output_files(output_dir::AbstractString) -> Vector{String}\n\nGet a list of all files in the output directory.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._get_valid_transitions-Tuple{Any, Any, Any}","page":"Home","title":"Mycelia._get_valid_transitions","text":"Helper function to get valid transitions from a vertex with given strand orientation.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._is_valid_qualmer_transition-Tuple{Any, Any, Mycelia.StrandOrientation, Mycelia.StrandOrientation}","page":"Home","title":"Mycelia._is_valid_qualmer_transition","text":"Validate that the transition between two k-mers is biologically valid.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._is_valid_transition-NTuple{5, Any}","page":"Home","title":"Mycelia._is_valid_transition","text":"_is_valid_transition(\n    src_kmer,\n    dst_kmer,\n    src_strand,\n    dst_strand,\n    k\n) -> Any\n\n\nValidate that a transition between two k-mers with given strand orientations is biologically valid.\n\nFor a transition to be valid, the suffix of the source k-mer must match the prefix of the  destination k-mer when accounting for strand orientations.\n\nArguments\n\nsrc_kmer: Source canonical k-mer\ndst_kmer: Destination canonical k-mer  \nsrc_strand: Strand orientation of source k-mer\ndst_strand: Strand orientation of destination k-mer\nk: K-mer size\n\nReturns\n\nBool: true if transition is biologically valid\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._path_to_sequence-Tuple{Any, Any}","page":"Home","title":"Mycelia._path_to_sequence","text":"Convert a path of vertices to a DNA sequence.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._polish_contig_viterbi-Tuple{Any, Any, Any}","page":"Home","title":"Mycelia._polish_contig_viterbi","text":"Polish a single contig using Viterbi error correction.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._prepare_fastq_observations-Tuple{Any}","page":"Home","title":"Mycelia._prepare_fastq_observations","text":"Convert observations to FASTQ records for quality processing.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._prepare_observations-Tuple{Any}","page":"Home","title":"Mycelia._prepare_observations","text":"Prepare observations from various input formats (FASTA/FASTQ records or file paths).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._qualmer_path_to_sequence-Tuple{Any, Any}","page":"Home","title":"Mycelia._qualmer_path_to_sequence","text":"Convert qualmer path to DNA sequence.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._reconstruct_sequence_and_quality_from_qualmer_path-Tuple{Vector, MetaGraphsNext.MetaGraph, Type}","page":"Home","title":"Mycelia._reconstruct_sequence_and_quality_from_qualmer_path","text":"Reconstruct sequence and quality from qualmer path.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._reconstruct_sequence_from_kmer_path-Tuple{Vector, Type}","page":"Home","title":"Mycelia._reconstruct_sequence_from_kmer_path","text":"Reconstruct a BioSequence from a path of k-mers.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._reconstruct_sequence_from_path-Tuple{Any}","page":"Home","title":"Mycelia._reconstruct_sequence_from_path","text":"Helper function to reconstruct sequence from a graph path.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._reconstruct_shortest_path-NTuple{5, Any}","page":"Home","title":"Mycelia._reconstruct_shortest_path","text":"Helper function to reconstruct shortest path from Dijkstra's algorithm.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._sample_transition-Tuple{Any, Any}","page":"Home","title":"Mycelia._sample_transition","text":"Helper function to sample a transition based on probabilities.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._sequence_to_canonical_path-Tuple{Any, Any, Any}","page":"Home","title":"Mycelia._sequence_to_canonical_path","text":"_sequence_to_canonical_path(\n    canonical_kmers,\n    sequence,\n    graph_mode\n) -> Vector{<:Tuple{Any, Mycelia.StrandOrientation}}\n\n\nConvert a sequence to a path through canonical k-mer space with strand awareness.\n\nThis is the key function that handles the distinction between single-strand and  double-strand modes while maintaining canonical k-mer vertices.\n\nArguments\n\ncanonical_kmers: Vector of canonical k-mers available in the graph\nsequence: DNA/RNA sequence to convert\ngraph_mode: SingleStrand or DoubleStrand mode\n\nReturns\n\nVector of (canonicalkmer, strandorientation) pairs representing the path\n\nDetails\n\nIn DoubleStrand mode:\n\nEach observed k-mer is converted to its canonical form\nStrand orientation tracks whether the canonical form matches the observed k-mer\nEdges respect the biological constraint that transitions must maintain proper overlap\n\nIn SingleStrand mode:\n\nK-mers are used as-is (no reverse complement consideration)\nAll strand orientations are Forward\nSuitable for RNA, amino acids, or directional DNA analysis\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._setup_phageboost_environment","page":"Home","title":"Mycelia._setup_phageboost_environment","text":"_setup_phageboost_environment(force_reinstall::Bool=false)\n\nSet up the PhageBoost conda environment if it doesn't exist or if force_reinstall is true.\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia._simplify_ngram_graph-Tuple{Any}","page":"Home","title":"Mycelia._simplify_ngram_graph","text":"Simplify N-gram graph by removing unnecessary complexity.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._simplify_ngram_to_string_graph-Tuple{Any}","page":"Home","title":"Mycelia._simplify_ngram_to_string_graph","text":"Convert N-gram graph to variable-length string graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._simplify_string_graph-Tuple{Any}","page":"Home","title":"Mycelia._simplify_string_graph","text":"Simplify string graph by removing unnecessary complexity.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia._validate_against_reference-Tuple{Any, Any}","page":"Home","title":"Mycelia._validate_against_reference","text":"Validate assembly against reference sequence (placeholder).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.accuracy-Tuple{Any, Any}","page":"Home","title":"Mycelia.accuracy","text":"accuracy(true_labels, pred_labels)\n\nReturns the overall accuracy.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.add_bioconda_env-Tuple{Any}","page":"Home","title":"Mycelia.add_bioconda_env","text":"add_bioconda_env(pkg; force) -> Union{Nothing, Base.Process}\n\n\nCreate a new Conda environment with a specified Bioconda package.\n\nArguments\n\npkg::String: Package name to install. Can include channel specification using \n\nthe format \"channel::package\"\n\nKeywords\n\nforce::Bool=false: If true, recreates the environment even if it already exists\n\nDetails\n\nThe function creates a new Conda environment named after the package and installs the package into it. It uses channel priority: conda-forge > bioconda > defaults. If CONDA_RUNNER is set to 'mamba', it will ensure mamba is installed first.\n\nExamples\n\n# Install basic package\nadd_bioconda_env(\"blast\")\n\n# Install from specific channel\nadd_bioconda_env(\"bioconda::blast\")\n\n# Force reinstallation\nadd_bioconda_env(\"blast\", force=true)\n\nNotes\n\nRequires Conda.jl to be installed and configured\nUses CONDA_RUNNER global variable to determine whether to use conda or mamba\nCleans conda cache after installation\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.add_edgemer_to_graph!-NTuple{4, Any}","page":"Home","title":"Mycelia.add_edgemer_to_graph!","text":"add_edgemer_to_graph!(\n    graph,\n    record_identifier,\n    index,\n    observed_edgemer\n) -> Any\n\n\nAdd an observed edgemer to a graph with its associated metadata.\n\nArguments\n\ngraph::MetaGraph: The graph to modify\nrecord_identifier: Identifier for the source record\nindex: Position where edgemer was observed\nobserved_edgemer: The biological sequence representing the edgemer\n\nDetails\n\nProcesses the edgemer by:\n\nSplitting it into source and destination kmers\nConverting kmers to their canonical forms\nCreating or updating an edge with orientation metadata\nStoring observation details (record, position, orientation)\n\nReturns\n\nModified graph with the new edge and metadata\n\nNote\n\nIf the edge already exists, the observation is added to the existing metadata.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.add_fastx_records_to_graph!-Tuple{Any, Any}","page":"Home","title":"Mycelia.add_fastx_records_to_graph!","text":"add_fastx_records_to_graph!(graph, fastxs) -> Any\n\n\nAdd FASTX records from multiple files as a graph property.\n\nArguments\n\ngraph: A MetaGraph that will store the FASTX records\nfastxs: Collection of FASTA/FASTQ file paths to process\n\nDetails\n\nCreates a dictionary mapping sequence descriptions to their corresponding FASTX records, then stores this dictionary as a graph property under the key :records. Multiple input files are merged, with later files overwriting records with duplicate descriptions.\n\nReturns\n\nThe modified graph with added records property.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.add_record_edgemers_to_graph!-Tuple{Any}","page":"Home","title":"Mycelia.add_record_edgemers_to_graph!","text":"add_record_edgemers_to_graph!(graph) -> Any\n\n\nProcesses DNA sequence records stored in the graph and adds their edgemers (k+1 length subsequences)  to build the graph structure.\n\nArguments\n\ngraph: A Mycelia graph object containing DNA sequence records and graph properties\n\nDetails\n\nUses the k-mer size specified in graph.gprops[:k] to generate k+1 length edgemers\nIterates through each record in graph.gprops[:records]\nFor each record, generates all possible overlapping edgemers\nAdds each edgemer to the graph with its position and record information\n\nReturns\n\nThe modified graph object with added edgemer information\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.adjust_quality_scores-Tuple{String, String, Float64}","page":"Home","title":"Mycelia.adjust_quality_scores","text":"Adjust quality scores based on likelihood improvement.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.alphabet_to_biosequence_type-Tuple{Symbol}","page":"Home","title":"Mycelia.alphabet_to_biosequence_type","text":"alphabet_to_biosequence_type(\n    alphabet::Symbol\n) -> Union{Type{BioSequences.LongAA}, Type{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}, Type{BioSequences.LongSequence{BioSequences.RNAAlphabet{4}}}}\n\n\nDetermine the BioSequence type from an alphabet symbol.\n\nMaps alphabet symbols to the corresponding BioSequences.jl type for  type-safe sequence operations throughout the codebase.\n\nArguments\n\nalphabet::Symbol: The alphabet symbol (:DNA, :RNA, or :AA)\n\nReturns\n\nType{<:BioSequences.BioSequence}: The corresponding BioSequence type\n\nExamples\n\nalphabet_to_biosequence_type(:DNA)  # Returns BioSequences.LongDNA{4}\nalphabet_to_biosequence_type(:RNA)  # Returns BioSequences.LongRNA{4}\nalphabet_to_biosequence_type(:AA)   # Returns BioSequences.LongAA\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.amino_acids_to_codons-Tuple{}","page":"Home","title":"Mycelia.amino_acids_to_codons","text":"amino_acids_to_codons(\n\n) -> Dict{BioSymbols.AminoAcid, DataType}\n\n\nCreates a mapping from amino acids to representative DNA codons using the standard genetic code.\n\nReturns\n\nDictionary mapping each amino acid (including stop codon AA_Term) to a valid DNA codon that encodes it\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.analyze_fastq_quality-Tuple{String}","page":"Home","title":"Mycelia.analyze_fastq_quality","text":"analyze_fastq_quality(fastq_file::String)\n\nAnalyzes quality metrics for a FASTQ file.\n\nCalculates comprehensive quality statistics including read count, quality scores, length distribution, GC content, and quality threshold percentages.\n\nArguments\n\nfastq_file: Path to FASTQ file (can be gzipped)\n\nReturns\n\nFastqQualityResults with the following fields:\n\nn_reads: Total number of reads\nmean_quality: Average Phred quality score across all reads\nmean_length: Average read length\ngc_content: GC content percentage\nquality_distribution: QualityDistribution with Q20+, Q30+, Q40+ percentages\n\nExample\n\nquality_stats = Mycelia.analyze_fastq_quality(\"reads.fastq\")\nprintln(\"Total reads: $(quality_stats.n_reads)\")\nprintln(\"Mean quality: $(quality_stats.mean_quality)\")\nprintln(\"Q30+ reads: $(quality_stats.quality_distribution.q30_percent)%\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.analyze_pangenome_kmers-Tuple{Vector{String}}","page":"Home","title":"Mycelia.analyze_pangenome_kmers","text":"analyze_pangenome_kmers(genome_files::Vector{String}; kmer_type=Kmers.DNAKmer{21}, distance_metric=:jaccard)\n\nPerform comprehensive k-mer based pangenome analysis using existing Mycelia infrastructure.\n\nLeverages existing count_canonical_kmers and distance metric functions to analyze genomic content across multiple genomes, identifying core, accessory, and unique regions.\n\nArguments\n\ngenome_files: Vector of FASTA file paths containing genome sequences\nkmer_type: K-mer type from Kmers.jl (default: Kmers.DNAKmer{21})\ndistance_metric: Distance metric (:jaccard, :bray_curtis, :cosine, :js_divergence)\n\nReturns\n\nPangenomeAnalysisResult with comprehensive pangenome statistics\n\nExample\n\ngenome_files = [\"genome1.fasta\", \"genome2.fasta\", \"genome3.fasta\"]\nresult = Mycelia.analyze_pangenome_kmers(genome_files, kmer_type=Kmers.DNAKmer{31})\nprintln(\"Core k-mers: $(length(result.core_kmers))\")\nprintln(\"Total pangenome size: $(size(result.presence_absence_matrix, 1)) k-mers\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.analyze_repeat_region-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, String, Int64}","page":"Home","title":"Mycelia.analyze_repeat_region","text":"Analyze a potential repeat region starting from a vertex.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.annotate_aa_fasta-Tuple{}","page":"Home","title":"Mycelia.annotate_aa_fasta","text":"annotate_aa_fasta(\n;\n    fasta,\n    identifier,\n    basedir,\n    mmseqsdb,\n    threads\n)\n\n\nAnnotate amino acid sequences in a FASTA file using MMseqs2 search against UniRef50 database.\n\nArguments\n\nfasta: Path to input FASTA file containing amino acid sequences\nidentifier: Name for the output directory (defaults to FASTA filename without extension)\nbasedir: Base directory for output (defaults to current directory)\nmmseqsdb: Path to MMseqs2 formatted UniRef50 database (defaults to ~/workspace/mmseqs/UniRef50)\nthreads: Number of CPU threads to use (defaults to system thread count)\n\nReturns\n\nPath to the output directory containing MMseqs2 search results\n\nThe function creates a new directory named by identifier under basedir, copies the input FASTA file, and runs MMseqs2 easy-search against the specified database. If the output directory already exists, the function skips processing and returns the directory path.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.annotate_fasta-Tuple{}","page":"Home","title":"Mycelia.annotate_fasta","text":"annotate_fasta(\n;\n    fasta,\n    identifier,\n    basedir,\n    mmseqsdb,\n    threads\n)\n\n\nPerform comprehensive annotation of a FASTA file including gene prediction, protein homology search, and terminator prediction.\n\nArguments\n\nfasta::String: Path to input FASTA file\nidentifier::String: Unique identifier for output directory (default: FASTA filename without extension)\nbasedir::String: Base directory for output (default: current working directory)\nmmseqsdb::String: Path to MMseqs2 UniRef50 database (default: joinpath(homedir(), \"workspace/mmseqs/UniRef50\"))\nthreads::Int: Number of CPU threads to use (default: all available). Note: This argument is not explicitly used by Pyrodigal or MMseqs2 in this version of the function, they might use their own defaults or require modifications to run_pyrodigal or run_mmseqs_easy_search to respect it.\n\nProcessing Steps\n\nCreates output directory and copies input FASTA.\nRuns Pyrodigal for gene prediction (nucleotide, amino acid, and GFF output).\nPerforms MMseqs2 homology search against UniRef50.\nPredicts terminators using TransTerm.\nCombines annotations into a unified GFF file.\nGenerates GenBank format output.\n\nReturns\n\nString: Path to the output directory containing all generated files.\n\nFiles Generated (within the output directory specified by identifier)\n\n(basename(fasta)).pyrodigal.fna: Predicted genes (nucleotide) from Pyrodigal.\n(basename(fasta)).pyrodigal.faa: Predicted proteins from Pyrodigal.\n(basename(fasta)).pyrodigal.gff: Pyrodigal GFF annotations.\n(basename(fasta)).gff: Combined GFF annotations (MMseqs2 and TransTerm).\n(basename(fasta)).gff.genbank: Final GenBank format from the first combined GFF.\n(basename(fasta)).transterm_raw.gff: Combined GFF (MMseqs2 and a second TransTerm run).\n(basename(fasta)).transterm_raw.gff.genbank: Final GenBank format from the second combined GFF.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.apply_learned_policy-Tuple{Mycelia.DQNPolicy, String}","page":"Home","title":"Mycelia.apply_learned_policy","text":"apply_learned_policy(policy::DQNPolicy, input_fastq::String; output_dir=\"rl_assembly\")\n\nApply a trained RL policy to perform genome assembly.\n\nThis function uses a trained policy to make autonomous assembly decisions.\n\nArguments\n\npolicy::DQNPolicy: Trained assembly policy\ninput_fastq::String: Path to input FASTQ file\noutput_dir::String: Output directory for assembly results\n\nReturns\n\nDict{String, Any}: Assembly results and metadata\n\nExample\n\nresults = apply_learned_policy(trained_policy, \"genome.fastq\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.are_equivalent_bubbles-Tuple{Mycelia.BubbleStructure, Mycelia.BubbleStructure}","page":"Home","title":"Mycelia.are_equivalent_bubbles","text":"Check if two bubbles are equivalent.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assemble_genome-Tuple{Any}","page":"Home","title":"Mycelia.assemble_genome","text":"assemble_genome(reads; method=StringGraph, config=AssemblyConfig()) -> AssemblyResult\n\nUnified genome assembly interface using Phase 2 next-generation algorithms.\n\nArguments\n\nreads: Vector of FASTA/FASTQ records or file paths\nmethod: Assembly strategy (StringGraph, KmerGraph, HybridOLC, MultiK)\nconfig: Assembly configuration parameters\n\nReturns\n\nAssemblyResult: Structure containing contigs, names, and assembly metadata\n\nDetails\n\nThis is the main entry point for the unified assembly pipeline, leveraging:\n\nPhase 1: MetaGraphsNext strand-aware graph construction  \nPhase 2: Probabilistic algorithms, enhanced Viterbi, and graph algorithms\nPhase 3: Integrated workflow with polishing and validation\n\nExamples\n\n# Basic assembly with default parameters\nreads = load_fastq_records(\"reads.fastq\")\nresult = assemble_genome(reads)\n\n# Custom assembly with specific k-mer size and error rate\nconfig = AssemblyConfig(k=25, error_rate=0.005, polish_iterations=5)\nresult = assemble_genome(reads; method=KmerGraph, config=config)\n\n# Access results\ncontigs = result.contigs\nstats = result.assembly_stats\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assemble_strings-Tuple{MetaGraphsNext.MetaGraph{var\"#s35\", Graph} where {var\"#s35\"<:Graphs.SimpleGraphs.AbstractSimpleGraph, Graph<:Graphs.AbstractGraph{var\"#s35\"}}}","page":"Home","title":"Mycelia.assemble_strings","text":"Assemble strings by performing graph walks from each connected component.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assembly_summary-Tuple{Dict{Int64, Any}}","page":"Home","title":"Mycelia.assembly_summary","text":"Generate a summary report of the assembly process.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_alignment-Tuple{Any, Any}","page":"Home","title":"Mycelia.assess_alignment","text":"assess_alignment(\n    a,\n    b\n) -> @NamedTuple{total_matches::Int64, total_edits::Int64}\n\n\nAligns two sequences using the Levenshtein distance and returns the total number of matches and edits.\n\nArguments\n\na::AbstractString: The first sequence to be aligned.\nb::AbstractString: The second sequence to be aligned.\n\nReturns\n\nNamedTuple{(:total_matches, :total_edits), Tuple{Int, Int}}: A named tuple containing:\ntotal_matches::Int: The total number of matching bases in the alignment.\ntotal_edits::Int: The total number of edits (insertions, deletions, substitutions) in the alignment.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_alignment_accuracy-Tuple{Any}","page":"Home","title":"Mycelia.assess_alignment_accuracy","text":"assess_alignment_accuracy(alignment_result) -> Any\n\n\nReturn proportion of matched bases in alignment to total matches + edits.\n\nCalculate the accuracy of a sequence alignment by computing the ratio of matched bases  to total alignment operations (matches + edits).\n\nArguments\n\nalignment_result: Alignment result object containing total_matches and total_edits fields\n\nReturns\n\nFloat64 between 0.0 and 1.0 representing alignment accuracy, where:\n\n1.0 indicates perfect alignment (all matches)\n0.0 indicates no matches\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_assembly_kmer_quality-Tuple{}","page":"Home","title":"Mycelia.assess_assembly_kmer_quality","text":"assess_assembly_kmer_quality(; assembly, observations, ks)\n\n\nEvaluate genome assembly quality by comparing k-mer distributions between assembled sequences and raw observations.\n\nArguments\n\nassembly: Input assembled sequences to evaluate\nobservations: Raw sequencing data for comparison\nks::Vector{Int}: Vector of k-mer sizes to analyze (default: k=17 to 23)\n\nReturns\n\nDataFrame containing quality metrics for each k-mer size:\n\nk: K-mer length used\ncosine_distance: Cosine similarity between k-mer distributions\njs_divergence: Jensen-Shannon divergence between distributions  \nqv: MerQury-style quality value score\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_assembly_quality-Tuple{Any}","page":"Home","title":"Mycelia.assess_assembly_quality","text":"assess_assembly_quality(contigs_file)\n\nAssess basic assembly quality metrics from a FASTA file.\n\nCalculates standard assembly quality metrics including contig count, total length, and N50 statistic for assembly evaluation.\n\nArguments\n\ncontigs_file: Path to FASTA file containing assembly contigs\n\nReturns\n\nTuple of (ncontigs, totallength, n50, l50)\nn_contigs: Number of contigs in the assembly\ntotal_length: Total length of all contigs in base pairs\nn50: N50 statistic (length of shortest contig in the set covering 50% of assembly)\nl50: L50 statistic (number of contigs needed to reach 50% of assembly length)\n\nExample\n\nn_contigs, total_length, n50, l50 = assess_assembly_quality(\"assembly.fasta\")\nprintln(\"Assembly has $n_contigs contigs, $total_length bp total, N50=$n50, L50=$l50\")\n\nSee Also\n\nassess_assembly_kmer_quality: For k-mer based assembly quality assessment\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_dnamer_saturation-Tuple{AbstractString}","page":"Home","title":"Mycelia.assess_dnamer_saturation","text":"assess_dnamer_saturation(\n    fastx::AbstractString;\n    power,\n    outdir,\n    min_k,\n    max_k,\n    threshold,\n    kmers_to_assess\n)\n\n\nAnalyzes k-mer saturation in a FASTA/FASTQ file to determine optimal k-mer size.\n\nArguments\n\nfastx::AbstractString: Path to input FASTA/FASTQ file\npower::Int=10: Exponent for downsampling k-mers (2^power)\noutdir::String=\"\": Output directory for results. Uses current directory if empty\nmin_k::Int=3: Minimum k-mer size to evaluate\nmax_k::Int=17: Maximum k-mer size to evaluate\nthreshold::Float64=0.1: Saturation threshold for k-mer assessment\nkmers_to_assess::Int=10_000_000: Maximum number of k-mers to sample\n\nReturns\n\nDict{Int,Float64}: Dictionary mapping k-mer sizes to their saturation scores\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_dnamer_saturation-Tuple{AbstractVector{<:AbstractString}, Any}","page":"Home","title":"Mycelia.assess_dnamer_saturation","text":"assess_dnamer_saturation(\n    fastxs::AbstractVector{<:AbstractString},\n    kmer_type;\n    kmers_to_assess,\n    power,\n    min_count\n) -> Union{@NamedTuple{sampling_points::Vector{Int64}, unique_kmer_counts::Vector{Int64}}, NamedTuple{(:sampling_points, :unique_kmer_counts, :eof), <:Tuple{Vector, Vector{Int64}, Bool}}}\n\n\nAssess k-mer saturation in DNA sequences from FASTX files.\n\nArguments\n\nfastxs::AbstractVector{<:AbstractString}: Vector of paths to FASTA/FASTQ files\nkmer_type: Type of k-mer to analyze (e.g., DNAKmer{21})\nkmers_to_assess=Inf: Maximum number of k-mers to process\npower=10: Base for exponential sampling intervals\nmin_count=1: Minimum count threshold for considering a k-mer\n\nReturns\n\nNamed tuple containing:\n\nsampling_points::Vector{Int}: K-mer counts at which samples were taken\nunique_kmer_counts::Vector{Int}: Number of unique canonical k-mers at each sampling point\neof::Bool: Whether the entire input was processed\n\nDetails\n\nAnalyzes k-mer saturation by counting unique canonical k-mers at exponentially spaced  intervals (powers of power). Useful for assessing sequence complexity and coverage. Returns early if all possible k-mers are observed.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_dnamer_saturation-Tuple{AbstractVector{<:AbstractString}}","page":"Home","title":"Mycelia.assess_dnamer_saturation","text":"assess_dnamer_saturation(\n    fastxs::AbstractVector{<:AbstractString};\n    power,\n    outdir,\n    min_k,\n    max_k,\n    threshold,\n    kmers_to_assess,\n    plot\n)\n\n\nAnalyze k-mer saturation in DNA sequences to determine optimal k value.\n\nArguments\n\nfastxs: Vector of paths to FASTA/FASTQ files to analyze\npower: Base of logarithmic sampling points (default: 10)\noutdir: Optional output directory for plots and results\nmin_k: Minimum k-mer size to test (default: 7)\nmax_k: Maximum k-mer size to test (default: 17)\nthreshold: Saturation threshold to determine optimal k (default: 0.1)\nkmers_to_assess: Maximum number of k-mers to sample (default: 10M)\nplot: Whether to generate saturation curves (default: true)\n\nReturns\n\nInteger representing the first k value that achieves saturation below threshold. If no k value meets the threshold, returns the k with minimum saturation.\n\nDetails\n\nTests only prime k values between mink and maxk\nGenerates saturation curves using logarithmic sampling\nFits curves to estimate maximum unique k-mers\nIf outdir is provided, saves plots as SVG and chosen k value to text file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_duplication_rates-Tuple{Any}","page":"Home","title":"Mycelia.assess_duplication_rates","text":"assess_duplication_rates(fastq; results_table) -> Any\n\n\nAnalyze sequence duplication rates in a FASTQ file.\n\nThis function processes a FASTQ file to quantify both exact sequence duplications and  canonical duplications (considering sequences and their reverse complements as equivalent). The function makes two passes through the file: first to count total records, then to analyze unique sequences.\n\nArguments\n\nfastq::String: Path to the input FASTQ file to analyze\nresults_table::String: Optional. Path where the results will be saved as a tab-separated file. Defaults to the same path as the input file but with extension changed to \".duplication_rates.tsv\"\n\nReturns\n\nString: Path to the results table file\n\nOutput\n\nGenerates a tab-separated file containing the following metrics:\n\ntotal_records: Total number of sequence records in the file\ntotal_unique_observations: Count of unique sequence strings\ntotal_unique_canonical_observations: Count of unique canonical sequences  (after normalizing for reverse complements)\npercent_unique_observations: Percentage of sequences that are unique\npercent_unique_canonical_observations: Percentage of sequences that are unique after canonicalization\npercent_duplication_rate: Percentage of sequences that are duplicates (100 - percentuniqueobservations)\npercent_canonical_duplication_rate: Percentage of sequences that are duplicates after canonicalization\n\nNotes\n\nIf the specified results file already exists and is not empty, the function will return early without recomputing.\nProgress is displayed during processing with a progress bar showing speed.\n\nExample\n\n# Analyze a FASTQ file and save results to default location\nresult_path = assess_duplication_rates(\"data/sample.fastq\")\n\n# Specify custom output path\nresult_path = assess_duplication_rates(\"data/sample.fastq\", results_table=\"results/duplication_analysis.tsv\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_optimal_kmer_alignment-Tuple{Any, Any}","page":"Home","title":"Mycelia.assess_optimal_kmer_alignment","text":"assess_optimal_kmer_alignment(\n    kmer,\n    observed_kmer\n) -> Tuple{@NamedTuple{total_matches::Int64, total_edits::Int64}, Union{Missing, Bool}}\n\n\nUsed to determine which orientation provides an optimal alignment for initiating path likelihood analyses in viterbi analysis\n\nCompare alignment scores between a query k-mer and an observed k-mer in both forward and reverse complement orientations to determine optimal alignment.\n\nArguments\n\nkmer: Query k-mer sequence to align\nobserved_kmer: Target k-mer sequence to align against\n\nReturns\n\nA tuple containing:\n\nalignment_result: The alignment result object for the optimal orientation\norientation: Boolean indicating orientation (true = forward, false = reverse complement, missing = tied scores)\n\nDetails\n\nPerforms pairwise alignment in both orientations using assess_alignment()\nCalculates accuracy scores using assess_alignment_accuracy()\nFor tied alignment scores, randomly selects one orientation\nUses BioSequences.reverse_complement for reverse orientation comparison\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.attempt_error_correction-Tuple{Any, Any, Any}","page":"Home","title":"Mycelia.attempt_error_correction","text":"Attempt to correct a specific k-mer using probabilistic path finding. Returns true if correction was applied.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.bam_to_fastq-Tuple{}","page":"Home","title":"Mycelia.bam_to_fastq","text":"bam_to_fastq(; bam, fastq)\n\n\nConvert a BAM file to FASTQ format with gzip compression.\n\nArguments\n\nbam: Path to input BAM file\nfastq: Optional output path. Defaults to input path with \".fq.gz\" extension\n\nReturns\n\nPath to the generated FASTQ file\n\nDetails\n\nUses samtools through conda environment\nAutomatically skips if output file exists\nOutput is gzip compressed\nRequires samtools to be available via conda\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.bandage_visualize-Tuple{}","page":"Home","title":"Mycelia.bandage_visualize","text":"bandage_visualize(; gfa, img)\n\n\nGenerate a visualization of a genome assembly graph using Bandage.\n\nArguments\n\ngfa: Path to input GFA (Graphical Fragment Assembly) file\nimg: Optional output image path. Defaults to GFA filename with .png extension\n\nReturns\n\nPath to the generated image file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.benchmark_graph_construction","page":"Home","title":"Mycelia.benchmark_graph_construction","text":"benchmark_graph_construction()\nbenchmark_graph_construction(\n    config::Mycelia.BenchmarkConfig\n)\n\n\nBenchmark graph construction performance: Legacy vs Next-generation.\n\nCompares:\n\nMetaGraphs.jl (legacy) vs MetaGraphsNext.jl (next-gen)\nMemory allocation patterns\nConstruction time\nType stability\n\nArguments\n\nconfig: BenchmarkConfig for test parameters\n\nReturns\n\nNamedTuple with benchmark results\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.benchmark_memory_patterns","page":"Home","title":"Mycelia.benchmark_memory_patterns","text":"benchmark_memory_patterns()\nbenchmark_memory_patterns(config::Mycelia.BenchmarkConfig)\n\n\nBenchmark memory usage patterns for different graph representations.\n\nCompares memory usage of:\n\nStranded vertices (legacy) vs canonical vertices (next-gen)\nEdge metadata structures\nCoverage tracking efficiency\n\nArguments\n\nconfig: BenchmarkConfig for test parameters\n\nReturns\n\nNamedTuple with memory analysis results\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.benchmark_type_stability","page":"Home","title":"Mycelia.benchmark_type_stability","text":"benchmark_type_stability()\nbenchmark_type_stability(config::Mycelia.BenchmarkConfig)\n\n\nBenchmark type stability and allocation patterns.\n\nMeasures:\n\nType inference success\nRuntime allocations\nPerformance predictability\n\nArguments\n\nconfig: BenchmarkConfig for test parameters\n\nReturns\n\nNamedTuple with type stability metrics\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.bernoulli_pca_epca-Tuple{AbstractMatrix{Bool}}","page":"Home","title":"Mycelia.bernoulli_pca_epca","text":"bernoullipcaepca(M::AbstractMatrix{Bool}; k::Int=0)\n\nPerform Bernoulli (logistic) EPCA on a 0/1 matrix M (features × samples).\n\nWhen to use\n\nUse for binary (0/1) data, such as presence/absence or yes/no features.\n\nReturns\n\nA NamedTuple with\n\nmodel    : the fitted ExpFamilyPCA.BernoulliEPCA object  \nscores   : k×n_samples matrix of low‐dimensional sample scores  \nloadings : k×n_features matrix of feature loadings  \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.best_label_mapping-Tuple{Any, Any}","page":"Home","title":"Mycelia.best_label_mapping","text":"best_label_mapping(true_labels, pred_labels)\n\nFinds the optimal mapping from predicted labels to true labels using the Hungarian algorithm, so that the total overlap (confusion matrix diagonal) is maximized. Returns the remapped predicted labels and the mapping as a Dict.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.binary_matrix_to_jaccard_distance_matrix-Tuple{Union{BitMatrix, Matrix{Bool}}}","page":"Home","title":"Mycelia.binary_matrix_to_jaccard_distance_matrix","text":"binary_matrix_to_jaccard_distance_matrix(binary_matrix::Union{BitMatrix, Matrix{Bool}})\n\nPairwise Jaccard distance between columns of a binary matrix (BitMatrix or Matrix{Bool}). Throws an error if the input is not strictly a binary matrix.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.binomial_pca_epca-Tuple{AbstractMatrix{<:Integer}}","page":"Home","title":"Mycelia.binomial_pca_epca","text":"binomial_pca_epca(M::AbstractMatrix{<:Integer}; k::Int=0, ntrials::Int=1)\n\nPerform Binomial EPCA on a count matrix M (features × samples).\n\nWhen to use\n\nUse for integer count data representing the number of successes out of a fixed number of trials (e.g., number of mutated alleles out of total alleles).\n\nKeyword arguments\n\nk : desired number of latent dimensions; if k<1 defaults to min(n_samples-1, n_features, 10)\nntrials : number of trials for the Binomial distribution (default=1)\n\nReturns\n\nNamedTuple with fields\n\nmodel    : the fitted ExpFamilyPCA.BinomialEPCA object  \nscores   : k×n_samples matrix of sample scores  \nloadings : k×n_features matrix of feature loadings  \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.biosequences_to_counts_table-Tuple{}","page":"Home","title":"Mycelia.biosequences_to_counts_table","text":"biosequences_to_counts_table(; biosequences, k)\n\n\nConvert a collection of biological sequences into a k-mer count matrix.\n\nArguments\n\nbiosequences: Vector of biological sequences (DNA, RNA, or Amino Acids)\nk: Length of k-mers to count\n\nReturns\n\nNamed tuple with:\n\nsorted_kmers: Vector of all unique k-mers found, lexicographically sorted\nkmer_counts_matrix: Sparse matrix where rows are k-mers and columns are sequences\n\nDetails\n\nFor DNA sequences, counts canonical k-mers (both strands)\nUses parallel processing with Thread-safe progress tracking\nMemory efficient sparse matrix representation\nSupports DNA, RNA and Amino Acid sequences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.biosequences_to_dense_counts_table-Tuple{}","page":"Home","title":"Mycelia.biosequences_to_dense_counts_table","text":"biosequences_to_dense_counts_table(; biosequences, k)\n\n\nConvert a collection of biological sequences into a dense k-mer count matrix.\n\nArguments\n\nbiosequences: Collection of DNA, RNA, or amino acid sequences (BioSequence types)\nk::Integer: Length of k-mers to count (must be ≤ 13)\n\nReturns\n\nNamed tuple containing:\n\nsorted_kmers: Vector of all possible k-mers in sorted order\nkmer_counts_matrix: Dense matrix where rows are k-mers and columns are sequences\n\nDetails\n\nFor DNA sequences, counts canonical k-mers (both strands)\nFor RNA and protein sequences, counts exact k-mers\nUses parallel processing with threads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.blastdb2table-Tuple{}","page":"Home","title":"Mycelia.blastdb2table","text":"blastdb2table(\n;\n    blastdb,\n    ALL_FIELDS,\n    sequence_sha256,\n    sequence_hash,\n    sequence_id,\n    accession,\n    gi,\n    sequence_title,\n    blast_name,\n    taxid,\n    taxonomic_super_kingdom,\n    scientific_name,\n    scientific_names_leaf_nodes,\n    common_taxonomic_name,\n    common_names_leaf_nodes,\n    leaf_node_taxids,\n    membership_integer,\n    ordinal_id,\n    pig,\n    sequence_length,\n    sequence\n)\n\n\nConvert a BLAST database to an in-memory table with sequence and taxonomy information.\n\nArguments\n\nblastdb::String: Path to the BLAST database\noutfile::String=\"\": Optional output file path. If provided, results will be saved to this file\nforce::Bool=false: Whether to overwrite existing output file\nALL_FIELDS::Bool=true: If true, include all fields regardless of other flag settings\nField selection flags (default to false unless ALL_FIELDS is true):\nsequence_sha256::Bool: Include SHA256 hash of the sequence\nsequence_hash::Bool: Include sequence hash\nsequence_id::Bool: Include sequence ID\naccession::Bool: Include accession number\ngi::Bool: Include GI number\nsequence_title::Bool: Include sequence title\nblast_name::Bool: Include BLAST name\ntaxid::Bool: Include taxid\ntaxonomic_super_kingdom::Bool: Include taxonomic super kingdom\nscientific_name::Bool: Include scientific name\nscientific_names_leaf_nodes::Bool: Include scientific names for leaf-node taxids\ncommon_taxonomic_name::Bool: Include common taxonomic name\ncommon_names_leaf_nodes::Bool: Include common taxonomic names for leaf-node taxids\nleaf_node_taxids::Bool: Include leaf-node taxids\nmembership_integer::Bool: Include membership integer\nordinal_id::Bool: Include ordinal ID\npig::Bool: Include PIG\nsequence_length::Bool: Include sequence length\nsequence::Bool: Include the full sequence\n\nReturns\n\nDataFrame: DataFrame containing the requested columns from the BLAST database\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.blastdb_to_fasta-Tuple{}","page":"Home","title":"Mycelia.blastdb_to_fasta","text":"blastdb_to_fasta(\n;\n    blastdb,\n    entries,\n    taxids,\n    outfile,\n    force,\n    max_cores\n)\n\n\nConvert a BLAST database to FASTA format.\n\nArguments\n\nblastdb::String: Name of the BLAST database to convert (e.g. \"nr\", \"nt\")\ndbdir::String: Directory containing the BLAST database files\noutfile::String: Path for the output FASTA file\n\nReturns\n\nPath to the generated FASTA file as String\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.bray_curtis_distance-Tuple{AbstractMatrix{<:Integer}}","page":"Home","title":"Mycelia.bray_curtis_distance","text":"Compute the Bray-Curtis distance between columns of a count matrix.\n\nArguments\n\nM::AbstractMatrix{<:Integer}: Count matrix where rows are features and columns are samples\n\nReturns\n\nMatrix{Float64}: Symmetric distance matrix with Bray-Curtis distances\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.breadth_first_sample-Tuple{Any, Int64}","page":"Home","title":"Mycelia.breadth_first_sample","text":"Breadth-first sampling: sample at least one from each group, then sample remaining proportionally to group frequencies\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.breadth_first_sample_dataframe-Tuple{DataFrames.DataFrame, Union{String, Symbol}, Int64}","page":"Home","title":"Mycelia.breadth_first_sample_dataframe","text":"Apply breadth-first sampling to a DataFrame\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.build_biosequence_graph-Tuple{Vector{FASTX.FASTA.Record}}","page":"Home","title":"Mycelia.build_biosequence_graph","text":"build_biosequence_graph(\n    fasta_records::Vector{FASTX.FASTA.Record};\n    graph_mode,\n    min_overlap\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, Mycelia.var\"#267#268\", Float64} where {_A, _B, _C}\n\n\nBuild a BioSequence graph directly from FASTA records.\n\nThis creates a variable-length BioSequence graph where vertices are the input sequences and edges represent relationships between sequences (e.g., overlaps, containment).\n\nArguments\n\nfasta_records: Vector of FASTA records\ngraph_mode: SingleStrand or DoubleStrand mode (default: DoubleStrand)\nmin_overlap: Minimum overlap length for creating edges (default: 100)\n\nReturns\n\nMetaGraphsNext.MetaGraph with BioSequence vertices and overlap edges\n\nExample\n\nrecords = [FASTX.FASTA.Record(\"seq1\", \"ATCGATCGATCG\"), \n           FASTX.FASTA.Record(\"seq2\", \"CGATCGATCGAA\")]\ngraph = build_biosequence_graph(records)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.build_directed_kmer_graph-Tuple{}","page":"Home","title":"Mycelia.build_directed_kmer_graph","text":"build_directed_kmer_graph(; fastq, k, plot)\n\n\nConstructs a directed graph representation of k-mer transitions from FASTQ sequencing data.\n\nArguments\n\nfastq: Path to input FASTQ file\nk: K-mer size (default: 1). Must be odd and prime. If k=1, optimal size is auto-determined\nplot: Boolean to display quality distribution plot (default: false)\n\nReturns\n\nMetaDiGraph with properties:\n\nassembly_k: k-mer size used\nkmer_counts: frequency of each k-mer\ntransition_likelihoods: edge weights between k-mers\nkmermeanquality, kmertotalquality: quality metrics\nbranchingnodes, unbranchingnodes: topological classification\nlikelyvalidkmer_indices: k-mers above mean quality threshold\nlikelysequencingartifact_indices: potential erroneous k-mers\n\nNote\n\nFor DNA assembly, quality scores are normalized across both strands.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.build_genome_distance_matrix-Tuple{Vector{String}}","page":"Home","title":"Mycelia.build_genome_distance_matrix","text":"build_genome_distance_matrix(genome_files::Vector{String}; kmer_type=Kmers.DNAKmer{21}, metric=:js_divergence)\n\nBuild a distance matrix between all genome pairs using existing distance metrics.\n\nCreates a comprehensive pairwise distance matrix using established k-mer distance functions, suitable for phylogenetic analysis and clustering.\n\nArguments\n\ngenome_files: Vector of genome FASTA file paths\nkmer_type: K-mer type from Kmers.jl (default: Kmers.DNAKmer{21})\nmetric: Distance metric (:js_divergence, :cosine, :jaccard)\n\nReturns\n\nNamed tuple with distance matrix and genome names\n\nExample\n\ngenomes = [\"genome1.fasta\", \"genome2.fasta\", \"genome3.fasta\"]\nresult = Mycelia.build_genome_distance_matrix(genomes, kmer_type=Kmers.DNAKmer{31})\nprintln(\"Distance matrix: $(result.distance_matrix)\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.build_kmer_graph_next-Tuple{Any, AbstractVector{<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}}","page":"Home","title":"Mycelia.build_kmer_graph_next","text":"build_kmer_graph_next(\n    kmer_type,\n    observations::AbstractVector{<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}};\n    graph_mode\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Label, VertexData, EdgeData, Nothing, WeightFunction, Float64} where {Label, VertexData, EdgeData, WeightFunction}\n\n\nCreate a next-generation, type-stable k-mer graph using MetaGraphsNext.\n\nThis implementation uses canonical k-mers as vertices with strand-aware edges that respect biological transition constraints for both single-strand and double-strand sequences.\n\nArguments\n\nkmer_type: Type of k-mer (e.g., DNAKmer{K})\nobservations: Vector of FASTA/FASTQ records\ngraph_mode: SingleStrand for directional sequences, DoubleStrand for DNA (default)\n\nReturns\n\nMetaGraphsNext.MetaGraph with canonical vertices and strand-aware edges\n\nDetails\n\nVertices: Always canonical k-mers (lexicographically smaller of kmer/reverse_complement)\nEdges: Strand-aware transitions that respect biological constraints\nSingleStrand mode: Only forward-strand transitions allowed\nDoubleStrand mode: Both forward and reverse-complement transitions allowed\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.build_quality_biosequence_graph-Tuple{Vector{FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.build_quality_biosequence_graph","text":"build_quality_biosequence_graph(\n    fastq_records::Vector{FASTX.FASTQ.Record};\n    graph_mode,\n    min_overlap,\n    min_quality\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, Mycelia.var\"#277#278\", Float64} where {_A, _B, _C}\n\n\nBuild a quality-aware BioSequence graph directly from FASTQ records.\n\nThis creates a variable-length quality-aware BioSequence graph where vertices are  the input sequences with their quality scores and edges represent quality-weighted  relationships between sequences.\n\nArguments\n\nfastq_records: Vector of FASTQ records with quality scores\ngraph_mode: SingleStrand or DoubleStrand mode (default: DoubleStrand)\nmin_overlap: Minimum overlap length for creating edges (default: 100)\nmin_quality: Minimum mean quality to include sequence (default: 20)\n\nReturns\n\nMetaGraphsNext.MetaGraph with quality-aware BioSequence vertices\n\nExample\n\nrecords = [FASTX.FASTQ.Record(\"seq1\", \"ATCGATCGATCG\", \"IIIIIIIIIIII\")]\ngraph = build_quality_biosequence_graph(records)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.build_qualmer_graph-Tuple{Vector{FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.build_qualmer_graph","text":"build_qualmer_graph(\n    fastq_records::Vector{FASTX.FASTQ.Record};\n    k,\n    graph_mode,\n    min_quality,\n    min_coverage\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Label, VertexData, EdgeData, Nothing, WeightFunction, Float64} where {Label, VertexData, EdgeData, WeightFunction}\n\n\nBuild a quality-aware k-mer graph from FASTQ records using existing Qualmer functionality. This function leverages the existing qualmer extraction functions and adds graph construction.\n\nArguments\n\nfastq_records: Vector of FASTQ records with quality scores\nk: K-mer size\ngraph_mode: SingleStrand or DoubleStrand mode (default: DoubleStrand)\nmin_quality: Minimum average PHRED quality to include k-mer (default: 10)\nmin_coverage: Minimum coverage (observations) to include k-mer (default: 1)\n\nReturns\n\nMetaGraphsNext.MetaGraph with QualmerVertexData and QualmerEdgeData\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.build_stranded_kmer_graph-Tuple{Any, AbstractVector{<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}}","page":"Home","title":"Mycelia.build_stranded_kmer_graph","text":"build_stranded_kmer_graph(\n    kmer_type,\n    observations::AbstractVector{<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}\n) -> MetaGraphs.MetaDiGraph{T, Float64} where T<:Integer\n\n\nCreate a weighted, strand-specific kmer (de bruijn) graph from a set of kmers and a series of sequence observations in FASTA format.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_accuracy_metrics-Tuple{Any, Int64}","page":"Home","title":"Mycelia.calculate_accuracy_metrics","text":"Calculate assembly accuracy metrics for reward function. Returns a comprehensive score based on multiple quality indicators.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_assembly_mapping_metrics-Tuple{Any, Vector{<:FASTX.FASTQ.Record}, String}","page":"Home","title":"Mycelia.calculate_assembly_mapping_metrics","text":"Calculate assembly mapping metrics for validation reads.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_assembly_quality_metrics-Tuple{Any}","page":"Home","title":"Mycelia.calculate_assembly_quality_metrics","text":"calculate_assembly_quality_metrics(\n    qualmer_graph;\n    low_confidence_threshold\n) -> NamedTuple{(:mean_coverage, :mean_quality, :mean_confidence, :low_confidence_fraction, :total_kmers), <:NTuple{5, Any}}\n\n\nCalculate comprehensive assembly quality metrics for a qualmer graph.\n\nArguments\n\ngraph: Qualmer graph (MetaGraphsNext with QualmerVertexData)\nlow_confidence_threshold::Float64=0.95: Threshold for identifying low-confidence k-mers\n\nReturns\n\nNamedTuple: Assembly quality metrics including coverage, quality, and confidence statistics\n\nDetails\n\nCalculates mean values for coverage, quality scores, and joint probabilities. Identifies fraction of k-mers below confidence threshold as potential error indicators.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_assembly_reward","page":"Home","title":"Mycelia.calculate_assembly_reward","text":"Calculate reward for current k-mer processing iteration. Higher rewards indicate better assembly quality progress.\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.calculate_bubble_complexity-Tuple{Vector{String}, Vector{String}}","page":"Home","title":"Mycelia.calculate_bubble_complexity","text":"Calculate complexity score for a bubble.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_degrees-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}}","page":"Home","title":"Mycelia.calculate_degrees","text":"Calculate in-degrees and out-degrees for all vertices.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_emission_probability-Tuple{Mycelia.ViterbiState, String, Mycelia.ViterbiConfig}","page":"Home","title":"Mycelia.calculate_emission_probability","text":"calculate_emission_probability(state::ViterbiState, observation::String, config::ViterbiConfig) -> Float64\n\nCalculate emission probability for a state given an observation.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_gc_content-Tuple{AbstractString}","page":"Home","title":"Mycelia.calculate_gc_content","text":"calculate_gc_content(sequence::AbstractString) -> Float64\n\n\nCalculate GC content from a string sequence.\n\nConvenience function that accepts string input and converts to appropriate BioSequence. Automatically detects DNA/RNA based on presence of T/U.\n\nArguments\n\nsequence::AbstractString: Input DNA or RNA sequence as string\n\nReturns\n\nFloat64: GC content as a percentage (0.0-100.0)\n\nExamples\n\n# Calculate GC content from string\ngc_percent = calculate_gc_content(\"ATCGATCGATCG\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_gc_content-Tuple{BioSequences.LongSequence}","page":"Home","title":"Mycelia.calculate_gc_content","text":"calculate_gc_content(\n    sequence::BioSequences.LongSequence\n) -> Float64\n\n\nCalculate GC content (percentage of G and C bases) from a BioSequence.\n\nThis function calculates the percentage of guanine (G) and cytosine (C) bases in a nucleotide sequence. Works with both DNA and RNA sequences.\n\nArguments\n\nsequence::BioSequences.LongSequence: Input DNA or RNA sequence\n\nReturns\n\nFloat64: GC content as a percentage (0.0-100.0)\n\nExamples\n\n# Calculate GC content for DNA\ndna_seq = BioSequences.LongDNA{4}(\"ATCGATCGATCG\")\ngc_percent = calculate_gc_content(dna_seq)\n\n# Calculate GC content for RNA\nrna_seq = BioSequences.LongRNA{4}(\"AUCGAUCGAUCG\") \ngc_percent = calculate_gc_content(rna_seq)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_gc_content-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}","page":"Home","title":"Mycelia.calculate_gc_content","text":"calculate_gc_content(\n    records::AbstractArray{T<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}, 1}\n) -> Float64\n\n\nCalculate GC content from FASTA/FASTQ records.\n\nProcesses multiple records and calculates overall GC content across all sequences.\n\nArguments\n\nrecords::AbstractVector{T} where T <: Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}`: Input records\n\nReturns\n\nFloat64: Overall GC content as a percentage (0.0-100.0)\n\nExamples\n\n# Calculate GC content from FASTA records\nrecords = collect(FASTX.FASTA.Reader(open(\"sequences.fasta\")))\ngc_percent = calculate_gc_content(records)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_path_support-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Vector{String}}","page":"Home","title":"Mycelia.calculate_path_support","text":"Calculate support for a path (simplified version).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_qualmer_likelihood-Tuple{Any, AbstractVector{Int8}, Any}","page":"Home","title":"Mycelia.calculate_qualmer_likelihood","text":"Calculate likelihood of a k-mer given its observed quality scores and qualmer vertex data. Leverages existing qualmer graph quality calculations.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_read_likelihood-Tuple{FASTX.FASTQ.Record, Any, Int64}","page":"Home","title":"Mycelia.calculate_read_likelihood","text":"Calculate likelihood of a FASTQ read given the current graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_recommendation_confidence-Tuple{Vector{Float64}, Vector{Float64}}","page":"Home","title":"Mycelia.calculate_recommendation_confidence","text":"Calculate confidence in recommendation based on variance across folds.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_repeat_confidence-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Vector{String}, Float64}","page":"Home","title":"Mycelia.calculate_repeat_confidence","text":"Calculate confidence in repeat identification.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_sequence_likelihood-Tuple{BioSequences.BioSequence, Vector{Int8}, Any, Int64}","page":"Home","title":"Mycelia.calculate_sequence_likelihood","text":"Calculate quality-aware likelihood of a sequence given the qualmer graph. Uses both k-mer presence and quality-based confidence from qualmer observations.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_sparsity-Tuple{Vector{<:FASTX.FASTQ.Record}, Int64}","page":"Home","title":"Mycelia.calculate_sparsity","text":"Calculate k-mer sparsity for a given k-mer size. Returns fraction of possible k-mers that are NOT observed. Higher sparsity indicates errors become singletons.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.calculate_unseen_kmer_penalty-Tuple{AbstractVector{Int8}}","page":"Home","title":"Mycelia.calculate_unseen_kmer_penalty","text":"Calculate penalty for unseen k-mers based on their quality scores. High quality unseen k-mers get less penalty than low quality ones.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.canonical-Tuple{Mycelia.Qualmer{<:Kmers.Kmer{BioSequences.AminoAcidAlphabet}}}","page":"Home","title":"Mycelia.canonical","text":"canonical(\n    qmer::Mycelia.Qualmer{<:Kmers.Kmer{BioSequences.AminoAcidAlphabet}}\n) -> Mycelia.Qualmer{<:Kmers.Kmer{BioSequences.AminoAcidAlphabet}}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.canonical-Union{Tuple{Mycelia.Qualmer{KmerT}}, Tuple{KmerT}} where KmerT<:Union{Kmers.DNAKmer, Kmers.RNAKmer}","page":"Home","title":"Mycelia.canonical","text":"canonical(\n    qmer::Mycelia.Qualmer{KmerT<:Union{Kmers.DNAKmer, Kmers.RNAKmer}}\n) -> Mycelia.Qualmer{KmerT} where KmerT<:Kmers.Kmer\n\n\nGet the canonical representation of a DNA qualmer, considering both sequence and quality. For DNA/RNA, this involves potentially reverse-complementing the k-mer and reversing the quality scores accordingly.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.canonicalize_kmer_counts!-Tuple{Any}","page":"Home","title":"Mycelia.canonicalize_kmer_counts!","text":"canonicalize_kmer_counts!(kmer_counts) -> Any\n\n\nCanonicalizes the k-mer counts in the given dictionary.\n\nThis function iterates over the provided dictionary kmer_counts, which maps k-mers to their respective counts. For each k-mer that is not in its canonical form, it converts the k-mer to its canonical form and updates the count in the dictionary accordingly. If the canonical form of the k-mer already exists in the dictionary, their counts are summed. The original non-canonical k-mer is then removed from the dictionary.\n\nArguments\n\nkmer_counts::Dict{BioSequences.Kmer, Int}: A dictionary where keys are k-mers and values are their counts.\n\nReturns\n\nThe input dictionary kmer_counts with all k-mers in their canonical form, sorted by k-mers.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.canonicalize_kmer_counts-Tuple{Any}","page":"Home","title":"Mycelia.canonicalize_kmer_counts","text":"canonicalize_kmer_counts(kmer_counts) -> Any\n\n\nNormalize k-mer counts into a canonical form by creating a non-mutating copy.\n\nArguments\n\nkmer_counts: Dictionary or collection of k-mer count data\n\nReturns\n\nA new normalized k-mer count collection\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.check_bioconda_env_is_installed-Tuple{Any}","page":"Home","title":"Mycelia.check_bioconda_env_is_installed","text":"check_bioconda_env_is_installed(pkg) -> Bool\n\n\nCheck whether a named Bioconda environment already exists.\n\nArguments\n\npkg::String: Name of the environment.\n\nReturns\n\nBool indicating if the environment is present.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.check_eulerian_conditions-Tuple{Dict{String, Int64}, Dict{String, Int64}}","page":"Home","title":"Mycelia.check_eulerian_conditions","text":"Check conditions for Eulerian path existence.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.check_matrix_fits_in_memory-Tuple{Integer}","page":"Home","title":"Mycelia.check_matrix_fits_in_memory","text":"check_matrix_fits_in_memory(bytes_needed::Integer; severity::Symbol=:warn)\n\nChecks whether the specified number of bytes can fit in the computer's memory.\n\nbytes_needed: The number of bytes required (output from estimate_dense_matrix_memory or estimate_sparse_matrix_memory).\nseverity: What to do if there is not enough available memory. Can be :warn (default) or :error.\n\nReturns a named tuple:     (willfittotal, willfitavailable, totalmemory, freememory, bytes_needed) Where:\n\nwill_fit_total: true if the matrix fits in total system memory.\nwill_fit_available: true if the matrix fits in currently available (free) system memory.\ntotal_memory: Total system RAM in bytes.\nfree_memory: Currently available system RAM in bytes.\nbytes_needed: Bytes requested for the matrix.\n\nIf will_fit_available is false, either warns or errors depending on severity.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.check_memory_limits-Tuple{Any, Int64}","page":"Home","title":"Mycelia.check_memory_limits","text":"Check if memory usage is within acceptable limits.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.choose_top_n_markers-Tuple{Int64}","page":"Home","title":"Mycelia.choose_top_n_markers","text":"choose_top_n_markers(N)\n\nReturn a vector of the top N most visually distinct marker symbols for plotting.\n\nArguments\n\nN::Int: Number of distinct markers to return (max 17 for best differentiation).\n\nReturns\n\nVector{Symbol}: Vector of marker symbol names.\n\nExample\n\nmarkers = choose_top_n_markers(7)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.chromosome_coverage_table_to_plot-Tuple{Any}","page":"Home","title":"Mycelia.chromosome_coverage_table_to_plot","text":"chromosome_coverage_table_to_plot(cdf) -> Plots.Plot\n\n\nCreates a visualization of chromosome coverage data with statistical thresholds.\n\nArguments\n\ncdf::DataFrame: Coverage data frame containing columns:\nindex: Chromosome position indices\ndepth: Coverage depth values\nchromosome: Chromosome identifier\nmean_coverage: Mean coverage value\nstd_coverage: Standard deviation of coverage\n3σ: Boolean vector indicating +3 sigma regions\n-3σ: Boolean vector indicating -3 sigma regions\n\nReturns\n\nA StatsPlots plot object showing:\nRaw coverage data (black line)\nMean coverage and ±1,2,3σ thresholds (rainbow colors)\nHighlighted regions exceeding ±3σ thresholds (red vertical lines)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.classify_reads_by_taxonomy-Tuple{}","page":"Home","title":"Mycelia.classify_reads_by_taxonomy","text":"Classify reads based on taxonomic alignments using individual alignment scoring.\n\nThis function takes taxonomy-aware alignment data and performs classification by:\n\nLoading the taxonomy-aware alignment data\nAnalyzing alignment score distributions per read\nIdentifying dominant taxonomic assignments\nApplying conservative taxonomy classification\n\nArguments\n\ntaxonomy_aware_file: Path to taxonomy-aware alignment file (.tsv.gz or .arrow)\nmin_relative_proportion::Float64=60.0: Minimum relative proportion threshold for accepting a taxonomic assignment\nverbose::Bool=true: Whether to print progress information\n\nReturns\n\nA DataFrame with taxonomic classification results including individual alignment metrics\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.classify_repeat_type-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Vector{String}, Vector{Tuple{String, String}}, Vector{Tuple{String, String}}}","page":"Home","title":"Mycelia.classify_repeat_type","text":"Classify the type of repeat.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.cleanup_directory-Tuple{AbstractString}","page":"Home","title":"Mycelia.cleanup_directory","text":"cleanup_directory(\n    directory::AbstractString;\n    verbose,\n    force\n) -> @NamedTuple{existed::Bool, files_deleted::Int64, bytes_freed::Int64, human_readable_size::String}\n\n\nClean up a directory by calculating its size and file count, then removing it.\n\nArguments\n\ndirectory::AbstractString: Path to the directory to clean up\nverbose::Bool=true: Whether to report cleanup results (default: true)\nforce::Bool=false: Whether to proceed without confirmation for large directories\n\nReturns\n\nNamed tuple with fields:\nexisted: Whether the directory existed before cleanup\nfiles_deleted: Number of files that were deleted\nbytes_freed: Total bytes freed up\nhuman_readable_size: Human-readable representation of bytes freed\n\nDetails\n\nThis function will:\n\nCheck if the directory exists and is non-empty\nCalculate the total size and number of files recursively\nRemove the directory and all its contents\nReport the cleanup results unless verbose=false\n\nFor directories larger than 1GB or containing more than 10,000 files, confirmation is required unless force=true.\n\nExamples\n\n# Clean up a temporary directory with reporting\nresult = cleanup_directory(\"/tmp/myapp_temp\")\n\n# Silent cleanup\ncleanup_directory(\"/tmp/cache\", verbose=false)\n\n# Force cleanup of large directory\ncleanup_directory(\"/tmp/large_data\", force=true)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.codon_optimize-Tuple{}","page":"Home","title":"Mycelia.codon_optimize","text":"codon_optimize(\n;\n    normalized_codon_frequencies,\n    protein_sequence,\n    n_iterations\n)\n\n\nOptimizes the DNA sequence encoding for a given protein sequence using codon usage frequencies.\n\nArguments\n\nnormalized_codon_frequencies: Dictionary mapping amino acids to their codon frequencies\nprotein_sequence::BioSequences.LongAA: Target protein sequence to optimize\nn_iterations::Integer: Number of optimization iterations to perform\n\nAlgorithm\n\nCreates initial DNA sequence through reverse translation\nIteratively generates new sequences by sampling codons based on their frequencies\nKeeps track of the sequence with highest codon usage likelihood\n\nReturns\n\nBioSequences.LongDNA{2}: Optimized DNA sequence encoding the input protein\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.codons_to_amino_acids-Tuple{}","page":"Home","title":"Mycelia.codons_to_amino_acids","text":"codons_to_amino_acids() -> Dict\n\n\nCreates a mapping between DNA codons and their corresponding amino acids using the standard genetic code.\n\nReturns a dictionary where:\n\nKeys are 3-letter DNA codons (e.g., \"ATG\")\nValues are the corresponding amino acids from BioSequences.jl\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.collapse_unbranching_paths-Tuple{MetaGraphsNext.MetaGraph{var\"#s35\", Graph} where {var\"#s35\"<:Graphs.SimpleGraphs.AbstractSimpleGraph, Graph<:Graphs.AbstractGraph{var\"#s35\"}}}","page":"Home","title":"Mycelia.collapse_unbranching_paths","text":"Collapse linear paths (vertices with one incoming and one outgoing edge) into a simpler graph where sequences are concatenated.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.compare_assembly_statistics-Tuple{Dict, Dict}","page":"Home","title":"Mycelia.compare_assembly_statistics","text":"Compare statistical properties of intelligent vs iterative assemblies.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.compare_genome_kmer_similarity-Tuple{String, String}","page":"Home","title":"Mycelia.compare_genome_kmer_similarity","text":"compare_genome_kmer_similarity(genome1_file::String, genome2_file::String; kmer_type=Kmers.DNAKmer{21}, metric=:js_divergence)\n\nCompare two genomes using existing k-mer distance metrics.\n\nLeverages existing distance metric functions to compare genomic similarity between pairs of genomes using various distance measures.\n\nArguments\n\ngenome1_file: Path to first genome FASTA file\ngenome2_file: Path to second genome FASTA file  \nkmer_type: K-mer type from Kmers.jl (default: Kmers.DNAKmer{21})\nmetric: Distance metric (:js_divergence, :cosine, :jaccard)\n\nReturns\n\nNamed tuple with similarity/distance metrics and k-mer statistics\n\nExample\n\nsimilarity = Mycelia.compare_genome_kmer_similarity(\n    \"genome1.fasta\", \"genome2.fasta\", \n    kmer_type=Kmers.DNAKmer{31}, \n    metric=:js_divergence\n)\nprintln(\"JS divergence: $(similarity.distance)\")\nprintln(\"Shared k-mers: $(similarity.shared_kmers)\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.concatenate_files-Tuple{}","page":"Home","title":"Mycelia.concatenate_files","text":"concatenate_files(; files, file)\n\n\nJoin fasta files without any regard to record uniqueness.\n\nA cross-platform version of cat *.fasta > joint.fasta\n\nSee mergefastafiles\n\nConcatenate multiple FASTA files into a single output file by simple appending.\n\nArguments\n\nfiles: Vector of paths to input FASTA files\nfile: Path where the concatenated output will be written\n\nReturns\n\nPath to the output concatenated file\n\nDetails\n\nPlatform-independent implementation of cat *.fasta > combined.fasta. Files are processed sequentially with a progress indicator.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.confusion_matrix-Tuple{Any, Any}","page":"Home","title":"Mycelia.confusion_matrix","text":"confusion_matrix(true_labels, pred_labels)\n\nReturns the confusion matrix as a Matrix{Int}, row = true, col = predicted. Also returns the list of unique labels in sorted order and a heatmap plot.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.contbernoulli_pca_epca-Tuple{AbstractMatrix{<:Real}}","page":"Home","title":"Mycelia.contbernoulli_pca_epca","text":"contbernoulli_pca_epca(M::AbstractMatrix{<:Real}; k::Int=0)\n\nPerform Continuous Bernoulli EPCA on a matrix M (features × samples).\n\nWhen to use\n\nUse for continuous data in the open interval (0, 1), such as probabilities or normalized intensities.\n\nKeyword arguments\n\nk : desired number of latent dimensions; if k<1 defaults to min(n_samples-1, n_features, 10)\n\nReturns\n\nNamedTuple with fields\n\nmodel    : the fitted ExpFamilyPCA.ContinuousBernoulliEPCA object  \nscores   : k×n_samples matrix of sample scores  \nloadings : k×n_features matrix of feature loadings  \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.contig_is_circular-Tuple{String, String}","page":"Home","title":"Mycelia.contig_is_circular","text":"contig_is_circular(\n    graph_file::String,\n    contig_name::String\n) -> Any\n\n\nReturns bool indicating whether the contig is a circle\n\ngraphfile = path to assembly graph.gfa file contigname = name of the contig\n\nDetermine if a contig represents a circular structure in the assembly graph.\n\nA circular contig is one where the sequence forms a complete loop in the assembly graph, typically representing structures like plasmids, circular chromosomes, or other circular DNA elements.\n\nArguments\n\ngraph_file::String: Path to the assembly graph in GFA format\ncontig_name::String: Name/identifier of the contig to check\n\nReturns\n\nBool: true if the contig forms a circular structure, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.contig_is_cleanly_assembled-Tuple{String, String}","page":"Home","title":"Mycelia.contig_is_cleanly_assembled","text":"contig_is_cleanly_assembled(\n    graph_file::String,\n    contig_name::String\n) -> Bool\n\n\nReturns bool indicating whether the contig is cleanly assembled.\n\nBy cleanly assembled we mean that the contig does not have other contigs attached in the same connected component.\n\ngraphfile = path to assembly graph.gfa file contigname = name of the contig\n\nCheck if a contig exists in isolation within its connected component in an assembly graph.\n\nArguments\n\ngraph_file::String: Path to the assembly graph file in GFA format\ncontig_name::String: Name/identifier of the contig to check\n\nReturns\n\nBool: true if the contig exists alone in its connected component, false otherwise\n\nDetails\n\nA contig is considered \"cleanly assembled\" if it appears as a single entry in the  assembly graph's connected components. This function parses the GFA file and checks the contig's isolation status using the graph structure.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.convert_legacy_gfa_to_next","page":"Home","title":"Mycelia.convert_legacy_gfa_to_next","text":"convert_legacy_gfa_to_next(\n    gfa_file::AbstractString\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, Mycelia.var\"#147#148\", Float64} where {_A, _B, _C}\nconvert_legacy_gfa_to_next(\n    gfa_file::AbstractString,\n    graph_mode::Mycelia.GraphMode\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, Mycelia.var\"#147#148\", Float64} where {_A, _B, _C}\n\n\nConvert a legacy MetaGraphs GFA to next-generation MetaGraphsNext format.\n\nThis convenience function reads a GFA file using the legacy parser and converts it to the new strand-aware format.\n\nArguments\n\ngfa_file: Path to GFA file\ngraph_mode: GraphMode for the output graph\n\nReturns\n\nMetaGraphsNext.MetaGraph in strand-aware format\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.convert_sequence-Tuple{AbstractString}","page":"Home","title":"Mycelia.convert_sequence","text":"convert_sequence(seq::AbstractString) -> Any\n\n\nConverts the given sequence (output from FASTX.sequence) into the appropriate BioSequence type:\n\nDNA sequences are converted using BioSequences.LongDNA\nRNA sequences are converted using BioSequences.LongRNA\nAA sequences are converted using BioSequences.LongAA\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.copy_to_tempdir-Tuple{String}","page":"Home","title":"Mycelia.copy_to_tempdir","text":"copy_to_tempdir(file_path::String) -> String\n\n\nCreate a copy of a file in a temporary directory while preserving the original filename.\n\nArguments\n\nfile_path::String: Path to the source file to be copied\n\nReturns\n\nString: Path to the newly created temporary file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.copy_with_unique_identifier-Tuple{Any, Any, Any}","page":"Home","title":"Mycelia.copy_with_unique_identifier","text":"copy_with_unique_identifier(\n    infile,\n    out_directory,\n    unique_identifier;\n    force\n) -> Any\n\n\nCopy a file to a new location with a unique identifier prepended to the filename.\n\nArguments\n\ninfile::AbstractString: Path to the source file to copy\nout_directory::AbstractString: Destination directory for the copied file\nunique_identifier::AbstractString: String to prepend to the filename\nforce::Bool=true: If true, overwrite existing files\n\nReturns\n\nString: Path to the newly created file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.correct_errors_at_k-Tuple{Any, Int64}","page":"Home","title":"Mycelia.correct_errors_at_k","text":"Perform error correction at the current k-mer size. Returns the number of corrections made.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.correct_errors_next","page":"Home","title":"Mycelia.correct_errors_next","text":"correct_errors_next(graph::MetaGraph, sequences::Vector, config::ViterbiConfig) -> Vector{FASTX.FASTA.Record}\n\nCorrect errors in sequences using Viterbi algorithm and return corrected FASTA records.\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.count_canonical_kmers-Union{Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, Any}} where KMER_TYPE","page":"Home","title":"Mycelia.count_canonical_kmers","text":"count_canonical_kmers(_::Type{KMER_TYPE}, sequences) -> Any\n\n\nCount canonical k-mers in biological sequences. A canonical k-mer is the lexicographically  smaller of a DNA sequence and its reverse complement, ensuring strand-independent counting.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer size and structure\nsequences: Iterator of biological sequences to analyze\n\nReturns\n\nDict{KMER_TYPE,Int}: Dictionary mapping canonical k-mers to their counts\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, AbstractString}} where KMER_TYPE","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    fastx_file::AbstractString\n) -> Any\n\n\nCount k-mers in a FASTA/FASTQ file and return their frequencies.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer type (e.g., DNAKmer{K})\nfastx_file: Path to input FASTA/FASTQ file\n\nReturns\n\nDict{KMER_TYPE, Int}: Dictionary mapping each k-mer to its frequency\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{K}, Tuple{A}, Tuple{Type{Kmers.Mer{K, A}}, BioSequences.LongSequence}} where {A<:BioSequences.AminoAcidAlphabet, K}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.AminoAcidAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> OrderedCollections.OrderedDict{K, Int64} where K<:(Kmers.Kmer{BioSequences.AminoAcidAlphabet, _A, _B} where {_B, _A})\n\n\nCount the frequency of amino acid k-mers in a biological sequence.\n\nArguments\n\nKmers.Kmer{A,K}: Type parameter specifying amino acid alphabet (A) and k-mer length (K)\nsequence: Input biological sequence to analyze\n\nReturns\n\nA sorted dictionary mapping each k-mer to its frequency count in the sequence.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{K}, Tuple{A}, Tuple{Type{Kmers.Mer{K, A}}, BioSequences.LongSequence}} where {A<:BioSequences.DNAAlphabet, K}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.DNAAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> Any\n\n\nCount the frequency of each k-mer in a DNA sequence.\n\nArguments\n\n::Type{Kmers.Kmer{A,K}}: K-mer type with alphabet A and length K\nsequence::BioSequences.LongSequence: Input DNA sequence to analyze\n\nReturns\n\nA sorted dictionary mapping each k-mer to its frequency count in the sequence.\n\nType Parameters\n\nA <: BioSequences.DNAAlphabet: DNA alphabet type\nK: Length of k-mers\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{K}, Tuple{A}, Tuple{Type{Kmers.Mer{K, A}}, BioSequences.LongSequence}} where {A<:BioSequences.RNAAlphabet, K}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.RNAAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> Any\n\n\nCount the frequency of each k-mer in an RNA sequence.\n\nArguments\n\nKmer: Type parameter specifying the k-mer length K and RNA alphabet\nsequence: Input RNA sequence to analyze\n\nReturns\n\nDict{Kmers.Kmer, Int}: Sorted dictionary mapping each k-mer to its frequency count\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{R}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, R}} where {KMER_TYPE, R<:Union{FASTX.FASTA.Reader, FASTX.FASTQ.Reader}}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    sequences::Union{FASTX.FASTA.Reader, FASTX.FASTQ.Reader}\n) -> Any\n\n\nCounts k-mer occurrences in biological sequences from a FASTA/FASTQ reader.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer length and encoding (e.g., DNAKmer{4} for 4-mers)\nsequences: A FASTA or FASTQ reader containing the biological sequences to analyze\n\nReturns\n\nA dictionary mapping k-mers to their counts in the input sequences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{R}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, R}} where {KMER_TYPE, R<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    record::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}\n) -> Any\n\n\nCount the frequency of amino acid k-mers in a biological sequence.\n\nArguments\n\nKmers.Kmer{A,K}: Type parameter specifying amino acid alphabet (A) and k-mer length (K)\nsequence: Input biological sequence to analyze\n\nReturns\n\nA sorted dictionary mapping each k-mer to its frequency count in the sequence.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{T}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, AbstractVector{T}}} where {KMER_TYPE, T<:AbstractString}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    fastx_files::AbstractArray{T<:AbstractString, 1}\n) -> Any\n\n\nCount k-mers across multiple FASTA/FASTQ files and merge the results.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer length (e.g., DNAKmer{4} for 4-mers)\nfastx_files: Vector of paths to FASTA/FASTQ files\n\nReturns\n\nDict{KMER_TYPE, Int}: Dictionary mapping k-mers to their total counts across all files\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{T}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, AbstractVector{T}}} where {KMER_TYPE, T<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    records::AbstractArray{T<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}, 1}\n) -> Any\n\n\nCount k-mers across multiple sequence records and return a sorted frequency table.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer length (e.g., DNAKmer{3} for 3-mers)\nrecords: Vector of FASTA/FASTQ records to analyze\n\nReturns\n\nDict{KMER_TYPE, Int}: Sorted dictionary mapping k-mers to their frequencies\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_matrix_to_probability_matrix-Tuple{Any}","page":"Home","title":"Mycelia.count_matrix_to_probability_matrix","text":"count_matrix_to_probability_matrix(counts_matrix) -> Any\n\n\nConvert a matrix of counts into a probability matrix by normalizing each column to sum to 1.0.\n\nArguments\n\ncounts_matrix::Matrix{<:Number}: Input matrix where each column represents counts/frequencies\n\nReturns\n\nMatrix{Float64}: Probability matrix where each column sums to 1.0\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_predicted_genes-Tuple{Any}","page":"Home","title":"Mycelia.count_predicted_genes","text":"count_predicted_genes(gff_file)\n\nCount the number of predicted genes from a GFF file.\n\nParses a GFF/GTF file and counts the number of CDS (coding sequence) features, which correspond to predicted genes.\n\nArguments\n\ngff_file: Path to GFF/GTF file\n\nReturns\n\nInteger count of predicted genes (CDS features)\n\nSee Also\n\nrun_pyrodigal: For gene prediction that generates GFF files\nparse_transterm_output: For parsing other annotation tool outputs\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_records-Tuple{Any}","page":"Home","title":"Mycelia.count_records","text":"count_records(fastx) -> Int64\n\n\nCounts the total number of records in a FASTA/FASTQ file.\n\nArguments\n\nfastx: Path to a FASTA or FASTQ file (can be gzipped)\n\nReturns\n\nNumber of records (sequences) in the file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.countmap_columns-Tuple{Any}","page":"Home","title":"Mycelia.countmap_columns","text":"countmap_columns(table)\n\n\nGenerate and display frequency counts for all columns in a DataFrame.\n\nArguments\n\ntable::DataFrame: Input DataFrame to analyze\n\nDetails\n\nIterates through each column in the DataFrame and displays:\n\nThe column name\nA Dict mapping unique values to their frequencies using StatsBase.countmap\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_assembly_environment-Tuple{Vector{String}, Vector{String}}","page":"Home","title":"Mycelia.create_assembly_environment","text":"create_assembly_environment(training_data, validation_data; episode_length=100)\n\nCreate a new reinforcement learning environment for assembly training.\n\nArguments\n\ntraining_data::Vector{String}: Paths to training FASTQ datasets\nvalidation_data::Vector{String}: Paths to validation FASTQ datasets\nepisode_length::Int: Maximum steps per training episode (default: 100)\n\nReturns\n\nAssemblyEnvironment: Initialized RL environment ready for training\n\nExample\n\ntraining_files = [\"genome1.fastq\", \"genome2.fastq\", \"genome3.fastq\"]\nvalidation_files = [\"validation1.fastq\", \"validation2.fastq\"]\nenv = create_assembly_environment(training_files, validation_files)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_curriculum_schedule-Tuple{}","page":"Home","title":"Mycelia.create_curriculum_schedule","text":"create_curriculum_schedule(; stages=4, datasets_per_stage=10)\n\nCreate a curriculum learning schedule that progressively increases difficulty.\n\nArguments\n\nstages::Int: Number of curriculum stages (default: 4)\ndatasets_per_stage::Int: Datasets per stage (default: 10)\n\nReturns\n\nVector{Dict}: Curriculum schedule with parameters for each stage\n\nExample\n\ncurriculum = create_curriculum_schedule(stages=5, datasets_per_stage=15)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_database-Tuple{}","page":"Home","title":"Mycelia.create_database","text":"create_database(; database, address, username, password)\n\n\nCreates a new Neo4j database instance if it doesn't already exist.\n\nArguments\n\ndatabase::String: Name of the database to create\naddress::String: Neo4j server address (e.g. \"neo4j://localhost:7687\")\nusername::String: Neo4j authentication username (defaults to \"neo4j\")\npassword::String: Neo4j authentication password\n\nNotes\n\nRequires system database privileges to execute\nSilently returns if database already exists\nTemporarily switches to system database to perform creation\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_dqn_policy-Tuple{}","page":"Home","title":"Mycelia.create_dqn_policy","text":"create_dqn_policy(; state_dim=11, action_dim=3, hidden_dims=[128, 64], learning_rate=0.001, epsilon=0.1)\n\nCreate a Deep Q-Network policy for assembly decisions.\n\nArguments\n\nstate_dim::Int: Dimension of state representation (default: 11)\naction_dim::Int: Number of discrete actions (default: 3 for continue/next/terminate)\nhidden_dims::Vector{Int}: Hidden layer sizes (default: [128, 64])\nlearning_rate::Float64: Learning rate (default: 0.001)\nepsilon::Float64: Exploration probability (default: 0.1)\n\nReturns\n\nDQNPolicy: Initialized policy network\n\nExample\n\npolicy = create_dqn_policy(hidden_dims=[256, 128, 64])\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_hmm_from_graph-Tuple{MetaGraphsNext.MetaGraph{<:Integer, <:Any, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Mycelia.ViterbiConfig}","page":"Home","title":"Mycelia.create_hmm_from_graph","text":"create_hmm_from_graph(graph::MetaGraph, config::ViterbiConfig) -> (states, transitions, emissions)\n\nCreate Hidden Markov Model parameters from a k-mer graph structure.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_kfold_partitions-Tuple{Vector{<:FASTX.FASTQ.Record}, Int64, Float64}","page":"Home","title":"Mycelia.create_kfold_partitions","text":"Create k-fold partitions with validation holdout for cross-validation.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_node_constraints-Tuple{Any}","page":"Home","title":"Mycelia.create_node_constraints","text":"create_node_constraints(\n    graph;\n    address,\n    username,\n    password,\n    database\n)\n\n\nCreates unique identifier constraints for each node type in a Neo4j database.\n\nArguments\n\ngraph: A MetaGraph containing nodes with TYPE properties\naddress: Neo4j server address\nusername: Neo4j username (default: \"neo4j\")\npassword: Neo4j password\ndatabase: Neo4j database name (default: \"neo4j\")\n\nDetails\n\nExtracts unique node types from the graph and creates Neo4j constraints ensuring each node of a given type has a unique identifier property.\n\nFailed constraint creation attempts are silently skipped.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_tarchive-Tuple{}","page":"Home","title":"Mycelia.create_tarchive","text":"create_tarchive(; directory, tarchive)\n\n\nCreates a gzipped tar archive of the specified directory along with verification files.\n\nArguments\n\ndirectory: Source directory path to archive\ntarchive: Optional output archive path (defaults to directory name with .tar.gz extension)\n\nGenerated Files\n\n{tarchive}: The compressed tar archive\n{tarchive}.log: Contents listing of the archive\n{tarchive}.hashdeep.dfxml: Cryptographic hashes (MD5, SHA1, SHA256) of the archive\n\nReturns\n\nPath to the created tar archive file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.cross_validation_summary-Tuple{Dict}","page":"Home","title":"Mycelia.cross_validation_summary","text":"Generate cross-validation summary report.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.current_unix_datetime-Tuple{}","page":"Home","title":"Mycelia.current_unix_datetime","text":"current_unix_datetime() -> Int64\n\n\nGet the current time as a Unix timestamp (seconds since epoch).\n\nReturns\n\nInt: Current time as an integer Unix timestamp (seconds since January 1, 1970 UTC)\n\nExamples\n\nunix_time = current_unix_datetime()\n# => 1709071368 (example value, will differ based on current time)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.cypher-Tuple{Any}","page":"Home","title":"Mycelia.cypher","text":"cypher(\n    cmd;\n    address,\n    username,\n    password,\n    format,\n    database\n) -> Cmd\n\n\nConstructs a command to execute Neo4j Cypher queries via cypher-shell.\n\nArguments\n\ncmd: The Cypher query command to execute\naddress::String=\"neo4j://localhost:7687\": Neo4j server address\nusername::String=\"neo4j\": Neo4j authentication username\npassword::String=\"password\": Neo4j authentication password \nformat::String=\"auto\": Output format (auto, verbose, or plain)\ndatabase::String=\"neo4j\": Target Neo4j database name\n\nReturns\n\nCmd: A command object ready for execution\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.dataframe_convert_dicts_to_json-Tuple{Any}","page":"Home","title":"Mycelia.dataframe_convert_dicts_to_json","text":"dataframe_convert_dicts_to_json(df) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.dataframe_replace_nothing_with_missing-Tuple{DataFrames.DataFrame}","page":"Home","title":"Mycelia.dataframe_replace_nothing_with_missing","text":"dataframe_replace_nothing_with_missing(df::DataFrames.DataFrame) -> DataFrames.DataFrame\n\nReturn the DataFrame with all nothing values replaced by missing.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.dataframe_to_ndjson-Tuple{DataFrames.DataFrame}","page":"Home","title":"Mycelia.dataframe_to_ndjson","text":"dataframe_to_ndjson(df::DataFrame; outfile::Union{String,Nothing}=nothing)\n\nConverts a DataFrame df into a newline-delimited JSON (NDJSON) string. Each line in the returned string represents one DataFrame row in JSON format, suitable for upload to Google BigQuery.\n\nKeyword Arguments\n\noutfile::Union{String,Nothing}: If provided, writes the resulting NDJSON to the file path given.\n\nExamples\n\n```julia using DataFrames, Dates\n\nSample DataFrame\n\ndf = DataFrame(     id = [1, 2, 3],     name = [\"Alice\", \"Bob\", \"Carol\"],     created = [DateTime(2025, 4, 8, 14, 30), DateTime(2025, 4, 8, 15, 0), missing] )\n\nndjsonstr = dataframetondjson(df) println(ndjsonstr)\n\nOptionally, write to a file\n\ndataframetondjson(df; outfile=\"output.ndjson\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.deduplicate_fasta_file-Tuple{Any, Any}","page":"Home","title":"Mycelia.deduplicate_fasta_file","text":"deduplicate_fasta_file(in_fasta, out_fasta) -> Any\n\n\nRemove duplicate sequences from a FASTA file while preserving headers.\n\nArguments\n\nin_fasta: Path to input FASTA file\nout_fasta: Path where deduplicated FASTA will be written\n\nReturns\n\nPath to the output FASTA file (same as out_fasta parameter)\n\nDetails\n\nSequences are considered identical if they match exactly (case-sensitive)\nFor duplicate sequences, keeps the first header encountered\nInput sequences are sorted by identifier before deduplication\nPreserves the original sequence formatting\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.detect_alphabet-Tuple{AbstractString}","page":"Home","title":"Mycelia.detect_alphabet","text":"detect_alphabet(seq::AbstractString) -> Symbol\n\n\nDetermines the alphabet of a sequence. The function scans through seq only once:\n\nIf a 'T' or 't' is found (and no 'U/u'), the sequence is classified as DNA.\nIf a 'U' or 'u' is found (and no 'T/t'), it is classified as RNA.\nIf both T and U occur, an error is thrown.\nIf a character outside the canonical nucleotide and ambiguity codes is encountered, the sequence is assumed to be protein.\nIf neither T nor U are found, the sequence is assumed to be DNA.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.detect_alphabet-Tuple{BioSequences.LongAA}","page":"Home","title":"Mycelia.detect_alphabet","text":"detect_alphabet(sequence::BioSequences.LongAA) -> Symbol\n\n\nDetect the alphabet of a LongAA sequence.\n\nAlways returns :AA.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.detect_alphabet-Tuple{BioSequences.LongDNA}","page":"Home","title":"Mycelia.detect_alphabet","text":"detect_alphabet(sequence::BioSequences.LongDNA) -> Symbol\n\n\nDetect the alphabet of a LongDNA sequence.\n\nAlways returns :DNA.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.detect_alphabet-Tuple{BioSequences.LongRNA}","page":"Home","title":"Mycelia.detect_alphabet","text":"detect_alphabet(sequence::BioSequences.LongRNA) -> Symbol\n\n\nDetect the alphabet of a LongRNA sequence.\n\nAlways returns :RNA.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.detect_and_extract_sequence-Tuple{Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.detect_and_extract_sequence","text":"detect_and_extract_sequence(\n    record::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}\n) -> Tuple{Symbol, Union{BioSequences.LongAA, BioSequences.LongDNA{4}, BioSequences.LongRNA{4}}}\n\n\nDetect alphabet and extract typed sequence from FASTX record in one step.\n\nConvenience function that combines alphabet detection with type-safe sequence extraction, ideal for workflows that need to determine sequence type once at the beginning.\n\nArguments\n\nrecord::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}: Input sequence record\n\nReturns\n\nTuple{Symbol, BioSequences.BioSequence}: (alphabetsymbol, typedsequence)\n\nExamples\n\nrecord = FASTX.FASTQ.Record(\"read1\", \"ATCG\", \"IIII\")\nalphabet, sequence = detect_and_extract_sequence(record)\n# alphabet = :DNA, sequence = LongDNA{4} object\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.detect_bubbles_next-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}}","page":"Home","title":"Mycelia.detect_bubbles_next","text":"detect_bubbles_next(graph::MetaGraphsNext.MetaGraph, min_bubble_length::Int=2, max_bubble_length::Int=100) -> Vector{BubbleStructure}\n\nDetect bubble structures (alternative paths) in the assembly graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.detect_sequence_extension-Tuple{Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.detect_sequence_extension","text":"detect_sequence_extension(\n    record::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}\n) -> String\n\n\nDetect sequence type from input and suggest appropriate file extension.\n\nArguments\n\nrecord: A FASTA/FASTQ record\nsequence: A string or BioSequence containing sequence data\n\nReturns\n\nString: Suggested file extension:\n\".fna\" for DNA\n\".frn\" for RNA\n\".faa\" for protein\n\".fa\" for unrecognized sequences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_fasta_coverage_from_bam-Tuple{Any}","page":"Home","title":"Mycelia.determine_fasta_coverage_from_bam","text":"determine_fasta_coverage_from_bam(bam) -> Any\n\n\nCalculate per-base genomic coverage from a BAM file using bedtools.\n\nArguments\n\nbam::String: Path to input BAM file\n\nReturns\n\nString: Path to the generated coverage file (.coverage.txt)\n\nDetails\n\nUses bedtools genomecov to compute per-base coverage. Creates a coverage file  with the format: <chromosome> <position> <coverage_depth>.  If the coverage file already exists, returns the existing file path.\n\nDependencies\n\nRequires bedtools (automatically installed in conda environment)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_max_canonical_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.determine_max_canonical_kmers","text":"determine_max_canonical_kmers(k, ALPHABET) -> Any\n\n\nCalculate the maximum number of possible canonical k-mers for a given alphabet.\n\nArguments\n\nk::Integer: Length of k-mer\nALPHABET::Vector{Char}: Character set (nucleotides or amino acids)\n\nReturns\n\nInt: Maximum number of possible canonical k-mers\n\nDetails\n\nFor amino acids (AA_ALPHABET): returns total possible k-mers\nFor nucleotides: returns half of total possible k-mers (canonical form)\nRequires odd k-mer length for nucleotide alphabets\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_max_possible_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.determine_max_possible_kmers","text":"determine_max_possible_kmers(k, ALPHABET) -> Any\n\n\nCalculate the total number of possible unique k-mers that can be generated from a given alphabet.\n\nArguments\n\nk: Length of k-mers to consider\nALPHABET: Vector containing the allowed characters/symbols\n\nReturns\n\nInteger representing the maximum number of possible unique k-mers (|Σ|ᵏ)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_primary_contig-Tuple{Any}","page":"Home","title":"Mycelia.determine_primary_contig","text":"determine_primary_contig(qualimap_results) -> Any\n\n\nDetermines the contig with the greatest number of total bases mapping to it\n\nIdentify the primary contig based on mapping coverage from Qualimap results.\n\nArguments\n\nqualimap_results::DataFrame: DataFrame containing Qualimap alignment statistics with  columns \"Contig\" and \"Mapped bases\"\n\nReturns\n\nString: Name of the contig with the highest number of mapped bases\n\nDescription\n\nTakes Qualimap alignment results and determines which contig has the most total bases  mapped to it, which often indicates the main chromosomal assembly.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_read_lengths-Tuple{Any}","page":"Home","title":"Mycelia.determine_read_lengths","text":"determine_read_lengths(\n    fastq_file;\n    total_reads\n) -> Vector{Int64}\n\n\nCalculate sequence lengths for reads in a FASTQ file.\n\nArguments\n\nfastq_file::String: Path to input FASTQ file\ntotal_reads::Integer=Inf: Number of reads to process (defaults to all reads)\n\nReturns\n\nVector{Int}: Array containing the length of each sequence read\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.dictvec_to_dataframe-Tuple{Vector{<:AbstractDict}}","page":"Home","title":"Mycelia.dictvec_to_dataframe","text":"dictvec_to_dataframe(dictvec::Vector{<:AbstractDict}; symbol_columns::Bool = true)\n\nConvert a vector of dictionaries (with possibly non-uniform keys and any key type) into a DataFrame. Missing keys in a row are filled with missing.\n\nArguments\n\ndictvec: Vector of dictionaries.\nsymbol_columns: If true (default), columns are named as Symbols (when possible), else as raw keys.\n\nReturns\n\nDataFrames.DataFrame with columns as the union of all keys.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.distance_matrix_to_newick-Tuple{}","page":"Home","title":"Mycelia.distance_matrix_to_newick","text":"distance_matrix_to_newick(\n;\n    distance_matrix,\n    labels,\n    outfile\n)\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\nConvert a distance matrix into a Newick tree format using UPGMA hierarchical clustering.\n\nArguments\n\ndistance_matrix: Square matrix of pairwise distances between entities\nlabels: Vector of labels corresponding to the entities in the distance matrix\noutfile: Path where the Newick tree file will be written\n\nReturns\n\nPath to the generated Newick tree file\n\nDetails\n\nPerforms hierarchical clustering using the UPGMA (average linkage) method and  converts the resulting dendrogram into Newick tree format. The branch lengths  in the tree represent the heights from the clustering.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.document_frequency-Tuple{Any}","page":"Home","title":"Mycelia.document_frequency","text":"document_frequency(\n    documents\n) -> Dict{T, Int64} where T<:(SubString{_A} where _A)\n\n\nCalculate the document frequency of tokens across a collection of documents.\n\nArguments\n\ndocuments: Collection of text documents where each document is a string\n\nReturns\n\nDictionary mapping each unique token to the number of documents it appears in\n\nDescription\n\nComputes how many documents contain each unique token. Each document is tokenized  by splitting on whitespace. Tokens are counted only once per document, regardless  of how many times they appear within that document.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_bandage","page":"Home","title":"Mycelia.download_bandage","text":"download_bandage() -> String\ndownload_bandage(outdir) -> Any\n\n\nDownloads and installs Bandage, a bioinformatics visualization tool for genome assembly graphs.\n\nArguments\n\noutdir=\"/usr/local/bin\": Target installation directory for the Bandage executable\n\nReturns\n\nPath to the installed Bandage executable\n\nDetails\n\nDownloads Bandage v0.8.1 for Ubuntu\nInstalls required system dependencies (libxcb-glx0, libx11-xcb-dev, libfontconfig, libgl1-mesa-glx)\nAttempts installation with sudo, falls back to root if sudo fails\nSkips download if Bandage is already installed at target location\n\nDependencies\n\nRequires system commands: wget, unzip, apt\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.download_blast_db-Tuple{}","page":"Home","title":"Mycelia.download_blast_db","text":"download_blast_db(; db, dbdir, source, wait)\n\n\nSmart downloading of blast dbs depending on interactive, non interactive context\n\nFor a list of all available databases, run: Mycelia.list_blastdbs()\n\nDownloads and sets up BLAST databases from various sources.\n\nArguments\n\ndb: Name of the BLAST database to download\ndbdir: Directory to store the downloaded database (default: \"~/workspace/blastdb\")\nsource: Download source - one of [\"\", \"aws\", \"gcp\", \"ncbi\"]. Empty string auto-detects fastest source\nwait: Whether to wait for download completion (default: true)\n\nReturns\n\nString path to the downloaded database directory\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_genome_by_accession-Tuple{}","page":"Home","title":"Mycelia.download_genome_by_accession","text":"download_genome_by_accession(\n;\n    accession,\n    outdir,\n    compressed\n)\n\n\nDownloads a genomic sequence from NCBI's nucleotide database by its accession number.\n\nArguments\n\naccession::String: NCBI nucleotide accession number (e.g. \"NC_045512\")\noutdir::String: Output directory path. Defaults to current directory\ncompressed::Bool: If true, compresses output file with gzip. Defaults to true\n\nReturns\n\nString: Path to the downloaded file (.fna or .fna.gz)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_genome_by_ftp-Tuple{}","page":"Home","title":"Mycelia.download_genome_by_ftp","text":"download_genome_by_ftp(; ftp, outdir)\n\n\nDownloads a genome file from NCBI FTP server to the specified directory.\n\nArguments\n\nftp::String: NCBI FTP path for the genome (e.g. \"ftp://ftp.ncbi.nlm.nih.gov/.../\")\noutdir::String: Output directory path. Defaults to current working directory.\n\nReturns\n\nString: Path to the downloaded file\n\nNotes\n\nIf the target file already exists, returns the existing file path without re-downloading\nDownloads the genomic.fna.gz version of the genome\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_mmseqs_db-Tuple{}","page":"Home","title":"Mycelia.download_mmseqs_db","text":"download_mmseqs_db(; db, dbdir, force, wait)\n\n\nDownloads and sets up MMseqs2 reference databases for sequence searching and analysis.\n\nArguments\n\ndb::String: Name of database to download (see table below)\ndbdir::String: Directory to store the downloaded database (default: \"~/workspace/mmseqs\")\nforce::Bool: If true, force re-download even if database exists (default: false)\nwait::Bool: If true, wait for download to complete (default: true)\n\nReturns\n\nPath to the downloaded database as a String\n\nAvailable Databases\n\nDatabase Type Taxonomy Description\nUniRef100 Aminoacid Yes UniProt Reference Clusters - 100% identity\nUniRef90 Aminoacid Yes UniProt Reference Clusters - 90% identity\nUniRef50 Aminoacid Yes UniProt Reference Clusters - 50% identity\nUniProtKB Aminoacid Yes Universal Protein Knowledge Base\nNR Aminoacid Yes NCBI Non-redundant proteins\nNT Nucleotide No NCBI Nucleotide collection\nGTDB Aminoacid Yes Genome Taxonomy Database\nPDB Aminoacid No Protein Data Bank structures\nPfam-A.full Profile No Protein family alignments\nSILVA Nucleotide Yes Ribosomal RNA database\n\n  Name                  Type            Taxonomy        Url                                                           \n- UniRef100             Aminoacid            yes        https://www.uniprot.org/help/uniref\n- UniRef90              Aminoacid            yes        https://www.uniprot.org/help/uniref\n- UniRef50              Aminoacid            yes        https://www.uniprot.org/help/uniref\n- UniProtKB             Aminoacid            yes        https://www.uniprot.org/help/uniprotkb\n- UniProtKB/TrEMBL      Aminoacid            yes        https://www.uniprot.org/help/uniprotkb\n- UniProtKB/Swiss-Prot  Aminoacid            yes        https://uniprot.org\n- NR                    Aminoacid            yes        https://ftp.ncbi.nlm.nih.gov/blast/db/FASTA\n- NT                    Nucleotide             -        https://ftp.ncbi.nlm.nih.gov/blast/db/FASTA\n- GTDB                  Aminoacid            yes        https://gtdb.ecogenomic.org\n- PDB                   Aminoacid              -        https://www.rcsb.org\n- PDB70                 Profile                -        https://github.com/soedinglab/hh-suite\n- Pfam-A.full           Profile                -        https://pfam.xfam.org\n- Pfam-A.seed           Profile                -        https://pfam.xfam.org\n- Pfam-B                Profile                -        https://xfam.wordpress.com/2020/06/30/a-new-pfam-b-is-released\n- CDD                   Profile                -        https://www.ncbi.nlm.nih.gov/Structure/cdd/cdd.shtml\n- eggNOG                Profile                -        http://eggnog5.embl.de\n- VOGDB                 Profile                -        https://vogdb.org\n- dbCAN2                Profile                -        http://bcb.unl.edu/dbCAN2\n- SILVA                 Nucleotide           yes        https://www.arb-silva.de\n- Resfinder             Nucleotide             -        https://cge.cbs.dtu.dk/services/ResFinder\n- Kalamari              Nucleotide           yes        https://github.com/lskatz/Kalamari\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_sra_data-Tuple{String}","page":"Home","title":"Mycelia.download_sra_data","text":"Downloads sequencing reads from NCBI's Sequence Read Archive (SRA).\n\nDownloads reads using fasterq-dump. The function automatically detects whether the data is single-end or paired-end and returns appropriate file paths. Users should apply quality control based on their knowledge of the data type.\n\nArguments\n\nsrr_identifier: SRA run identifier (e.g., \"SRR1234567\")\noutdir: Output directory for downloaded files (default: current directory)\n\nReturns\n\nNamed tuple with:\n\nsrr_id: The SRA identifier\noutdir: Output directory path\nfiles: Vector of downloaded file paths (1 file for single-end, 2 for paired-end)\nis_paired: Boolean indicating if data is paired-end\n\nExample\n\n# Download SRA data\nresult = Mycelia.download_sra_data(\"SRR1234567\", outdir=\"./data\")\n\n# Apply appropriate QC based on data type\nif result.is_paired\n    # Paired-end data - use paired-end QC\n    Mycelia.trim_galore_paired(forward_reads=result.files[1], reverse_reads=result.files[2])\nelse\n    # Single-end data - use single-end QC\n    Mycelia.qc_filter_short_reads_fastp(input=result.files[1])\nend\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.draw_dendrogram_tree-Tuple{MetaGraphs.MetaDiGraph}","page":"Home","title":"Mycelia.draw_dendrogram_tree","text":"draw_dendrogram_tree(\n    mg::MetaGraphs.MetaDiGraph;\n    width,\n    height,\n    fontsize,\n    margins,\n    mergenodesize,\n    lineweight,\n    filename\n) -> Luxor.Drawing\n\n\nDraw a dendrogram visualization of hierarchical clustering results stored in a MetaDiGraph.\n\nArguments\n\nmg::MetaGraphs.MetaDiGraph: Graph containing hierarchical clustering results. Must have :hcl in graph properties with clustering data and vertex properties containing :x, :y coordinates.\n\nKeywords\n\nwidth::Integer=500: Width of output image in pixels\nheight::Integer=500: Height of output image in pixels \nfontsize::Integer=12: Font size for node labels in points\nmargins::Float64: Margin size in pixels, defaults to min(width,height)/20\nmergenodesize::Float64=1: Size of circular nodes at merge points\nlineweight::Float64=1: Thickness of dendrogram lines\nfilename::String: Output filename, defaults to timestamp with .dendrogram.png extension\n\nReturns\n\nNothing, but saves dendrogram image to disk and displays preview.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.draw_radial_tree-Tuple{MetaGraphs.MetaDiGraph}","page":"Home","title":"Mycelia.draw_radial_tree","text":"draw_radial_tree(\n    mg::MetaGraphs.MetaDiGraph;\n    width,\n    height,\n    fontsize,\n    margins,\n    mergenodesize,\n    lineweight,\n    filename\n) -> Luxor.Drawing\n\n\nDraw a radial hierarchical clustering tree visualization and save it as an image file.\n\nArguments\n\nmg::MetaGraphs.MetaDiGraph: A meta directed graph containing hierarchical clustering data with required graph properties :hcl containing clustering information.\n\nKeywords\n\nwidth::Int=500: Width of the output image in pixels\nheight::Int=500: Height of the output image in pixels\nfontsize::Int=12: Font size for node labels\nmargins::Float64: Margin size (automatically calculated as min(width,height)/20)\nmergenodesize::Float64=1: Size of the merge point nodes\nlineweight::Float64=1: Thickness of the connecting lines\nfilename::String: Output filename (defaults to timestamp with \".radial.png\" suffix)\n\nDetails\n\nThe function creates a radial visualization of hierarchical clustering results where:\n\nLeaf nodes are arranged in a circle with labels\nInternal nodes represent merge points\nConnections show the hierarchical structure through arcs and lines\n\nThe visualization is saved as a PNG file and automatically previewed.\n\nRequired Graph Properties\n\nThe input graph must have:\n\nmg.gprops[:hcl].labels: Vector of leaf node labels\nmg.gprops[:hcl].order: Vector of ordered leaf nodes\nmg.gprops[:hcl].merges: Matrix of merge operations\nmg.vprops[v][:x]: X coordinate for each vertex\nmg.vprops[v][:y]: Y coordinate for each vertex\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.drop_empty_columns!-Tuple{DataFrames.AbstractDataFrame}","page":"Home","title":"Mycelia.drop_empty_columns!","text":"drop_empty_columns!(\n    df::DataFrames.AbstractDataFrame\n) -> DataFrames.AbstractDataFrame\n\n\nIdentify all columns that have only missing or empty values, and remove those columns from the dataframe in-place.\n\nReturns a modified version of the original dataframe. \n\nSee also: dropemptycolumns\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.drop_empty_columns-Tuple{DataFrames.AbstractDataFrame}","page":"Home","title":"Mycelia.drop_empty_columns","text":"drop_empty_columns(df::DataFrames.AbstractDataFrame) -> Any\n\n\nIdentify all columns that have only missing or empty values, and remove those columns from the dataframe.\n\nReturns a modified copy of the dataframe.\n\nSee also: dropemptycolumns!\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.edge_path_to_sequence-Tuple{Any, Any}","page":"Home","title":"Mycelia.edge_path_to_sequence","text":"edge_path_to_sequence(kmer_graph, edge_path) -> Any\n\n\nConverts a path of edges in a kmer graph into a DNA sequence by concatenating overlapping kmers.\n\nArguments\n\nkmer_graph: A directed graph where vertices represent kmers and edges represent overlaps\nedge_path: Vector of edges representing a path through the graph\n\nReturns\n\nA BioSequences.LongDNASeq containing the merged sequence represented by the path\n\nDetails\n\nThe function:\n\nTakes the first kmer from the source vertex of first edge\nFor each edge, handles orientation (forward/reverse complement)\nVerifies overlaps between consecutive kmers\nConcatenates unique bases to build final sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.edge_probability-Tuple{Any, Any}","page":"Home","title":"Mycelia.edge_probability","text":"edge_probability(stranded_kmer_graph, edge) -> Any\n\n\nCalculate the probability of traversing a specific edge in a stranded k-mer graph.\n\nThe probability is computed as the ratio of this edge's coverage weight to the sum of all outgoing edge weights from the source vertex.\n\nedge_probability(stranded_kmer_graph, edge) -> Any\n\n\nArguments\n\nstranded_kmer_graph: A directed graph where edges represent k-mer connections\nedge: The edge for which to calculate the probability\n\nReturns\n\nFloat64: Probability in range [0,1] representing likelihood of traversing this edge Returns 0.0 if sum of all outgoing edge weights is zero\n\nNote\n\nProbability is based on the :coverage property of edges, using their length as weights\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.edgemer_to_vertex_kmers-Tuple{Any}","page":"Home","title":"Mycelia.edgemer_to_vertex_kmers","text":"edgemer_to_vertex_kmers(\n    edgemer\n) -> Tuple{Kmers.Kmer{BioSequences.DNAAlphabet{2}}, Kmers.Kmer{BioSequences.DNAAlphabet{2}}}\n\n\nConvert an edgemer to two vertex kmers.\n\nThis function takes an edgemer (a sequence of DNA nucleotides) and converts it into two vertex kmers.  A kmer is a substring of length k from a DNA sequence. The first kmer is created from the first  n-1 elements of the edgemer, and the second kmer is created from the last n-1 elements of the edgemer.\n\nArguments\n\nedgemer::AbstractVector{T}: A vector of DNA nucleotides where T is a subtype of BioSequences.DNAAlphabet{2}.\n\nReturns\n\nTuple{Kmers.Kmer{BioSequences.DNAAlphabet{2}}, Kmers.Kmer{BioSequences.DNAAlphabet{2}}}: A tuple containing two kmers.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ensure_next_graph-Tuple{Any}","page":"Home","title":"Mycelia.ensure_next_graph","text":"ensure_next_graph(graph) -> Any\n\n\nAutomatically convert legacy graphs to next-generation format if needed.\n\nThis is a convenience function that checks the graph type and converts if necessary.\n\nArguments\n\ngraph: Graph in either legacy or next-generation format\n\nReturns\n\nMetaGraphsNext.MetaGraph: Graph in next-generation format\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.equally_spaced_samples-Tuple{Any, Any}","page":"Home","title":"Mycelia.equally_spaced_samples","text":"equally_spaced_samples(vector, n) -> Any\n\n\nSample n equally spaced elements from vector.\n\nArguments\n\nvector: Input vector to sample from\nn: Number of samples to return (must be positive)\n\nReturns\n\nA vector containing n equally spaced elements from the input vector.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.equivalent_fasta_sequences-Tuple{Any, Any}","page":"Home","title":"Mycelia.equivalent_fasta_sequences","text":"equivalent_fasta_sequences(fasta_1, fasta_2) -> Bool\n\n\nCompare two FASTA files to determine if they contain the same set of sequences, regardless of sequence order.\n\nArguments\n\nfasta_1::String: Path to first FASTA file\nfasta_2::String: Path to second FASTA file\n\nReturns\n\nBool: true if both files contain exactly the same sequences, false otherwise\n\nDetails\n\nPerforms a set-based comparison of DNA sequences by hashing each sequence. Sequence order differences between files do not affect the result.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.error_rate_to_q_value-Tuple{Any}","page":"Home","title":"Mycelia.error_rate_to_q_value","text":"error_rate_to_q_value(error_rate) -> Any\n\n\nConvert a sequencing error probability to a Phred quality score (Q-value).\n\nThe calculation uses the standard Phred formula: Q = -10 * log₁₀(error_rate)\n\nArguments\n\nerror_rate::Float64: Probability of error (between 0 and 1)\n\nReturns\n\nq_value::Float64: Phred quality score\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.errors_are_singletons-Tuple{Vector{<:FASTX.FASTQ.Record}, Int64}","page":"Home","title":"Mycelia.errors_are_singletons","text":"Analyze k-mer coverage distribution to detect if errors are singletons. Returns true if low-coverage k-mers (likely errors) are well-separated from high-coverage ones.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.estimate_copy_number-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Vector{String}}","page":"Home","title":"Mycelia.estimate_copy_number","text":"Estimate copy number for repeat region.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.estimate_dense_matrix_memory-Tuple","page":"Home","title":"Mycelia.estimate_dense_matrix_memory","text":"estimate_dense_matrix_memory(nrows::Integer, ncols::Integer)\nestimate_dense_matrix_memory(T::DataType, nrows::Integer, ncols::Integer)\n\nEstimate the memory required (in bytes) for a dense matrix.\n\nIf T is provided, estimate memory for a matrix with element type T.\nIf T is not provided, defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.estimate_genome_size_from_kmers-Tuple{Union{AbstractString, BioSequences.LongSequence}, Integer}","page":"Home","title":"Mycelia.estimate_genome_size_from_kmers","text":"estimate_genome_size_from_kmers(\n    sequence::Union{AbstractString, BioSequences.LongSequence},\n    k::Integer\n) -> Dict\n\n\nEstimate genome size from k-mer analysis using total k-mer count.\n\nThis function estimates genome size using the basic relationship:  genomesize ≈ totalkmers - k + 1, where total_kmers is the sum of all k-mer  counts. This is a simple estimation method; more sophisticated approaches  accounting for sequencing depth, repeats, and errors may be more accurate.\n\nArguments\n\nsequence::Union{BioSequences.LongSequence, AbstractString}: Input sequence or string\nk::Integer: K-mer size for analysis\n\nReturns\n\nDict{String, Any}: Dictionary containing:\n\"unique_kmers\": Number of unique k-mers observed\n\"total_kmers\": Total k-mer count (sum of all frequencies)\n\"estimatedgenomesize\": Estimated genome size\n\"actual_size\": Length of input sequence (if provided)\n\nExamples\n\n# Estimate genome size from a sequence\nsequence = \"ATCGATCGATCGATCG\"\nresult = estimate_genome_size_from_kmers(sequence, 5)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.estimate_genome_size_from_kmers-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}","page":"Home","title":"Mycelia.estimate_genome_size_from_kmers","text":"estimate_genome_size_from_kmers(\n    records::AbstractArray{T<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}, 1},\n    k::Integer\n)\n\n\nEstimate genome size from FASTQ/FASTA records using k-mer analysis.\n\nOverload for processing FASTQ or FASTA records directly.\n\nArguments\n\nrecords::AbstractVector{T} where T <: Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}`: Input records\nk::Integer: K-mer size for analysis\n\nReturns\n\nDict{String, Any}: Dictionary with k-mer statistics and genome size estimate\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.estimate_memory_usage-Tuple{Int64, Int64}","page":"Home","title":"Mycelia.estimate_memory_usage","text":"Estimate memory usage for a graph with given number of k-mers. Provides rough estimate for memory monitoring.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.estimate_sparse_matrix_memory-Tuple","page":"Home","title":"Mycelia.estimate_sparse_matrix_memory","text":"estimate_sparse_matrix_memory(nrows::Integer, ncols::Integer; nnz=nothing, density=nothing)\nestimate_sparse_matrix_memory(T::DataType, nrows::Integer, ncols::Integer; nnz=nothing, density=nothing)\n\nEstimate the memory required (in bytes) for a sparse matrix in CSC format.\n\nIf T is provided, estimate memory for a matrix with element type T.\nIf T is not provided, defaults to Float64.\nYou must specify either nnz (number of non-zeros) or density (proportion of non-zeros, between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.estimate_transition_probabilities-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Vector}","page":"Home","title":"Mycelia.estimate_transition_probabilities","text":"estimate_transition_probabilities(graph::MetaGraph, sequences::Vector) -> Matrix{Float64}\n\nEstimate transition probabilities from observed sequences in the graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.evaluate_assembly_agent-Tuple{Mycelia.DQNPolicy, Vector{String}}","page":"Home","title":"Mycelia.evaluate_assembly_agent","text":"evaluate_assembly_agent(policy::DQNPolicy, validation_data::Vector{String}; episodes=10)\n\nEvaluate a trained assembly agent on validation data.\n\nArguments\n\npolicy::DQNPolicy: Trained policy to evaluate\nvalidation_data::Vector{String}: Validation FASTQ files\nepisodes::Int: Number of evaluation episodes (default: 10)\n\nReturns\n\nDict{String, Float64}: Evaluation metrics including mean reward, assembly quality, etc.\n\nExample\n\n# metrics = evaluate_assembly_agent(trained_policy, validation_files)\n# println(\"Mean reward: $(metrics[\"mean_reward\"])\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.evaluate_classification-Tuple{Any, Any}","page":"Home","title":"Mycelia.evaluate_classification","text":"evaluate_classification(true_labels, pred_labels)\n\nRuns confusionmatrix, precisionrecall_f1, and accuracy. Pretty-prints macro metrics and accuracy. Returns a named tuple with all results and plots.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.execute_continue_k_action-Tuple{Mycelia.AssemblyEnvironment, Mycelia.AssemblyAction}","page":"Home","title":"Mycelia.execute_continue_k_action","text":"execute_continue_k_action(env::AssemblyEnvironment, action::AssemblyAction)\n\nExecute a \"continue with current k\" action by performing error correction iterations.\n\nArguments\n\nenv::AssemblyEnvironment: Current environment\naction::AssemblyAction: Action specifying correction parameters\n\nReturns\n\nRewardComponents: Reward breakdown for the action\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.execute_next_k_action-Tuple{Mycelia.AssemblyEnvironment, Mycelia.AssemblyAction}","page":"Home","title":"Mycelia.execute_next_k_action","text":"execute_next_k_action(env::AssemblyEnvironment, action::AssemblyAction)\n\nExecute a \"move to next k\" action by progressing to the next prime k-mer size.\n\nArguments\n\nenv::AssemblyEnvironment: Current environment\naction::AssemblyAction: Action specifying progression parameters\n\nReturns\n\nRewardComponents: Reward breakdown for the action\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.execute_terminate_action-Tuple{Mycelia.AssemblyEnvironment, Mycelia.AssemblyAction}","page":"Home","title":"Mycelia.execute_terminate_action","text":"execute_terminate_action(env::AssemblyEnvironment, action::AssemblyAction)\n\nExecute a \"terminate assembly\" action and assess final assembly quality.\n\nArguments\n\nenv::AssemblyEnvironment: Current environment\naction::AssemblyAction: Termination action\n\nReturns\n\nRewardComponents: Final reward breakdown including assembly quality assessment\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.export_blast_db-Tuple{}","page":"Home","title":"Mycelia.export_blast_db","text":"export_blast_db(; path_to_db, fasta)\n\n\nExport sequences from a BLAST database to a gzipped FASTA file.\n\nArguments\n\npath_to_db: Path to the BLAST database\nfasta: Output path for the gzipped FASTA file (default: path_to_db * \".fna.gz\")\n\nDetails\n\nUses conda's BLAST environment to extract sequences using blastdbcmd. The output is automatically compressed using pigz. If the output file already exists, the function will skip extraction.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.export_blast_db_taxonomy_table-Tuple{}","page":"Home","title":"Mycelia.export_blast_db_taxonomy_table","text":"export_blast_db_taxonomy_table(; path_to_db, outfile)\n\n\nExports a taxonomy mapping table from a BLAST database in seqid2taxid format.\n\nArguments\n\npath_to_db::String: Path to the BLAST database\noutfile::String: Output file path (defaults to input path + \".seqid2taxid.txt.gz\")\n\nReturns\n\nString: Path to the created output file\n\nDetails\n\nCreates a compressed tab-delimited file mapping sequence IDs to taxonomy IDs. Uses blastdbcmd without GI identifiers for better cross-referencing compatibility. If the output file already exists, returns the path without regenerating.\n\nDependencies\n\nRequires BLAST+ tools installed via Bioconda.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.extract_pacbiosample_information-Tuple{Any}","page":"Home","title":"Mycelia.extract_pacbiosample_information","text":"extract_pacbiosample_information(\n    xml\n) -> DataFrames.DataFrame\n\n\nExtract biosample and barcode information from a PacBio XML metadata file.\n\nArguments\n\nxml: Path to PacBio XML metadata file\n\nReturns\n\nDataFrame with two columns:\n\nBioSampleName: Name of the biological sample\nBarcodeName: Associated DNA barcode identifier\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.extract_typed_sequence-Tuple{Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}, Type{<:BioSequences.BioSequence}}","page":"Home","title":"Mycelia.extract_typed_sequence","text":"extract_typed_sequence(\n    record::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record},\n    sequence_type::Type{<:BioSequences.BioSequence}\n) -> Any\n\n\nExtract sequence from FASTX record using dynamically determined type.\n\nThis function provides type-safe sequence extraction by using the appropriate BioSequence type, avoiding hardcoded sequence types and string conversions.\n\nArguments\n\nrecord::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}: Input sequence record\nsequence_type::Type{<:BioSequences.BioSequence}: Target BioSequence type\n\nReturns\n\nBioSequences.BioSequence: Typed sequence from the record\n\nExamples\n\nrecord = FASTX.FASTQ.Record(\"read1\", \"ATCG\", \"IIII\")\nseq_type = alphabet_to_biosequence_type(:DNA)\nsequence = extract_typed_sequence(record, seq_type)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_and_gff_to_genbank-Tuple{}","page":"Home","title":"Mycelia.fasta_and_gff_to_genbank","text":"fasta_and_gff_to_genbank(; fasta, gff, genbank)\n\n\nConvert FASTA sequence and GFF annotation files to GenBank format using EMBOSS seqret.\n\nArguments\n\nfasta::String: Path to input FASTA file containing sequence data\ngff::String: Path to input GFF file containing genomic features\ngenbank::String: Path for output GenBank file\n\nDetails\n\nRequires EMBOSS toolkit (installed via Bioconda). The function will:\n\nCreate necessary output directories\nRun seqret to combine sequence and features\nGenerate a GenBank format file at the specified location\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_genome_size-Tuple{Any}","page":"Home","title":"Mycelia.fasta_genome_size","text":"fasta_genome_size(fasta_file) -> Any\n\n\nCalculate the total size (in bases) of all sequences in a FASTA file.\n\nArguments\n\nfasta_file::AbstractString: Path to the FASTA file\n\nReturns\n\nInt: Sum of lengths of all sequences in the FASTA file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_list_to_dense_kmer_counts-Tuple{}","page":"Home","title":"Mycelia.fasta_list_to_dense_kmer_counts","text":"fasta_list_to_dense_kmer_counts(\n;\n    fasta_list,\n    k,\n    alphabet,\n    temp_dir_parent,\n    count_element_type,\n    result_file,\n    force,\n    cleanup_temp\n)\n\n\nCreate a dense k-mer counts table for a set of FASTA files, with disk-backed temporary storage,  custom element type, robust error handling, and optional output file caching.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_list_to_sparse_kmer_counts-Tuple{}","page":"Home","title":"Mycelia.fasta_list_to_sparse_kmer_counts","text":"fasta_list_to_sparse_kmer_counts(\n;\n    fasta_list,\n    k,\n    alphabet,\n    temp_dir_parent,\n    count_element_type,\n    rarefaction_data_filename,\n    rarefaction_plot_basename,\n    show_rarefaction_plot,\n    result_file,\n    out_dir,\n    force,\n    rarefaction_plot_kwargs...\n)\n\n\nCreate a sparse kmer counts table (SparseMatrixCSC) from a list of FASTA files using a 3-pass approach. Pass 1 (Parallel): Counts kmers per file and writes to temporary JLD2 files. Pass 2 (Serial): Aggregates unique kmers, max count, nnz per file, and rarefaction data from temp files.                  Generates and saves a k-mer rarefaction plot. Pass 3 (Parallel): Reads temporary counts again to construct the final sparse matrix.\n\nOptionally, a results filename can be provided to save/load the output. If the file exists and force is false, the result is loaded and returned. If force is true or the file does not exist, results are computed and saved.\n\nOutput Directory Behavior\n\nAll auxiliary output files (e.g., rarefaction data, plots) are written to a common output directory.\nBy default, this is:\nThe value of out_dir if provided.\nOtherwise, the directory containing result_file (if provided and has a directory component).\nOtherwise, the current working directory (pwd()).\nIf you provide an absolute path for an output file (e.g. rarefaction_data_filename), that path is used directly.\nIf both out_dir and a relative filename are given, the file is written to out_dir.\n\nArguments\n\nfasta_list::AbstractVector{<:AbstractString}: A list of paths to FASTA files.\nk::Integer: The length of the kmer.\nalphabet::Symbol: The alphabet type (:AA, :DNA, :RNA).\ntemp_dir_parent::AbstractString: Parent directory for creating the temporary working directory. Defaults to Base.tempdir().\ncount_element_type::Union{Type{<:Unsigned}, Nothing}: Optional. Specifies the unsigned integer type for the counts. If nothing (default), the smallest UInt type capable of holding the maximum observed count is used.\nrarefaction_data_filename::AbstractString: Filename for the TSV output of rarefaction data. If a relative path, will be written to out_dir.\nrarefaction_plot_basename::AbstractString: Basename for the output rarefaction plots. If a relative path, will be written to out_dir.\nshow_rarefaction_plot::Bool: Whether to display the rarefaction plot after generation. Defaults to true.\nresult_file::Union{Nothing, AbstractString}: Optional. If provided, path to a file to save/load the full results (kmers, counts, etc) as a JLD2 file.\nout_dir::Union{Nothing, AbstractString}: Optional. Output directory for auxiliary outputs. Defaults as described above.\nforce::Bool: If true, recompute and overwrite the output file even if it exists. Defaults to false.\nrarefaction_plot_kwargs...: Keyword arguments to pass to plot_kmer_rarefaction for plot customization.\n\nReturns\n\nNamedTuple{(:kmers, :counts, :rarefaction_data_path)}:\nkmers: A sorted Vector of unique kmer objects.\ncounts: A SparseArrays.SparseMatrixCSC{V, Int} storing kmer counts.\nrarefaction_data_path: Path to the saved TSV file with rarefaction data.\n\nRaises\n\nErrorException: If input fasta_list is empty, alphabet is invalid, or required Kmer/counting functions are not found.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_table_to_fasta-Tuple{Any}","page":"Home","title":"Mycelia.fasta_table_to_fasta","text":"fasta_table_to_fasta(fasta_df) -> Any\n\n\nConvert a DataFrame containing FASTA sequence information into a vector of FASTA records.\n\nArguments\n\nfasta_df::DataFrame: DataFrame with columns \"identifier\", \"description\", and \"sequence\"\n\nReturns\n\nVector{FASTX.FASTA.Record}: Vector of FASTA records\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_to_reference_kmer_counts-Tuple{}","page":"Home","title":"Mycelia.fasta_to_reference_kmer_counts","text":"fasta_to_reference_kmer_counts(; kmer_type, fasta)\n\n\nCounts k-mer occurrences in a FASTA file, considering both forward and reverse complement sequences.\n\nArguments\n\nkmer_type: Type specification for k-mers (e.g., DNAKmer{21})\nfasta: Path to FASTA file containing reference sequences\n\nReturns\n\nDict{kmer_type, Int}: Dictionary mapping each k-mer to its total count across all sequences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_to_table-Tuple{Any}","page":"Home","title":"Mycelia.fasta_to_table","text":"fasta_to_table(fasta) -> DataFrames.DataFrame\n\n\nConvert a FASTA file/record iterator to a DataFrame.\n\nArguments\n\nfasta: FASTA record iterator from FASTX.jl\n\nReturns\n\nDataFrame with columns:\nidentifier: Sequence identifiers\ndescription: Full sequence descriptions \nsequence: Biological sequences as strings\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_xam_mapping_stats-Tuple{}","page":"Home","title":"Mycelia.fasta_xam_mapping_stats","text":"fasta_xam_mapping_stats(; fasta, xam)\n\n\nCalculate mapping statistics by comparing sequence alignments (BAM/SAM) to a reference FASTA.\n\nArguments\n\nfasta::String: Path to reference FASTA file\nxam::String: Path to alignment file (BAM or SAM format)\n\nReturns\n\nDataFrame with columns:\n\ncontig: Reference sequence name\ncontig_length: Length of reference sequence\ntotal_aligned_bases: Total number of bases aligned to reference\nmean_depth: Average depth of coverage (totalalignedbases/contig_length)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastani_list-Tuple{}","page":"Home","title":"Mycelia.fastani_list","text":"fastani_list(\n;\n    query_list,\n    reference_list,\n    outfile,\n    threads,\n    force\n) -> Union{Nothing, Base.Process}\n\n\nRun fastani with a query and reference list\n\nCalculate Average Nucleotide Identity (ANI) between genome sequences using FastANI.\n\nArguments\n\nquery_list::String: Path to file containing list of query genome paths (one per line)\nreference_list::String: Path to file containing list of reference genome paths (one per line)\noutfile::String: Path to output file that will contain ANI results\nthreads::Int=Sys.CPU_THREADS: Number of parallel threads to use\nforce::Bool=false: If true, rerun analysis even if output file exists\n\nOutput\n\nGenerates a tab-delimited file with columns:\n\nQuery genome\nReference genome  \nANI value (%)\nCount of bidirectional fragment mappings\nTotal query fragments\n\nNotes\n\nRequires FastANI to be available via Bioconda\nAutomatically sets up required conda environment\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasterq_dump-Tuple{}","page":"Home","title":"Mycelia.fasterq_dump","text":"fasterq_dump(\n;\n    outdir,\n    srr_identifier\n) -> NamedTuple{(:forward_reads, :reverse_reads, :unpaired_reads), <:Tuple{Union{Missing, String}, Union{Missing, String}, Union{Missing, String}}}\n\n\nDownload and compress sequencing reads from the SRA database using fasterq-dump.\n\nArguments\n\noutdir::String=\"\": Output directory for the FASTQ files. Defaults to current directory.\nsrr_identifier::String=\"\": SRA run accession number (e.g., \"SRR12345678\")\n\nReturns\n\nNamed tuple containing paths to the generated files:\n\nforward_reads: Path to forward reads file (*_1.fastq.gz) or missing\nreverse_reads: Path to reverse reads file (*_2.fastq.gz) or missing\nunpaired_reads: Path to unpaired reads file (*.fastq.gz) or missing\n\nOutputs\n\nCreates compressed FASTQ files in the output directory:\n\n{srr_identifier}_1.fastq.gz: Forward reads (for paired-end data)\n{srr_identifier}_2.fastq.gz: Reverse reads (for paired-end data)\n{srr_identifier}.fastq.gz: Unpaired reads (for single-end data)\n\nDependencies\n\nRequires:\n\nfasterq-dump from the SRA Toolkit (installed via Conda)\ngzip for compression\n\nNotes\n\nSkips download if output files already exist\nUses up to 4 threads or system maximum, whichever is lower\nAllocates 1GB memory for processing\nSkips technical reads\nHandles both paired-end and single-end data automatically\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasterq_dump_parallel-Tuple{Vector{String}}","page":"Home","title":"Mycelia.fasterq_dump_parallel","text":"Parallel FASTQ dump for multiple SRA files.\n\nConverts multiple SRA files to FASTQ format in parallel. More efficient than sequential processing for large batches.\n\nArguments\n\nsrr_identifiers: Vector of SRA run identifiers\noutdir: Output directory for FASTQ files (default: current directory)\nmax_parallel: Maximum number of parallel conversions (default: 2)\n\nReturns\n\nVector of named tuples with conversion results\n\nExample\n\nruns = [\"SRR1234567\", \"SRR1234568\"]\nresults = Mycelia.fasterq_dump_parallel(runs, outdir=\"./fastq_data\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastq_record-Tuple{}","page":"Home","title":"Mycelia.fastq_record","text":"fastq_record(; identifier, sequence, quality_scores)\n\n\nConstruct a FASTX FASTQ record from its components.\n\nArguments\n\nidentifier::String: The sequence identifier without the '@' prefix\nsequence::String: The nucleotide sequence\nquality_scores::Vector{Int}: Quality scores (0-93) as raw integers\n\nReturns\n\nFASTX.FASTQRecord: A parsed FASTQ record\n\nNotes\n\nQuality scores are automatically capped at 93 to ensure FASTQ compatibility\nQuality scores are converted to ASCII by adding 33 (Phred+33 encoding)\nThe record is constructed in standard FASTQ format with four lines:\nHeader line (@ + identifier)\nSequence\nPlus line\nQuality scores (ASCII encoded)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx2normalized_table-Tuple{Any}","page":"Home","title":"Mycelia.fastx2normalized_table","text":"fastx2normalized_table(fastx::AbstractString) -> DataFrames.DataFrame\n\nfastx2normalized_table(fastx) -> DataFrames.DataFrame\n\n\nRead a FASTA or FASTQ file and convert its records into a normalized DataFrames.DataFrame where each row represents a sequence record and columns provide standardized metadata and sequence statistics.\n\nArguments\n\nfastx::AbstractString: Path to a FASTA or FASTQ file. The file must exist and be non-empty. The file type is inferred from the filename using Mycelia.FASTA_REGEX and Mycelia.FASTQ_REGEX.\n\nReturns\n\nDataFrames.DataFrame: A data frame where each row contains information for a record from the input file, and columns include:\nfastx_path: Basename of the input file.\nfastx_sha256: Aggregated SHA256 hash of all record SHA256s in the file.\nrecord_identifier: Identifier from the record header.\nrecord_description: Description from the record header.\nrecord_sha256: SHA256 hash of the record sequence.\nrecord_quality: Vector of quality scores (Vector{Float64}) for FASTQ, or missing for FASTA.\nrecord_alphabet: Sorted, joined string of unique, uppercase characters in the record sequence.\nrecord_type: Alphabet type detected by Mycelia.detect_alphabet (e.g., :DNA, :RNA, etc.).\nmean_record_quality: Mean quality score (for FASTQ), or missing (for FASTA).\nmedian_record_quality: Median quality score (for FASTQ), or missing (for FASTA).\nrecord_length: Length of the sequence.\nrecord_sequence: The sequence string itself.\n\nNotes\n\nThe function asserts that the file exists and is not empty.\nFile type is determined by regex matching on the filename.\nFor FASTA files, quality-related columns are set to missing.\nFor FASTQ files, quality scores are extracted and statistics are computed.\nRecord SHA256 hashes are aggregated to compute a file-level SHA256 via Mycelia.metasha256.\nRequires the following namespaces: DataFrames, Statistics, Mycelia, FASTX, and Base.basename.\nThe function returns the columns in the order: fastx_path, fastx_sha256, followed by all other record columns.\n\nExample\n\nimport DataFrames\nimport Mycelia\nimport FASTX\n\ntable = fastx2normalized_table(\"example.fasta\")\nDataFrames.first(table, 3)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_stats-Tuple{Any}","page":"Home","title":"Mycelia.fastx_stats","text":"fastx_stats(fastx) -> DataFrames.DataFrame\n\n\nCalculate basic statistics for FASTQ/FASTA sequence files using seqkit.\n\nArguments\n\nfastq::String: Path to input FASTQ/FASTA file\n\nDetails\n\nAutomatically installs and uses seqkit from Bioconda to compute sequence statistics including number of sequences, total bases, GC content, average length, etc.\n\nDependencies\n\nRequires Conda and Bioconda channel\nInstalls seqkit package if not present\n\nReturns\n\nReturns a DataFrame of the table\n\nhttps://bioinf.shenwei.me/seqkit/usage/#stats\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_to_contig_lengths-Tuple{Any}","page":"Home","title":"Mycelia.fastx_to_contig_lengths","text":"fastx_to_contig_lengths(\n    fastx\n) -> OrderedCollections.OrderedDict\n\n\nGenerate detailed mapping statistics for each reference sequence/contig in a XAM (SAM/BAM/CRAM) file.\n\nArguments\n\nxam: Path to XAM file or XAM object\n\nReturns\n\nA DataFrame with per-contig statistics including:\n\nn_aligned_reads: Number of aligned reads\ntotal_aligned_bases: Sum of alignment lengths\ntotal_alignment_score: Sum of alignment scores\nMapping quality statistics (mean, std, median)\nAlignment length statistics (mean, std, median)\nAlignment score statistics (mean, std, median)\nPercent mismatches statistics (mean, std, median)\n\nNote: Only primary alignments (isprimary=true) and mapped reads (ismapped=true) are considered.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_to_kmer_graph-Tuple{Any, AbstractString}","page":"Home","title":"Mycelia.fastx_to_kmer_graph","text":"fastx_to_kmer_graph(\n    KMER_TYPE,\n    fastx::AbstractString\n) -> MetaGraphs.MetaGraph\n\n\nConstructs a k-mer graph from a single FASTX format string.\n\nArguments\n\nKMER_TYPE: The k-mer type specification (e.g., DNAKmer{K} where K is k-mer length)\nfastx::AbstractString: Input sequence in FASTX format (FASTA or FASTQ)\n\nReturns\n\nKmerGraph: A directed graph where vertices are k-mers and edges represent overlaps\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_to_kmer_graph-Tuple{Any, AbstractVector{<:AbstractString}}","page":"Home","title":"Mycelia.fastx_to_kmer_graph","text":"fastx_to_kmer_graph(\n    KMER_TYPE,\n    fastxs::AbstractVector{<:AbstractString}\n) -> MetaGraphs.MetaGraph\n\n\nCreate an in-memory kmer-graph that records:\n\nall kmers\ncounts\nall observed edges between kmers\nedge orientations\nedge counts\n\nConstruct a kmer-graph from one or more FASTX files (FASTA/FASTQ).\n\nArguments\n\nKMER_TYPE: Type for kmer representation (e.g., DNAKmer{K})\nfastxs: Vector of paths to FASTX files\n\nReturns\n\nA MetaGraph where:\n\nVertices represent unique kmers with properties:\n:kmer => The kmer sequence\n:count => Number of occurrences\nEdges represent observed kmer adjacencies with properties:\n:orientation => Relative orientation of connected kmers\n:count => Number of observed transitions\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fibonacci_numbers_less_than-Tuple{Int64}","page":"Home","title":"Mycelia.fibonacci_numbers_less_than","text":"fibonacci_numbers_less_than(\n    n::Int64\n) -> Union{Vector{Any}, Vector{Int64}}\n\n\nGenerate a sequence of Fibonacci numbers strictly less than the input value.\n\nArguments\n\nn::Int: Upper bound (exclusive) for the Fibonacci sequence\n\nReturns\n\nVector{Int}: Array containing Fibonacci numbers less than n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.filesize_human_readable-Tuple{Any}","page":"Home","title":"Mycelia.filesize_human_readable","text":"filesize_human_readable(f) -> Any\n\n\nGets the size of a file and returns it in a human-readable format.\n\nArguments\n\nf: The path to the file, either as a String or an AbstractString.\n\nReturns\n\nA string representing the file size in a human-readable format (e.g., \"3.40 MB\").\n\nDetails\n\nThis function internally uses filesize(f) to get the file size in bytes, then leverages Base.format_bytes to convert it into a human-readable format with appropriate units (KB, MB, GB, etc.).\n\nExamples\n\njulia> filesize_human_readable(\"my_image.jpg\")\n\"2.15 MB\"\n\nSee Also\n\nfilesize: Gets the size of a file in bytes.\nBase.format_bytes: Converts a byte count into a human-readable string. \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.finalize_assembly","page":"Home","title":"Mycelia.finalize_assembly","text":"Finalize assembly by combining information from all k-mer sizes. Phase 5.1b: Enhanced with accuracy metrics and reward tracking.\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.finalize_cross_validation-Tuple{Dict, Dict, Dict, Dict, Float64, String}","page":"Home","title":"Mycelia.finalize_cross_validation","text":"Finalize cross-validation results with comprehensive summary.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.finalize_iterative_assembly-Tuple{String, Vector{Int64}, Dict{Int64, Vector{Dict{Symbol, Any}}}, Float64}","page":"Home","title":"Mycelia.finalize_iterative_assembly","text":"Finalize iterative assembly by combining results from all k-mer sizes and iterations.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_bubble_paths-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, String, Vector{String}, Int64, Int64}","page":"Home","title":"Mycelia.find_bubble_paths","text":"Find potential bubble paths from an entry vertex.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_connected_components-Tuple{MetaGraphsNext.MetaGraph{var\"#s36\", Graph} where {var\"#s36\"<:Graphs.SimpleGraphs.AbstractSimpleGraph, Graph<:Graphs.AbstractGraph{var\"#s36\"}}}","page":"Home","title":"Mycelia.find_connected_components","text":"Find all connected components in the graph. Returns a vector of vectors of vertex indices.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_connected_components-Tuple{MetaGraphsNext.MetaGraph{var\"#s36\", Graph} where {var\"#s36\"<:Graphs.SimpleGraphs.SimpleDiGraph, Graph<:Graphs.AbstractGraph{var\"#s36\"}}}","page":"Home","title":"Mycelia.find_connected_components","text":"Specialized method for directed graphs using weakly connected components. \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_connected_components-Tuple{MetaGraphsNext.MetaGraph{var\"#s36\", Graph} where {var\"#s36\"<:Graphs.SimpleGraphs.SimpleGraph, Graph<:Graphs.AbstractGraph{var\"#s36\"}}}","page":"Home","title":"Mycelia.find_connected_components","text":"Specialized method for undirected graphs. \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_contigs_next-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}}","page":"Home","title":"Mycelia.find_contigs_next","text":"find_contigs_next(graph::MetaGraphsNext.MetaGraph, min_contig_length::Int=500) -> Vector{ContigPath}\n\nExtract linear contigs from the assembly graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_eulerian_path_from_vertex-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, String, Dict{String, Int64}, Dict{String, Int64}}","page":"Home","title":"Mycelia.find_eulerian_path_from_vertex","text":"Find Eulerian path starting from a specific vertex using Hierholzer's algorithm.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_eulerian_paths_next-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}}","page":"Home","title":"Mycelia.find_eulerian_paths_next","text":"find_eulerian_paths_next(graph::MetaGraphsNext.MetaGraph) -> Vector{Vector{String}}\n\nFind Eulerian paths in the assembly graph. An Eulerian path visits every edge exactly once.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_eulerian_start_vertices-Tuple{Dict{String, Int64}, Dict{String, Int64}, Any}","page":"Home","title":"Mycelia.find_eulerian_start_vertices","text":"Find valid starting vertices for Eulerian paths.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_fasta_files-Tuple{String}","page":"Home","title":"Mycelia.find_fasta_files","text":"find_fasta_files(input_path::String) -> Vector{String}\n\nFind all FASTA files in a directory or return single file if path is a file.\n\nUses the existing FASTA_REGEX constant to identify FASTA files.\n\nArguments\n\ninput_path: Path to directory or single FASTA file\n\nReturns\n\nVector of FASTA file paths\n\nExample\n\nfasta_files = find_fasta_files(\"./genomes/\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_initial_k-Tuple{Vector{<:FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.find_initial_k","text":"Find the optimal starting k-mer size using sparsity detection. Only considers prime k-mer sizes for optimal performance.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_limited_path-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, String, Int64}","page":"Home","title":"Mycelia.find_limited_path","text":"Find a limited-length path from a starting vertex.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_linear_path-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, String, Set{String}}","page":"Home","title":"Mycelia.find_linear_path","text":"Find a linear path through the graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_matching_prefix-Tuple{String, String}","page":"Home","title":"Mycelia.find_matching_prefix","text":"find_matching_prefix(\n    filename1::String,\n    filename2::String;\n    strip_trailing_delimiters\n) -> String\n\n\nFind the longest common prefix between two filenames.\n\nArguments\n\nfilename1::String: First filename to compare\nfilename2::String: Second filename to compare\n\nKeywords\n\nstrip_trailing_delimiters::Bool=true: If true, removes trailing dots, hyphens, and underscores from the result\n\nReturns\n\nString: The longest common prefix found between the filenames\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_nonempty_columns-Tuple{Any}","page":"Home","title":"Mycelia.find_nonempty_columns","text":"find_nonempty_columns(df) -> Any\n\n\nIdentify all columns that have only missing or empty values\n\nReturns as a bit array\n\nSee also: dropemptycolumns, dropemptycolumns!\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_optimal_sequence_path-Tuple{FASTX.FASTQ.Record, Any, Int64}","page":"Home","title":"Mycelia.find_optimal_sequence_path","text":"Find optimal sequence path through graph using maximum likelihood principles. Returns improved sequence and likelihood improvement score.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_path_convergence-Tuple{Vector{String}, Vector{String}}","page":"Home","title":"Mycelia.find_path_convergence","text":"Find where two paths converge.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_primes_in_range-Tuple{Int64, Int64}","page":"Home","title":"Mycelia.find_primes_in_range","text":"Find all primes in a range (convenience function).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_quality_weighted_path-Tuple{Any, Any}","page":"Home","title":"Mycelia.find_quality_weighted_path","text":"find_quality_weighted_path(\n    graph,\n    start_vertex;\n    max_path_length\n) -> Vector\n\n\nFind a quality-weighted path through a qualmer graph starting from a given vertex. Uses joint probability as the primary weighting factor for path selection.\n\nArguments\n\ngraph: Qualmer graph (MetaGraphsNext with QualmerVertexData)\nstart_vertex: Starting vertex for path traversal\nmax_path_length::Int=1000: Maximum path length to prevent infinite loops\n\nReturns\n\nVector{Int}: Path as sequence of vertex indices\n\nDetails\n\nAt each step, selects the unvisited neighbor with the highest joint probability. Terminates when no unvisited neighbors are available or max length is reached.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_repeat_candidates-Tuple{Dict{String, Int64}, Dict{String, Int64}}","page":"Home","title":"Mycelia.find_repeat_candidates","text":"Find vertices that could be part of repeat regions.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_resampling_stretches-Tuple{}","page":"Home","title":"Mycelia.find_resampling_stretches","text":"find_resampling_stretches(\n;\n    record_kmer_solidity,\n    solid_branching_kmer_indices\n)\n\n\nIdentifies sequence regions that require resampling based on kmer solidity patterns.\n\nArguments\n\nrecord_kmer_solidity::BitVector: Boolean array where true indicates solid kmers\nsolid_branching_kmer_indices::Vector{Int}: Indices of solid branching kmers\n\nReturns\n\nVector{UnitRange{Int64}}: Array of ranges (start:stop) indicating stretches that need resampling\n\nDetails\n\nFinds continuous stretches of non-solid kmers and extends them to the nearest solid branching kmers on either side. These stretches represent regions that need resampling.\n\nIf a stretch doesn't have solid branching kmers on both sides, it is excluded from the result. Duplicate ranges are removed from the final output.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_true_ranges-Tuple{AbstractVector{Bool}}","page":"Home","title":"Mycelia.find_true_ranges","text":"find_true_ranges(\n    bool_vec::AbstractVector{Bool};\n    min_length\n) -> Vector\n\n\nFinds contiguous ranges of true values in a boolean vector.\n\nArguments\n\nbool_vec::AbstractVector{Bool}: Input boolean vector to analyze\nmin_length=1: Minimum length requirement for a range to be included\n\nReturns\n\nVector of tuples (start, end) where each tuple represents the indices of a contiguous range of true values meeting the minimum length requirement.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.first_of_each_group-Tuple{DataFrames.GroupedDataFrame{DataFrames.DataFrame}}","page":"Home","title":"Mycelia.first_of_each_group","text":"first_of_each_group(\n    gdf::DataFrames.GroupedDataFrame{DataFrames.DataFrame}\n) -> Any\n\n\nReturn a DataFrame containing the first row from each group in a GroupedDataFrame.\n\nArguments\n\ngdf::GroupedDataFrame: A grouped DataFrame created using groupby\n\nReturns\n\nDataFrame: A new DataFrame containing first row from each group\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.frequency_matrix_to_bray_curtis_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.frequency_matrix_to_bray_curtis_distance_matrix","text":"frequency_matrix_to_bray_curtis_distance_matrix(counts_table)\n\nPairwise Bray-Curtis distance between columns of counts_table.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.frequency_matrix_to_cosine_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.frequency_matrix_to_cosine_distance_matrix","text":"frequency_matrix_to_cosine_distance_matrix(probability_matrix)\n\nPairwise cosine distance between columns of probability_matrix.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.frequency_matrix_to_euclidean_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.frequency_matrix_to_euclidean_distance_matrix","text":"frequency_matrix_to_euclidean_distance_matrix(counts_table)\n\nPairwise Euclidean distance between columns of counts_table.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.frequency_matrix_to_jaccard_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.frequency_matrix_to_jaccard_distance_matrix","text":"frequency_matrix_to_jaccard_distance_matrix(matrix)\n\nThresholds the input matrix at >0 to obtain a binary matrix, then computes pairwise Jaccard distance between columns. Accepts any numeric matrix.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.frequency_matrix_to_jensen_shannon_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.frequency_matrix_to_jensen_shannon_distance_matrix","text":"frequency_matrix_to_jensen_shannon_distance_matrix(probability_matrix)\n\nPairwise Jensen-Shannon divergence between columns of probability_matrix.\n\nArguments\n\nprobability_matrix: Matrix where each column is a probability distribution (sums to 1.0).\n\nReturns\n\nSymmetric matrix of Jensen-Shannon divergence values between columns.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.gamma_pca_epca-Tuple{AbstractMatrix{<:Real}}","page":"Home","title":"Mycelia.gamma_pca_epca","text":"gamma_pca_epca(M::AbstractMatrix{<:Real}; k::Int=0)\n\nPerform Gamma EPCA on a matrix M (features × samples).\n\nWhen to use\n\nUse for positive continuous data, such as rates, times, or strictly positive measurements.\n\nKeyword arguments\n\nk : desired number of latent dimensions; if k<1 defaults to min(n_samples-1, n_features, 10)\n\nReturns\n\nNamedTuple with fields\n\nmodel    : the fitted ExpFamilyPCA.GammaEPCA object  \nscores   : k×n_samples matrix of sample scores  \nloadings : k×n_features matrix of feature loadings  \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.gaussian_pca_epca-Tuple{AbstractMatrix{<:Real}}","page":"Home","title":"Mycelia.gaussian_pca_epca","text":"gaussian_pca_epca(M::AbstractMatrix{<:Real}; k::Int=0)\n\nPerform Gaussian EPCA on a matrix M (features × samples).\n\nWhen to use\n\nUse for real-valued continuous data (centered, can be negative or positive), such as normalized or standardized measurements.\n\nKeyword arguments\n\nk : desired number of latent dimensions; if k<1 defaults to min(n_samples-1, n_features, 10)\n\nReturns\n\nNamedTuple with fields\n\nmodel    : the fitted ExpFamilyPCA.GaussianEPCA object  \nscores   : k×n_samples matrix of sample scores  \nloadings : k×n_features matrix of feature loadings  \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.genbank_to_codon_frequencies-Tuple{Any}","page":"Home","title":"Mycelia.genbank_to_codon_frequencies","text":"genbank_to_codon_frequencies(\n    genbank;\n    allow_all\n) -> Dict{BioSymbols.AminoAcid, Dict{Kmers.Kmer{BioSequences.DNAAlphabet{2}, 3, 1}, Int64}}\n\n\nAnalyze codon usage frequencies from genes in a GenBank file.\n\nArguments\n\ngenbank: Path to GenBank format file containing genomic sequences and annotations\nallow_all: If true, initializes frequencies for all possible codons with count=1 (default: true)\n\nReturns\n\nNested dictionary mapping amino acids to their corresponding codon usage counts:\n\nOuter key: AminoAcid (including stop codon)\nInner key: DNACodon\nValue: Count of codon occurrences\n\nDetails\n\nOnly processes genes marked as ':misc_feature' in the GenBank file\nAnalyzes both forward and reverse complement sequences\nDetermines coding strand based on presence of stop codons and start codons\nSkips ambiguous sequences that cannot be confidently oriented\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.genbank_to_fasta-Tuple{}","page":"Home","title":"Mycelia.genbank_to_fasta","text":"genbank_to_fasta(; genbank, fasta, force)\n\n\nConvert a GenBank format file to FASTA format using EMBOSS seqret.\n\nArguments\n\ngenbank: Path to input GenBank format file\nfasta: Optional output FASTA file path (defaults to input path with .fna extension)\nforce: If true, overwrites existing output file (defaults to false)\n\nReturns\n\nPath to the output FASTA file\n\nNotes\n\nRequires EMBOSS suite (installed automatically via Conda)\nWill not regenerate output if it already exists unless force=true\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_all_possible_canonical_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.generate_all_possible_canonical_kmers","text":"generate_all_possible_canonical_kmers(k, alphabet) -> Any\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\nGenerate all possible canonical k-mers of length k from the given alphabet.\n\nFor DNA/RNA sequences, returns unique canonical k-mers where each k-mer is represented by the lexicographically smaller of itself and its reverse complement. For amino acid sequences, returns all possible k-mers without canonicalization.\n\nArguments\n\nk: Length of k-mers to generate\nalphabet: Vector of BioSymbols (DNA, RNA or AminoAcid)\n\nReturns\n\nVector of k-mers, canonicalized for DNA/RNA alphabets\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_all_possible_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.generate_all_possible_kmers","text":"generate_all_possible_kmers(k, alphabet) -> Any\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\nGenerate a sorted list of all possible k-mers for a given alphabet.\n\nArguments\n\nk::Integer: Length of k-mers to generate\nalphabet: Collection of symbols (DNA, RNA, or amino acids) from BioSymbols\n\nReturns\n\nSorted Vector of Kmers of the appropriate type (DNA, RNA, or amino acid)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_alternative_qualmer_paths-Tuple{FASTX.FASTQ.Record, Any, Int64}","page":"Home","title":"Mycelia.generate_alternative_qualmer_paths","text":"Generate alternative qualmer paths through the graph using quality-aware probabilistic sampling.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_and_save_kmer_counts-Tuple{}","page":"Home","title":"Mycelia.generate_and_save_kmer_counts","text":"generate_and_save_kmer_counts(; \n    bioalphabet, \n    fastas, \n    k, \n    output_dir=pwd(),\n    filename=nothing\n)\n\nGenerates and saves k-mer counts for a list of FASTA files for a single k.\n\nKeyword Arguments\n\nbioalphabet: Alphabet type (e.g., :DNA).\nfastas: List of FASTA file paths.\nk: Value of k (e.g., 9).\noutput_dir: (optional) Directory to write output files (default: current directory).\nfilename: (optional) Full file name for output (default:    \"{Mycelia.normalized_current_date()}.{lowercase(string(bioalphabet))}{k}mers.jld2\").\n\nOutput\n\nSaves a .jld2 file with the specified file name in output_dir if it does not already exist.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_binary_matrix-Tuple{Int64, Int64, Float64}","page":"Home","title":"Mycelia.generate_binary_matrix","text":"Generate a binary (Bernoulli) matrix with given dimensions and probability.\n\nArguments\n\nn_features::Int: Number of features (rows)\nn_samples::Int: Number of samples (columns)\np::Float64: Probability of 1 in the Bernoulli distribution\n\nReturns\n\nMatrix{Bool}: Binary matrix with dimensions (nfeatures, nsamples)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_consensus_pangenome-Tuple{Dict, Dict, Dict, String}","page":"Home","title":"Mycelia.generate_consensus_pangenome","text":"Generate consensus pangenome from cross-validation results.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_contig_sequence-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Vector{String}}","page":"Home","title":"Mycelia.generate_contig_sequence","text":"Generate sequence for a contig path.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_coverage_profile-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Vector{String}}","page":"Home","title":"Mycelia.generate_coverage_profile","text":"Generate coverage profile for a contig path.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_kmer_alternatives-Tuple{Any, Any, Type{<:BioSequences.BioSequence}}","page":"Home","title":"Mycelia.generate_kmer_alternatives","text":"Generate alternative k-mers for improvement attempts using proper k-mer objects.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_paired_end_reads-NTuple{4, Any}","page":"Home","title":"Mycelia.generate_paired_end_reads","text":"generate_paired_end_reads(reference_seq, coverage, read_length, insert_size; error_rate=0.01)\n\nGenerate realistic paired-end sequencing reads from a reference sequence.\n\nSimulates paired-end Illumina sequencing with realistic insert sizes, read lengths, and optional sequencing errors for assembly benchmarking.\n\nArguments\n\nreference_seq: Reference sequence (BioSequences.LongDNA{4})\ncoverage: Target sequencing coverage depth\nread_length: Length of each read in base pairs\ninsert_size: Insert size between paired reads\nerror_rate: Sequencing error rate (default: 0.01)\n\nReturns\n\nTuple of (forwardreads, reversereads) as vectors of BioSequences.LongDNA{4}\n\nSee Also\n\nsimulate_illumina_paired_reads: For more sophisticated read simulation using ART\nintroduce_sequencing_errors: For adding realistic sequencing errors\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_poisson_matrix-Tuple{Int64, Int64, Float64}","page":"Home","title":"Mycelia.generate_poisson_matrix","text":"Generate a Poisson matrix with given dimensions and rate parameter.\n\nArguments\n\nn_features::Int: Number of features (rows)\nn_samples::Int: Number of samples (columns)\nλ::Float64: Rate parameter for the Poisson distribution\n\nReturns\n\nMatrix{Int}: Poisson matrix with dimensions (nfeatures, nsamples)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_polished_sequence-Tuple{Vector{Mycelia.ViterbiState}, Vector{String}, Mycelia.ViterbiConfig}","page":"Home","title":"Mycelia.generate_polished_sequence","text":"generate_polished_sequence(states::Vector{ViterbiState}, observations::Vector{String}, \n                          config::ViterbiConfig) -> (String, Vector{Tuple{Int, String, String}})\n\nGenerate polished sequence and track corrections made.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_prime_k_sequence","page":"Home","title":"Mycelia.generate_prime_k_sequence","text":"Generate sequence of prime k-mer sizes starting from min_k.\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.generate_recommendation_reasoning-Tuple{Float64, Float64}","page":"Home","title":"Mycelia.generate_recommendation_reasoning","text":"Generate reasoning for assembly approach recommendation.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_taxa_abundances_plot-Tuple{DataFrames.DataFrame}","page":"Home","title":"Mycelia.generate_taxa_abundances_plot","text":"generate_taxa_abundances_plot(\n    joint_reads_to_taxon_lineage_table::DataFrames.DataFrame;\n    taxa_level::String,\n    top_n::Int = 30,\n    kwargs...\n)\n\nConvenience wrapper function to generate taxa abundance visualization with default parameters and save to a file if requested.\n\nArguments\n\njoint_reads_to_taxon_lineage_table: DataFrame with sample_id and taxonomic assignments\ntaxa_level: Taxonomic level to analyze\ntop_n: Number of top taxa to display individually\nkwargs...: Additional parameters to pass to plottaxaabundances\n\nReturns\n\nfig: CairoMakie figure object\nax: CairoMakie axis object\ntaxa_colors: Dictionary mapping taxa to their assigned colors\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_test_fastq_data-Tuple{Int64, Int64, String}","page":"Home","title":"Mycelia.generate_test_fastq_data","text":"generate_test_fastq_data(n_reads::Int, read_length::Int, filename::String)\n\nGenerate test FASTQ data for benchmarking purposes.\n\nCreates a FASTQ file with random DNA sequences and realistic quality scores suitable for performance testing and validation.\n\nArguments\n\nn_reads::Int: Number of reads to generate\nread_length::Int: Length of each read in base pairs\nfilename::String: Output filename for the FASTQ file\n\nDetails\n\nGenerates random DNA sequences using BioSequences.randdnaseq\nAssigns realistic quality scores (Phred+33 encoding, range 20-40)\nUses existing Mycelia I/O functions for consistency\n\nSee Also\n\nMycelia.write_fastq: For writing FASTQ records\nMycelia.fastq_record: For creating FASTQ records\nMycelia.simulate_illumina_paired_reads: For more sophisticated read simulation\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_test_genome_with_genes","page":"Home","title":"Mycelia.generate_test_genome_with_genes","text":"generate_test_genome_with_genes(genome_size, gene_density=0.02)\n\nGenerate a test genome with simulated gene positions for annotation benchmarking.\n\nCreates a random DNA sequence with estimated gene positions based on gene density, suitable for testing gene prediction algorithms.\n\nArguments\n\ngenome_size: Size of the genome in base pairs\ngene_density: Proportion of genome that consists of genes (default: 0.02)\n\nReturns\n\nTuple of (genomesequence, genepositions) where gene_positions is a vector of (start, end) tuples\n\nSee Also\n\nrandom_fasta_record: For generating random FASTA sequences\nsave_genome_as_fasta: For saving genomes to FASTA format\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.generate_test_sequences","page":"Home","title":"Mycelia.generate_test_sequences","text":"generate_test_sequences(genome_size::Int, n_sequences::Int=1)\n\nGenerate test DNA sequences for k-mer analysis benchmarking.\n\nCreates random DNA sequences suitable for k-mer counting and analysis performance testing.\n\nArguments\n\ngenome_size::Int: Size of each generated sequence in base pairs\nn_sequences::Int: Number of sequences to generate (default: 1)\n\nReturns\n\nVector of BioSequences.LongDNA{4} sequences\n\nSee Also\n\nrandom_fasta_record: For generating FASTA records with random sequences\nBioSequences.randdnaseq: For generating random DNA sequences\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.generate_test_sequences-Tuple{Mycelia.BenchmarkConfig}","page":"Home","title":"Mycelia.generate_test_sequences","text":"generate_test_sequences(\n    config::Mycelia.BenchmarkConfig\n) -> Vector{FASTX.FASTA.Record}\n\n\nGenerate synthetic DNA sequences for benchmarking.\n\nArguments\n\nconfig: BenchmarkConfig with test parameters\n\nReturns\n\nVector of FASTA records for testing\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_training_datasets-Tuple{}","page":"Home","title":"Mycelia.generate_training_datasets","text":"generate_training_datasets(; n_datasets=20, genome_sizes=[10000, 50000, 100000], \n                          error_rates=[0.001, 0.01, 0.05], coverage_levels=[20, 30, 50])\n\nGenerate diverse training datasets for RL agent training.\n\nThis function creates simulated genomic datasets with varying characteristics to provide comprehensive training scenarios for the RL agent.\n\nArguments\n\nn_datasets::Int: Total number of datasets to generate (default: 20)\ngenome_sizes::Vector{Int}: Range of genome sizes to simulate (default: [10K, 50K, 100K])\nerror_rates::Vector{Float64}: Range of sequencing error rates (default: [0.1%, 1%, 5%])\ncoverage_levels::Vector{Int}: Range of coverage depths (default: [20x, 30x, 50x])\n\nReturns\n\nVector{String}: Paths to generated training FASTQ files\n\nExample\n\ntraining_files = generate_training_datasets(n_datasets=50, genome_sizes=[50000, 100000, 200000])\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_transterm_coordinates_from_fasta-Tuple{Any}","page":"Home","title":"Mycelia.generate_transterm_coordinates_from_fasta","text":"generate_transterm_coordinates_from_fasta(fasta) -> Any\n\n\nGenerate minimal coordinate files required for TransTermHP analysis from FASTA sequences.\n\nCreates artificial gene annotations at sequence boundaries to enable TransTermHP to run without real gene annotations. For each sequence in the FASTA file, generates two single-base-pair \"genes\" at positions 1-2 and (L-1)-L, where L is sequence length.\n\nArguments\n\nfasta: Path to input FASTA file containing sequences to analyze\n\nReturns\n\nPath to generated coordinate file (original path with \".coords\" extension)\n\nFormat\n\nGenerated coordinate file follows TransTermHP format: gene_id start stop chromosome\n\nwhere chromosome matches FASTA sequence identifiers.\n\nSee also: run_transterm\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_transterm_coordinates_from_gff-Tuple{Any}","page":"Home","title":"Mycelia.generate_transterm_coordinates_from_gff","text":"generate_transterm_coordinates_from_gff(gff_file) -> Any\n\n\nConvert a GFF file to a coordinates file compatible with TransTermHP format.\n\nArguments\n\ngff_file::String: Path to input GFF file\n\nProcessing\n\nConverts 1-based to 0-based coordinates\nExtracts gene IDs from the attributes field\nRetains columns: gene_id, start, end, seqid\n\nReturns\n\nPath to the generated coordinates file (original filename with '.coords' suffix)\n\nOutput Format\n\nSpace-delimited file with columns: gene_id, start, end, seqid\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_base_extension-Tuple{String}","page":"Home","title":"Mycelia.get_base_extension","text":"get_base_extension(filename::String) -> String\n\n\nExtract the base file extension from a filename, handling compressed files.\n\nFor regular files, returns the last extension. For gzipped files, returns the extension before .gz.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_biosequence_alphabet-Tuple{T} where T<:BioSequences.BioSequence","page":"Home","title":"Mycelia.get_biosequence_alphabet","text":"get_biosequence_alphabet(s::BioSequences.BioSequence) -> Any\n\n\nReturn the alphabet associated with a BioSequence type.\n\nArguments\n\ns::BioSequences.BioSequence: A subtype instance.\n\nReturns\n\nBioSymbols.Alphabet of the sequence type.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_correct_quality-Tuple{Symbol, Int64, Int64}","page":"Home","title":"Mycelia.get_correct_quality","text":"get_correct_quality(tech::Symbol, pos::Int, read_length::Int) -> Int\n\nSimulates a Phred quality score (using the Sanger convention) for a correctly observed base. For Illumina, the quality score is modeled to decay linearly from ~40 at the start to ~20 at the end of the read. For other technologies, the score is sampled from a normal distribution with parameters typical for that platform.\n\nReturns an integer quality score.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_error_quality-Tuple{Symbol}","page":"Home","title":"Mycelia.get_error_quality","text":"get_error_quality(tech::Symbol) -> Int\n\nSimulates a Phred quality score (using the Sanger convention) for a base observed with an error. Error bases are assigned lower quality scores than correctly observed bases. For Illumina, scores typically range between 5 and 15; for nanopore and pacbio, slightly lower values are used; and for ultima, a modest quality score is assigned.\n\nReturns an integer quality score.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_genbank-Tuple{}","page":"Home","title":"Mycelia.get_genbank","text":"get_genbank(\n;\n    db,\n    accession,\n    ftp\n) -> Union{Nothing, GenomicAnnotations.GenBank.Reader}\n\n\nGet dna (db = \"nuccore\") or protein (db = \"protein\") sequences from NCBI or get fasta directly from FTP site\n\nRetrieve GenBank records from NCBI or directly from an FTP site.\n\nArguments\n\ndb::String: NCBI database to query (\"nuccore\" for nucleotide or \"protein\" for protein sequences)\naccession::String: NCBI accession number for the sequence\nftp::String: Direct FTP URL to a GenBank file (gzipped)\n\nReturns\n\nGenomicAnnotations.GenBank.Reader: A reader object containing the GenBank record\n\nDetails\n\nWhen using NCBI queries (db and accession), the function implements rate limiting  (0.5s sleep) to comply with NCBI's API restrictions of max 2 requests per second.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_gff-Tuple{}","page":"Home","title":"Mycelia.get_gff","text":"get_gff(; db, accession, ftp) -> Any\n\n\nGet dna (db = \"nuccore\") or protein (db = \"protein\") sequences from NCBI or get fasta directly from FTP site\n\nRetrieve GFF3 formatted genomic feature data from NCBI or direct FTP source.\n\nArguments\n\ndb::String: NCBI database to query (\"nuccore\" for DNA or \"protein\" for protein sequences)\naccession::String: NCBI accession number\nftp::String: Direct FTP URL to GFF3 file (typically gzipped)\n\nReturns\n\nIO: IOBuffer containing uncompressed GFF3 data\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_in_neighbors-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, String}","page":"Home","title":"Mycelia.get_in_neighbors","text":"Get incoming neighbors of a vertex.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_kmer_index-Tuple{Any, Any}","page":"Home","title":"Mycelia.get_kmer_index","text":"get_kmer_index(kmers, kmer) -> Any\n\n\nReturns the index position of a given k-mer in a sorted list of k-mers.\n\nArguments\n\nkmers: A sorted vector of k-mers to search within\nkmer: The k-mer sequence to find\n\nReturns\n\nInteger index position where kmer is found in kmers\n\nThrows\n\nAssertionError: If the k-mer is not found in the list\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_local_subgraph-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, String, Int64}","page":"Home","title":"Mycelia.get_local_subgraph","text":"Get local subgraph around a vertex.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_out_neighbors-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, String}","page":"Home","title":"Mycelia.get_out_neighbors","text":"Get outgoing neighbors of a vertex.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_phred_scores-Tuple{FASTX.FASTQ.Record}","page":"Home","title":"Mycelia.get_phred_scores","text":"get_phred_scores(\n    record::FASTX.FASTQ.Record\n) -> Vector{UInt8}\n\n\nGet numerical PHRED quality scores from a FASTQ record.\n\nThis is a convenience wrapper around FASTX.quality_scores() that returns the quality scores as a Vector{UInt8} representing PHRED scores.\n\nArguments\n\nrecord::FASTX.FASTQ.Record: FASTQ record to extract quality scores from\n\nReturns\n\nVector{UInt8}: PHRED quality scores (0-based, where 0 = lowest quality, 40+ = highest quality)\n\nExamples\n\nrecord = FASTX.FASTQ.Record(\"read1\", \"ATCG\", \"IIII\")\nscores = get_phred_scores(record)  # Returns [40, 40, 40, 40]\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_qualmer_statistics-Tuple{MetaGraphsNext.MetaGraph}","page":"Home","title":"Mycelia.get_qualmer_statistics","text":"get_qualmer_statistics(\n    graph::MetaGraphsNext.MetaGraph\n) -> Dict{String, Any}\n\n\nGet comprehensive statistics about a qualmer graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_sequence-Tuple{}","page":"Home","title":"Mycelia.get_sequence","text":"get_sequence(\n;\n    db,\n    accession,\n    ftp\n) -> Union{Nothing, FASTX.FASTA.Reader}\n\n\nGet dna (db = \"nuccore\") or protein (db = \"protein\") sequences from NCBI or get fasta directly from FTP site\n\nRetrieve FASTA format sequences from NCBI databases or direct FTP URLs.\n\nArguments\n\ndb::String: NCBI database type (\"nuccore\" for DNA or \"protein\" for protein sequences)\naccession::String: NCBI sequence accession number\nftp::String: Direct FTP URL to a FASTA file (alternative to db/accession pair)\n\nReturns\n\nFASTX.FASTA.Reader: Reader object containing the requested sequence(s)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.gfa_to_fasta-Tuple{}","page":"Home","title":"Mycelia.gfa_to_fasta","text":"gfa_to_fasta(; gfa, fasta)\n\n\nConvert a GFA (Graphical Fragment Assembly) file to FASTA format.\n\nArguments\n\ngfa::String: Path to input GFA file\nfasta::String=gfa * \".fna\": Path for output FASTA file. Defaults to input filename with \".fna\" extension\n\nReturns\n\nString: Path to the generated FASTA file\n\nDetails\n\nUses gfatools (via Conda) to perform the conversion. The function will:\n\nEnsure gfatools is available in the Conda environment\nExecute the conversion using gfatools gfa2fa\nWrite sequences to the specified FASTA file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.gfa_to_structure_table-Tuple{Any}","page":"Home","title":"Mycelia.gfa_to_structure_table","text":"gfa_to_structure_table(\n    gfa\n) -> NamedTuple{(:contig_table, :records), <:Tuple{DataFrames.DataFrame, Any}}\n\n\nConvert a GFA (Graphical Fragment Assembly) file into a structured representation.\n\nArguments\n\ngfa: Path to GFA file or GFA content as string\n\nReturns\n\nNamed tuple containing:\n\ncontig_table: DataFrame with columns:\nconnected_component: Integer ID for each component\ncontigs: Comma-separated list of contig IDs\nis_circular: Boolean indicating if component forms a cycle\nis_closed: Boolean indicating if single contig forms a cycle\nlengths: Comma-separated list of contig lengths\nrecords: FASTA records from the GFA\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.githash-Tuple{}","page":"Home","title":"Mycelia.githash","text":"githash(; short) -> SubString{String}\n\n\nReturns the current git commit hash of the repository.\n\nArguments\n\nshort::Bool=false: If true, returns abbreviated 8-character hash\n\nReturns\n\nA string containing the git commit hash (full 40 characters by default)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.graph_to_gfa-Tuple{}","page":"Home","title":"Mycelia.graph_to_gfa","text":"graph_to_gfa(; graph, outfile)\n\n\nConvert a Mycelia graph to GFA (Graphical Fragment Assembly) format.\n\nWrites a graph to GFA format, including:\n\nHeader (H) line with GFA version\nSegment (S) lines for each vertex with sequence and depth\nLink (L) lines for edges with overlap size and orientations\n\nArguments\n\ngraph: MetaGraph containing sequence vertices and their relationships\noutfile: Path where the GFA file should be written\n\nReturns\n\nPath to the written GFA file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.hclust_to_metagraph-Tuple{Clustering.Hclust}","page":"Home","title":"Mycelia.hclust_to_metagraph","text":"hclust_to_metagraph(\n    hcl::Clustering.Hclust\n) -> MetaGraphs.MetaDiGraph{Int64, Float64}\n\n\nConvert a hierarchical clustering tree into a directed metagraph representation.\n\nArguments\n\nhcl::Clustering.Hclust: Hierarchical clustering result object\n\nReturns\n\nMetaGraphs.MetaDiGraph: Directed graph with metadata representing the clustering hierarchy\n\nGraph Properties\n\nThe resulting graph contains the following vertex properties:\n\n:hclust_id: String identifier for each node\n:height: Height/distance at each merge point (0.0 for leaves)\n:x: Horizontal position for visualization (0-1 range)\n:y: Vertical position based on normalized height\n:hcl: Original clustering object (stored as graph property)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.heirarchically_cluster_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.heirarchically_cluster_distance_matrix","text":"heirarchically_cluster_distance_matrix(\n    distance_matrix\n) -> Clustering.Hclust\n\n\nPerforms hierarchical clustering on a distance matrix using Ward's linkage method.\n\nArguments\n\ndistance_matrix::Matrix{<:Real}: A symmetric distance/dissimilarity matrix\n\nReturns\n\nHierarchicalCluster: A hierarchical clustering object from Clustering.jl\n\nDetails\n\nUses Ward's method (minimum variance) for clustering, which:\n\nMinimizes total within-cluster variance\nProduces compact, spherical clusters\nWorks well for visualization in radial layouts\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.identify_optimal_number_of_clusters-Tuple{Any}","page":"Home","title":"Mycelia.identify_optimal_number_of_clusters","text":"identify_optimal_number_of_clusters(\n    distance_matrix;\n    min_k,\n    max_k\n) -> Any\n\n\nIdentifies the optimal number of clusters using hierarchical clustering and maximizing the average silhouette score, displaying progress.\n\nUses Clustering.clustering_quality for score calculation.\n\nArgs:     distance_matrix: A square matrix of pairwise distances between items.\n\nReturns:     A tuple containing:     - hcl: The hierarchical clustering result object.     - optimalnumberof_clusters: The inferred optimal number of clusters (k).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.identify_potential_errors-Tuple{Any}","page":"Home","title":"Mycelia.identify_potential_errors","text":"identify_potential_errors(\n    graph;\n    min_coverage,\n    min_quality,\n    min_confidence\n) -> Vector{Int64}\n\n\nIdentify potential sequencing errors based on quality scores and coverage patterns.\n\nArguments\n\ngraph: Qualmer graph (MetaGraphsNext with QualmerVertexData)\nmin_coverage::Int=2: Minimum coverage for reliable k-mers\nmin_quality::Float64=20.0: Minimum mean quality score\nmin_confidence::Float64=0.95: Minimum joint probability threshold\n\nReturns\n\nVector{Int}: Vertex indices of potential error k-mers\n\nDetails\n\nIdentifies k-mers that are likely errors based on:\n\nLow coverage (singleton or few observations)\nLow quality scores\nLow joint probability (low confidence)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.improve_read_likelihood-Tuple{FASTX.FASTQ.Record, Any, Int64}","page":"Home","title":"Mycelia.improve_read_likelihood","text":"Improve likelihood of a single read using maximum likelihood path finding. Returns improved read and boolean indicating if improvement was made.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.improve_read_set_likelihood-Tuple{Vector{<:FASTX.FASTQ.Record}, Any, Int64}","page":"Home","title":"Mycelia.improve_read_set_likelihood","text":"Improve likelihood of entire read set using current graph and k-mer size. Returns updated reads and count of improvements made. Uses memory-efficient batch processing for large datasets.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.include_all_files-Tuple{AbstractString}","page":"Home","title":"Mycelia.include_all_files","text":"include_all_files(dir::AbstractString; pattern)\n\n\nRecursively include all files matching a pattern in a directory and its subdirectories.\n\nArguments\n\ndir::AbstractString: Directory path to search recursively\npattern::Regex=r\"\\.jl$\": Regular expression pattern to match files (defaults to .jl files)\n\nDetails\n\nFiles are processed in sorted order within each directory. This is useful for  loading test files, examples, or other Julia modules in a predictable order.\n\nExamples\n\n# Include all Julia files in a directory tree\ninclude_all_files(\"test/modules\")\n\n# Include all text files\ninclude_all_files(\"docs\", r\"\\.txt$\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.install_hashdeep-Tuple{}","page":"Home","title":"Mycelia.install_hashdeep","text":"install_hashdeep() -> Union{Nothing, Base.Process}\n\n\nEnsures the hashdeep utility is installed on the system.\n\nChecks if hashdeep is available in PATH and attempts to install it via apt package manager if not found. Will try with sudo privileges first, then without sudo if that fails.\n\nDetails\n\nChecks PATH for existing hashdeep executable\nAttempts installation using apt package manager\nRequires a Debian-based Linux distribution\n\nReturns\n\nNothing, but prints status messages during execution\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.introduce_sequencing_errors-Tuple{Any, Any}","page":"Home","title":"Mycelia.introduce_sequencing_errors","text":"introduce_sequencing_errors(sequence, error_rate)\n\nIntroduce realistic sequencing errors into a DNA sequence.\n\nSimulates substitutions (70%), insertions (15%), and deletions (15%) at the specified error rate for realistic sequencing simulation.\n\nArguments\n\nsequence: Input DNA sequence (BioSequences.LongDNA{4})\nerror_rate: Probability of error per base\n\nReturns\n\nModified sequence with introduced errors (BioSequences.LongDNA{4})\n\nSee Also\n\nobserve: For more sophisticated error modeling with quality scores\nmutate_string: For string-based mutation operations\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.introduce_sequencing_errors-Tuple{Vector, Float64}","page":"Home","title":"Mycelia.introduce_sequencing_errors","text":"introduce_sequencing_errors(reads::Vector, error_rate::Float64)\n\nIntroduce realistic sequencing errors into a set of reads.\n\nArguments\n\nreads::Vector: Vector of FASTQ records\nerror_rate::Float64: Error rate (0.0 to 1.0)\n\nReturns\n\nVector: Reads with introduced errors\n\nExample\n\nerror_reads = introduce_sequencing_errors(clean_reads, 0.01)  # 1% error rate\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.is_equivalent-Tuple{Any, Any}","page":"Home","title":"Mycelia.is_equivalent","text":"is_equivalent(a, b) -> Any\n\n\nCheck if two biological sequences are equivalent, considering both direct and reverse complement matches.\n\nArguments\n\na: First biological sequence (BioSequence or compatible type)\nb: Second biological sequence (BioSequence or compatible type)\n\nReturns\n\nBool: true if sequences are identical or if one is the reverse complement of the other, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.is_isolated_vertex-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, String}","page":"Home","title":"Mycelia.is_isolated_vertex","text":"Check if a vertex is isolated (no edges).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.is_legacy_graph-Tuple{Any}","page":"Home","title":"Mycelia.is_legacy_graph","text":"is_legacy_graph(graph) -> Bool\n\n\nCheck if a graph is using the legacy MetaGraphs format.\n\nArguments\n\ngraph: Graph to check\n\nReturns\n\nBool: true if legacy format, false if next-generation format\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.is_valid_bubble-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Mycelia.BubbleStructure}","page":"Home","title":"Mycelia.is_valid_bubble","text":"Check if a bubble structure is valid.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.is_valid_path-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Vector{String}}","page":"Home","title":"Mycelia.is_valid_path","text":"Check if a path is valid in the graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.isolate_normalized_primary_contig-Tuple{Any, Any, Any, Any, Int64}","page":"Home","title":"Mycelia.isolate_normalized_primary_contig","text":"isolate_normalized_primary_contig(\n    assembled_fasta,\n    assembled_gfa,\n    qualimap_report_txt,\n    identifier,\n    k::Int64;\n    primary_contig_fasta\n) -> String\n\n\nPrimary contig is defined as the contig with the most bases mapped to it\n\nIn the context of picking out phage from metagenomic assemblies the longest contig is often bacteria whereas the highest coverage contigs are often primer-dimers or other PCR amplification artifacts.\n\nTaking the contig that has the most bases mapped to it as a product of length * depth is cherry picked as our phage\n\nIsolates and exports the primary contig from an assembly based on coverage depth × length.\n\nThe primary contig is defined as the contig with the highest total mapped bases  (coverage depth × length). This method helps identify potential phage contigs in  metagenomic assemblies, avoiding both long bacterial contigs and short high-coverage  PCR artifacts.\n\nArguments\n\nassembled_fasta: Path to the assembled contigs in FASTA format\nassembled_gfa: Path to the assembly graph in GFA format\nqualimap_report_txt: Path to Qualimap coverage report\nidentifier: String identifier for the output file\nk: Integer representing k-mer size used in assembly\nprimary_contig_fasta: Optional output filepath (default: \"{identifier}.primary_contig.fna\")\n\nReturns\n\nPath to the output FASTA file containing the primary contig\n\nNotes\n\nFor circular contigs, removes the k-mer closure scar if detected\nTrims k bases from the end if they match the first k bases\nUses coverage × length to avoid both long bacterial contigs and short PCR artifacts\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.iterative_assembly_summary-Tuple{Dict}","page":"Home","title":"Mycelia.iterative_assembly_summary","text":"Generate summary report of iterative assembly process.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.iterative_polishing","page":"Home","title":"Mycelia.iterative_polishing","text":"iterative_polishing(\n    fastq\n) -> Vector{T} where T<:(NamedTuple{(:fastq, :k), <:Tuple{Any, Any}})\niterative_polishing(\n    fastq,\n    max_k\n) -> Vector{T} where T<:(NamedTuple{(:fastq, :k), <:Tuple{Any, Any}})\niterative_polishing(\n    fastq,\n    max_k,\n    plot\n) -> Vector{T} where T<:(NamedTuple{(:fastq, :k), <:Tuple{Any, Any}})\n\n\nPerforms iterative error correction on FASTQ sequences using progressively larger k-mer sizes.\n\nStarting with the default k-mer size, this function repeatedly applies polishing steps, incrementing the k-mer size until either reaching max_k or encountering instability.\n\nArguments\n\nfastq: Path to input FASTQ file or FastqRecord object\nmax_k: Maximum k-mer size to attempt (default: 89)\nplot: Whether to generate diagnostic plots (default: false)\n\nReturns\n\nVector of polishing results, where each element contains:\n\nk: k-mer size used\nfastq: resulting polished sequences\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.jaccard_distance-Tuple{AbstractMatrix{<:Integer}}","page":"Home","title":"Mycelia.jaccard_distance","text":"Compute the Jaccard distance between columns of a binary matrix.\n\nArguments\n\nM::AbstractMatrix{<:Integer}: Binary matrix where rows are features and columns are samples\n\nReturns\n\nMatrix{Float64}: Symmetric distance matrix with Jaccard distances\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.jaccard_distance-Tuple{Any, Any}","page":"Home","title":"Mycelia.jaccard_distance","text":"jaccard_distance(set1, set2) -> Any\n\n\nCalculate the Jaccard distance between two sets, which is the complement of the Jaccard similarity.\n\nThe Jaccard distance is defined as: J_d(AB) = 1 - J_s(AB) = 1 - fracA  BA  B\n\nArguments\n\nset1: First set to compare\nset2: Second set to compare\n\nReturns\n\nFloat64: A value in [0,1] where 0 indicates identical sets and 1 indicates disjoint sets\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.jaccard_similarity-Tuple{Any, Any}","page":"Home","title":"Mycelia.jaccard_similarity","text":"jaccard_similarity(set1, set2) -> Any\n\n\nCompute the Jaccard similarity coefficient between two sets.\n\nThe Jaccard similarity is defined as the size of the intersection divided by the size of the union of two sets:\n\nJ(A,B) = |A ∩ B| / |A ∪ B|\n\nArguments\n\nset1: First set for comparison\nset2: Second set for comparison\n\nReturns\n\nFloat64: A value between 0.0 and 1.0, where:\n1.0 indicates identical sets\n0.0 indicates completely disjoint sets\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.jellyfish_count-Tuple{}","page":"Home","title":"Mycelia.jellyfish_count","text":"jellyfish_count(\n;\n    fastx,\n    k,\n    threads,\n    max_mem,\n    canonical,\n    outfile,\n    conda_check\n)\n\n\nCount k-mers in a FASTA/FASTQ file using Jellyfish.\n\nArguments\n\nfastx::String: Path to input FASTA/FASTQ file (can be gzipped)\nk::Integer: k-mer length\nthreads::Integer=Sys.CPU_THREADS: Number of threads to use\nmax_mem::Integer=Int(Sys.free_memory()): Maximum memory in bytes (defaults to system free memory)\ncanonical::Bool=false: Whether to count canonical k-mers (both strands combined)\noutfile::String=auto: Output filename (auto-generated based on input and parameters)\nconda_check::Bool=true: Whether to verify Jellyfish conda installation\n\nReturns\n\nString: Path to gzipped TSV file containing k-mer counts\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.jellyfish_counts_to_kmer_frequency_histogram","page":"Home","title":"Mycelia.jellyfish_counts_to_kmer_frequency_histogram","text":"jellyfish_counts_to_kmer_frequency_histogram(\n    jellyfish_counts_file\n) -> Any\njellyfish_counts_to_kmer_frequency_histogram(\n    jellyfish_counts_file,\n    outfile\n) -> Any\n\n\nConvert a Jellyfish k-mer count file into a frequency histogram.\n\nArguments\n\njellyfish_counts_file::String: Path to the gzipped TSV file containing Jellyfish k-mer counts\noutfile::String=replace(jellyfish_counts_file, r\"\\.tsv\\.gz$\" => \".count_histogram.tsv\"): Optional output file path\n\nReturns\n\nString: Path to the generated histogram file\n\nDescription\n\nProcesses a Jellyfish k-mer count file to create a frequency histogram where:\n\nColumn 1: Number of k-mers that share the same count\nColumn 2: The count they share\n\nUses system sorting with LC_ALL=C for optimal performance on large files.\n\nNotes\n\nRequires gzip, sort, uniq, and sed command line tools\nUses intermediate disk storage for sorting large files\nSkips processing if output file already exists\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.jitter-Tuple{Any, Any}","page":"Home","title":"Mycelia.jitter","text":"jitter(x, n) -> Any\n\n\nAdd random noise to create a vector of jittered values.\n\nGenerates n values by adding random noise to the input value x.  The noise is uniformly distributed between -1/3 and 1/3.\n\nArguments\n\nx: Base value to add jitter to\nn: Number of jittered values to generate\n\nReturns\n\nVector of length n containing jittered values around x\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.join_fastqs_with_uuid-Tuple{Vector{String}}","page":"Home","title":"Mycelia.join_fastqs_with_uuid","text":"join_fastqs_with_uuid(\n    fastq_files::Vector{String};\n    fastq_out::String\n    tsv_out::String\n)\n\nNote: does not keep track of paired-end data - assumes single end reads\n\nDesigned primarily to allow joint mapping of many long-read samples\n\nGiven a collection of fastq files, creates:\n\nA gzipped TSV mapping original file and read_id to a new UUID per read\nA gzipped joint fastq file with the new UUID as read header\n\nReturns: Tuple of output file paths (tsvout, fastqout)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.joint_base_quality_score-Tuple{Vector{Float64}}","page":"Home","title":"Mycelia.joint_base_quality_score","text":"joint_base_quality_score(\n    error_probabilities::Vector{Float64}\n) -> Float64\n\n\nCalculate the quality score for a single base given multiple observations.\n\nThis function implements the \"Converting to Error Probabilities and Combining\" method:\n\nTakes error probabilities from multiple reads covering the same base\nCalculates probability of ALL reads being wrong by multiplying probabilities\nCalculates final Phred score from this combined probability\n\nTo avoid numerical underflow with very small probabilities, the calculation is performed in log space.\n\nArguments\n\nerror_probabilities::Vector{Float64}: Vector of error probabilities from  multiple reads covering the same base position\n\nReturns\n\nFloat64: Phred quality score representing the combined confidence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.joint_qualmer_probability-Tuple{Vector{<:Mycelia.Qualmer}}","page":"Home","title":"Mycelia.joint_qualmer_probability","text":"joint_qualmer_probability(\n    qualmers::Vector{<:Mycelia.Qualmer};\n    use_log_space\n) -> Float64\n\n\nCalculate joint probability that multiple observations of the same k-mer are all correct. For independent observations of the same k-mer sequence, this represents our confidence that the k-mer truly exists in the data.\n\nArguments\n\nqualmers: Vector of Qualmer observations of the same k-mer sequence\nuse_log_space: Use log-space arithmetic for numerical stability (default: true)\n\nReturns\n\nFloat64: Joint probability that all observations are correct\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.jsonl_to_dataframe-Tuple{String}","page":"Home","title":"Mycelia.jsonl_to_dataframe","text":"jsonl_to_dataframe(filepath::String) -> DataFrames.DataFrame\n\n\njsonl_to_dataframe(filepath::String) -> DataFrame\n\nParse a JSONL (or gzipped JSONL) file and return a DataFrame. Internally calls parse_jsonl for validation and parsing. Ensures that all rows have the same set of keys by inserting missing for any absent field before constructing the DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.k_ladder-Tuple{}","page":"Home","title":"Mycelia.k_ladder","text":"k_ladder(\n;\n    max_k,\n    seed_primes,\n    ratio,\n    min_fractional_gap,\n    read_length,\n    read_margin,\n    only_odd,\n    return_unique,\n    min_k\n) -> Vector{Int64}\n\n\nGenerate a √2-scaled ladder of odd primes for k-mer-based assembly / error-screening.\n\nStarts with a user-supplied list of seed_primes (default [3, 5, 7]), then iteratively multiplies the last accepted k by ratio (default sqrt(2)), rounds up to the next odd prime, and appends it only if it differs from the previous accepted prime by at least min_fractional_gap.\n\nKeyword arguments\n\nmax_k::Int = 10_000          : Absolute upper bound.\nseed_primes::Vector{Int}     : Initial primes (e.g. [3,5,7] for protein,                                  [11,13,17] for nucleotides).\nratio::Float64 = sqrt(2)     : Target geometric growth factor.\nmin_fractional_gap::Float64 = 0.30 : Minimum (knew − kprev)/k_prev to skip                                        “sister” primes.\nread_length::Union{Int,Nothing} = nothing : If set, cap at                                              read_length − read_margin.\nread_margin::Int = 20        : Safety margin for short-read data.\nonly_odd::Bool = true        : Force odd k (recommended).\nreturn_unique::Bool = true   : De-duplicate before returning.\nmin_k::Int = 3               : Drop any k below this after generation.\n\nReturns\n\nVector{Int} — ascending prime k values suitable for -k/--k-list.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_dict_to_vector-Tuple{Any, Any}","page":"Home","title":"Mycelia.kmer_counts_dict_to_vector","text":"kmer_counts_dict_to_vector(\n    kmer_to_index_map,\n    kmer_counts\n) -> Any\n\n\nConvert a dictionary of k-mer counts to a fixed-length numeric vector based on a predefined mapping.\n\nArguments\n\nkmer_to_index_map: Dictionary mapping k-mer sequences to their corresponding vector indices\nkmer_counts: Dictionary containing k-mer sequences and their occurrence counts\n\nReturns\n\nA vector where each position corresponds to a k-mer count, with zeros for absent k-mers\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_to_cosine_similarity-Tuple{Any, Any}","page":"Home","title":"Mycelia.kmer_counts_to_cosine_similarity","text":"kmer_counts_to_cosine_similarity(\n    kmer_counts_1,\n    kmer_counts_2\n) -> Any\n\n\nCalculate the cosine similarity between two k-mer count dictionaries.\n\nArguments\n\nkmer_counts_1::Dict{String,Int}: First dictionary mapping k-mer sequences to their counts\nkmer_counts_2::Dict{String,Int}: Second dictionary mapping k-mer sequences to their counts\n\nReturns\n\nFloat64: Cosine distance between the two k-mer count vectors, in range [0,1] where 0 indicates identical distributions and 1 indicates maximum dissimilarity\n\nDetails\n\nConverts k-mer count dictionaries into vectors using a unified set of keys, then computes cosine distance. Missing k-mers are treated as count 0. Result is invariant to input order and total counts (normalized internally).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_to_js_divergence-Tuple{Any, Any}","page":"Home","title":"Mycelia.kmer_counts_to_js_divergence","text":"kmer_counts_to_js_divergence(\n    kmer_counts_1,\n    kmer_counts_2\n) -> Any\n\n\nCalculate the Jensen-Shannon divergence between two k-mer frequency distributions.\n\nArguments\n\nkmer_counts_1: Dictionary mapping k-mers to their counts in first sequence\nkmer_counts_2: Dictionary mapping k-mers to their counts in second sequence\n\nReturns\n\nNormalized Jensen-Shannon divergence score between 0 and 1, where:\n0 indicates identical distributions\n1 indicates maximally different distributions\n\nNotes\n\nThe measure is symmetric: JS(P||Q) = JS(Q||P)\nCounts are automatically normalized to probability distributions\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_to_merqury_qv-Union{Tuple{}, Tuple{N}, Tuple{k}} where {k, N}","page":"Home","title":"Mycelia.kmer_counts_to_merqury_qv","text":"kmer_counts_to_merqury_qv(\n;\n    raw_data_counts,\n    assembly_counts\n)\n\n\nCalculate assembly Quality Value (QV) score using the Merqury method.\n\nEstimates base-level accuracy by comparing k-mer distributions between raw sequencing data and assembly. Higher QV scores indicate better assembly quality.\n\nArguments\n\nraw_data_counts::AbstractDict{Kmers.DNAKmer{k,N}, Int}: K-mer counts from raw sequencing data\nassembly_counts::AbstractDict{Kmers.DNAKmer{k,N}, Int}: K-mer counts from assembly\n\nReturns\n\nFloat64: Quality Value score in Phred scale (-10log₁₀(error rate))\n\nMethod\n\nQV is calculated using:\n\nKtotal = number of unique kmers in assembly\nKshared = number of kmers shared between raw data and assembly\nP = (Kshared/Ktotal)^(1/k) = estimated base-level accuracy\nQV = -10log₁₀(1-P)\n\nReference\n\nRhie et al. \"Merqury: reference-free quality, completeness, and phasing assessment for genome assemblies\" Genome Biology (2020)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_graph_to_biosequence_graph-Tuple{MetaGraphsNext.MetaGraph}","page":"Home","title":"Mycelia.kmer_graph_to_biosequence_graph","text":"kmer_graph_to_biosequence_graph(\n    kmer_graph::MetaGraphsNext.MetaGraph;\n    min_path_length\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, Mycelia.var\"#270#272\", Float64} where {_A, _B, _C}\n\n\nConvert a k-mer graph to a BioSequence graph by collapsing linear paths.\n\nThis is the primary method for creating BioSequence graphs from k-mer graphs, following the 6-graph hierarchy where BioSequence graphs are simplifications of k-mer graphs.\n\nArguments\n\nkmer_graph: MetaGraphsNext k-mer graph to convert\nmin_path_length: Minimum path length to keep (default: 2)\n\nReturns\n\nMetaGraphsNext.MetaGraph with BioSequence vertices\n\nExample\n\n# Start with k-mer graph\nkmer_graph = build_kmer_graph_next(BioSequences.DNAKmer{31}, fasta_records)\n\n# Convert to BioSequence graph\nbiosequence_graph = kmer_graph_to_biosequence_graph(kmer_graph)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_path_to_biosequence-Tuple{Vector{<:Kmers.Kmer}}","page":"Home","title":"Mycelia.kmer_path_to_biosequence","text":"Convert k-mer path back to BioSequence.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_path_to_sequence-Tuple{Any}","page":"Home","title":"Mycelia.kmer_path_to_sequence","text":"kmer_path_to_sequence(kmer_path) -> Any\n\n\nConvert a path of overlapping k-mers into a single DNA sequence.\n\nArguments\n\nkmer_path: Vector of k-mers (DNA sequences) where each consecutive pair overlaps by k-1 bases\n\nReturns\n\nBioSequences.LongDNA{2}: Assembled DNA sequence from the k-mer path\n\nDescription\n\nReconstructs the original DNA sequence by joining k-mers, validating that consecutive k-mers  overlap correctly. The first k-mer is used in full, then each subsequent k-mer contributes  its last base.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_quality_score","page":"Home","title":"Mycelia.kmer_quality_score","text":"kmer_quality_score(base_qualities::Vector{Float64}) -> Any\nkmer_quality_score(\n    base_qualities::Vector{Float64},\n    method::Symbol\n) -> Any\n\n\nCalculate kmer quality score using the specified aggregation method.\n\nAvailable methods:\n\n:min: Use the minimum base quality (default)\n:mean: Use the mean of all base qualities\n:geometric: Use the geometric mean (appropriate for probabilities)\n:harmonic: Use the harmonic mean (emphasizes lower values)\n\nArguments\n\nbase_qualities::Vector{Float64}: Vector of quality scores for each base\nmethod::Symbol: Method to use for aggregation\n\nReturns\n\nFloat64: Overall quality score for the kmer\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.kmer_space_size","page":"Home","title":"Mycelia.kmer_space_size","text":"kmer_space_size(k::Integer) -> Any\nkmer_space_size(k::Integer, alphabet_size::Integer) -> Any\n\n\nCalculate the theoretical k-mer space size for a given k-mer length and alphabet size.\n\nArguments\n\nk::Integer: K-mer length\nalphabet_size::Integer=4: Size of the alphabet (defaults to 4 for DNA: A,C,G,T)\n\nReturns\n\nInteger: Total number of possible k-mers (alphabet_size^k)\n\nDetails\n\nFor DNA sequences (alphabet_size=4), this computes 4^k. Useful for:\n\nMemory estimation for k-mer analysis\nParameter validation and selection\nUnderstanding computational complexity\n\nExamples\n\n# DNA 3-mers: 4^3 = 64 possible k-mers\nkmer_space_size(3)\n\n# Protein 5-mers: 20^5 = 3,200,000 possible k-mers  \nkmer_space_size(5, 20)\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.ks-Tuple{}","page":"Home","title":"Mycelia.ks","text":"ks(; min, max) -> Vector{Int64}\n\n\nGenerates a specialized sequence of prime numbers combining:\n\nOdd primes up to 23 (flip_point)\nPrimes nearest to Fibonacci numbers above 23 up to max\n\nArguments\n\nmin::Int=0: Lower bound for the sequence\nmax::Int=10_000: Upper bound for the sequence\n\nReturns\n\nVector of Int containing the specialized prime sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.lawrencium_sbatch-Tuple{}","page":"Home","title":"Mycelia.lawrencium_sbatch","text":"lawrencium_sbatch(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    partition,\n    qos,\n    account,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd\n)\n\n\nSubmit a job to SLURM scheduler on Lawrence Berkeley Lab's Lawrencium cluster.\n\nArguments\n\njob_name: Name identifier for the SLURM job\nmail_user: Email address for job notifications\nmail_type: Notification type (\"ALL\", \"BEGIN\", \"END\", \"FAIL\", or \"NONE\")\nlogdir: Directory for SLURM output and error logs\npartition: Lawrencium compute partition\nqos: Quality of Service level\naccount: Project account for billing\nnodes: Number of nodes to allocate\nntasks: Number of tasks to spawn\ntime: Wall time limit in format \"days-hours:minutes:seconds\"\ncpus_per_task: CPU cores per task\nmem_gb: Memory per node in GB\ncmd: Shell command to execute\n\nReturns\n\ntrue if submission was successful\n\nNote\n\nFunction includes 5-second delays before and after submission for queue stability.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.legacy_to_next_graph","page":"Home","title":"Mycelia.legacy_to_next_graph","text":"legacy_to_next_graph(\n    legacy_graph\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, Mycelia.var\"#147#148\", Float64} where {_A, _B, _C}\nlegacy_to_next_graph(\n    legacy_graph,\n    kmer_type\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, Mycelia.var\"#147#148\", Float64} where {_A, _B, _C}\n\n\nConvert a legacy MetaGraphs-based k-mer graph to the next-generation MetaGraphsNext format.\n\nThis function provides a migration path from the deprecated MetaGraphs.jl implementation to the new type-stable MetaGraphsNext.jl format.\n\nArguments\n\nlegacy_graph: MetaGraphs.MetaDiGraph from the old implementation\n\nReturns\n\nMetaGraphsNext.MetaGraph with equivalent structure and type-stable metadata\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.list_blastdbs-Tuple{}","page":"Home","title":"Mycelia.list_blastdbs","text":"list_blastdbs(; source) -> DataFrames.DataFrame\n\n\nLists available BLAST databases from the specified source.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_classes-Tuple{}","page":"Home","title":"Mycelia.list_classes","text":"list_classes() -> DataFrames.DataFrame\n\n\nReturns an array of all taxonomic classes in the database.\n\nClasses represent a major taxonomic rank between phylum and order in biological classification.\n\nReturns\n\nVector{String}: Array of class names sorted alphabetically\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_databases-Tuple{}","page":"Home","title":"Mycelia.list_databases","text":"list_databases(; address, username, password)\n\n\nLists all available Neo4j databases on the specified server.\n\nArguments\n\naddress::String: Neo4j server address (e.g. \"neo4j://localhost:7687\")\nusername::String=\"neo4j\": Neo4j authentication username\npassword::String: Neo4j authentication password\n\nReturns\n\nDataFrame: Contains database information with columns typically including:\nname: Database name\naddress: Database address\nrole: Database role (e.g., primary, secondary)\nstatus: Current status (e.g., online, offline)\ndefault: Boolean indicating if it's the default database\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_families-Tuple{}","page":"Home","title":"Mycelia.list_families","text":"list_families() -> DataFrames.DataFrame\n\n\nReturns a sorted vector of all family names present in the database.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_full_taxonomy-Tuple{}","page":"Home","title":"Mycelia.list_full_taxonomy","text":"list_full_taxonomy() -> DataFrames.DataFrame\n\n\nRetrieves and formats the complete NCBI taxonomy hierarchy into a structured DataFrame.\n\nDetails\n\nAutomatically sets up taxonkit environment and downloads taxonomy database if needed\nStarts from root taxid (1) and includes all descendant taxa\nReformats lineage information into separate columns for each taxonomic rank\n\nReturns\n\nDataFrame with columns:\n\ntaxid: Taxonomy identifier\nlineage: Full taxonomic lineage string\ntaxid_lineage: Lineage with taxonomy IDs\nIndividual rank columns:\nsuperkingdom, kingdom, phylum, class, order, family, genus, species\ncorresponding taxid columns (e.g., superkingdom_taxid)\n\nDependencies\n\nRequires taxonkit (installed automatically via Bioconda)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_genera-Tuple{}","page":"Home","title":"Mycelia.list_genera","text":"list_genera() -> DataFrames.DataFrame\n\n\nReturns a sorted vector of all genera names present in the database.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_kingdoms-Tuple{}","page":"Home","title":"Mycelia.list_kingdoms","text":"list_kingdoms() -> DataFrames.DataFrame\n\n\nLists all taxonomic kingdoms in the database.\n\nReturns a vector of kingdom names as strings. Kingdoms represent the highest major taxonomic rank in biological classification.\n\nReturns\n\nVector{String}: Array of kingdom names\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_orders-Tuple{}","page":"Home","title":"Mycelia.list_orders","text":"list_orders() -> DataFrames.DataFrame\n\n\nLists all orders in the taxonomic database.\n\nReturns a vector of strings containing valid order names according to current mycological taxonomy. Uses the underlying list_rank() function with rank=\"order\".\n\nReturns\n\nVector{String}: Alphabetically sorted list of order names\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_phylums-Tuple{}","page":"Home","title":"Mycelia.list_phylums","text":"list_phylums() -> DataFrames.DataFrame\n\n\nReturns a sorted list of all unique phyla in the database.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_rank-Tuple{Any}","page":"Home","title":"Mycelia.list_rank","text":"list_rank(rank) -> DataFrames.DataFrame\n\n\nList all taxonomic entries at the specified rank level.\n\nArguments\n\nrank::String: Taxonomic rank to query. Must be one of:\n\"top\" (top level)\n\"superkingdom\"/\"domain\"  \n\"kingdom\"\n\"phylum\" \n\"class\"\n\"order\"\n\"family\"\n\"genus\"\n\"species\"\n\nReturns\n\nDataFrame with columns:\n\ntaxid: NCBI taxonomy ID\nname: Scientific name at the specified rank\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_ranks-Tuple{}","page":"Home","title":"Mycelia.list_ranks","text":"list_ranks(; synonyms) -> Vector{String}\n\n\nReturn an ordered list of taxonomic ranks from highest (top) to lowest (species).\n\nArguments\n\nsynonyms::Bool=false: If true, includes alternative names for certain ranks (e.g. \"domain\" for \"superkingdom\")\n\nReturns\n\nVector{String}: An array of taxonomic rank names in hierarchical order\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_species-Tuple{}","page":"Home","title":"Mycelia.list_species","text":"list_species() -> DataFrames.DataFrame\n\n\nReturns a sorted vector of all species names present in the database.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_subtaxa-Tuple{Any}","page":"Home","title":"Mycelia.list_subtaxa","text":"list_subtaxa(taxid) -> Vector{Int64}\n\n\nReturns an array of Integer taxon IDs representing all sub-taxa under the specified taxonomic ID.\n\nArguments\n\ntaxid: NCBI taxonomy identifier for the parent taxon\n\nReturns\n\nVector{Int} containing all descendant taxon IDs\n\nDetails\n\nRequires taxonkit to be installed via Bioconda\nAutomatically sets up taxonkit database if not present\nUses local taxonomy database in ~/.taxonkit/\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_superkingdoms-Tuple{}","page":"Home","title":"Mycelia.list_superkingdoms","text":"list_superkingdoms() -> DataFrames.DataFrame\n\n\nReturns an array of all taxonomic superkingdoms (e.g., Bacteria, Archaea, Eukaryota).\n\nReturns\n\nVector{String}: Array containing names of all superkingdoms in the taxonomy database\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_toplevel-Tuple{}","page":"Home","title":"Mycelia.list_toplevel","text":"list_toplevel() -> DataFrames.DataFrame\n\n\nReturns a DataFrame containing the top-level taxonomic nodes.\n\nThe DataFrame has two fixed rows representing the most basic taxonomic classifications:\n\ntaxid=0: \"unclassified\"\ntaxid=1: \"root\"\n\nReturns\n\nDataFrame     Columns:     - taxid::Int : Taxonomic identifier     - name::String : Node name\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_blast_db_taxonomy_table-Tuple{Any}","page":"Home","title":"Mycelia.load_blast_db_taxonomy_table","text":"load_blast_db_taxonomy_table(\n    compressed_blast_db_taxonomy_table_file\n) -> DataFrames.DataFrame\n\n\nLoads a BLAST database taxonomy mapping table from a gzipped file into a DataFrame.\n\nArguments\n\ncompressed_blast_db_taxonomy_table_file::String: Path to a gzipped file containing BLAST taxonomy mappings\n\nReturns\n\nDataFrame: A DataFrame with columns :sequence_id and :taxid containing the sequence-to-taxonomy mappings\n\nFormat\n\nInput file should be a space-delimited text file (gzipped) with two columns:\n\nsequence identifier\ntaxonomy identifier (taxid)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_df_jld2-Tuple{String}","page":"Home","title":"Mycelia.load_df_jld2","text":"load_df_jld2(filename::String; key) -> Any\n\n\nload_df_jld2(filename::String; key::String=\"dataframe\") -> DataFrames.DataFrame\n\nLoad a DataFrame from a JLD2 file.\n\nArguments\n\nfilename: Path to the JLD2 file (will add .jld2 extension if not present)\nkey: The name of the dataset within the JLD2 file (defaults to \"dataframe\")\n\nReturns\n\nThe loaded DataFrame\n\nExamples\n\ndf = load_df_jld2(\"mydata\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_genbank_metadata-Tuple{}","page":"Home","title":"Mycelia.load_genbank_metadata","text":"load_genbank_metadata() -> DataFrames.DataFrame\n\n\nLoad metadata for GenBank sequences into a DataFrame.\n\nThis is a convenience wrapper around load_ncbi_metadata(\"genbank\") that specifically loads metadata from the GenBank database.\n\nReturns\n\nDataFrame: Contains metadata fields like accession numbers, taxonomy,\n\nand sequence information from GenBank.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_graph-Tuple{Any}","page":"Home","title":"Mycelia.load_graph","text":"load_graph(file) -> Any\n\n\nLoad a graph structure from a serialized file.\n\nArguments\n\nfile::AbstractString: Path to the file containing the serialized graph data\n\nReturns\n\nThe deserialized graph object\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_graph-Tuple{String}","page":"Home","title":"Mycelia.load_graph","text":"load_graph(file::String) -> Any\n\n\nLoads a graph object from a serialized file.\n\nArguments\n\nfile::String: Path to the file containing the serialized graph data. The file should have been created using save_graph.\n\nReturns\n\nThe deserialized graph object stored under the \"graph\" key.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_jellyfish_counts-Tuple{Any}","page":"Home","title":"Mycelia.load_jellyfish_counts","text":"load_jellyfish_counts(jellyfish_counts) -> Any\n\n\nLoad k-mer counts from a Jellyfish output file into a DataFrame.\n\nArguments\n\njellyfish_counts::String: Path to a gzipped TSV file (*.jf.tsv.gz) containing Jellyfish k-mer counts\n\nReturns\n\nDataFrame: Table with columns:\nkmer: Biologically encoded k-mers as DNAKmer{k} objects\ncount: Integer count of each k-mer's occurrences\n\nNotes\n\nInput file must be a gzipped TSV with exactly two columns (k-mer sequences and counts)\nK-mer length is automatically detected from the first entry\nFilename must end with '.jf.tsv.gz'\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_jld2-Tuple{Any}","page":"Home","title":"Mycelia.load_jld2","text":"load_jld2(filename) -> Any\n\n\nLoad data stored in a JLD2 file format.\n\nArguments\n\nfilename::String: Path to the JLD2 file to load\n\nReturns\n\nDict: Dictionary containing the loaded data structures\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_kmer_results-Tuple{AbstractString}","page":"Home","title":"Mycelia.load_kmer_results","text":"load_kmer_results(\n    filename::AbstractString\n) -> Union{Nothing, NamedTuple{(:kmers, :counts, :fasta_list, :metadata), <:Tuple{Any, Any, Any, Dict{String, Any}}}}\n\n\nLoad kmer counting results previously saved with save_kmer_results.\n\nArguments\n\nfilename::AbstractString: Path to the input JLD2 file.\n\nReturns\n\nNamedTuple: Contains the loaded kmers, counts, fasta_list, and metadata. Returns nothing if the file cannot be loaded or essential keys are missing.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_matrix_jld2-Tuple{Any}","page":"Home","title":"Mycelia.load_matrix_jld2","text":"load_matrix_jld2(filename) -> Any\n\n\nLoads a matrix from a JLD2 file.\n\nArguments\n\nfilename::String: Path to the JLD2 file containing the matrix under the key \"matrix\"\n\nReturns\n\nMatrix: The loaded matrix data\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_ncbi_metadata-Tuple{String}","page":"Home","title":"Mycelia.load_ncbi_metadata","text":"load_ncbi_metadata(db::String) -> DataFrames.DataFrame\n\n\nLoad and parse NCBI assembly summary metadata (GenBank/RefSeq), using a daily cache.\n\nChecks for homedir()/workspace/.ncbi/YYYY-MM-DD.assembly_summary_{db}.txt. Uses the cache if valid (exists, readable, not empty). Otherwise, downloads from NCBI using Downloads.download(), caches the result (replacing any previous version for the same day), and then parses the cached file.\n\nHandles NCBI's header format and uses CSV.jl for parsing.\n\nArguments\n\ndb::String: Database source (\"genbank\" or \"refseq\").\n\nReturns\n\nDataFrames.DataFrame: Parsed metadata table.\n\nErrors\n\nThrows ArgumentError for invalid db.\nThrows error if cache directory cannot be created.\nThrows error if data cannot be obtained from cache or download.\nRethrows errors from Downloads.download or CSV parsing.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_ncbi_taxonomy-Tuple{}","page":"Home","title":"Mycelia.load_ncbi_taxonomy","text":"load_ncbi_taxonomy(\n;\n    path_to_taxdump\n) -> MetaGraphs.MetaDiGraph{T, Float64} where T<:Integer\n\n\nDownloads and constructs a MetaDiGraph representation of the NCBI taxonomy database.\n\nArguments\n\npath_to_taxdump: Directory path where taxonomy files will be downloaded and extracted\n\nReturns\n\nMetaDiGraph: A directed graph where:\nVertices represent taxa with properties:\n:tax_id: NCBI taxonomy identifier\n:scientific_name, :common_name, etc.: Name properties\n:rank: Taxonomic rank\n:division_id, :division_cde, :division_name: Division information\nEdges represent parent-child relationships in the taxonomy\n\nDependencies\n\nRequires internet connection for initial download. Uses DataFrames, MetaGraphs, and ProgressMeter.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_refseq_metadata-Tuple{}","page":"Home","title":"Mycelia.load_refseq_metadata","text":"load_refseq_metadata() -> DataFrames.DataFrame\n\n\nLoads NCBI RefSeq metadata into a DataFrame. RefSeq is NCBI's curated collection  of genomic, transcript and protein sequences.\n\nReturns\n\nDataFrame: Contains metadata columns including accession numbers, taxonomic information,\n\nand sequence details from RefSeq.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.local_blast_database_info-Tuple{}","page":"Home","title":"Mycelia.local_blast_database_info","text":"local_blast_database_info(; blastdbs_dir) -> Any\n\n\nQuery information about local BLAST databases and return a formatted summary.\n\nArguments\n\nblastdbs_dir::String: Directory containing BLAST databases (default: \"~/workspace/blastdb\")\n\nReturns\n\nDataFrame with columns:\nBLAST database path\nBLAST database molecule type\nBLAST database title\ndate of last update\nnumber of bases/residues\nnumber of sequences\nnumber of bytes\nBLAST database format version\nhuman readable size\n\nDependencies\n\nRequires NCBI BLAST+ tools. Will attempt to install via apt-get if not present.\n\nSide Effects\n\nMay install system packages (ncbi-blast+, perl-doc) using sudo/apt-get\nFilters out numbered database fragments from results\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.logistic_pca_epca-Tuple{AbstractMatrix{Bool}}","page":"Home","title":"Mycelia.logistic_pca_epca","text":"logistic_pca_epca(M::AbstractMatrix{Bool}; k::Int=0)\n\nSynonym for bernoulli_pca_epca(M; k=k).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.mash_distance_from_jaccard-Tuple{Float64, Int64}","page":"Home","title":"Mycelia.mash_distance_from_jaccard","text":"mash_distance_from_jaccard(jaccard_index::Float64, kmer_size::Int)\n\nCalculates the Mash distance (an estimate of Average Nucleotide Identity) from a given Jaccard Index and k-mer size.\n\nArguments\n\njaccard_index::Float64: The Jaccard similarity between the two k-mer sets. Must be between 0.0 and 1.0.\nkmer_size::Int: The length of k-mers used to calculate the Jaccard index.\n\nReturns\n\nFloat64: The estimated Mash distance D. The estimated ANI would be 1.0 - D.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.maximum_weight_walk_next-Tuple{MetaGraphsNext.MetaGraph, String, Int64}","page":"Home","title":"Mycelia.maximum_weight_walk_next","text":"maximum_weight_walk_next(\n    graph::MetaGraphsNext.MetaGraph,\n    start_vertex::String,\n    max_steps::Int64;\n    weight_function\n) -> Mycelia.GraphPath\n\n\nPerform a maximum weight walk prioritizing highest confidence edges.\n\nThis greedy algorithm always chooses the edge with the highest weight (coverage) at each step, useful for finding high-confidence assembly paths.\n\nArguments\n\ngraph: MetaGraphsNext k-mer graph\nstart_vertex: Starting vertex label\nmax_steps: Maximum steps to take\nweight_function: Function to extract weight from edge data (default: uses edge.weight)\n\nReturns\n\nGraphPath: Path following maximum weight edges\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.merge_and_map_single_end_samples-Tuple{}","page":"Home","title":"Mycelia.merge_and_map_single_end_samples","text":"merge_and_map_single_end_samples(; \n    fasta_reference::AbstractString, \n    fastq_list::Vector{<:AbstractString}, \n    minimap_index::AbstractString, \n    mapping_type::AbstractString,\n    outbase::AbstractString = \"results\",\n    outformats::Vector{<:AbstractString} = [\".tsv.gz\", \".jld2\"]\n) -> DataFrames.DataFrame\n\nMerge and map single-end sequencing samples, then output results in one or more formats.\n\nArguments\n\nfasta_reference: Path to the reference FASTA file.\nfastq_list: Vector of paths to input FASTQ files to be merged.\nminimap_index: Path to the minimap2 index file (.mmi).\nmapping_type: Mapping type string for minimap2 (e.g., \"map-ont\").\noutbase: Base name (optionally including path) for output files (default: Mycelia.normalized_current_date() * \".joint-minimap-mapping-results\").\noutformats: Vector of output file formats to write results to. Supported: \".tsv.gz\", \".jld2\".\n\nDescription\n\nThis function merges provided FASTQ files and assigns unique UUIDs to reads, maps the merged FASTQ against the provided reference using minimap2, reads mapping and UUID tables, joins them into a single DataFrame, writes this table to all requested output formats with filenames constructed from the outbase and the appropriate extension, and returns the resulting joined DataFrame.\n\nOutput Files\n\n.tsv.gz: Tab-separated, gzip-compressed table of results.\n\".jld2\": JLD2 file containing results.\n\nReturns\n\nThe joined results as a DataFrames.DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.merge_colors-Tuple{Any, Any}","page":"Home","title":"Mycelia.merge_colors","text":"merge_colors(c1, c2) -> Any\n\n\nMerge two colors by calculating their minimal color difference vector.\n\nArguments\n\nc1::Color: First color input\nc2::Color: Second color input \n\nReturns\n\nIf colors are equal, returns the input color\nOtherwise returns the color difference vector (c1-c2 or c2-c1) with minimal RGB sum\n\nDetails\n\nCalculates two difference vectors:\n\nmix_a = c1 - c2 \nmix_b = c2 - c1\n\nReturns the difference vector with the smallest sum of RGB components.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.merge_fasta_files-Tuple{}","page":"Home","title":"Mycelia.merge_fasta_files","text":"merge_fasta_files(; fasta_files, fasta_file)\n\n\nJoin fasta files while adding origin prefixes to the identifiers.\n\nDoes not guarantee uniqueness but will warn if conflicts arise\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.merge_overlapping_repeats-Tuple{Vector{Mycelia.RepeatRegion}}","page":"Home","title":"Mycelia.merge_overlapping_repeats","text":"Merge overlapping repeat regions.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.merge_repeat_regions-Tuple{Vector{Mycelia.RepeatRegion}}","page":"Home","title":"Mycelia.merge_repeat_regions","text":"Merge multiple repeat regions into one.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.merge_xam_with_taxonomies-Tuple{}","page":"Home","title":"Mycelia.merge_xam_with_taxonomies","text":"Merge XAM alignment data with taxonomic information and calculate alignment metrics.\n\nThis function processes XAM alignment data by:\n\nLoading an accession-to-taxid mapping table\nLeft-joining alignment data with taxonomic IDs\nRetrieving full taxonomic lineage information\nCalculating percent identity scores\nCalculating relative alignment score proportions per read\nWriting results to cached files\n\nArguments\n\nxam: Path to XAM file or XAM data structure\naccession2taxid_file: Path to accession-to-taxid mapping file (.tsv.gz or .arrow)\noutput_prefix: Prefix for output files (.tsv.gz and .arrow). Defaults to \"xam\"\nverbose::Bool=true: Whether to print progress information\nforce_recalculate::Bool=false: Whether to force recalculation even if cached files exist\n\nReturns\n\nA NamedTuple with paths to the output files: (tsvout, arrowout)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.metasha256-Tuple{Vector{<:AbstractString}}","page":"Home","title":"Mycelia.metasha256","text":"metasha256(\n    vector_of_sha256s::Vector{<:AbstractString}\n) -> String\n\n\nCompute a single SHA256 hash from multiple SHA256 hashes.\n\nTakes a vector of hex-encoded SHA256 hashes and produces a new SHA256 hash by:\n\nSorting the input hashes lexicographically\nConcatenating them in sorted order\nComputing a new SHA256 hash over the concatenated data\n\nArguments\n\nvector_of_sha256s: Vector of hex-encoded SHA256 hash strings\n\nReturns\n\nA hex-encoded string representing the computed meta-hash\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_index-Tuple{}","page":"Home","title":"Mycelia.minimap_index","text":"minimap_index(\n;\n    fasta,\n    mapping_type,\n    mem_gb,\n    threads,\n    as_string,\n    denominator\n)\n\n\nCreate a minimap2 index for the provided reference sequence.\n\nArguments\n\nfasta::String: Path to the reference FASTA.\nmapping_type::String: Preset (e.g. \"map-hifi\").\nmem_gb::Real: Memory available in GB.\nthreads::Integer: Number of threads.\nas_string::Bool=false: If true, return the command string instead of Cmd.\ndenominator::Real: Scaling factor passed to system_mem_to_minimap_index_size.\n\nReturns\n\nNamed tuple (cmd, outfile) where outfile is the generated .mmi index path.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_map-Tuple{}","page":"Home","title":"Mycelia.minimap_map","text":"minimap_map(\n;\n    fasta,\n    fastq,\n    mapping_type,\n    as_string,\n    mem_gb,\n    threads,\n    denominator\n)\n\n\nGenerate minimap2 alignment commands for sequence mapping.\n\naligning and compressing. No sorting or filtering.\n\nUse shell_only=true to get string command to submit to SLURM\n\nCreates a command to align reads in FASTQ format to a reference FASTA using minimap2,  followed by SAM compression with pigz. Handles resource allocation and conda environment setup.\n\nArguments\n\nfasta: Path to reference FASTA file\nfastq: Path to query FASTQ file\nmapping_type: Alignment preset (\"map-hifi\", \"map-ont\", \"map-pb\", \"sr\", or \"lr:hq\")\nas_string: If true, returns shell command as string; if false, returns command array\nmem_gb: Available memory in GB for indexing (defaults to system free memory)\nthreads: Number of CPU threads to use (defaults to system threads)\ndenominator: Divisor for calculating minimap2 index size\n\nReturns\n\nNamed tuple containing:\n\ncmd: Shell command (as string or array)\noutfile: Path to compressed output SAM file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_map_paired_end_with_index-Tuple{}","page":"Home","title":"Mycelia.minimap_map_paired_end_with_index","text":"minimap_map_paired_end_with_index(\n;\n    forward,\n    reverse,\n    mem_gb,\n    threads,\n    outdir,\n    as_string,\n    denominator,\n    fasta,\n    index_file\n)\n\n\nMap paired-end reads to a reference sequence using minimap2.\n\nArguments\n\nfasta::String: Path to reference FASTA file\nforward::String: Path to forward reads FASTQ file\nreverse::String: Path to reverse reads FASTQ file\nmem_gb::Integer: Available system memory in GB\nthreads::Integer: Number of threads to use\noutdir::String: Output directory (defaults to forward reads directory)\nas_string::Bool=false: Return command as string instead of Cmd array\nmapping_type::String=\"sr\": Minimap2 preset [\"map-hifi\", \"map-ont\", \"map-pb\", \"sr\", \"lr:hq\"]\ndenominator::Float64: Memory scaling factor for index size\n\nReturns\n\nNamed tuple containing:\n\ncmd: Command(s) to execute (String or Array{Cmd})\noutfile: Path to compressed output SAM file (*.sam.gz)\n\nNotes\n\nRequires minimap2, samtools, and pigz conda environments\nAutomatically compresses output using pigz\nIndex file must exist at $(fasta).x$(mapping_type).I$(index_size).mmi\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_map_with_index-Tuple{}","page":"Home","title":"Mycelia.minimap_map_with_index","text":"minimap_map_with_index(\n;\n    fasta,\n    mapping_type,\n    fastq,\n    index_file,\n    mem_gb,\n    threads,\n    as_string,\n    denominator\n)\n\n\nMap reads using an existing minimap2 index file.\n\nArguments\n\nfasta: Path to the reference FASTA (used only if an index must be created).\nmapping_type: Minimap2 preset.\nfastq: Input reads.\nindex_file::String=\"\": Optional prebuilt index path. If empty, one is created.\nmem_gb, threads, as_string, denominator: Parameters forwarded to minimap_index.\n\nReturns\n\nNamed tuple (cmd, outfile) producing a BAM file from the mapping.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.mmseqs_pairwise_search-Tuple{}","page":"Home","title":"Mycelia.mmseqs_pairwise_search","text":"mmseqs_pairwise_search(; fasta, output)\n\n\nPerform all-vs-all sequence search using MMseqs2's easy-search command.\n\nArguments\n\nfasta::String: Path to input FASTA file containing sequences to compare\noutput::String: Output directory path (default: input filename + \".mmseqseasysearch_pairwise\")\n\nReturns\n\nString: Path to the output directory\n\nDetails\n\nExecutes MMseqs2 with sensitive search parameters (7 sensitivity steps) and outputs results in  tabular format with the following columns:\n\nquery, qheader: Query sequence ID and header\ntarget, theader: Target sequence ID and header  \npident: Percentage sequence identity\nfident: Fraction of identical matches\nnident: Number of identical matches\nalnlen: Alignment length\nmismatch: Number of mismatches\ngapopen: Number of gap openings\nqstart, qend, qlen: Query sequence coordinates and length\ntstart, tend, tlen: Target sequence coordinates and length\nevalue: Expected value\nbits: Bit score\n\nRequires MMseqs2 to be available through Bioconda.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.mutate_sequence-Tuple{Any}","page":"Home","title":"Mycelia.mutate_sequence","text":"mutate_sequence(reference_sequence) -> Tuple{Any, Any}\n\n\nGenerate a single random mutation in an amino acid sequence.\n\nArguments\n\nreference_sequence: Input amino acid sequence to be mutated\n\nReturns\n\nmutant_sequence: The sequence after applying the mutation\nhaplotype: A SequenceVariation.Haplotype object containing the mutation details\n\nDetails\n\nPerforms one of three possible mutation types:\n\nSubstitution: Replace one amino acid with another\nInsertion: Insert 1+ random amino acids at a position\nDeletion: Remove 1+ amino acids from a position\n\nInsertion and deletion sizes follow a truncated Poisson distribution (λ=1, min=1).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.mycelia_assemble-Tuple{Vector{<:FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.mycelia_assemble","text":"Main Mycelia intelligent assembly algorithm. Implements iterative prime k-mer progression with error correction.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.mycelia_cross_validation-Tuple{String}","page":"Home","title":"Mycelia.mycelia_cross_validation","text":"Main cross-validation function for hybrid assembly quality assessment. Compares intelligent vs iterative assembly approaches across multiple validation folds.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.mycelia_iterative_assemble-Tuple{String}","page":"Home","title":"Mycelia.mycelia_iterative_assemble","text":"Main iterative maximum likelihood assembly function. Processes entire read sets per iteration with complete FASTQ I/O tracking. Enhanced with performance optimizations, caching, and progress tracking.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.n_maximally_distinguishable_colors-Tuple{Any}","page":"Home","title":"Mycelia.n_maximally_distinguishable_colors","text":"n_maximally_distinguishable_colors(n) -> Any\n\n\nGenerate n colors that are maximally distinguishable from each other.\n\nArguments\n\nn::Integer: The number of distinct colors to generate\n\nReturns\n\nA vector of n RGB colors that are optimized for maximum perceptual distinction, using white (RGB(1,1,1)) and black (RGB(0,0,0)) as anchor colors.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.name2taxid-Tuple{Any}","page":"Home","title":"Mycelia.name2taxid","text":"name2taxid(name) -> DataFrames.DataFrame\n\n\nConvert scientific name(s) to NCBI taxonomy ID(s) using taxonkit.\n\nArguments\n\nname::AbstractString: Scientific name(s) to query. Can be a single name or multiple names separated by newlines.\n\nReturns\n\nDataFrame with columns:\nname: Input scientific name\ntaxid: NCBI taxonomy ID\nrank: Taxonomic rank (e.g., \"species\", \"genus\")\n\nDependencies\n\nRequires taxonkit package (installed automatically via Bioconda)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.names2taxids-Tuple{AbstractVector{<:AbstractString}}","page":"Home","title":"Mycelia.names2taxids","text":"names2taxids(names::AbstractVector{<:AbstractString}) -> Any\n\n\nConvert a vector of species/taxon names to their corresponding NCBI taxonomy IDs.\n\nArguments\n\nnames::AbstractVector{<:AbstractString}: Vector of scientific names or common names\n\nReturns\n\nVector{Int}: Vector of NCBI taxonomy IDs corresponding to the input names\n\nProgress is displayed using ProgressMeter.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ncbi_ftp_path_to_url-Tuple{}","page":"Home","title":"Mycelia.ncbi_ftp_path_to_url","text":"ncbi_ftp_path_to_url(; ftp_path, extension)\n\n\nConstructs a complete NCBI FTP URL by combining a base FTP path with a file extension.\n\nArguments\n\nftp_path::String: Base FTP directory path for the resource\nextension::String: File extension to append to the resource name\n\nReturns\n\nString: Complete FTP URL path to the requested resource\n\nExtensions include:\n\ngenomic.fna.gz\ngenomic.gff.gz\nprotein.faa.gz\nassembly_report.txt\nassembly_stats.txt\ncdsfromgenomic.fna.gz\nfeature_count.txt.gz\nfeature_table.txt.gz\ngenomic.gbff.gz\ngenomic.gtf.gz\nprotein.gpff.gz\ntranslated_cds.faa.gz\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ncbi_genome_download_accession-Tuple{}","page":"Home","title":"Mycelia.ncbi_genome_download_accession","text":"ncbi_genome_download_accession(\n;\n    accession,\n    outdir,\n    outpath,\n    include_string\n)\n\n\nDownload an accession using NCBI datasets command line tool\n\nthe .zip download output to outpath will be unzipped\n\nreturns the outfolder\n\nncbi's default include string is  include_string = \"gff3,rna,cds,protein,genome,seq-report\"\n\nDownloads and extracts a genome from NCBI using the datasets command line tool.\n\nArguments\n\naccession: NCBI accession number for the genome\noutdir: Directory where files will be downloaded (defaults to current directory)\noutpath: Full path for the temporary zip file (defaults to outdir/accession.zip)\ninclude_string: Data types to download (defaults to all \"gff3,rna,cds,protein,genome,seq-report\").\n\nReturns\n\nPath to the extracted genome data directory\n\nNotes\n\nRequires the ncbi-datasets-cli conda package (automatically installed if missing)\nDownloaded zip file is automatically removed after extraction\nIf output folder already exists, download is skipped\nData is extracted to outdir/accession/ncbi_dataset/data/accession\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ncbi_taxon_summary-Tuple{Any}","page":"Home","title":"Mycelia.ncbi_taxon_summary","text":"ncbi_taxon_summary(taxa_id) -> DataFrames.DataFrame\n\n\nRetrieve taxonomic information for a given NCBI taxonomy ID.\n\nArguments\n\ntaxa_id: NCBI taxonomy identifier (integer)\n\nReturns\n\nDataFrame: Taxonomy summary containing fields like tax_id, rank, species, etc.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.nearest_prime-Tuple{Int64}","page":"Home","title":"Mycelia.nearest_prime","text":"nearest_prime(n::Int64) -> Int64\n\n\nFind the closest prime number to the given integer n.\n\nReturns the nearest prime number to n. If two prime numbers are equally distant  from n, returns the smaller one.\n\nArguments\n\nn::Int: The input integer to find the nearest prime for\n\nReturns\n\nInt: The closest prime number to n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.negbin_pca_epca-Tuple{AbstractMatrix{<:Integer}}","page":"Home","title":"Mycelia.negbin_pca_epca","text":"negbin_pca_epca(M::AbstractMatrix{<:Integer};\n               k::Int=0,\n               r::Int=1)\n\nPerform Negative-Binomial EPCA on a count matrix M (features × samples).\n\nWhen to use\n\nUse for overdispersed count data (variance > mean), such as RNA-seq or metagenomic counts.\n\nKeyword arguments\n\nk : desired number of latent dimensions; if k<1 defaults to min(n_samples-1, n_features, 10)\nr : known NB “number of successes” parameter\n\nReturns\n\nNamedTuple with fields\n\nmodel    : the fitted ExpFamilyPCA.NegativeBinomialEPCA object  \nscores   : k×n_samples matrix of sample scores  \nloadings : k×n_features matrix of feature loadings  \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.nersc_sbatch-Tuple{}","page":"Home","title":"Mycelia.nersc_sbatch","text":"nersc_sbatch(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    scriptdir,\n    qos,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd,\n    constraint\n)\n\n\nSubmit a batch job to NERSC's SLURM workload manager.\n\nArguments\n\njob_name: Identifier for the SLURM job\nmail_user: Email address for job notifications\nmail_type: Notification type (\"ALL\", \"BEGIN\", \"END\", \"FAIL\", or \"NONE\")\nlogdir: Directory for storing job output/error logs\nscriptdir: Directory for storing generated SLURM scripts\nqos: Quality of Service level (\"regular\", \"premium\", or \"preempt\")\nnodes: Number of nodes to allocate\nntasks: Number of tasks to run\ntime: Maximum wall time in format \"days-HH:MM:SS\"\ncpus_per_task: CPU cores per task\nmem_gb: Memory per node in GB\ncmd: Command(s) to execute (String or Vector{String})\nconstraint: Node type constraint (\"cpu\" or \"gpu\")\n\nReturns\n\ntrue if job submission succeeds\nfalse if submission fails\n\nQoS Options\n\nregular: Standard priority queue\npremium: High priority queue (5x throughput limit)\npreempt: Reduced credit usage but jobs may be interrupted\n\nhttps://docs.nersc.gov/jobs/policy/ https://docs.nersc.gov/systems/perlmutter/architecture/#cpu-nodes\n\ndefault is to use shared qos\n\nuse\n\nregular\npreempt (reduced credit usage but not guaranteed to finish)\npremium (priorty runs limited to 5x throughput)\n\nhttps://docs.nersc.gov/systems/perlmutter/running-jobs/#tips-and-tricks\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.nersc_sbatch_shared-Tuple{}","page":"Home","title":"Mycelia.nersc_sbatch_shared","text":"nersc_sbatch_shared(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    qos,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd,\n    constraint\n)\n\n\nSubmit a job to NERSC's SLURM scheduler using the shared QOS (Quality of Service).\n\nArguments\n\njob_name: Identifier for the job\nmail_user: Email address for job notifications\nmail_type: Notification type (\"ALL\", \"BEGIN\", \"END\", \"FAIL\", \"REQUEUE\", \"STAGE_OUT\")\nlogdir: Directory for storing job output and error logs\nqos: Quality of Service level (\"shared\", \"regular\", \"preempt\", \"premium\")\nnodes: Number of nodes to allocate\nntasks: Number of tasks to run\ntime: Maximum wall time in format \"days-hours:minutes:seconds\"\ncpus_per_task: Number of CPUs per task\nmem_gb: Memory per node in GB (default: 2GB per CPU)\ncmd: Command to execute\nconstraint: Node type constraint (\"cpu\" or \"gpu\")\n\nResource Limits\n\nMaximum memory per node: 512GB\nMaximum cores per node: 128\nDefault memory allocation: 2GB per CPU requested\n\nQOS Options\n\nshared: Default QOS for shared node usage\nregular: Standard priority\npreempt: Reduced credit usage but preemptible\npremium: 5x throughput priority (limited usage)\n\nReturns\n\ntrue if job submission succeeds\n\nhttps://docs.nersc.gov/jobs/policy/ https://docs.nersc.gov/systems/perlmutter/architecture/#cpu-nodes\n\ndefault is to use shared qos\n\nuse\n\nregular\npreempt (reduced credit usage but not guaranteed to finish)\npremium (priority runs limited to 5x throughput)\n\nmax request is 512Gb memory and 128 cores per node\n\nhttps://docs.nersc.gov/systems/perlmutter/running-jobs/#tips-and-tricks\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.next_prime_k-Tuple{Int64}","page":"Home","title":"Mycelia.next_prime_k","text":"Find the next prime number greater than current_k. For k-mer progression, we prefer odd numbers and especially primes.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.node_type_to_dataframe-Tuple{}","page":"Home","title":"Mycelia.node_type_to_dataframe","text":"node_type_to_dataframe(; node_type, graph)\n\n\nConvert all nodes of a specific type in a MetaGraph to a DataFrame representation.\n\nArguments\n\nnode_type: The type of nodes to extract from the graph\ngraph: A MetaGraph containing the nodes\n\nReturns\n\nA DataFrame where:\n\nEach row represents a node of the specified type\nColumns correspond to all unique properties found across nodes\nValues are JSON-serialized strings for consistency\n\nNotes\n\nAll values are normalized through JSON serialization\nDictionary values receive double JSON encoding\nThe TYPE column is converted using type_to_string\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_codon_frequencies-Tuple{Any}","page":"Home","title":"Mycelia.normalize_codon_frequencies","text":"normalize_codon_frequencies(\n    codon_frequencies\n) -> Dict{BioSymbols.AminoAcid, Dict{Kmers.Kmer{BioSequences.DNAAlphabet{2}, 3, 1}, Float64}}\n\n\nNormalizes codon frequencies for each amino acid such that frequencies sum to 1.0.\n\nArguments\n\ncodon_frequencies: Nested dictionary mapping amino acids to their codon frequency distributions\n\nReturns\n\nNormalized codon frequencies where values for each amino acid sum to 1.0\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_countmap-Tuple{Any}","page":"Home","title":"Mycelia.normalize_countmap","text":"normalize_countmap(countmap) -> Dict\n\n\nNormalize a dictionary of counts into a probability distribution where values sum to 1.0.\n\nArguments\n\ncountmap::Dict: Dictionary mapping keys to count values\n\nReturns\n\nDict: New dictionary with same keys but values normalized by total sum\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.normalize_distance_matrix","text":"normalize_distance_matrix(distance_matrix) -> Any\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\nNormalize a distance matrix by dividing all elements by the maximum non-NaN value.\n\nArguments\n\ndistance_matrix: A matrix of distance values that may contain NaN, nothing, or missing values\n\nReturns\n\nNormalized distance matrix with values scaled to [0, 1] range\n\nDetails\n\nFilters out NaN, nothing, and missing values when finding the maximum\nAll elements are divided by the same maximum value to preserve relative distances\nIf all values are NaN/nothing/missing, may return NaN values\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_kmer_counts-Tuple{Any}","page":"Home","title":"Mycelia.normalize_kmer_counts","text":"normalize_kmer_counts(\n    kmer_counts\n) -> OrderedCollections.OrderedDict\n\n\nConvert raw k‑mer counts into normalized frequencies.\n\nArguments\n\nkmer_counts::Dict: Mapping of k-mers to counts.\n\nReturns\n\nOrderedDict with values scaled so the sum equals 1.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_vcf-Tuple{}","page":"Home","title":"Mycelia.normalize_vcf","text":"normalize_vcf(; reference_fasta, vcf_file)\n\n\nNormalize a VCF file using bcftools norm, with automated handling of compression and indexing.\n\nArguments\n\nreference_fasta::String: Path to the reference FASTA file used for normalization\nvcf_file::String: Path to input VCF file (can be gzipped or uncompressed)\n\nReturns\n\nString: Path to the normalized, sorted, and compressed output VCF file (*.sorted.normalized.vcf.gz)\n\nNotes\n\nRequires bioconda packages: htslib, tabix, bcftools\nCreates intermediate files with extensions .tbi for indices\nSkips processing if output file already exists\nPerforms left-alignment and normalization of variants\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalized_current_date-Tuple{}","page":"Home","title":"Mycelia.normalized_current_date","text":"normalized_current_date() -> String\n\n\nReturns the current date as a normalized string with all non-word characters removed.\n\nThe output format is based on ISO datetime (YYYYMMDD) but strips any special characters like hyphens, colons or dots.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalized_current_datetime-Tuple{}","page":"Home","title":"Mycelia.normalized_current_datetime","text":"normalized_current_datetime() -> String\n\n\nReturns the current date and time as a normalized string with all non-word characters removed.\n\nThe output format is based on ISO datetime (YYYYMMDDThhmmss) but strips any special characters like hyphens, colons or dots.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.observe-Tuple{R} where R<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}","page":"Home","title":"Mycelia.observe","text":"observe(\n    record::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record};\n    error_rate\n)\n\n\nSimulate sequencing of a DNA/RNA record by introducing random errors at the specified rate.\n\nArguments\n\nrecord: A FASTA or FASTQ record containing the sequence to be \"observed\"\nerror_rate: Probability of error at each position (default: 0.0)\n\nReturns\n\nA new FASTQ.Record with:\n\nRandom UUID as identifier\nOriginal record's description \nModified sequence with introduced errors\nGenerated quality scores\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.observe-Union{Tuple{BioSequences.LongSequence{T}}, Tuple{T}} where T","page":"Home","title":"Mycelia.observe","text":"observe(sequence::BioSequences.LongSequence{T}; error_rate=nothing, tech::Symbol=:illumina) where T\n\nSimulates the “observation” of a biological polymer (DNA, RNA, or protein) by introducing realistic errors along with base‐quality scores. The simulation takes into account both random and systematic error components. In particular, for technologies:\n\nillumina: (mostly substitution errors) the per‐base quality decays along the read (from ~Q40 at the start to ~Q20 at the end);\nnanopore: errors are more frequent and include both substitutions and indels (with overall lower quality scores, and an extra “homopolymer” penalty);\npacbio: errors are dominated by indels (with quality scores typical of raw reads);\nultima: (UG 100/ppmSeq™) correct bases are assigned very high quality (~Q60) while errors are extremely rare and, if they occur, are given a modest quality.\n\nAn error is introduced at each position with a (possibly position‐dependent) probability. For Illumina, the error probability increases along the read; additionally, if a base is part of a homopolymer run (length ≥ 3) and the chosen technology is one that struggles with homopolymers (nanopore, pacbio, ultima), then the local error probability is multiplied by a constant factor.\n\nReturns a tuple (new_seq, quality_scores) where:\n\nnew_seq is a BioSequences.LongSequence{T} containing the “observed” sequence (which may be longer or shorter than the input if insertions or deletions occur), and \nquality_scores is a vector of integers representing the Phred quality scores (using the Sanger convention) for each base in the output sequence.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.open_fastx-Tuple{AbstractString}","page":"Home","title":"Mycelia.open_fastx","text":"open_fastx(path::AbstractString) -> Any\n\n\nOpen and return a reader for FASTA or FASTQ format files.\n\nArguments\n\npath::AbstractString: Path to input file. Can be:\nLocal file path\nHTTP/FTP URL\nGzip compressed (.gz extension)\n\nSupported formats\n\nFASTA (.fasta, .fna, .faa, .fa)\nFASTQ (.fastq, .fq)\n\nReturns\n\nFASTX.FASTA.Reader for FASTA files\nFASTX.FASTQ.Reader for FASTQ files\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.open_genbank-Tuple{Any}","page":"Home","title":"Mycelia.open_genbank","text":"open_genbank(\n    genbank_file\n) -> Vector{GenomicAnnotations.Record}\n\n\nOpens and parses a GenBank format file containing genomic sequence and annotation data.\n\nArguments\n\ngenbank_file::AbstractString: Path to the GenBank (.gb or .gbk) file\n\nReturns\n\nVector{GenomicAnnotations.Chromosome}: Vector containing parsed chromosome data\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.open_gff-Tuple{String}","page":"Home","title":"Mycelia.open_gff","text":"open_gff(path::String) -> Any\n\n\nOpens a GFF (General Feature Format) file for reading.\n\nArguments\n\npath::String: Path to GFF file. Can be:\nLocal file path\nHTTP/FTP URL (FTP URLs are automatically converted to HTTP)\nGzipped file (automatically decompressed)\n\nReturns\n\nIO: An IO stream ready to read the GFF content\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.optimal_subsequence_length-Tuple{}","page":"Home","title":"Mycelia.optimal_subsequence_length","text":"optimal_subsequence_length(\n;\n    error_rate,\n    threshold,\n    sequence_length,\n    plot_result\n)\n\n\nCalculate the optimal subsequence length based on error rate distribution.\n\nArguments\n\nerror_rate: Single error rate or array of error rates (between 0 and 1)\nthreshold: Desired probability that a subsequence is error-free (default: 0.95)\nsequence_length: Maximum sequence length to consider for plotting\nplot_result: If true, returns a plot of probability vs. length\n\nReturns\n\nIf plot_result=false: Integer representing optimal subsequence length\nIf plot_result=true: Tuple of (optimal_length, plot)\n\nExamples\n\n# Single error rate\noptimal_subsequence_length(error_rate=0.01)\n\n# Array of error rates\noptimal_subsequence_length(error_rate=[0.01, 0.02, 0.01])\n\n# With more stringent threshold\noptimal_subsequence_length(error_rate=0.01, threshold=0.99)\n\n# Generate plot\nlength, p = optimal_subsequence_length(error_rate=0.01, plot_result=true)\nPlots.display(p)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.pairwise_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.pairwise_distance_matrix","text":"pairwise_distance_matrix(\n    matrix;\n    dist_func = Distances.euclidean,\n    show_progress = true,\n    progress_desc = \"Computing distances\"\n)\n\nCompute a symmetric pairwise distance matrix between columns of matrix using the supplied distance function.\n\nArguments\n\nmatrix: Column-major matrix (features as rows, entities as columns)\ndist_func: Function of the form f(a, b) returning the distance between two vectors (default: Distances.euclidean)\nshow_progress: Display progress bar if true (default: true)\nprogress_desc: Progress bar description (default: \"Computing distances\")\n\nReturns\n\nSymmetric N×N matrix of pairwise distances between columns (entities)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parallel_pyrodigal-Tuple{Vector{String}}","page":"Home","title":"Mycelia.parallel_pyrodigal","text":"parallel_pyrodigal(normalized_fastas::Vector{String})\n\nRuns Mycelia.run_pyrodigal on a list of FASTA files in parallel using Threads.\n\nArgs:     normalized_fastas: A vector of strings, where each string is a path to a FASTA file.\n\nReturns:     A tuple containing two elements:     1. successes (Vector{Tuple{String, Any}}): A vector of tuples, where each tuple contains the        filename and the result returned by a successful Mycelia.runpyrodigal call.     2. failures (Vector{Tuple{String, String}}): A vector of tuples, where each tuple contains the        filename and the error message string for a failed Mycelia.runpyrodigal call.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_blast_report-Tuple{Any}","page":"Home","title":"Mycelia.parse_blast_report","text":"parse_blast_report(blast_report) -> DataFrames.DataFrame\n\n\nExpects output type 7 from BLAST, default output type 6 doesn't have the header comments and won't auto-parse\n\nParse a BLAST output file into a structured DataFrame.\n\nArguments\n\nblast_report::AbstractString: Path to a BLAST output file in format 7 (tabular with comments)\n\nReturns\n\nDataFrame: Table containing BLAST results with columns matching the header fields. Returns empty DataFrame if no hits found.\n\nDetails\n\nRequires BLAST output format 7 (-outfmt 7), which includes header comments\nHandles missing values (encoded as \"N/A\") automatically\nInfers column types based on BLAST field names\nSupports standard BLAST tabular fields including sequence IDs, scores, alignments and taxonomic information\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_gfa-Tuple{Any}","page":"Home","title":"Mycelia.parse_gfa","text":"parse_gfa(gfa) -> MetaGraphs.MetaGraph{Int64, Float64}\n\n\nParse a GFA (Graphical Fragment Assembly) file into a MetaGraph representation.\n\nArguments\n\ngfa: Path to GFA format file\n\nReturns\n\nA MetaGraph where:\n\nVertices represent segments (contigs)\nEdges represent links between segments\nVertex properties include :id with segment identifiers\nGraph property :records contains the original FASTA records\n\nFormat Support\n\nHandles standard GFA v1 lines:\n\nH: Header lines (skipped)\nS: Segments (stored as nodes with FASTA records)\nL: Links (stored as edges)\nP: Paths (stored in paths dictionary)\nA: HiFiAsm specific lines (skipped)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_jsonl-Tuple{String}","page":"Home","title":"Mycelia.parse_jsonl","text":"parse_jsonl(filepath::String) -> Vector{Dict{String, Any}}\n\n\nparse_jsonl(filepath::String) -> Vector{Dict{String,Any}}\n\nValidate and parse a JSON Lines file (either .ndjson/.jsonl, optionally gzipped) into a vector of dictionaries, reporting progress in bytes processed.\n\nValidations performed:   • Extension must be one of: .jsonl, .ndjson, .jsonl.gz, .ndjson.gz   • File must exist   • File size must be non-zero\n\nProgress meter shows bytes read from the underlying file (compressed bytes for .gz). No second full pass is needed.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_mmseqs_easy_taxonomy_lca_tsv-Tuple{Any}","page":"Home","title":"Mycelia.parse_mmseqs_easy_taxonomy_lca_tsv","text":"parse_mmseqs_easy_taxonomy_lca_tsv(\n    lca_tsv\n) -> DataFrames.DataFrame\n\n\nParse the taxonomic Last Common Ancestor (LCA) TSV output from MMseqs2's easy-taxonomy workflow.\n\nArguments\n\nlca_tsv: Path to the TSV file containing MMseqs2 taxonomy results\n\nReturns\n\nDataFrame with columns:\n\ncontig_id: Sequence identifier\ntaxon_id: NCBI taxonomy identifier \ntaxon_rank: Taxonomic rank (e.g. species, genus)\ntaxon_name: Scientific name\nfragments_retained: Number of fragments kept\nfragments_taxonomically_assigned: Number of fragments with taxonomy\nfragments_in_agreement_with_assignment: Fragments matching contig taxonomy\nsupport -log(E-value): Statistical support score\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_mmseqs_easy_taxonomy_tophit_report-Tuple{Any}","page":"Home","title":"Mycelia.parse_mmseqs_easy_taxonomy_tophit_report","text":"parse_mmseqs_easy_taxonomy_tophit_report(\n    tophit_report\n) -> DataFrames.DataFrame\n\n\nParse an MMseqs2 easy-taxonomy tophit report into a structured DataFrame.\n\nArguments\n\ntophit_report::String: Path to the MMseqs2 easy-taxonomy tophit report file (tab-delimited)\n\nReturns\n\nDataFrame: A DataFrame with columns:\ntarget_id: Target sequence identifier\nnumber of sequences aligning to target: Count of aligned sequences\nunique coverage of target: Ratio of uniqueAlignedResidues to targetLength\nTarget coverage: Ratio of alignedResidues to targetLength\nAverage sequence identity: Mean sequence identity\ntaxon_id: Taxonomic identifier\ntaxon_rank: Taxonomic rank\ntaxon_name: Species name and lineage\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_mmseqs_tophit_aln-Tuple{Any}","page":"Home","title":"Mycelia.parse_mmseqs_tophit_aln","text":"parse_mmseqs_tophit_aln(tophit_aln) -> DataFrames.DataFrame\n\n\nParse MMseqs2 tophit alignment output file into a structured DataFrame.\n\nArguments\n\ntophit_aln::AbstractString: Path to tab-delimited MMseqs2 alignment output file\n\nReturns\n\nDataFrame with columns:\n\nquery: Query sequence/profile identifier\ntarget: Target sequence/profile identifier  \npercent identity: Sequence identity percentage\nalignment length: Length of alignment\nnumber of mismatches: Count of mismatched positions\nnumber of gaps: Count of gap openings\nquery start: Start position in query sequence\nquery end: End position in query sequence\ntarget start: Start position in target sequence\ntarget end: End position in target sequence\nevalue: E-value of alignment\nbit score: Bit score of alignment\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_qualimap_contig_coverage-Tuple{Any}","page":"Home","title":"Mycelia.parse_qualimap_contig_coverage","text":"parse_qualimap_contig_coverage(\n    qualimap_report_txt\n) -> DataFrames.DataFrame\n\n\nParse contig coverage statistics from a Qualimap BAM QC report file.\n\nArguments\n\nqualimap_report_txt::String: Path to Qualimap bamqc report text file\n\nReturns\n\nDataFrame: Coverage statistics with columns:\nContig: Contig identifier\nLength: Contig length in bases\nMapped bases: Number of bases mapped to contig\nMean coverage: Average coverage depth\nStandard Deviation: Standard deviation of coverage\n% Mapped bases: Percentage of total mapped bases on this contig\n\nSupported Assemblers\n\nHandles output from both SPAdes and MEGAHIT assemblers:\n\nSPAdes format: NODEXlengthYcov_Z\nMEGAHIT format: kXX_Y \n\nParse the contig coverage information from qualimap bamqc text report, which looks like the following:\n\n# this is spades\n>>>>>>> Coverage per contig\n\n\tNODE_1_length_107478_cov_9.051896\t107478\t21606903\t201.0355886786133\t60.39424208607496\n\tNODE_2_length_5444_cov_1.351945\t5444\t153263\t28.152645113886848\t5.954250612823136\n\tNODE_3_length_1062_cov_0.154390\t1062\t4294\t4.043314500941619\t1.6655384692688975\n\tNODE_4_length_776_cov_0.191489\t776\t3210\t4.13659793814433\t2.252009588980858\n\n# below is megahit\n>>>>>>> Coverage per contig\n\n\tk79_175\t235\t3862\t16.43404255319149\t8.437436249612457\n\tk79_89\t303\t3803\t12.551155115511552\t5.709975376279777\n\tk79_262\t394\t6671\t16.931472081218274\t7.579217802849293\n\tk79_90\t379\t1539\t4.060686015831134\t1.2929729111266581\n\tk79_91\t211\t3749\t17.767772511848342\t11.899185693011933\n\tk79_0\t2042\t90867\t44.49902056807052\t18.356525483516613\n\nTo make this more robust, consider reading in the names of the contigs from the assembled fasta\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_rtg_eval_output-Tuple{Any}","page":"Home","title":"Mycelia.parse_rtg_eval_output","text":"parse_rtg_eval_output(f) -> DataFrames.DataFrame\n\n\nParse RTG evaluation output from a gzipped tab-separated file.\n\nArguments\n\nf: Path to a gzipped TSV file containing RTG evaluation output\n\nFormat\n\nExpected file format:\n\nHeader line starting with '#' and tab-separated column names\nData rows in tab-separated format\nEmpty files return a DataFrame with empty columns matching header\n\nReturns\n\nA DataFrame where:\n\nColumn names are taken from the header line (stripped of '#')\nData is parsed as Float64 values\nEmpty files result in empty columns preserving header structure\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_transterm_output-Tuple{Any}","page":"Home","title":"Mycelia.parse_transterm_output","text":"parse_transterm_output(\n    transterm_output\n) -> DataFrames.DataFrame\n\n\nParse TransTerm terminator prediction output into a structured DataFrame.\n\nTakes a TransTerm output file path and returns a DataFrame containing parsed terminator predictions. Each row represents one predicted terminator with the following columns:\n\nchromosome: Identifier of the sequence being analyzed\nterm_id: Unique terminator identifier (e.g. \"TERM 19\")\nstart: Start position of the terminator\nstop: End position of the terminator\nstrand: Strand orientation (\"+\" or \"-\")\nlocation: Context type, where:\nG/g = in gene interior (≥50bp from ends)\nF/f = between two +strand genes\nR/r = between two -strand genes\nT = between ends of +strand and -strand genes\nH = between starts of +strand and -strand genes\nN = none of the above\nLowercase indicates opposite strand from region\nconfidence: Overall confidence score (0-100)\nhairpin_score: Hairpin structure score\ntail_score: Tail sequence score  \nnotes: Additional annotations (e.g. \"bidir\")\n\nArguments\n\ntransterm_output::AbstractString: Path to TransTerm output file\n\nReturns\n\nDataFrame: Parsed terminator predictions with columns as described above\n\nSee TransTerm HP documentation for details on scoring and location codes.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_virsorter_score_tsv-Tuple{Any}","page":"Home","title":"Mycelia.parse_virsorter_score_tsv","text":"parse_virsorter_score_tsv(\n    virsorter_score_tsv\n) -> DataFrames.DataFrame\n\n\nParse a VirSorter score TSV file and return a DataFrame.\n\nArguments\n\nvirsorter_score_tsv::String: The file path to the VirSorter score TSV file.\n\nReturns\n\nDataFrame: A DataFrame containing the parsed data from the TSV file. If the file is empty, returns a DataFrame with the appropriate headers but no data.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_xam_to_summary_table-Tuple{Any}","page":"Home","title":"Mycelia.parse_xam_to_summary_table","text":"parse_xam_to_summary_table(xam) -> DataFrames.DataFrame\n\n\nParse a SAM/BAM file into a summary DataFrame containing alignment metadata.\n\nArguments\n\nxam::AbstractString: Path to input SAM (.sam), BAM (.bam), or gzipped SAM (.sam.gz) file\n\nReturns\n\nDataFrame with columns:\n\ntemplate: Read name\nflag: SAM flag\nreference: Reference sequence name\nposition: Alignment position range (start:end)\nmappingquality: Mapping quality score\nalignment_score: Alignment score (AS tag)\nisprimary: Whether alignment is primary\nalignlength: Length of the alignment\nismapped: Whether read is mapped\nmismatches: Number of mismatches (NM tag)\n\nNote: Only mapped reads are included in the output DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.path_to_sequence-Tuple{Any, Any}","page":"Home","title":"Mycelia.path_to_sequence","text":"path_to_sequence(kmers, path) -> Any\n\n\nConvert a path through k-mers into a single DNA sequence.\n\nTakes a vector of k-mers and a path representing the order to traverse them, reconstructs the original sequence by joining the k-mers according to the path. The first k-mer is used in full, then only the last nucleotide from each subsequent k-mer is added.\n\nArguments\n\nkmers: Vector of DNA k-mers (as LongDNA{4})\npath: Vector of tuples representing the path through the k-mers\n\nReturns\n\nLongDNA{4}: The reconstructed DNA sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.pca_transform-Tuple{AbstractMatrix{<:Real}}","page":"Home","title":"Mycelia.pca_transform","text":"pca_transform(\n  M::AbstractMatrix{<:Real};\n  k::Int = 0,\n  var_prop::Float64 = 1.0\n)\n\nPerform standard PCA on M (features × samples), returning enough PCs to either:\n\nmatch a user‐supplied k > 0, or  \nexplain at least var_prop of the total variance (0 < var_prop ≤ 1).  \n\nBy default (k=0, var_prop=1.0), this will capture all variance, i.e. use min(n_samples-1, n_features) components.\n\nWhen to use\n\nUse for real-valued, continuous, and approximately Gaussian data. PCA is most suitable when features are linearly related and data is centered and scaled. Not ideal for count, binary, or highly skewed data.\n\nReturns\n\nA NamedTuple with fields\n\nmodel    : the fitted MultivariateStats.PCA object  \nscores   : k×n_samples matrix of PC scores  \nloadings : k×n_features matrix of PC loadings  \nchosen_k : the number of components actually used\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.pcoa_from_dist-Tuple{AbstractMatrix{<:Real}}","page":"Home","title":"Mycelia.pcoa_from_dist","text":"pcoa_from_dist(D::AbstractMatrix{<:Real}; maxoutdim::Int = 2)\n\nPerform Principal Coordinates Analysis directly from a precomputed distance matrix D (nsamples×nsamples).\n\nKeyword arguments\n\nmaxoutdim : target embedding dimension (default=2)\n\nReturns\n\nNamedTuple with fields\n\nmodel      : the fitted MultivariateStats.MDS model  \ncoordinates: maxoutdim×n_samples matrix of embedded coordinates  \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.phred_to_error_probability-Tuple{UInt8}","page":"Home","title":"Mycelia.phred_to_error_probability","text":"phred_to_error_probability(phred_score::UInt8) -> Float64\n\n\nConvert PHRED quality score to error probability.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.phred_to_probability-Tuple{UInt8}","page":"Home","title":"Mycelia.phred_to_probability","text":"phred_to_probability(phred_score::UInt8) -> Float64\n\n\nConvert PHRED quality score to probability of correctness. PHRED score Q relates to error probability P by: Q = -10 * log10(P) Therefore, correctness probability = 1 - P = 1 - 10^(-Q/10)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.pixels_to_points-Tuple{Any}","page":"Home","title":"Mycelia.pixels_to_points","text":"pixels_to_points(pixels) -> Any\n\n\nConvert pixel measurements to point measurements using the standard 4:3 ratio.\n\nPoints are the standard unit for typography (1 point = 1/72 inch), while pixels are  used for screen measurements. This conversion uses the conventional 4:3 ratio where  3 points equal 4 pixels.\n\nArguments\n\npixels: The number of pixels to convert\n\nReturns\n\nThe equivalent measurement in points\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_embeddings-Tuple{Any}","page":"Home","title":"Mycelia.plot_embeddings","text":"Plot embeddings with optional true and fitted cluster labels using Makie.jl,  with legend outside, and color by fit labels, shape by true labels.\n\nArguments\n\nembeddings::Matrix{<:Real}: 2D embedding matrix where each column is a data point\ntitle::String: Title of the plot\nxlabel::String: Label for the x-axis\nylabel::String: Label for the y-axis\ntrue_labels::Vector{<:Integer}: Vector of true cluster labels (optional)\nfit_labels::Vector{<:Integer}: Vector of fitted cluster labels (optional)\n\nReturns\n\nMakie.Figure: Figure object that can be displayed or saved\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_graph-Tuple{Any}","page":"Home","title":"Mycelia.plot_graph","text":"plot_graph(graph) -> Any\n\n\nCreates a visualization of a kmer graph where nodes represent kmers and their sizes reflect counts.\n\nArguments\n\ngraph: A MetaGraph where vertices have :kmer and :count properties\n\nReturns\n\nA Plots.jl plot object showing the graph visualization\n\nDetails\n\nNode sizes are scaled based on kmer counts\nPlot dimensions scale logarithmically with number of vertices\nEach node is labeled with its kmer sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_kmer_frequency_spectra-Tuple{Any}","page":"Home","title":"Mycelia.plot_kmer_frequency_spectra","text":"plot_kmer_frequency_spectra(\n    counts;\n    log_scale,\n    kwargs...\n) -> Plots.Plot\n\n\nPlots a histogram of kmer counts against # of kmers with those counts\n\nReturns the plot object for adding additional layers and saving\n\nCreates a scatter plot visualizing the k-mer frequency spectrum - the relationship between k-mer frequencies and how many k-mers occur at each frequency.\n\nArguments\n\ncounts::AbstractVector{<:Integer}: Vector of k-mer counts/frequencies\nlog_scale::Union{Function,Nothing} = log2: Function to apply logarithmic scaling to both axes. Set to nothing to use linear scaling.\nkwargs...: Additional keyword arguments passed to StatsPlots.plot()\n\nReturns\n\nPlots.Plot: A scatter plot object that can be further modified or saved\n\nDetails\n\nThe x-axis shows k-mer frequencies (how many times each k-mer appears), while the y-axis shows how many distinct k-mers appear at each frequency. Both axes are log-scaled by default using log2.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_kmer_rarefaction-Tuple{AbstractString}","page":"Home","title":"Mycelia.plot_kmer_rarefaction","text":"plot_kmer_rarefaction(\n    rarefaction_data_path::AbstractString;\n    output_dir,\n    output_basename,\n    display_plot,\n    fig_size,\n    title,\n    xlabel,\n    ylabel,\n    line_color,\n    line_style,\n    marker,\n    markersize,\n    axis_kwargs...\n) -> Union{Nothing, Makie.Figure}\n\n\nPlots a k-mer rarefaction curve from data stored in a TSV file. The TSV file should contain two columns:\n\nNumber of FASTA files processed.\nCumulative unique k-mers observed at that point.\n\nThe plot is displayed and saved in PNG, PDF, and SVG formats.\n\nArguments\n\nrarefaction_data_path::AbstractString: Path to the TSV file containing rarefaction data.\noutput_dir::AbstractString: Directory where the output plots will be saved. Defaults to the directory of rarefaction_data_path.\noutput_basename::AbstractString: Basename for the output plot files (without extension). Defaults to the basename of rarefaction_data_path without its original extension.\ndisplay_plot::Bool: Whether to display the plot interactively. Defaults to true.\n\nKeyword Arguments\n\nfig_size::Tuple{Int, Int}: Size of the output figure, e.g., (1000, 750).\ntitle::AbstractString: Title of the plot.\nxlabel::AbstractString: Label for the x-axis.\nylabel::AbstractString: Label for the y-axis.\nline_color: Color of the plotted line.\nline_style: Style of the plotted line (e.g. :dash, :dot).\nmarker: Marker style for points (e.g. :circle, :xcross).\nmarkersize::Number: Size of the markers.\nAny other keyword arguments will be passed to Makie.Axis.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_optimal_cluster_assessment_results-Tuple{Any}","page":"Home","title":"Mycelia.plot_optimal_cluster_assessment_results","text":"plot_optimal_cluster_assessment_results(\n    clustering_results\n) -> Any\n\n\nVisualizes cluster assessment metrics and saves the resulting plots.\n\nArguments\n\nclustering_results: A named tuple containing:\nks_assessed: Vector of k values tested\nwithin_cluster_sum_of_squares: Vector of WCSS scores\nsilhouette_scores: Vector of silhouette scores\noptimal_number_of_clusters: Integer indicating optimal k\n\nDetails\n\nCreates two plots:\n\nWithin-cluster sum of squares (WCSS) vs number of clusters\nSilhouette scores vs number of clusters\n\nBoth plots include a vertical line indicating the optimal number of clusters.\n\nOutputs\n\nSaves two SVG files in the project directory:\n\nwcss.svg: WCSS plot\nsilhouette.svg: Silhouette scores plot\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_per_base_quality-Tuple{String}","page":"Home","title":"Mycelia.plot_per_base_quality","text":"plot_per_base_quality(fastq_file::String; max_position::Union{Int,Nothing}=nothing, sample_size::Union{Int,Nothing}=nothing)\n\nCreate per-base quality boxplots for FASTQ data, similar to FastQC output.\n\nArguments\n\nfastq_file::String: Path to FASTQ file to analyze\nmax_position::Union{Int,Nothing}=nothing: Maximum read position to plot (default: auto-detect from data)\nsample_size::Union{Int,Nothing}=nothing: Number of reads to sample for analysis (default: use all reads)\n\nReturns\n\nPlots.Plot: Boxplot showing quality distribution at each base position\n\nExamples\n\n# Basic per-base quality plot\np = Mycelia.plot_per_base_quality(\"reads.fastq\")\n\n# Plot first 100 positions only, sampling 10000 reads\np = Mycelia.plot_per_base_quality(\"reads.fastq\", max_position=100, sample_size=10000)\n\nNotes\n\nQuality scores are displayed in Phred scale\nGreen zone: Q>=30 (high quality)\nYellow zone: Q20-29 (medium quality)  \nRed zone: Q<20 (low quality)\nFor large files, consider using sample_size to improve performance\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_taxa_abundances-Tuple{DataFrames.DataFrame, String}","page":"Home","title":"Mycelia.plot_taxa_abundances","text":"plot_taxa_abundances(\n    df::DataFrames.DataFrame, \n    taxa_level::String; \n    top_n::Int = 10,\n    sample_id_col::String = \"sample_id\",\n    filter_taxa::Union{Vector{Union{String, Missing}}, Nothing} = nothing,\n    figure_width::Int = 1500,\n    figure_height::Int = 1000,\n    bar_width::Float64 = 0.7,\n    x_rotation::Int = 45,\n    sort_samples::Bool = true,\n    color_seed::Union{Int, Nothing} = nothing,\n    legend_fontsize::Float64 = 12.0,\n    legend_itemsize::Float64 = 12.0,\n    legend_padding::Float64 = 5.0,\n    legend_rowgap::Float64 = 1.0,\n    legend_labelwidth::Union{Nothing, Float64} = nothing,\n    legend_titlesize::Float64 = 15.0,\n    legend_nbanks::Int = 1\n)\n\nCreate a stacked bar chart showing taxa relative abundances for each sample.\n\nArguments\n\ndf: DataFrame with sample_id and taxonomic assignments at different levels\ntaxa_level: Taxonomic level to analyze (e.g., \"genus\", \"species\")\ntop_n: Number of top taxa to display individually, remainder grouped as \"Other\"\nsample_id_col: Column name containing sample identifiers\nfilter_taxa: Taxa to exclude from visualization (default: nothing - no filtering)\nfigure_width: Width of the figure in pixels\nfigure_height: Height of the figure in pixels\nbar_width: Width of each bar (between 0 and 1)\nx_rotation: Rotation angle for x-axis labels in degrees\nsort_samples: Whether to sort samples alphabetically\ncolor_seed: Seed for reproducible color generation\nlegend_fontsize: Font size for legend entries\nlegend_itemsize: Size of the colored marker/icon in the legend\nlegend_padding: Padding around legend elements\nlegend_rowgap: Space between legend rows\nlegend_labelwidth: Maximum width for legend labels (truncation)\nlegend_titlesize: Font size for legend title\nlegend_nbanks: Number of legend columns\n\nReturns\n\nfig: CairoMakie figure object\nax: CairoMakie axis object\ntaxa_colors: Dictionary mapping taxa to their assigned colors\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.points_to_pixels-Tuple{Any}","page":"Home","title":"Mycelia.points_to_pixels","text":"points_to_pixels(points) -> Any\n\n\nConvert typographic points to pixels using a 4:3 ratio (1 point = 4/3 pixels).\n\nArguments\n\npoints: Size in typographic points (pt)\n\nReturns\n\nSize in pixels (px)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.poisson_pca_epca-Tuple{AbstractMatrix{<:Integer}}","page":"Home","title":"Mycelia.poisson_pca_epca","text":"poissonpcaepca(M::AbstractMatrix{<:Integer}; k::Int=0)\n\nPerform Poisson EPCA on a count matrix M (features × samples).\n\nWhen to use\n\nUse for non-negative integer count data, such as raw event or read counts.\n\nReturns\n\nA NamedTuple with\n\nmodel    : the fitted ExpFamilyPCA.PoissonEPCA object  \nscores   : k×n_samples matrix of low‐dimensional sample scores  \nloadings : k×n_features matrix of feature loadings  \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.polish_assembly-Tuple{Mycelia.AssemblyResult, Any}","page":"Home","title":"Mycelia.polish_assembly","text":"polish_assembly(assembly::AssemblyResult, reads; iterations=3) -> AssemblyResult\n\nPolish assembled contigs using quality-aware error correction.\n\nArguments\n\nassembly: Initial assembly result to polish\nreads: Original reads for polishing (FASTQ with quality scores preferred)\niterations: Number of polishing iterations (default: 3)\n\nReturns\n\nAssemblyResult: Polished assembly with improved accuracy\n\nDetails\n\nUses Phase 2 enhanced Viterbi algorithms with quality score integration for:\n\nError correction based on k-mer graph traversals\nConsensus calling from multiple observations\nIterative improvement until convergence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.polish_fastq-Tuple{}","page":"Home","title":"Mycelia.polish_fastq","text":"polish_fastq(; fastq, k)\n\n\nPolish FASTQ reads using a k-mer graph-based approach to correct potential sequencing errors.\n\nArguments\n\nfastq::String: Path to input FASTQ file\nk::Int=1: Initial k-mer size parameter. Final assembly k-mer size may differ.\n\nProcess\n\nBuilds a directed k-mer graph from input reads\nProcesses each read through the graph to find optimal paths\nWrites corrected reads to a new FASTQ file\nAutomatically compresses output with gzip\n\nReturns\n\nNamed tuple with:\n\nfastq::String: Path to output gzipped FASTQ file\nk::Int: Final assembly k-mer size used\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.polish_sequence_next","page":"Home","title":"Mycelia.polish_sequence_next","text":"polish_sequence_next(graph::MetaGraph, sequence::String, config::ViterbiConfig) -> ViterbiPath\n\nPolish a single sequence using Viterbi algorithm on k-mer graph.\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.position_wise_joint_probability-Tuple{Vector{<:Mycelia.Qualmer}}","page":"Home","title":"Mycelia.position_wise_joint_probability","text":"position_wise_joint_probability(\n    qualmers::Vector{<:Mycelia.Qualmer};\n    use_log_space\n) -> Float64\n\n\nCalculate position-wise joint probability for multiple qualmer observations. This is more sophisticated than joint_qualmer_probability as it considers the quality at each position across all observations.\n\nArguments\n\nqualmers: Vector of Qualmer observations of the same k-mer sequence\nuse_log_space: Use log-space arithmetic for numerical stability (default: true)\n\nReturns\n\nFloat64: Position-wise joint probability\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.precision_recall_f1-Tuple{Any, Any}","page":"Home","title":"Mycelia.precision_recall_f1","text":"precision_recall_f1(true_labels, pred_labels)\n\nReturns dictionaries mapping each label to its precision, recall, and F1 score. Also returns macro-averaged (unweighted mean) precision, recall, F1, and a grouped bar plot.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.prefetch-Tuple{}","page":"Home","title":"Mycelia.prefetch","text":"prefetch(; SRR, outdir)\n\n\nDownloads Sequence Read Archive (SRA) data using the prefetch tool from sra-tools.\n\nArguments\n\nSRR: SRA accession number (e.g., \"SRR12345678\")\noutdir: Directory where the downloaded data will be saved. Defaults to current directory.\n\nNotes\n\nRequires sra-tools which will be installed in a Conda environment\nDownloads are saved in .sra format\nInternet connection required\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.prefetch_sra_runs-Tuple{Vector{String}}","page":"Home","title":"Mycelia.prefetch_sra_runs","text":"Prefetches multiple SRA runs in parallel.\n\nDownloads SRA run files (.sra) to local storage without converting to FASTQ. Useful for batch downloading before processing with fasterq-dump.\n\nArguments\n\nsrr_identifiers: Vector of SRA run identifiers\noutdir: Output directory for prefetched files (default: current directory)\nmax_parallel: Maximum number of parallel downloads (default: 4)\n\nReturns\n\nVector of named tuples with prefetch results for each SRA run\n\nExample\n\nruns = [\"SRR1234567\", \"SRR1234568\", \"SRR1234569\"]\nresults = Mycelia.prefetch_sra_runs(runs, outdir=\"./sra_data\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.probabilistic_walk_next-Tuple{MetaGraphsNext.MetaGraph, String, Int64}","page":"Home","title":"Mycelia.probabilistic_walk_next","text":"probabilistic_walk_next(\n    graph::MetaGraphsNext.MetaGraph,\n    start_vertex::String,\n    max_steps::Int64;\n    seed\n) -> Mycelia.GraphPath\n\n\nPerform a probabilistic walk through the strand-aware k-mer graph.\n\nThis algorithm follows edges based on their probability weights, respecting strand orientation constraints. The walk continues until max_steps is reached or no valid transitions are available.\n\nArguments\n\ngraph: MetaGraphsNext k-mer graph with strand-aware edges\nstart_vertex: Starting k-mer (vertex label)\nmax_steps: Maximum number of steps to take\nseed: Random seed for reproducibility (optional)\n\nReturns\n\nGraphPath: Complete path with probability information\n\nAlgorithm\n\nStart at given vertex with forward strand orientation\nAt each step, calculate transition probabilities based on edge weights\nSample next vertex according to probabilities\nUpdate cumulative probability and continue\nRespect strand orientation constraints from edge metadata\n\nExample\n\ngraph = build_kmer_graph_next(DNAKmer{15}, observations)\npath = probabilistic_walk_next(graph, \"ATCGATCGATCGATC\", 100)\nprintln(\"Assembled sequence: $(path.sequence)\")\nprintln(\"Path probability: $(path.total_probability)\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.process_fastq_record-Tuple{}","page":"Home","title":"Mycelia.process_fastq_record","text":"process_fastq_record(\n;\n    record,\n    kmer_graph,\n    yen_k_shortest_paths_and_weights,\n    yen_k\n)\n\n\nProcess and error-correct a FASTQ sequence record using a kmer graph and path resampling.\n\nArguments\n\nrecord: FASTQ record containing the sequence to process\nkmer_graph: MetaGraph containing the kmer network and associated properties\nyen_k_shortest_paths_and_weights: Cache of pre-computed k-shortest paths between nodes\nyen_k: Number of alternative paths to consider during resampling (default: 3)\n\nDescription\n\nPerforms error correction by:\n\nTrimming low-quality sequence ends\nIdentifying stretches requiring resampling between solid branching kmers\nSelecting alternative paths through the kmer graph based on:\nPath quality scores\nTransition likelihoods\nPath length similarity to original sequence\n\nReturns\n\nModified FASTQ record with error-corrected sequence and updated quality scores\nOriginal record if no error correction was needed\n\nRequired Graph Properties\n\nThe kmer_graph must contain the following properties:\n\n:ordered_kmers\n:likelyvalidkmer_indices  \n:kmer_indices\n:branching_nodes\n:assembly_k\n:transition_likelihoods\n:kmermeanquality\n:kmertotalquality\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.q_value_to_error_rate-Tuple{Any}","page":"Home","title":"Mycelia.q_value_to_error_rate","text":"q_value_to_error_rate(q_value) -> Any\n\n\nConvert a Phred quality score (Q-value) to a probability of error.\n\nArguments\n\nq_value: Phred quality score, typically ranging from 0 to 40\n\nReturns\n\nError probability in range [0,1], where 0 indicates highest confidence\n\nA Q-value of 10 corresponds to an error rate of 0.1 (10%), while a Q-value of  30 corresponds to an error rate of 0.001 (0.1%).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qc_filter_long_reads_fastplong-Tuple{}","page":"Home","title":"Mycelia.qc_filter_long_reads_fastplong","text":"qc_filter_long_reads_fastplong(\n;\n    in_fastq,\n    report_title,\n    out_fastq,\n    html_report,\n    json_report,\n    min_length,\n    max_length\n)\n\n\nPerform QC filtering on long-read FASTQ files using fastplong.\n\nArguments\n\nin_fastq::String: Path to the input FASTQ file.\nout_fastq::String: Path to the output FASTQ file.\nquality_threshold::Int: Minimum average quality to retain a read (default 10).\nmin_length::Int: Minimum read length (default 1000).\nmax_length::Int=0: Maximum read length (default 0, no maximum).\n\nReturns\n\nString: Path to the filtered FASTQ file.\n\nDetails\n\nThis function uses fastplong to filter long reads based on quality and length criteria. It is optimized for Oxford Nanopore, PacBio, or similar long-read datasets.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qc_filter_long_reads_filtlong-Tuple{}","page":"Home","title":"Mycelia.qc_filter_long_reads_filtlong","text":"qc_filter_long_reads_filtlong(\n;\n    in_fastq,\n    out_fastq,\n    min_mean_q,\n    keep_percent\n)\n\n\nFilter and process long reads from a FASTQ file using Filtlong.\n\nThis function filters long sequencing reads based on quality and length criteria,  then compresses the output using pigz.\n\nArguments\n\nin_fastq::String: Path to the input FASTQ file.\nout_fastq::String: Path to the output filtered and compressed FASTQ file.   Defaults to the input filename with \".filtlong.fq.gz\" appended.\nmin_mean_q::Int: Minimum mean quality score for reads to be kept. Default is 20.\nkeep_percent::Int: Percentage of reads to keep after filtering. Default is 95.\n\nReturns\n\nout_fastq\n\nDetails\n\nThis function uses Filtlong to filter long reads and pigz for compression. It requires the Bioconda environment for Filtlong to be set up, which is handled internally.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qc_filter_short_reads_fastp-Tuple{}","page":"Home","title":"Mycelia.qc_filter_short_reads_fastp","text":"qc_filter_short_reads_fastp(\n;\n    forward_reads,\n    reverse_reads,\n    out_forward,\n    out_reverse,\n    report_title,\n    html,\n    json\n)\n\n\nPerform quality control (QC) filtering and trimming on short-read FASTQ files using fastp.\n\nArguments\n\nin_fastq::String: Path to the input FASTQ file.\nout_fastq::String: Path to the output FASTQ file.\nadapter_seq::String: Adapter sequence to trim.\nquality_threshold::Int: Minimum phred score for trimming (default 20).\nmin_length::Int: Minimum read length to retain (default 50).\n\nReturns\n\nString: Path to the filtered and trimmed FASTQ file.\n\nDetails\n\nThis function uses fastp to remove adapter contamination, trim low‐quality bases from the 3′ end, and discard reads shorter than min_length. It’s a simple wrapper that executes the external fastp command.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.quality_biosequence_graph_to_fastq","page":"Home","title":"Mycelia.quality_biosequence_graph_to_fastq","text":"quality_biosequence_graph_to_fastq(\n    graph::MetaGraphsNext.MetaGraph\n) -> Vector{FASTX.FASTQ.Record}\nquality_biosequence_graph_to_fastq(\n    graph::MetaGraphsNext.MetaGraph,\n    output_file::Union{Nothing, AbstractString}\n) -> Vector{FASTX.FASTQ.Record}\n\n\nConvert quality-aware BioSequence vertices back to FASTQ records.\n\nThis function demonstrates the key feature of FASTQ graphs - they maintain per-base  quality information and can be converted back to FASTQ format.\n\nArguments\n\ngraph: Quality-aware BioSequence graph\noutput_file: Path to output FASTQ file (optional)\n\nReturns\n\nVector of FASTX.FASTQ.Record objects\n\nExample\n\n# Convert graph back to FASTQ\nfastq_records = quality_biosequence_graph_to_fastq(graph)\n\n# Or write directly to file\nquality_biosequence_graph_to_fastq(graph, \"output.fastq\")\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.quality_string_to_phred-Tuple{AbstractString}","page":"Home","title":"Mycelia.quality_string_to_phred","text":"quality_string_to_phred(\n    quality_string::AbstractString\n) -> Vector{UInt8}\n\n\nConvert FASTQ quality string to numerical PHRED scores.\n\nArguments\n\nquality_string::AbstractString: Quality string from FASTQ record (e.g., \"IIII\")\n\nReturns\n\nVector{UInt8}: PHRED quality scores\n\nExamples\n\nscores = quality_string_to_phred(\"IIII\")  # Returns [40, 40, 40, 40]\nscores = quality_string_to_phred(\"!#%+\")  # Returns [0, 2, 4, 10]\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmer_correctness_probability-Tuple{Mycelia.Qualmer}","page":"Home","title":"Mycelia.qualmer_correctness_probability","text":"qualmer_correctness_probability(\n    qmer::Mycelia.Qualmer\n) -> Float64\n\n\nCalculate joint probability that a single qualmer is correct. For a k-mer with quality scores [q1, q2, ..., qk], the joint probability that all positions are correct is: ∏(1 - 10^(-qi/10))\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmer_graph_to_quality_biosequence_graph-Tuple{MetaGraphsNext.MetaGraph}","page":"Home","title":"Mycelia.qualmer_graph_to_quality_biosequence_graph","text":"qualmer_graph_to_quality_biosequence_graph(\n    qualmer_graph::MetaGraphsNext.MetaGraph;\n    min_path_length\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, Mycelia.var\"#280#282\", Float64} where {_A, _B, _C}\n\n\nConvert a Qualmer graph to a quality-aware BioSequence graph by collapsing linear paths.\n\nThis is the primary method for creating quality-aware BioSequence graphs from Qualmer graphs, following the 6-graph hierarchy where FASTQ graphs are simplifications of Qualmer graphs with quality retention.\n\nArguments\n\nqualmer_graph: MetaGraphsNext Qualmer graph to convert\nmin_path_length: Minimum path length to keep (default: 2)\n\nReturns\n\nMetaGraphsNext.MetaGraph with quality-aware BioSequence vertices\n\nExample\n\n# Start with qualmer graph\nqualmer_graph = build_qualmer_graph(fastq_records)\n\n# Convert to quality-aware BioSequence graph\nquality_graph = qualmer_graph_to_quality_biosequence_graph(qualmer_graph)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmer_path_to_biosequence-Tuple{Vector{<:Mycelia.Qualmer}}","page":"Home","title":"Mycelia.qualmer_path_to_biosequence","text":"Convert qualmer path back to BioSequence and quality vector. Returns a named tuple with sequence and quality_scores.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmers_canonical-Tuple{FASTX.FASTQ.Record, Int64}","page":"Home","title":"Mycelia.qualmers_canonical","text":"qualmers_canonical(\n    record::FASTX.FASTQ.Record,\n    k::Int64\n) -> Base.Generator\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmers_canonical-Union{Tuple{K}, Tuple{BioSequences.LongAA, AbstractVector{<:Integer}, Val{K}}} where K","page":"Home","title":"Mycelia.qualmers_canonical","text":"qualmers_canonical(\n    sequence::BioSequences.LongAA,\n    quality::AbstractVector{<:Integer},\n    _::Val{K}\n) -> Base.Generator{I, F} where {I<:(Base.Iterators.Enumerate{I} where I<:(Kmers.FwAAMers{_A, BioSequences.LongAA} where _A)), F<:(Mycelia.var\"#228#229\"{_A, <:AbstractVector{var\"#s36\"}} where {_A, var\"#s36\"<:Integer})}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmers_canonical-Union{Tuple{K}, Tuple{N}, Tuple{BioSequences.LongDNA{N}, AbstractVector{<:Integer}, Val{K}}} where {N, K}","page":"Home","title":"Mycelia.qualmers_canonical","text":"qualmers_canonical(\n    sequence::BioSequences.LongSequence{BioSequences.DNAAlphabet{N}},\n    quality::AbstractVector{<:Integer},\n    _::Val{K}\n) -> Base.Generator{I, F} where {I<:(Base.Iterators.Enumerate{I} where I<:(Kmers.CanonicalKmers{A, _A, S} where {A<:(BioSequences.DNAAlphabet), _A, S<:(BioSequences.LongDNA)})), F<:(Mycelia.var\"#234#235\"{_A, <:AbstractVector{var\"#s34\"}} where {_A, var\"#s34\"<:Integer})}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmers_fw-Tuple{FASTX.FASTQ.Record, Int64}","page":"Home","title":"Mycelia.qualmers_fw","text":"qualmers_fw(\n    record::FASTX.FASTQ.Record,\n    k::Int64\n) -> Base.Generator\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmers_fw-Union{Tuple{K}, Tuple{A}, Tuple{BioSequences.LongSequence{A}, AbstractVector{<:Integer}, Val{K}}} where {A, K}","page":"Home","title":"Mycelia.qualmers_fw","text":"qualmers_fw(\n    sequence::BioSequences.LongSequence{A},\n    quality::AbstractVector{<:Integer},\n    _::Val{K}\n) -> Base.Generator{I, F} where {I<:(Base.Iterators.Enumerate{I} where I<:(Kmers.FwKmers{A, _A, S} where {A<:BioSequences.Alphabet, _A, S<:(BioSequences.LongSequence{A} where A)})), F<:(Mycelia.var\"#228#229\"{_A, <:AbstractVector{var\"#s34\"}} where {_A, var\"#s34\"<:Integer})}\n\n\nCreate an iterator that yields DNA qualmers from the given sequence and quality scores.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmers_unambiguous-Tuple{FASTX.FASTQ.Record, Int64}","page":"Home","title":"Mycelia.qualmers_unambiguous","text":"qualmers_unambiguous(\n    record::FASTX.FASTQ.Record,\n    k::Int64\n) -> Base.Generator\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmers_unambiguous-Union{Tuple{K}, Tuple{BioSequences.LongAA, AbstractVector{<:Integer}, Val{K}}} where K","page":"Home","title":"Mycelia.qualmers_unambiguous","text":"qualmers_unambiguous(\n    sequence::BioSequences.LongAA,\n    quality::AbstractVector{<:Integer},\n    _::Val{K}\n) -> Base.Generator{I, F} where {I<:(Base.Iterators.Enumerate{I} where I<:(Kmers.FwAAMers{_A, BioSequences.LongAA} where _A)), F<:(Mycelia.var\"#228#229\"{_A, <:AbstractVector{var\"#s36\"}} where {_A, var\"#s36\"<:Integer})}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmers_unambiguous-Union{Tuple{K}, Tuple{N}, Tuple{BioSequences.LongDNA{N}, AbstractVector{<:Integer}, Val{K}}} where {N, K}","page":"Home","title":"Mycelia.qualmers_unambiguous","text":"qualmers_unambiguous(\n    sequence::BioSequences.LongSequence{BioSequences.DNAAlphabet{N}},\n    quality::AbstractVector{<:Integer},\n    _::Val{K}\n) -> Base.Generator{I, F} where {I<:(Kmers.UnambiguousDNAMers{_A, S} where {_A, S<:(BioSequences.LongDNA)}), F<:(Mycelia.var\"#230#231\"{_A, <:AbstractVector{var\"#s34\"}} where {_A, var\"#s34\"<:Integer})}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmers_unambiguous-Union{Tuple{K}, Tuple{N}, Tuple{BioSequences.LongRNA{N}, AbstractVector{<:Integer}, Val{K}}} where {N, K}","page":"Home","title":"Mycelia.qualmers_unambiguous","text":"qualmers_unambiguous(\n    sequence::BioSequences.LongSequence{BioSequences.RNAAlphabet{N}},\n    quality::AbstractVector{<:Integer},\n    _::Val{K}\n) -> Base.Generator{I, F} where {I<:(Kmers.UnambiguousRNAMers{_A, S} where {_A, S<:(BioSequences.LongRNA)}), F<:(Mycelia.var\"#232#233\"{_A, <:AbstractVector{var\"#s34\"}} where {_A, var\"#s34\"<:Integer})}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qualmers_unambiguous_canonical-Tuple{FASTX.FASTQ.Record, Int64}","page":"Home","title":"Mycelia.qualmers_unambiguous_canonical","text":"qualmers_unambiguous_canonical(\n    record::FASTX.FASTQ.Record,\n    k::Int64\n) -> Base.Generator{I, Mycelia.var\"#236#237\"} where I\n\n\nGenerate unambiguous canonical qualmers from the given FASTQ record.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rand_ascii_greek_string-Tuple{Int64}","page":"Home","title":"Mycelia.rand_ascii_greek_string","text":"rand_ascii_greek_string(len::Int) -> String\n\nGenerate a random string of printable ASCII and Greek characters of length len.\n\nThe string contains random printable ASCII characters and both uppercase and lowercase Greek letters.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rand_bmp_printable_string-Tuple{Int64}","page":"Home","title":"Mycelia.rand_bmp_printable_string","text":"rand_bmp_printable_string(len::Int) -> String\n\nGenerate a random string of printable Basic Multilingual Plane (BMP) characters of length len.\n\nThe string contains random printable BMP characters, excluding surrogate code points.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rand_latin1_string-Tuple{Int64}","page":"Home","title":"Mycelia.rand_latin1_string","text":"rand_latin1_string(len::Int) -> String\n\nGenerate a random string of printable Latin-1 characters of length len.\n\nThe string contains random printable characters from the Latin-1 character set.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rand_of_each_group-Tuple{DataFrames.GroupedDataFrame{DataFrames.DataFrame}}","page":"Home","title":"Mycelia.rand_of_each_group","text":"rand_of_each_group(\n    gdf::DataFrames.GroupedDataFrame{DataFrames.DataFrame}\n) -> Any\n\n\nSelect one random row from each group in a grouped DataFrame.\n\nArguments\n\ngdf::GroupedDataFrame: A grouped DataFrame created using groupby\n\nReturns\n\nDataFrame: A new DataFrame containing exactly one randomly sampled row from each group\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rand_printable_unicode_string-Tuple{Int64}","page":"Home","title":"Mycelia.rand_printable_unicode_string","text":"rand_printable_unicode_string(len::Int) -> String\n\nGenerate a random string of printable Unicode characters of length len.\n\nThe string contains random printable Unicode characters, excluding surrogate code points.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.random_fasta_record-Tuple{}","page":"Home","title":"Mycelia.random_fasta_record","text":"random_fasta_record(\n;\n    moltype,\n    seed,\n    L\n) -> FASTX.FASTA.Record\n\n\nGenerates a random FASTA record with a specified molecular type and sequence length.\n\nArguments\n\nmoltype::Symbol=:DNA: The type of molecule to generate (:DNA, :RNA, or :AA for amino acids).\nseed: The random seed used for sequence generation (default: a random integer).\nL: The length of the sequence (default: a random integer up to typemax(UInt16)).\n\nReturns\n\nA FASTX.FASTA.Record containing:\nA randomly generated UUID identifier.\nA randomly generated sequence of the specified type.\n\nErrors\n\nThrows an error if moltype is not one of :DNA, :RNA, or :AA.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.random_symmetric_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.random_symmetric_distance_matrix","text":"random_symmetric_distance_matrix(n) -> Any\n\n\nGenerate a random symmetric distance matrix of size n×n with zeros on the diagonal.\n\nArguments\n\nn: Positive integer specifying the matrix dimensions\n\nReturns\n\nA symmetric n×n matrix with random values in [0,1), zeros on the diagonal\n\nDetails\n\nThe matrix is symmetric, meaning M[i,j] = M[j,i]\nDiagonal elements M[i,i] are set to 0.0\nOff-diagonal elements are uniformly distributed random values\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rclone_copy-Tuple{Any, Any}","page":"Home","title":"Mycelia.rclone_copy","text":"rclone_copy(source, dest; config, max_attempts, sleep_timer)\n\n\nCopy files between local and remote storage using rclone with automated retry logic.\n\nArguments\n\nsource::String: Source path or remote (e.g. \"local/path\" or \"gdrive:folder\")\ndest::String: Destination path or remote (e.g. \"gdrive:folder\" or \"local/path\")\n\nKeywords\n\nconfig::String=\"\": Optional path to rclone config file\nmax_attempts::Int=3: Maximum number of retry attempts\nsleep_timer::Int=60: Initial sleep duration between retries in seconds (doubles after each attempt)\n\nDetails\n\nUses optimized rclone settings for large files:\n\n2GB chunk size\n1TB upload cutoff\nRate limited to 1 transaction per second\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rclone_copy2-Tuple{Any, Any}","page":"Home","title":"Mycelia.rclone_copy2","text":"rclone_copy2(\n    source,\n    dest;\n    config,\n    max_attempts,\n    sleep_timer,\n    includes,\n    excludes,\n    recursive\n)\n\n\nCopy files between local and remote storage using rclone with automated retry logic.\n\nArguments\n\nsource::String: Source path or remote (e.g. \"local/path\" or \"gdrive:folder\")\ndest::String: Destination path or remote (e.g. \"gdrive:folder\" or \"local/path\")\n\nKeywords\n\nconfig::String=\"\": Optional path to rclone config file\nmax_attempts::Int=3: Maximum number of retry attempts\nsleep_timer::Int=60: Initial sleep duration between retries in seconds (doubles after each attempt)\nincludes::Vector{String}=[]: One or more include patterns (each will be passed using --include)\nexcludes::Vector{String}=[]: One or more exclude patterns (each will be passed using --exclude)\nrecursive::Bool=false: If true, adds the flag for recursive traversal\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rclone_list_directories-Tuple{Any}","page":"Home","title":"Mycelia.rclone_list_directories","text":"rclone_list_directories(path) -> Any\n\n\nList all directories at the specified rclone path.\n\nArguments\n\npath::String: Remote path to list directories from (e.g. \"remote:/path/to/dir\")\n\nReturns\n\nVector{String}: Full paths to all directories found at the specified location\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_fastani-Tuple{String}","page":"Home","title":"Mycelia.read_fastani","text":"read_fastani(path::String) -> DataFrames.DataFrame\n\n\nImports results of fastani\n\nReads and processes FastANI output results from a tab-delimited file.\n\nArguments\n\npath::String: Path to the FastANI output file\n\nReturns\n\nDataFrame with columns:\n\nquery: Original query filepath\nquery_identifier: Extracted filename without extension\nreference: Original reference filepath\nreference_identifier: Extracted filename without extension\n%_identity: ANI percentage identity\nfragments_mapped: Number of fragments mapped\ntotal_query_fragments: Total number of query fragments\n\nNotes\n\nExpects tab-delimited input file from FastANI\nAutomatically strips .fasta, .fna, or .fa extensions from filenames\nColumn order is preserved as listed above\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_gfa_next","page":"Home","title":"Mycelia.read_gfa_next","text":"read_gfa_next(\n    gfa_file::AbstractString,\n    kmer_type::Type\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, Mycelia.var\"#151#152\", Float64} where {_A, _B, _C}\nread_gfa_next(\n    gfa_file::AbstractString,\n    kmer_type::Type,\n    graph_mode::Mycelia.GraphMode\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, Mycelia.var\"#151#152\", Float64} where {_A, _B, _C}\n\n\nRead a GFA file and convert it to a MetaGraphsNext k-mer graph with fixed-length vertices.\n\nThis function parses GFA format files and creates a strand-aware k-mer graph compatible with the next-generation implementation using fixed-length k-mer vertices.\n\nArguments\n\ngfa_file: Path to input GFA file\nkmer_type: Type of k-mer to use (e.g., Kmers.DNAKmer{31})\ngraph_mode: GraphMode (SingleStrand or DoubleStrand, default: DoubleStrand)\n\nReturns\n\nMetaGraphsNext.MetaGraph with k-mer vertices and strand-aware edges\n\nGFA Format Support\n\nSupports GFA v1.0 with:\n\nHeader (H) lines (ignored)\nSegment (S) lines: parsed as fixed-length k-mer vertices\nLink (L) lines: parsed as strand-aware edges\nPath (P) lines: stored as metadata (future use)\n\nExample\n\n# Fixed-length k-mer graph\ngraph = read_gfa_next(\"assembly.gfa\", Kmers.DNAKmer{31})\n# Or with specific mode\ngraph = read_gfa_next(\"assembly.gfa\", Kmers.DNAKmer{31}, SingleStrand)\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.read_gfa_next-2","page":"Home","title":"Mycelia.read_gfa_next","text":"read_gfa_next(\n    gfa_file::AbstractString;\n    ...\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Label, VertexData, EdgeData, Nothing, WeightFunction, Float64} where {Label, VertexData, EdgeData, WeightFunction}\nread_gfa_next(\n    gfa_file::AbstractString,\n    graph_mode::Mycelia.GraphMode;\n    force_biosequence_graph\n) -> MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Label, VertexData, EdgeData, Nothing, WeightFunction, Float64} where {Label, VertexData, EdgeData, WeightFunction}\n\n\nRead a GFA file and auto-detect whether to create a k-mer graph or BioSequence graph.\n\nThis function parses GFA format files and intelligently chooses between:\n\nFixed-length k-mer graph (if all segments have the same length)\nVariable-length BioSequence graph (if segments have different lengths)\n\nArguments\n\ngfa_file: Path to input GFA file\ngraph_mode: GraphMode (SingleStrand or DoubleStrand, default: DoubleStrand)\nforce_biosequence_graph: Force creation of variable-length BioSequence graph (default: false)\n\nReturns\n\nMetaGraphsNext.MetaGraph with either k-mer vertices or BioSequence vertices\n\nAuto-Detection Logic\n\nFixed-length detection: If all segments are the same length k, creates DNAKmer{k}/RNAKmer{k}/AAKmer{k} graph\nVariable-length fallback: If segments have different lengths, creates BioSequence graph\nOverride: Use force_biosequence_graph=true to force variable-length graph\n\nGFA Format Support\n\nSupports GFA v1.0 with:\n\nHeader (H) lines (ignored)\nSegment (S) lines: parsed as vertices (k-mer or BioSequence)\nLink (L) lines: parsed as strand-aware edges\nPath (P) lines: stored as metadata (future use)\n\nExamples\n\n# Auto-detect graph type\ngraph = read_gfa_next(\"assembly.gfa\")\n\n# Force variable-length BioSequence graph\ngraph = read_gfa_next(\"assembly.gfa\", force_biosequence_graph=true)\n\n# SingleStrand mode with auto-detection\ngraph = read_gfa_next(\"assembly.gfa\", SingleStrand)\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.read_gff-Tuple{AbstractString}","page":"Home","title":"Mycelia.read_gff","text":"read_gff(gff::AbstractString) -> DataFrames.DataFrame\n\n\nReads a GFF (General Feature Format) file and parses it into a DataFrame.\n\nArguments\n\ngff::AbstractString: Path to the GFF file\n\nReturns\n\nDataFrame: A DataFrame containing the parsed GFF data with standard columns: seqid, source, type, start, end, score, strand, phase, and attributes\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_gff-Tuple{Any}","page":"Home","title":"Mycelia.read_gff","text":"read_gff(gff_io) -> DataFrames.DataFrame\n\n\nRead a GFF (General Feature Format) file into a DataFrame.\n\nArguments\n\ngff_io: An IO stream containing GFF formatted data\n\nReturns\n\nDataFrame: A DataFrame with standard GFF columns:\nseqid: sequence identifier\nsource: feature source\ntype: feature type\nstart: start position (1-based)\nend: end position\nscore: numeric score\nstrand: strand (+, -, or .)\nphase: phase (0, 1, 2 or .)\nattributes: semicolon-separated key-value pairs\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_kraken_report-Tuple{Any}","page":"Home","title":"Mycelia.read_kraken_report","text":"read_kraken_report(kraken_report) -> DataFrames.DataFrame\n\n\nParse a Kraken taxonomic classification report into a structured DataFrame.\n\nArguments\n\nkraken_report::AbstractString: Path to a tab-delimited Kraken report file\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\npercentage_of_fragments_at_or_below_taxon: Percentage of fragments covered\nnumber_of_fragments_at_or_below_taxon: Count of fragments at/below taxon\nnumber_of_fragments_assigned_directly_to_taxon: Direct fragment assignments\nrank: Taxonomic rank\nncbi_taxonid: NCBI taxonomy identifier\nscientific_name: Scientific name (whitespace-trimmed)\n\nNotes\n\nScientific names are automatically stripped of leading/trailing whitespace\nInput file must be tab-delimited\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_mmseqs_easy_search-Tuple{String}","page":"Home","title":"Mycelia.read_mmseqs_easy_search","text":"read_mmseqs_easy_search(\n    mmseqs_file::String\n) -> DataFrames.DataFrame\n\n\nRead results from MMSeqs2 easy-search output file (plain or gzipped) into a DataFrame with optimized memory usage. Automatically detects if the file is gzipped based on the '.gz' extension.\n\nArguments\n\nmmseqs_file::String: Path to the tab-delimited output file from MMSeqs2 easy-search.                        Can be a plain text file or a gzipped file (ending in .gz).\n\nReturns\n\nDataFrame: Contains search results with columns:\nquery::String: Query sequence identifier (pooled)\ntarget::String: Target sequence identifier (pooled)\nseqIdentity::Float64: Sequence identity (0.0-1.0)\nalnLen::Int: Alignment length\nmismatch::Int: Number of mismatches\ngapOpen::Int: Number of gap openings\nqStart::Int: Query start position\nqEnd::Int: Query end position\ntStart::Int: Target start position\ntEnd::Int: Target end position\nevalue::Float64: Expected value\nbits::Float64: Bit score\n\nRemarks\n\nEnsure the CodecZlib.jl package is installed for gzipped file support.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_tsvgz-Tuple{String}","page":"Home","title":"Mycelia.read_tsvgz","text":"read_tsvgz(filename::String; buffer_in_memory::Bool=false, threaded::Bool=true, bufsize::Int=10*1024*1024) -> DataFrames.DataFrame\n\nRead a DataFrame from a gzipped TSV file.\n\nArguments\n\nfilename: Path to the gzipped TSV file (must have .tsv.gz extension)\nbuffer_in_memory: If false, uses temporary files for large data (default: false)\nbufsize: Buffer size in bytes for decompression stream (default: 10MB)\n\nReturns\n\nThe loaded DataFrame\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.regions_overlap-Tuple{Mycelia.RepeatRegion, Mycelia.RepeatRegion}","page":"Home","title":"Mycelia.regions_overlap","text":"Check if two repeat regions overlap.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.remove_duplicate_bubbles-Tuple{Vector{Mycelia.BubbleStructure}}","page":"Home","title":"Mycelia.remove_duplicate_bubbles","text":"Remove duplicate bubbles.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.remove_isolated_vertices!-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}}","page":"Home","title":"Mycelia.remove_isolated_vertices!","text":"Remove all isolated vertices from the graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.remove_path_from_graph!-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Vector{String}, String, String}","page":"Home","title":"Mycelia.remove_path_from_graph!","text":"Remove a path from the graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.repr_long-Tuple{Any}","page":"Home","title":"Mycelia.repr_long","text":"repr_long(v) -> String\n\n\nReturn a string representation of the vector v with each element on a new line, mimicking valid Julia syntax. The output encloses the elements in square brackets and separates them with a comma followed by a newline.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.reset_environment!","page":"Home","title":"Mycelia.reset_environment!","text":"reset_environment!(env::AssemblyEnvironment, dataset_idx::Int=1)\n\nReset the RL environment to start a new training episode.\n\nArguments\n\nenv::AssemblyEnvironment: Environment to reset\ndataset_idx::Int: Index of training dataset to use (default: 1)\n\nReturns\n\nAssemblyState: Initial state for new episode\n\nExample\n\ninitial_state = reset_environment!(env, 2)  # Use second training dataset\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.resolve_repeats_next-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}}","page":"Home","title":"Mycelia.resolve_repeats_next","text":"resolve_repeats_next(graph::MetaGraphsNext.MetaGraph, min_repeat_length::Int=10) -> Vector{RepeatRegion}\n\nIdentify and characterize repetitive regions in the assembly graph.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.reverse_complement-Tuple{String}","page":"Home","title":"Mycelia.reverse_complement","text":"Helper function to reverse complement a DNA string.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.reverse_translate-Tuple{BioSequences.LongAA}","page":"Home","title":"Mycelia.reverse_translate","text":"reverse_translate(\n    protein_sequence::BioSequences.LongAA\n) -> BioSequences.LongSequence{BioSequences.DNAAlphabet{2}}\n\n\nConvert a protein sequence back to a possible DNA coding sequence using weighted random codon selection.\n\nArguments\n\nprotein_sequence::BioSequences.LongAA: The amino acid sequence to reverse translate\n\nReturns\n\nBioSequences.LongDNA{2}: A DNA sequence that would translate to the input protein sequence\n\nDetails\n\nUses codon usage frequencies to randomly select codons for each amino acid, weighted by their  natural occurrence. Each selected codon is guaranteed to translate back to the original amino acid.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rolling_centered_avg-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Home","title":"Mycelia.rolling_centered_avg","text":"rolling_centered_avg(data::AbstractArray{T, 1}; window_size)\n\n\nCompute a centered moving average over a vector using a sliding window.\n\nArguments\n\ndata::AbstractVector{T}: Input vector to be averaged\nwindow_size::Int: Size of the sliding window (odd number recommended)\n\nReturns\n\nVector{Float64}: Vector of same length as input containing moving averages\n\nDetails\n\nFor points near the edges, the window is truncated to available data\nWindow is centered on each point, using floor(window_size/2) points on each side\nResult type is always Float64 regardless of input type T\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_amrfinderplus-Tuple{}","page":"Home","title":"Mycelia.run_amrfinderplus","text":"run_amrfinderplus(; fasta, output_dir, force)\n\n\nRun AMRFinderPlus on FASTA input to identify antimicrobial resistance genes.\n\nArguments\n\nfasta::String: Path to input FASTA file (must match Mycelia.FASTA_REGEX pattern)\noutput_dir::String: Output directory path (default: input filename + \"_amrfinderplus\")\nforce::Bool: Force rerun even if output files already exist (default: false)\n\nReturns\n\nPath to the output directory containing AMRFinderPlus results\n\nDetails\n\nFor nucleotide FASTA files, automatically runs Mycelia.run_pyrodigal to generate protein sequences\nFor protein FASTA files, runs AMRFinderPlus directly  \nValidates input file extension against Mycelia.FASTA_REGEX\nCreates output directory if it doesn't exist\nSkips processing if results already exist in output directory unless force=true\nUses –plus flag for enhanced detection capabilities\n\nFiles Generated\n\n<basename>.amrfinderplus.tsv: AMRFinderPlus results table\nFor nucleotide inputs: intermediate pyrodigal outputs in subdirectory\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_blast-Tuple{}","page":"Home","title":"Mycelia.run_blast","text":"run_blast(\n;\n    out_dir,\n    fasta,\n    blast_db,\n    blast_command,\n    force,\n    remote,\n    wait\n)\n\n\nRun a BLAST (Basic Local Alignment Search Tool) command with the specified parameters.\n\nArguments\n\nout_dir::String: The output directory where the BLAST results will be stored.\nfasta::String: The path to the input FASTA file.\nblast_db::String: The path to the BLAST database.\nblast_command::String: The BLAST command to be executed (e.g., blastn, blastp).\nforce::Bool: If true, forces the BLAST command to run even if the output file already exists. Default is false.\nremote::Bool: If true, runs the BLAST command remotely. Default is false.\nwait::Bool: If true, waits for the BLAST command to complete before returning. Default is true.\n\nReturns\n\noutfile::String: The path to the output file containing the BLAST results.\n\nDescription\n\nThis function constructs and runs a BLAST command based on the provided parameters. It creates the necessary output directory, constructs the output file name, and determines whether the BLAST command needs to be run based on the existence and size of the output file. The function supports both local and remote execution of the BLAST command.\n\nIf force is set to true or the output file does not exist or is empty, the BLAST command is executed. The function logs the command being run and measures the time taken for execution. The output file path is returned upon completion.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_blastn-Tuple{}","page":"Home","title":"Mycelia.run_blastn","text":"run_blastn(\n;\n    outdir,\n    fasta,\n    blastdb,\n    threads,\n    task,\n    force,\n    remote,\n    wait\n)\n\n\nRun the BLASTN (Basic Local Alignment Search Tool for Nucleotides) command with specified parameters.\n\nArguments\n\noutdir::String: The output directory where the BLASTN results will be saved.\nfasta::String: The path to the input FASTA file containing the query sequences.\nblastdb::String: The path to the BLAST database to search against.\ntask::String: The BLASTN task to perform. Default is \"megablast\".\nforce::Bool: If true, forces the BLASTN command to run even if the output file already exists. Default is false.\nremote::Bool: If true, runs the BLASTN command remotely. Default is false.\nwait::Bool: If true, waits for the BLASTN command to complete before returning. Default is true.\n\nReturns\n\noutfile::String: The path to the output file containing the BLASTN results.\n\nDescription\n\nThis function constructs and runs a BLASTN command based on the provided parameters. It creates an output directory if it doesn't exist, constructs the output file path, and checks if the BLASTN command needs to be run based on the existence and size of the output file. The function supports running the BLASTN command locally or remotely, with options to force re-running and to wait for completion.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_blastp_search-Tuple{}","page":"Home","title":"Mycelia.run_blastp_search","text":"run_blastp_search(\n;\n    query_fasta,\n    reference_fasta,\n    output_dir,\n    threads,\n    evalue,\n    max_target_seqs\n)\n\n\nPerform BLASTP search between query and reference protein FASTA files.\n\nArguments\n\nquery_fasta::String: Path to query protein FASTA file\nreference_fasta::String: Path to reference protein FASTA file\noutput_dir::String: Output directory (defaults to query filename + \"_blastp\")\nthreads::Int: Number of threads (defaults to system CPU count)\nevalue::Float64: E-value threshold (default: 1e-3)\nmax_target_seqs::Int: Maximum target sequences (default: 500)\n\nReturns\n\nString: Path to the BLASTP results file (.tsv format)\n\nThrows\n\nAssertionError: If input files don't exist or are invalid\nSystemError: If BLAST execution fails\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_canu-Tuple{}","page":"Home","title":"Mycelia.run_canu","text":"run_canu(; fastq, outdir, genome_size, read_type)\n\n\nRun Canu assembler for long read assembly.\n\nArguments\n\nfastq::String: Path to input FASTQ file containing long reads\noutdir::String: Output directory path (default: \"canu_output\")\ngenome_size::String: Estimated genome size (e.g., \"5m\", \"1.2g\")\nread_type::String: Type of reads (\"pacbio\", \"nanopore\")\n\nReturns\n\nNamed tuple containing:\n\noutdir::String: Path to output directory\nassembly::String: Path to final assembly file\n\nDetails\n\nAutomatically creates and uses a conda environment with canu\nIncludes error correction, trimming, and assembly stages\nSkips assembly if output directory already exists\nUtilizes all available CPU threads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_checkm-Tuple{String}","page":"Home","title":"Mycelia.run_checkm","text":"run_checkm(input_path::String; outdir::String=input_path * \"_checkm\", db_dir::String=joinpath(homedir(), \"workspace\", \".checkm\"), extension::String=\"fasta\")\n\nRun CheckM on directory containing FASTA files.\n\nCheckM requires a directory of genome files as input.\n\nArguments\n\ninput_path: Path to directory containing FASTA files\noutdir: Output directory for CheckM results (default: inputpath * \"checkm\")\ndb_dir: CheckM database directory (default: ~/.checkm)\nextension: File extension for genomes (default: \"fasta\")\nthreads: Number of threads to use (default: all available CPU threads)\n\nExample\n\nrun_checkm(\"./genomes/\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_checkm2-Tuple{String}","page":"Home","title":"Mycelia.run_checkm2","text":"run_checkm2(input_path::String; outdir::String=input_path * \"_checkm2\", db_dir::String=joinpath(homedir(), \"workspace\", \".checkm2\"))\n\nRun CheckM2 on FASTA file(s) or directory containing FASTA files.\n\nArguments\n\ninput_path: Path to FASTA file or directory containing FASTA files\noutdir: Output directory for CheckM2 results (default: inputpath * \"checkm2\")\nthreads: Number of threads to use (default: all available CPU threads)\ndb_dir: CheckM2 database directory (default: ~/.checkm2)\n\nReturns\n\nA named tuple with the following fields:\n\noutdir: Output directory path\nquality_report: Path to quality_report.tsv\nlog_file: Path to checkm2.log\ndiamond_results: Path to DIAMOND_RESULTS.tsv\nprotein_file: Path to the single .faa file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_checkm2_list-Tuple{Vector{String}}","page":"Home","title":"Mycelia.run_checkm2_list","text":"run_checkm2_list(fasta_files::Vector{String}; outdir::String=normalized_current_datetime() * \"_checkm2\", db_dir::String=joinpath(homedir(), \"workspace\", \".checkm2\"))\n\nRun CheckM2 on a list of FASTA files.\n\nCheckM2 can automatically handle mixed lists of gzipped and non-gzipped files when given a list.\n\nArguments\n\nfasta_files: Vector of FASTA file paths (can be mixed gzipped and non-gzipped)\noutdir: Output directory for CheckM2 results (default: normalizedcurrentdatetime() * \"_checkm2\")\nthreads: Number of threads to use (default: all available CPU threads)\ndb_dir: CheckM2 database directory (default: ~/.checkm2)\n\nExample\n\nfiles = [\"genome1.fasta.gz\", \"genome2.fasta\", \"genome3.fasta.gz\"]\nrun_checkm2_list(files)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_checkv-Tuple{String}","page":"Home","title":"Mycelia.run_checkv","text":"run_checkv(fasta_file::String; outdir::String=fasta_file * \"_checkv\", db_dir::String=joinpath(homedir(), \"workspace\", \".checkv\"))\n\nRun CheckV on a single genome FASTA file.\n\nCheckV assesses the quality and completeness of viral genomes.\n\nArguments\n\nfasta_file: Path to single FASTA file (can be gzipped)\noutdir: Output directory for CheckV results (default: fastafile * \"checkv\")\nthreads: Number of threads to use (default: all available CPU threads)\ndb_dir: CheckV database directory (default: ~/.checkv)\n\nReturns\n\nNamed tuple with fields:\noutdir: Output directory path\ncomplete_genomes: Path to complete_genomes.tsv\ncompleteness: Path to completeness.tsv\ncontamination: Path to contamination.tsv\nproviruses: Path to proviruses.fna\nquality_summary: Path to quality_summary.tsv\nviruses: Path to viruses.fna\n\nExample\n\nresult = run_checkv(\"genome.fasta\")\nprintln(\"Quality summary: \", result.quality_summary)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_clustal_omega-Tuple{}","page":"Home","title":"Mycelia.run_clustal_omega","text":"run_clustal_omega(; fasta, outfmt)\n\n\nRun Clustal Omega multiple sequence alignment on a FASTA file.\n\nArguments\n\nfasta::String: Path to input FASTA file\noutfmt::String=\"clustal\": Output format for the alignment\n\nReturns\n\nString: Path to the output alignment file\n\nSupported Output Formats\n\n\"fasta\": FASTA format\n\"clustal\": Clustal format\n\"msf\": MSF format  \n\"phylip\": PHYLIP format\n\"selex\": SELEX format\n\"stockholm\": Stockholm format\n\"vienna\": Vienna format\n\nNotes\n\nUses Bioconda to manage the Clustal Omega installation\nCaches results - will return existing output file if already generated\nHandles single sequence files gracefully by returning output path without error\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_diamond_search-Tuple{}","page":"Home","title":"Mycelia.run_diamond_search","text":"run_diamond_search(\n;\n    query_fasta,\n    reference_fasta,\n    output_dir,\n    threads,\n    evalue,\n    block_size,\n    sensitivity\n)\n\n\nPerform DIAMOND BLASTP search between query and reference protein FASTA files.\n\nArguments\n\nquery_fasta::String: Path to query protein FASTA file\nreference_fasta::String: Path to reference protein FASTA file\noutput_dir::String: Output directory (defaults to query filename + \"_diamond\")\nthreads::Int: Number of threads (defaults to system CPU count)\nevalue::Float64: E-value threshold (default: 1e-3)\nblock_size::Float64: Block size in GB (default: auto-calculated from system memory)\nsensitivity::String: Sensitivity mode (default: \"–iterate\")\n\nReturns\n\nString: Path to the DIAMOND results file (.tsv format)\n\nThrows\n\nAssertionError: If input files don't exist or are invalid\nSystemError: If DIAMOND execution fails\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_ectyper-Tuple{Any}","page":"Home","title":"Mycelia.run_ectyper","text":"run_ectyper(fasta_file) -> Any\n\n\nRun ECTyper for serotyping E. coli genome assemblies.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing assembled genome(s)\n\nReturns\n\nString: Path to output directory containing ECTyper results\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_fastqc-Tuple{}","page":"Home","title":"Mycelia.run_fastqc","text":"run_fastqc(; forward, reverse, outdir)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_flye-Tuple{}","page":"Home","title":"Mycelia.run_flye","text":"run_flye(; fastq, outdir, genome_size, read_type)\n\n\nRun Flye assembler for long read assembly.\n\nArguments\n\nfastq::String: Path to input FASTQ file containing long reads\noutdir::String: Output directory path (default: \"flye_output\")\ngenome_size::String: Estimated genome size (e.g., \"5m\", \"1.2g\")\nread_type::String: Type of reads (\"pacbio-raw\", \"pacbio-corr\", \"pacbio-hifi\", \"nano-raw\", \"nano-corr\", \"nano-hq\")\n\nReturns\n\nNamed tuple containing:\n\noutdir::String: Path to output directory\nassembly::String: Path to final assembly file\n\nDetails\n\nAutomatically creates and uses a conda environment with flye\nSupports various long read technologies and quality levels\nSkips assembly if output directory already exists\nUtilizes all available CPU threads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_full_benchmark_suite","page":"Home","title":"Mycelia.run_full_benchmark_suite","text":"run_full_benchmark_suite()\nrun_full_benchmark_suite(config::Mycelia.BenchmarkConfig)\n\n\nRun comprehensive performance benchmark suite.\n\nExecutes all benchmark tests and provides a summary report against our targets:\n\nMemory Usage: 50% reduction through type-stable metadata\nConstruction Speed: 2x faster graph building  \nType Stability: Zero allocations in hot paths\n\nArguments\n\nconfig: BenchmarkConfig for test parameters\n\nReturns\n\nNamedTuple with comprehensive results\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.run_genomad-Tuple{}","page":"Home","title":"Mycelia.run_genomad","text":"Run geNomad mobile genetic element identification tool.\n\ngeNomad identifies viruses and plasmids in genomic and metagenomic data using machine learning and database comparisons.\n\nArguments\n\ninput_fasta: Path to input FASTA file\noutput_directory: Output directory path\ngenomad_dbpath: Path to geNomad database directory\nthreads: Number of CPU threads to use\ncleanup: Remove intermediate files after completion\nsplits: Number of splits for memory management\nforce: Force rerun even if output files already exist\n\nReturns\n\nNamedTuple containing paths to all generated output files and directories\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_hifiasm-Tuple{}","page":"Home","title":"Mycelia.run_hifiasm","text":"run_hifiasm(; fastq, outdir)\n\n\nRun the hifiasm genome assembler on PacBio HiFi reads.\n\nArguments\n\nfastq::String: Path to input FASTQ file containing HiFi reads\noutdir::String: Output directory path (default: \"{basename(fastq)}_hifiasm\")\n\nReturns\n\nNamed tuple containing:\n\noutdir::String: Path to output directory\nhifiasm_outprefix::String: Prefix used for hifiasm output files\n\nDetails\n\nAutomatically creates and uses a conda environment with hifiasm\nUses primary assembly mode (–primary) optimized for inbred samples\nSkips assembly if output files already exist at the specified prefix\nUtilizes all available CPU threads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_mash_comparison-Tuple{String, String}","page":"Home","title":"Mycelia.run_mash_comparison","text":"run_mash_comparison(fasta1::String, fasta2::String; k::Int=21, s::Int=10000, mash_path::String=\"mash\")\n\nRuns a genome-by-genome comparison using the mash command-line tool.\n\nThis function first creates sketch files for each FASTA input and then calculates the distance between them, capturing and parsing the result.\n\nArguments\n\nfasta1::String: Path to the first FASTA file.\nfasta2::String: Path to the second FASTA file.\n\nKeyword Arguments\n\nk::Int=21: The k-mer size to use for sketching. Default is 21.\ns::Int=10000: The sketch size (number of hashes to keep). Default is 10000.\nmash_path::String=\"mash\": The path to the mash executable if not in the system PATH.\n\nReturns\n\nNamedTuple: A named tuple containing the parsed results, e.g., (reference=..., query=..., distance=..., p_value=..., shared_hashes=...)\nnothing: Returns nothing if the mash command fails.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_megahit-Tuple{}","page":"Home","title":"Mycelia.run_megahit","text":"run_megahit(\n;\n    fastq1,\n    fastq2,\n    outdir,\n    min_contig_len,\n    k_list\n)\n\n\nRun MEGAHIT assembler for metagenomic short read assembly.\n\nArguments\n\nfastq1::String: Path to first paired-end FASTQ file\nfastq2::String: Path to second paired-end FASTQ file (optional for single-end)\noutdir::String: Output directory path (default: \"megahit_output\")\nmin_contig_len::Int: Minimum contig length (default: 200)\nk_list::String: k-mer sizes to use (default: \"21,29,39,59,79,99,119,141\")\n\nReturns\n\nNamed tuple containing:\n\noutdir::String: Path to output directory\ncontigs::String: Path to final contigs file\n\nDetails\n\nAutomatically creates and uses a conda environment with megahit\nOptimized for metagenomic assemblies with varying coverage\nSkips assembly if output directory already exists\nUtilizes all available CPU threads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_metaspades-Tuple{}","page":"Home","title":"Mycelia.run_metaspades","text":"run_metaspades(; fastq1, fastq2, outdir, k_list)\n\n\nRun metaSPAdes assembler for metagenomic short read assembly.\n\nArguments\n\nfastq1::String: Path to first paired-end FASTQ file\nfastq2::String: Path to second paired-end FASTQ file (optional for single-end)\noutdir::String: Output directory path (default: \"metaspades_output\")\nk_list::String: k-mer sizes to use (default: \"21,33,55,77\")\n\nReturns\n\nNamed tuple containing:\n\noutdir::String: Path to output directory\ncontigs::String: Path to contigs file\nscaffolds::String: Path to scaffolds file\n\nDetails\n\nAutomatically creates and uses a conda environment with spades\nDesigned for metagenomic datasets with uneven coverage\nSkips assembly if output directory already exists\nUtilizes all available CPU threads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_mlst-Tuple{Any}","page":"Home","title":"Mycelia.run_mlst","text":"run_mlst(fasta_file) -> String\n\n\nRun Multi-Locus Sequence Typing (MLST) analysis on a genome assembly.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing the genome assembly\n\nReturns\n\nPath to the output file containing MLST results (<input>.mlst.out)\n\nDetails\n\nUses the mlst tool from PubMLST to identify sequence types by comparing allelic  profiles of housekeeping genes against curated MLST schemes.\n\nDependencies\n\nRequires Bioconda and the mlst package\nAutomatically sets up conda environment if not present\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_mmseqs_easy_search-Tuple{}","page":"Home","title":"Mycelia.run_mmseqs_easy_search","text":"run_mmseqs_easy_search(\n;\n    query_fasta,\n    target_database,\n    out_dir,\n    outfile,\n    format_output,\n    threads,\n    force\n)\n\n\nRuns the MMseqs2 easy-search command on the given query FASTA file against the target database.\n\nArguments\n\nquery_fasta::String: Path to the query FASTA file.\ntarget_database::String: Path to the target database.\nout_dir::String: Directory to store the output file. Defaults to the directory of the query FASTA file.\noutfile::String: Name of the output file. Defaults to a combination of the query FASTA and target database filenames.\nformat_output::String: Format of the output. Defaults to a predefined set of fields.\nthreads::Int: Number of CPU threads to use. Defaults to the number of CPU threads available.\nforce::Bool: If true, forces the re-generation of the output file even if it already exists. Defaults to false.\n\nReturns\n\noutfile_path::String: Path to the generated output file.\n\nNotes\n\nAdds the mmseqs2 environment using Bioconda if not already present.\nRemoves temporary files created during the process.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_mmseqs_search-Tuple{}","page":"Home","title":"Mycelia.run_mmseqs_search","text":"run_mmseqs_search(\n;\n    query_fasta,\n    reference_fasta,\n    output_dir,\n    threads,\n    evalue,\n    sensitivity\n)\n\n\nPerform MMseqs2 easy-search between query and reference FASTA files.\n\nArguments\n\nquery_fasta::String: Path to query FASTA file\nreference_fasta::String: Path to reference FASTA file  \noutput_dir::String: Output directory (defaults to query filename + \"_mmseqs\")\nthreads::Int: Number of threads (defaults to system CPU count)\nevalue::Float64: E-value threshold (default: 1e-3)\nsensitivity::Float64: Sensitivity parameter (default: 4.0)\n\nReturns\n\nString: Path to the MMseqs2 results file (.tsv format)\n\nThrows\n\nAssertionError: If input files don't exist or are invalid\nSystemError: If MMseqs2 execution fails\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_padloc-Tuple{}","page":"Home","title":"Mycelia.run_padloc","text":"run_padloc(; fasta_file, outdir, threads)\n\n\nRun the 'padloc' tool from the 'padlocbio' conda environment on a given FASTA file.\n\nhttps://doi.org/10.1093/nar/gkab883\n\nhttps://github.com/padlocbio/padloc\n\nThis function first ensures that the 'padloc' environment is available via Bioconda.  It then attempts to update the 'padloc' database.  If a 'padloc' output file (with a '_padloc.csv' suffix) does not already exist for the input FASTA file,  it runs 'padloc' with the specified FASTA file as input.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_parallel_progress-Tuple{Function, AbstractVector}","page":"Home","title":"Mycelia.run_parallel_progress","text":"run_parallel_progress(\n    f::Function,\n    items::AbstractVector\n) -> Any\n\n\nRun a function f in parallel over a collection of items with a progress meter.\n\nArguments\n\nf::Function: The function to be applied to each item in the collection.\nitems::AbstractVector: A collection of items to be processed.\n\nDescription\n\nThis function creates a progress meter to track the progress of processing each item in the items collection.  It uses multithreading to run the function f on each item in parallel, updating the progress meter after each item is processed.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_phageboost-Tuple{}","page":"Home","title":"Mycelia.run_phageboost","text":"run_phageboost(input_fasta::AbstractString, output_dir::AbstractString; force_reinstall::Bool=false)\n\nRun PhageBoost on the provided FASTA file, automatically handling conda environment setup.\n\nThis function will:\n\nCheck if the phageboost_env conda environment exists\nCreate and set up the environment if it doesn't exist\nValidate that PhageBoost is properly installed\nRun PhageBoost on the input FASTA file\nReturn the output directory path and list of generated files\n\nArguments\n\ninput_fasta::AbstractString: Path to the input FASTA file\noutput_dir::AbstractString: Directory where PhageBoost outputs will be saved\nforce_reinstall::Bool=false: If true, recreate the environment even if it exists\n\nReturns\n\nNamedTuple with fields:\noutput_dir::String: Path to the output directory\nfiles::Vector{String}: List of files generated in the output directory\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_phispy-Tuple{String}","page":"Home","title":"Mycelia.run_phispy","text":"run_phispy(input_file::String; output_dir::String=\"\", \n       phage_genes::Int=2, color::Bool=false, prefix::String=\"\",\n       phmms::String=\"\", threads::Int=1, metrics::Vector{String}=String[],\n       expand_slope::Bool=false, window_size::Int=30, \n       min_contig_size::Int=5000, skip_search::Bool=false,\n       output_choice::Int=3, training_set::String=\"\", \n       prokka_args::NamedTuple=NamedTuple(), force::Bool=false)\n\nRun PhiSpy to identify prophages in bacterial genomes.\n\nPhiSpy identifies prophage regions in bacterial (and archaeal) genomes using multiple approaches including gene composition, AT/GC skew, and optional HMM searches.\n\nArguments\n\ninput_file::String: Path to input file (FASTA or GenBank format)\noutput_dir::String: Output directory (default: inputfile * \"phispy\")  \nphage_genes::Int: Minimum phage genes required per prophage region (default: 2, set to 0 for mobile elements)\ncolor::Bool: Add color annotations for CDS based on function (default: false)\nprefix::String: Prefix for output filenames (default: basename of input)\nphmms::String: Path to HMM database for additional phage gene detection\nthreads::Int: Number of threads for HMM searches (default: 1)\nmetrics::Vector{String}: Metrics to use for prediction (default: all standard metrics)\nexpand_slope::Bool: Expand Shannon slope calculations (default: false)\nwindow_size::Int: Window size for calculations (default: 30)\nmin_contig_size::Int: Minimum contig size to analyze (default: 5000)\nskip_search::Bool: Skip HMM search if already done (default: false)\noutput_choice::Int: Bitmask for output files (default: 3 for coordinates + GenBank)\ntraining_set::String: Path to custom training set\nprokka_args::NamedTuple: Additional arguments to pass to Prokka if FASTA input is provided\nforce::Bool: Force rerun even if output files already exist (default: false)\n\nOutput Choice Codes (add values for multiple outputs)\n\n1: prophage_coordinates.tsv\n2: GenBank format output  \n4: prophage and bacterial sequences\n8: prophage_information.tsv\n16: prophage.tsv\n32: GFF3 format (prophages only)\n64: prophage.tbl\n128: test data used in random forest\n256: GFF3 format (full genome)\n512: all output files\n\nReturns\n\nA NamedTuple with paths to generated output files (contents depend on output_choice):\n\nprophage_coordinates: prophage_coordinates.tsv file path\ngenbank_output: Updated GenBank file with prophage annotations\nprophage_sequences: Prophage and bacterial sequence files\nprophage_information: prophage_information.tsv file path\nprophage_simple: prophage.tsv file path\ngff3_prophages: GFF3 file with prophage regions only\nprophage_table: prophage.tbl file path\ntest_data: Random forest test data file path\ngff3_genome: GFF3 file with full genome annotations\noutput_dir: Path to output directory\ninput_genbank: Path to GenBank file used (original or generated by Prokka)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_prodigal-Tuple{}","page":"Home","title":"Mycelia.run_prodigal","text":"run_prodigal(; fasta_file, out_dir)\n\n\nRun Prodigal gene prediction software on input FASTA file to identify protein-coding genes in metagenomes or single genomes.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing genomic sequences\nout_dir::String=dirname(fasta_file): Directory for output files. Defaults to input file's directory\n\nReturns\n\nNamed tuple containing paths to all output files:\n\nfasta_file: Input FASTA file path\nout_dir: Output directory path  \ngff: Path to GFF format gene predictions\ngene_scores: Path to all potential genes and their scores\nfna: Path to nucleotide sequences of predicted genes\nfaa: Path to protein translations of predicted genes\nstd_out: Path to captured stdout\nstd_err: Path to captured stderr\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_prokka-Tuple{String}","page":"Home","title":"Mycelia.run_prokka","text":"run_prokka(input_fasta::String; output_dir::String=\"\", prefix::String=\"\", \n       cpus::Int=0, kingdom::String=\"Bacteria\", genus::String=\"\", \n       species::String=\"\", strain::String=\"\", force_overwrite::Bool=false,\n       addgenes::Bool=false, compliant::Bool=false, fast::Bool=false,\n       evalue::Float64=1e-06, mincontiglen::Int=1, force::Bool=false)\n\nRun Prokka for rapid prokaryotic genome annotation.\n\nProkka annotates bacterial, archaeal and viral genomes quickly and produces  standards-compliant output files including GFF3, GenBank, and FASTA formats.\n\nArguments\n\ninput_fasta::String: Path to input FASTA file containing contigs\noutput_dir::String: Output directory (default: inputfasta * \"prokka\")\nprefix::String: Output file prefix (default: basename of input file)\ncpus::Int: Number of CPUs to use, 0 for all available (default: 0)\nkingdom::String: Annotation mode - \"Bacteria\", \"Archaea\", \"Viruses\", or \"Mitochondria\" (default: \"Bacteria\")\ngenus::String: Genus name for annotation\nspecies::String: Species name for annotation  \nstrain::String: Strain name for annotation\nforce_overwrite::Bool: Force overwrite existing output directory (default: false)\naddgenes::Bool: Add 'gene' features for each 'CDS' feature (default: false)\ncompliant::Bool: Force GenBank/ENA/DDJB compliance (default: false)\nfast::Bool: Fast mode - skip CDS product searching (default: false)\nevalue::Float64: Similarity e-value cut-off (default: 1e-06)\nmincontiglen::Int: Minimum contig size (default: 1, NCBI needs 200)\nforce::Bool: Force rerun even if output files already exist (default: false)\n\nReturns\n\nA NamedTuple with paths to all generated output files:\n\ngff: Master annotation in GFF3 format\ngbk: Standard GenBank file  \nfna: Nucleotide FASTA of input contigs\nfaa: Protein FASTA of translated CDS sequences\nffn: Nucleotide FASTA of all transcripts\nsqn: ASN1 Sequin file for GenBank submission\nfsa: Nucleotide FASTA for tbl2asn\ntbl: Feature table file\nerr: NCBI discrepancy report\nlog: Complete run log\ntxt: Annotation statistics\ntsv: Tab-separated feature table\noutput_dir: Path to output directory\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_pyrodigal-Tuple{}","page":"Home","title":"Mycelia.run_pyrodigal","text":"run_pyrodigal(; fasta_file, out_dir)\n\n\nRun Pyrodigal gene prediction on a FASTA file using the meta procedure optimized for metagenomic sequences.\n\nPyrodigal is a reimplementation of the Prodigal gene finder, which identifies protein-coding sequences in bacterial and archaeal genomes.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing genomic sequences\nout_dir::String: Output directory path (default: input filename + \"_pyrodigal\")\n\nReturns\n\nNamed tuple containing:\n\nfasta_file: Input FASTA file path\nout_dir: Output directory path\ngff: Path to GFF output file with gene predictions\nfaa: Path to FASTA file with predicted protein sequences \nfna: Path to FASTA file with nucleotide sequences\n\nNotes\n\nUses metagenomic mode (-p meta) optimized for mixed communities\nMasks runs of N nucleotides (-m flag)\nMinimum gene length set to 33bp\nMaximum overlap between genes set to 31bp\nRequires Pyrodigal to be available in a Conda environment\nSkips processing if output files already exist\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_quast-Tuple{String}","page":"Home","title":"Mycelia.run_quast","text":"run_quast(assembly_file::String; kwargs...)\n\nRun QUAST on a single assembly file. See run_quast(::Vector{String}) for details.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_quast-Tuple{Vector{String}}","page":"Home","title":"Mycelia.run_quast","text":"run_quast(assembly_files::Vector{String}; outdir::String=\"quast_results\", reference::Union{String,Nothing}=nothing, threads::Int=Sys.CPU_THREADS, min_contig::Int=500, gene_finding::Bool=false)\n\nRun QUAST (Quality Assessment Tool for Genome Assemblies) to evaluate assembly quality.\n\nArguments\n\nassembly_files::Vector{String}: Vector of paths to assembly FASTA files to evaluate\noutdir::String=\"quast_results\": Output directory for QUAST results\nreference::Union{String,Nothing}=nothing: Optional reference genome for reference-based metrics\nthreads::Int=Sys.CPU_THREADS: Number of threads to use\nmin_contig::Int=500: Minimum contig length to consider\ngene_finding::Bool=false: Whether to run gene finding (requires GeneMark-ES/ET)\n\nReturns\n\nString: Path to the output directory containing QUAST results\n\nOutput Files\n\nreport.html: Interactive HTML report\nreport.txt: Text summary report\nreport.tsv: Tab-separated values report for programmatic access\ntransposed_report.tsv: Transposed TSV format\nicarus.html: Icarus contig browser (if reference provided)\n\nExamples\n\n# Basic assembly evaluation\nassemblies = [\"assembly1.fasta\", \"assembly2.fasta\"]\nquast_dir = Mycelia.run_quast(assemblies)\n\n# With reference genome\nref_genome = \"reference.fasta\"\nquast_dir = Mycelia.run_quast(assemblies, reference=ref_genome)\n\n# Custom parameters\nquast_dir = Mycelia.run_quast(assemblies, \n                             outdir=\"my_quast_results\",\n                             min_contig=1000,\n                             threads=8)\n\nNotes\n\nRequires QUAST to be installed via Bioconda\nWithout reference: provides basic metrics (N50, total length, # contigs, etc.)\nWith reference: adds reference-based metrics (genome fraction, misassemblies, etc.)\nGene finding requires additional dependencies and is disabled by default\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_samtools_flagstat","page":"Home","title":"Mycelia.run_samtools_flagstat","text":"run_samtools_flagstat(xam) -> Any\nrun_samtools_flagstat(xam, samtools_flagstat) -> Any\n\n\nGenerate alignment statistics for a SAM/BAM/CRAM file using samtools flagstat.\n\nArguments\n\nxam::AbstractString: Path to input SAM/BAM/CRAM alignment file\nsamtools_flagstat::AbstractString: Output path for flagstat results (default: input_path.samtools-flagstat.txt)\n\nReturns\n\nString: Path to the generated flagstat output file\n\nDetails\n\nRuns samtools flagstat to calculate statistics on the alignment file, including:\n\nTotal reads\nSecondary alignments\nSupplementary alignments  \nDuplicates\nMapped/unmapped reads\nProper pairs\nRead 1/2 counts\n\nRequirements\n\nRequires samtools to be available via Bioconda\nInput file must be in SAM, BAM or CRAM format\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.run_transterm-Tuple{}","page":"Home","title":"Mycelia.run_transterm","text":"run_transterm(; fasta, gff)\n\n\nRun TransTermHP to predict rho-independent transcription terminators in DNA sequences.\n\nArguments\n\nfasta: Path to input FASTA file containing DNA sequences\ngff: Optional path to GFF annotation file. If provided, improves prediction accuracy\n\nReturns\n\nString: Path to output file containing TransTermHP predictions\n\nDetails\n\nUses Conda environment 'transtermhp' for execution\nAutomatically generates coordinate file from FASTA or GFF input\nRemoves temporary coordinate file after completion\nRequires Mycelia's Conda setup\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_trnascan-Tuple{}","page":"Home","title":"Mycelia.run_trnascan","text":"run_trnascan(; fna_file, outdir)\n\n\nRun tRNAscan-SE to identify and annotate transfer RNA genes in the provided sequence file.\n\nArguments\n\nfna_file::String: Path to input FASTA nucleotide file\noutdir::String: Output directory path (default: inputfilepath + \"_trnascan\")\n\nReturns\n\nString: Path to the output directory containing tRNAscan-SE results\n\nOutput Files\n\nCreates the following files in outdir:\n\n*.trnascan.out: Main output with tRNA predictions\n*.trnascan.bed: BED format coordinates\n*.trnascan.fasta: FASTA sequences of predicted tRNAs\n*.trnascan.struct: Secondary structure predictions\n*.trnascan.stats: Summary statistics\n*.trnascan.log: Program execution log\n\nNotes\n\nUses the general tRNA model (-G flag) suitable for all domains of life\nAutomatically sets up tRNAscan-SE via Bioconda\nSkips processing if output directory contains files\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_unicycler-Tuple{}","page":"Home","title":"Mycelia.run_unicycler","text":"run_unicycler(; short_1, short_2, long_reads, outdir)\n\n\nRun hybrid assembly combining short and long reads using Unicycler.\n\nArguments\n\nshort_1::String: Path to first short read FASTQ file\nshort_2::String: Path to second short read FASTQ file (optional)\nlong_reads::String: Path to long read FASTQ file\noutdir::String: Output directory path (default: \"unicycler_output\")\n\nReturns\n\nNamed tuple containing:\n\noutdir::String: Path to output directory\nassembly::String: Path to final assembly file\n\nDetails\n\nAutomatically creates and uses a conda environment with unicycler\nCombines short read accuracy with long read scaffolding\nSkips assembly if output directory already exists\nUtilizes all available CPU threads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_virsorter2-Tuple{}","page":"Home","title":"Mycelia.run_virsorter2","text":"Run VirSorter2 viral sequence identification tool.\n\nVirSorter2 identifies viral sequences in genomic and metagenomic data using machine learning models and database comparisons.\n\nArguments\n\ninput_fasta: Path to input FASTA file\noutput_directory: Output directory path\ndatabase_path: Path to VirSorter2 database directory\ninclude_groups: Comma-separated viral groups to include\nfull set = dsDNAphage,NCLDV,RNA,ssDNA,lavidaviridae\ntools original default set = dsDNAphage,ssDNA\nLavidaviridae = A family of small double‑stranded DNA \"virophages\" that parasitize the replication machinery of certain NCLDVs\nNCLDV = Nucleocytoplasmic Large DNA Viruses = An informal clade of large double‑stranded DNA viruses that replicate (at least in part) in the cytoplasm of eukaryotic cells.\nmin_score: Minimum score threshold for viral sequences\nmin_length: Minimum sequence length threshold\nthreads: Number of CPU threads to use\nprovirus_off: Disable provirus detection\nmax_orf_per_seq: Maximum ORFs per sequence\nprep_for_dramv: Prepare output for DRAMv annotation\nlabel: Label for output files\nforceall: Force rerun all steps\nforce: Force rerun even if output files already exist\n\nReturns\n\nNamedTuple containing paths to all generated output files and directories\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.samtools_index_fasta-Tuple{}","page":"Home","title":"Mycelia.samtools_index_fasta","text":"samtools_index_fasta(; fasta)\n\n\nCreates an index file (.fai) for a FASTA reference sequence using samtools.\n\nThe FASTA index allows efficient random access to the reference sequence. This is  required by many bioinformatics tools that need to quickly fetch subsequences  from the reference.\n\nArguments\n\nfasta: Path to the input FASTA file\n\nSide Effects\n\nCreates a {fasta}.fai index file in the same directory as input\nInstalls samtools via conda if not already present\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sanitize_inline_strings!-Tuple{DataFrames.DataFrame}","page":"Home","title":"Mycelia.sanitize_inline_strings!","text":"sanitize_inline_strings!(\n    df::DataFrames.DataFrame\n) -> DataFrames.DataFrame\n\n\nConvert all InlineString columns in a DataFrame to standard Strings. Modifies the dataframe in-place and returns it.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sanitize_inline_strings-Tuple{AbstractVector}","page":"Home","title":"Mycelia.sanitize_inline_strings","text":"sanitize_inline_strings(v::AbstractVector) -> Any\n\n\nConvert a column to standard Strings if it contains InlineStrings, otherwise return the original column unchanged.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sanity_check_matrix-Tuple{AbstractMatrix}","page":"Home","title":"Mycelia.sanity_check_matrix","text":"sanity_check_matrix(M::AbstractMatrix)\n\nChecks matrix shape, value types, and distributional properties. Suggests the most appropriate ePCA function and distance metric.\n\nReturns a NamedTuple with fields:\n\nn_features, n_samples\nvalue_type\nrange\nis_binary\nis_integer\nis_nonnegative\nis_strictly_positive\nis_in_01\nis_centered\nis_overdispersed\nsuggested_epca\nsuggested_distance\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.save_consensus_analysis-Tuple{Dict, String}","page":"Home","title":"Mycelia.save_consensus_analysis","text":"Save consensus analysis to JSON file.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.save_df_jld2-Tuple{}","page":"Home","title":"Mycelia.save_df_jld2","text":"save_df_jld2(;df::DataFrames.DataFrame, filename::String, key::String=\"dataframe\")\n\nSave a DataFrame to a JLD2 file.\n\nArguments\n\ndf: The DataFrame to save\nfilename: Path to the JLD2 file (will add .jld2 extension if not present)\nkey: The name of the dataset within the JLD2 file (defaults to \"dataframe\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.save_genome_as_fasta-Tuple{Any, Any}","page":"Home","title":"Mycelia.save_genome_as_fasta","text":"save_genome_as_fasta(genome, filename)\n\nSave a genome sequence as a FASTA file.\n\nConvenience function for saving a single genome sequence to FASTA format for annotation benchmarking.\n\nArguments\n\ngenome: DNA sequence (BioSequences.LongDNA{4})\nfilename: Output FASTA filename\n\nSee Also\n\nwrite_fasta: For more flexible FASTA writing with multiple records\nrandom_fasta_record: For generating random FASTA records\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.save_graph-Tuple{Graphs.AbstractGraph, String}","page":"Home","title":"Mycelia.save_graph","text":"save_graph(\n    graph::Graphs.AbstractGraph,\n    outfile::String\n) -> String\n\n\nSaves the given graph to a file in JLD2 format.\n\nArguments\n\ngraph::Graphs.AbstractGraph: The graph to be saved.\noutfile::String: The name of the output file. If the file extension is not .jld2, it will be appended automatically.\n\nReturns\n\nString: The name of the output file with the .jld2 extension.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.save_kmer_results-Tuple{}","page":"Home","title":"Mycelia.save_kmer_results","text":"save_kmer_results(\n;\n    filename,\n    kmers,\n    counts,\n    fasta_list,\n    k,\n    alphabet\n)\n\n\nSave the kmer counting results (kmers vector, counts sparse matrix) and the input FASTA file list to a JLD2 file for long-term storage and reproducibility.\n\nArguments\n\nfilename::AbstractString: Path to the output JLD2 file.\nkmers::AbstractVector{<:Kmers.Kmer}: The sorted vector of unique kmer objects.\ncounts::AbstractMatrix: The (sparse or dense) matrix of kmer counts.\nfasta_list::AbstractVector{<:AbstractString}: The list of FASTA file paths used as input.\nk::Integer: The kmer size used.\nalphabet::Symbol: The alphabet used (:AA, :DNA, :RNA).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.save_matrix_jld2-Tuple{}","page":"Home","title":"Mycelia.save_matrix_jld2","text":"save_matrix_jld2(; matrix, filename)\n\n\nSaves a matrix to a JLD2 file format.\n\nArguments\n\nmatrix: The matrix to be saved\nfilename: String path where the file should be saved\n\nReturns\n\nThe filename string that was used to save the matrix\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.save_reads_as_fastq","page":"Home","title":"Mycelia.save_reads_as_fastq","text":"save_reads_as_fastq(reads, filename, base_quality=30)\n\nSave DNA reads as a FASTQ file with specified quality scores.\n\nConverts a vector of DNA sequences to FASTQ format with uniform quality scores.\n\nArguments\n\nreads: Vector of DNA sequences (BioSequences.LongDNA{4})\nfilename: Output FASTQ filename\nbase_quality: Base quality score for all positions (default: 30)\n\nSee Also\n\nwrite_fastq: For more flexible FASTQ writing with records\nfastq_record: For creating individual FASTQ records\ngenerate_test_fastq_data: For generating test FASTQ data with variable quality scores\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.save_validation_report-Tuple{Dict, String}","page":"Home","title":"Mycelia.save_validation_report","text":"Save validation report to JSON file.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.scg_sbatch-Tuple{}","page":"Home","title":"Mycelia.scg_sbatch","text":"scg_sbatch(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    partition,\n    account,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd\n)\n\n\nSubmit a job to SLURM using sbatch with specified parameters.\n\nArguments\n\njob_name::String: Name identifier for the SLURM job\nmail_user::String: Email address for job notifications\nmail_type::String: Type of mail notifications (default: \"ALL\")\nlogdir::String: Directory for error and output logs (default: \"~/workspace/slurmlogs\")\npartition::String: SLURM partition to submit job to\naccount::String: Account to charge for compute resources\nnodes::Int: Number of nodes to allocate (default: 1)\nntasks::Int: Number of tasks to run (default: 1)\ntime::String: Maximum wall time in format \"days-hours:minutes:seconds\" (default: \"1-00:00:00\")\ncpus_per_task::Int: CPUs per task (default: 12)\nmem_gb::Int: Memory in GB, defaults to 96GB\ncmd::String: Command to execute\n\nReturns\n\nBool: Returns true if submission succeeds\n\nNotes\n\nFunction includes 5-second delays before and after submission\nMemory is automatically scaled with CPU count\nLog files are named with job ID (%j) and job name (%x)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.select_action-Tuple{Mycelia.DQNPolicy, Mycelia.AssemblyState}","page":"Home","title":"Mycelia.select_action","text":"select_action(policy::DQNPolicy, state::AssemblyState)\n\nSelect an action using the DQN policy with epsilon-greedy exploration.\n\nThis is a placeholder implementation that will be replaced with actual neural network inference once the ML framework is integrated.\n\nArguments\n\npolicy::DQNPolicy: Trained policy network\nstate::AssemblyState: Current environment state\n\nReturns\n\nAssemblyAction: Selected action for the given state\n\nExample\n\naction = select_action(policy, current_state)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.seq2sha256-Tuple{AbstractString}","page":"Home","title":"Mycelia.seq2sha256","text":"seq2sha256(seq::AbstractString) -> String\n\n\nCompute the SHA-256 hash of a sequence string.\n\nArguments\n\nseq::AbstractString: Input sequence to be hashed\n\nReturns\n\nString: Hexadecimal representation of the SHA-256 hash\n\nDetails\n\nThe input sequence is converted to uppercase before hashing.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.seq2sha256-Tuple{BioSequences.BioSequence}","page":"Home","title":"Mycelia.seq2sha256","text":"seq2sha256(seq::BioSequences.BioSequence) -> String\n\n\nConvert a biological sequence to its SHA256 hash value.\n\nCalculates a cryptographic hash of the sequence by first converting it to a string representation. This method dispatches to the string version of seq2sha256.\n\nArguments\n\nseq::BioSequences.BioSequence: The biological sequence to hash\n\nReturns\n\nString: A 64-character hexadecimal string representing the SHA256 hash\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sequence_to_kmer_path-Tuple{String, Int64}","page":"Home","title":"Mycelia.sequence_to_kmer_path","text":"Convert sequence to k-mer path representation (simplified version for backward compatibility).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sequence_to_qualmer_path-Tuple{String, String, Any, Int64}","page":"Home","title":"Mycelia.sequence_to_qualmer_path","text":"Convert sequence with quality to qualmer path representation using graph vertices.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sequence_to_stranded_path-Tuple{Any, Any}","page":"Home","title":"Mycelia.sequence_to_stranded_path","text":"sequence_to_stranded_path(\n    stranded_kmers,\n    sequence\n) -> Vector{Pair{Int64, Bool}}\n\n\nConvert a DNA sequence into a path through a collection of stranded k-mers.\n\nArguments\n\nstranded_kmers: Collection of unique k-mers representing possible path vertices\nsequence: Input DNA sequence to convert to a path\n\nReturns\n\nVector of Pair{Int,Bool} where:\n\nFirst element (Int) is the index of the k-mer in stranded_kmers\nSecond element (Bool) indicates orientation (true=forward, false=reverse)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.setup_checkm-Tuple{}","page":"Home","title":"Mycelia.setup_checkm","text":"setup_checkm(; db_dir::String=joinpath(homedir(), \"workspace\", \".checkm\"))\n\nInstall CheckM via Bioconda and set up its database.\n\nCheckM is a tool for assessing the quality and completeness of bacterial genomes.\n\nArguments\n\ndb_dir: Directory to store CheckM database (default: ~/.checkm)\n\nExample\n\nsetup_checkm()\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.setup_checkm2-Tuple{}","page":"Home","title":"Mycelia.setup_checkm2","text":"setup_checkm2(; db_dir::String=joinpath(homedir(), \"workspace\", \".checkm2\"))\n\nInstall CheckM2 via Bioconda and set up its database.\n\nCheckM2 is a rapid tool for assessing the quality and completeness of bacterial genomes.\n\nArguments\n\ndb_dir: Directory to store CheckM2 database (default: ~/.checkm2)\n\nExample\n\nsetup_checkm2()\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.setup_checkv-Tuple{}","page":"Home","title":"Mycelia.setup_checkv","text":"setup_checkv(; db_dir::String=joinpath(homedir(), \"workspace\", \".checkv\"))\n\nInstall CheckV via Bioconda and set up its database.\n\nCheckV is a tool for assessing the quality and completeness of viral genomes.\n\nArguments\n\ndb_dir: Directory to store CheckV database (default: ~/.checkv)\n\nExample\n\nsetup_checkv()\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.setup_padloc-Tuple{}","page":"Home","title":"Mycelia.setup_padloc","text":"setup_padloc() -> Union{Nothing, Base.Process}\n\n\nEnsure the padloc environment and database are installed.\n\nDownloads the environment if missing and updates the padloc database.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.setup_taxonkit_taxonomy-Tuple{}","page":"Home","title":"Mycelia.setup_taxonkit_taxonomy","text":"setup_taxonkit_taxonomy(; force_update, max_age_days)\n\n\nDownloads and extracts the NCBI taxonomy database required for taxonkit operations.\n\nDownloads taxdump.tar.gz from NCBI FTP server and extracts it to ~/.taxonkit/. This is a prerequisite for using taxonkit-based taxonomy functions.\n\nArguments\n\nforce_update::Bool=false: Force download even if taxdump already exists\nmax_age_days::Int=30: Maximum age in days before warning about stale data\n\nRequirements\n\nWorking internet connection\nSufficient disk space (~100MB)\ntaxonkit must be installed separately\n\nReturns\n\nNothing\n\nThrows\n\nSystemError if download fails or if unable to create directory\nErrorException if tar extraction fails\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sha256_file-Tuple{AbstractString}","page":"Home","title":"Mycelia.sha256_file","text":"sha256_file(file::AbstractString) -> String\n\n\nCompute the SHA-256 hash of the contents of a file.\n\nArguments\n\nfile::AbstractString: The path to the file for which the SHA-256 hash is to be computed.\n\nReturns\n\nString: The SHA-256 hash of the file contents, represented as a hexadecimal string.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.shortest_probability_path_next-Tuple{MetaGraphsNext.MetaGraph, String, String}","page":"Home","title":"Mycelia.shortest_probability_path_next","text":"shortest_probability_path_next(\n    graph::MetaGraphsNext.MetaGraph,\n    source::String,\n    target::String\n) -> Union{Nothing, Mycelia.GraphPath}\n\n\nFind the shortest path in probability space between two vertices.\n\nUses Dijkstra's algorithm where edge distances are -log(probability), so the shortest path corresponds to the highest probability path.\n\nArguments\n\ngraph: MetaGraphsNext k-mer graph\nsource: Source vertex label\ntarget: Target vertex label\n\nReturns\n\nUnion{GraphPath, Nothing}: Shortest probability path, or nothing if no path exists\n\nAlgorithm\n\nConvert edge weights to -log(probability) distances\nRun Dijkstra's algorithm with strand-aware edge traversal\nReconstruct path maintaining strand information\nConvert back to probability space for final result\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.should_continue_k-Tuple{Any, Int64, Int64}","page":"Home","title":"Mycelia.should_continue_k","text":"Determine if we should continue processing the current k-mer size or move to the next. Uses accuracy-prioritized reward function for decision making.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.should_continue_k_advanced-Tuple{Any, Int64, Int64, Vector{Float64}}","page":"Home","title":"Mycelia.should_continue_k_advanced","text":"Advanced decision making with reward history tracking. This function maintains state across iterations for better decisions.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.should_continue_k_progression-Tuple{Vector{Dict{Symbol, Any}}, Int64, Int64}","page":"Home","title":"Mycelia.should_continue_k_progression","text":"Enhanced convergence detection for k-mer progression. Determines if we should move to the next k-mer size based on multiple criteria.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simple_edit_distance-Tuple{String, String}","page":"Home","title":"Mycelia.simple_edit_distance","text":"simple_edit_distance(s1::String, s2::String) -> Int\n\nSimple edit distance calculation for k-mers.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simplify_graph_next-Tuple{MetaGraphsNext.MetaGraph{<:Integer, String, Mycelia.KmerVertexData, Mycelia.KmerEdgeData}, Vector{Mycelia.BubbleStructure}}","page":"Home","title":"Mycelia.simplify_graph_next","text":"simplify_graph_next(graph::MetaGraphsNext.MetaGraph, bubbles::Vector{BubbleStructure}) -> MetaGraphsNext.MetaGraph\n\nSimplify the graph by resolving bubbles and removing low-confidence paths.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_illumina_paired_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_illumina_paired_reads","text":"simulate_illumina_paired_reads(\n;\n    in_fasta,\n    coverage,\n    read_count,\n    outbase,\n    read_length,\n    mflen,\n    sdev,\n    seqSys,\n    amplicon,\n    errfree,\n    rndSeed\n)\n\n\nSimulate Illumina short reads from a FASTA file using the ART Illumina simulator.\n\nThis function wraps ART (installed via Bioconda) to simulate reads from an input reference FASTA. It supports paired-end (or optionally single-end/mate-pair) simulation, with options to choose either fold coverage (--fcov) or an absolute read count (--rcount), to enable amplicon mode, and to optionally generate a zero-error SAM file.\n\nArguments\n\nin_fasta::String: Path to the input FASTA file.\ncoverage::Union{Nothing,Number}: Desired fold coverage (used with --fcov); if nothing and read_count is provided then fold coverage is ignored. (Default: 20)\nread_count::Union{Nothing,Number}: Total number of reads (or read pairs) to generate (used with --rcount instead of fold coverage). (Default: nothing)\noutbase::String: Output file prefix (default: \"(in_fasta)art(coverage)x.\").\nread_length::Int: Length of reads to simulate (default: 150).\nmflen::Int: Mean fragment length for paired-end simulations (default: 500).\nsdev::Int: Standard deviation of fragment lengths (default: 10).\nseqSys::String: Illumina sequencing system ID (e.g. \"HS25\" for HiSeq 2500) (default: \"HS25\").\npaired::Bool: Whether to simulate paired-end reads (default: true).\namplicon::Bool: Enable amplicon sequencing simulation mode (default: false).\nerrfree::Bool: Generate an extra SAM file with zero sequencing errors (default: false).\nrndSeed::Union{Nothing,Int}: Optional seed for reproducibility (default: nothing).\n\nOutputs\n\nGenerates gzipped FASTQ files in the working directory:\n\nFor paired-end: $(outbase)1.fq.gz (forward) and $(outbase)2.fq.gz (reverse).\nFor single-end: $(outbase)1.fq.gz.\n\nAdditional SAM files may be produced if --errfree is enabled and/or if the ART --samout option is specified.\n\nDetails\n\nThis function calls ART with the provided options. Note that if read_count is supplied, the function uses the --rcount option; otherwise, it uses --fcov with the given coverage. Amplicon mode (via --amplicon) restricts the simulation to the amplicon regions, which is important for targeted sequencing studies.\n\nDependencies\n\nRequires ART simulator (installed via Bioconda) and the Mycelia environment helper.\n\nSee also: simulate_nanopore_reads, simulate_nearly_perfect_long_reads, simulate_pacbio_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_nanopore_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_nanopore_reads","text":"simulate_nanopore_reads(; fasta, quantity, outfile)\n\n\nSimulate Oxford Nanopore sequencing reads using the Badread tool with 2023 error models.\n\nArguments\n\nfasta::String: Path to input reference FASTA file\nquantity::String: Either fold coverage (e.g. \"50x\") or total bases to sequence (e.g. \"1000000\")\noutfile::String: Output path for gzipped FASTQ file. Defaults to input filename with modified extension\n\nReturns\n\nString: Path to the generated output FASTQ file\n\nSee also: simulate_pacbio_reads, simulate_nearly_perfect_long_reads, simulate_short_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_nearly_perfect_long_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_nearly_perfect_long_reads","text":"simulate_nearly_perfect_long_reads()\n\n\nSimulate high-quality long reads with minimal errors using Badread.\n\nArguments\n\nreference::String: Path to reference FASTA file\nquantity::String: Coverage depth (e.g. \"50x\") or total bases (e.g. \"1000000\")\nlength_mean::Int=40000: Mean read length\nlength_sd::Int=20000: Standard deviation of read length\n\nReturns\n\nVector of simulated reads in FASTQ format\n\nDetails\n\nGenerates nearly perfect long reads by setting error rates and artifacts to minimum values. Uses ideal quality scores and disables common sequencing artifacts like chimeras and adapters.\n\nSee also: simulate_pacbio_reads, simulate_nanopore_reads, simulate_short_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_pacbio_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_pacbio_reads","text":"simulate_pacbio_reads(; fasta, quantity, outfile)\n\n\nSimulate PacBio HiFi reads using the Badread error model.\n\nArguments\n\nfasta::String: Path to input FASTA file containing reference sequence\nquantity::String: Coverage depth (e.g. \"50x\") or total bases (e.g. \"1000000\") - NOT TOTAL READS\noutfile::String: Output filepath for simulated reads. Defaults to input filename with \".badread.pacbio2021.{quantity}.fq.gz\" suffix\n\nReturns\n\nString: Path to the generated output file\n\nNotes\n\nRequires Badread tool from Bioconda\nUses PacBio 2021 error and quality score models\nAverage read length ~15kb\nOutput is gzipped FASTQ format\n\nSee also: simulate_nanopore_reads, simulate_nearly_perfect_long_reads, simulate_short_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_variants-Tuple{FASTX.FASTA.Record}","page":"Home","title":"Mycelia.simulate_variants","text":"simulate_variants(\n    fasta_record::FASTX.FASTA.Record;\n    n_variants,\n    window_size,\n    variant_size_disbribution,\n    variant_type_likelihoods\n) -> Any\n\n\nSimulates genetic variants (substitutions, insertions, deletions, inversions) in a DNA sequence.\n\nArguments\n\nfasta_record: Input DNA sequence in FASTA format\n\nKeywords\n\nn_variants=√(sequence_length): Number of variants to generate\nwindow_size=sequence_length/n_variants: Size of windows for variant placement\nvariant_size_disbribution=Geometric(1/√window_size): Distribution for variant sizes\nvariant_type_likelihoods: Vector of pairs mapping variant types to probabilities\n:substitution => 10⁻¹\n:insertion => 10⁻² \n:deletion => 10⁻²\n:inversion => 10⁻²\n\nReturns\n\nDataFrame in VCF format containing simulated variants with columns: CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO, FORMAT, SAMPLE\n\nNotes\n\nVariants are distributed across sequence windows to ensure spread\nVariant sizes are capped by window size\nEquivalent variants are filtered out\nFILTER column indicates variant type\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_variants-Tuple{String}","page":"Home","title":"Mycelia.simulate_variants","text":"simulate_variants(fasta_file::String) -> String\n\n\nSimulates genetic variants from sequences in a FASTA file and generates corresponding VCF records.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing sequences to analyze\n\nDetails\n\nProcesses each record in the input FASTA file\nGenerates simulated variants for each sequence\nCreates a VCF file with the same base name as input file (.vcf extension)\nUpdates sequences with simulated variants in a new FASTA file (.vcf.fna extension)\n\nReturns\n\nPath to the modified FASTA file containing sequences with simulated variants\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sort_contigs_by_length-Tuple{Vector{Mycelia.ContigPath}}","page":"Home","title":"Mycelia.sort_contigs_by_length","text":"Sort contigs by length (descending).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sort_fastq","page":"Home","title":"Mycelia.sort_fastq","text":"sort_fastq(input_fastq) -> String\nsort_fastq(input_fastq, output_fastq) -> Any\n\n\nThis turns a 4-line FASTQ entry into a single tab separated line, adds a column with the length of each read, passes it to Unix sort, removes the length column, and converts it back into a FASTQ file.\n\nsorts longest to shortest!!\n\nhttp://thegenomefactory.blogspot.com/2012/11/sorting-fastq-files-by-sequence-length.html\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.split_gff_attributes_into_columns-Tuple{Any}","page":"Home","title":"Mycelia.split_gff_attributes_into_columns","text":"split_gff_attributes_into_columns(gff_df) -> Any\n\n\nTakes a GFF (General Feature Format) DataFrame and expands the attributes column into separate columns.\n\nArguments\n\ngff_df::DataFrame: A DataFrame containing GFF data with an 'attributes' column formatted as key-value pairs separated by semicolons (e.g., \"ID=gene1;Name=BRCA1;Type=gene\")\n\nReturns\n\nDataFrame: The input DataFrame with additional columns for each attribute key found in the 'attributes' column\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.step_environment!-Tuple{Mycelia.AssemblyEnvironment, Mycelia.AssemblyAction}","page":"Home","title":"Mycelia.step_environment!","text":"step_environment!(env::AssemblyEnvironment, action::AssemblyAction)\n\nExecute an action in the RL environment and return the resulting state and reward.\n\nArguments\n\nenv::AssemblyEnvironment: Environment to step\naction::AssemblyAction: Action to execute\n\nReturns\n\nTuple{AssemblyState, RewardComponents, Bool}: (next_state, reward, done)\nnext_state: State after action execution\nreward: Reward components for the action\ndone: Whether episode is complete\n\nExample\n\naction = AssemblyAction(:continue_k, Dict(), 0.95, 1000, 5)\nnext_state, reward, done = step_environment!(env, action)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.subsample_reads_seqkit-Tuple{}","page":"Home","title":"Mycelia.subsample_reads_seqkit","text":"subsample_reads_seqkit(\n;\n    in_fastq,\n    out_fastq,\n    n_reads,\n    proportion_reads\n)\n\n\nSubsample reads from a FASTQ file using seqkit.\n\nArguments\n\nin_fastq::String: Path to input FASTQ file\nout_fastq::String=\"\": Path to output FASTQ file. If empty, auto-generated based on input filename\nn_reads::Union{Missing,Int}=missing: Number of reads to sample\nproportion_reads::Union{Missing,Float64}=missing: Proportion of reads to sample (0.0-1.0)\n\nReturns\n\nString: Path to the output FASTQ file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sufficient_improvements","page":"Home","title":"Mycelia.sufficient_improvements","text":"Determine if sufficient improvements were made to continue with current k. Enhanced with convergence detection and adaptive thresholds.\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.system_mem_to_minimap_index_size-Tuple{}","page":"Home","title":"Mycelia.system_mem_to_minimap_index_size","text":"system_mem_to_minimap_index_size(\n;\n    system_mem_gb,\n    denominator\n) -> String\n\n\nCompute the minimap2 index size string based on available system memory.\n\nArguments\n\nsystem_mem_gb::Real: Amount of memory (GB) to allocate for indexing.\ndenominator::Real: Factor to scale the memory usage (default Mycelia.DEFAULT_MINIMAP_DENOMINATOR).\n\nReturns\n\nString: Value such as \"4G\" suitable for the minimap2 -I option.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.system_overview-Tuple{}","page":"Home","title":"Mycelia.system_overview","text":"system_overview(\n;\n    path\n) -> @NamedTuple{system_threads::Int64, julia_threads::Int64, total_memory::String, available_memory::String, occupied_memory::String, total_storage::String, available_storage::String, occupied_storage::String}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.tar_extract-Tuple{}","page":"Home","title":"Mycelia.tar_extract","text":"tar_extract(; tarchive, directory)\n\n\nExtract contents of a gzipped tar archive file to a specified directory.\n\nArguments\n\ntarchive::AbstractString: Path to the .tar.gz file to extract\ndirectory::AbstractString=dirname(tarchive): Target directory for extraction (defaults to the archive's directory)\n\nReturns\n\nAbstractString: Path to the directory where contents were extracted\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.tar_gz_files-Tuple{String, Vector{String}}","page":"Home","title":"Mycelia.tar_gz_files","text":"tar_gz_files(output_file::String, input_files::Vector{String})\n\nCreates a tar.gz archive from input_files. Handles many files by writing a file list and using tar -czf ... -T filelist. Appends .tar.gz if missing.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2lca-Tuple{Vector{Int64}}","page":"Home","title":"Mycelia.taxids2lca","text":"taxids2lca(ids::Vector{Int64}) -> Int64\n\n\nCalculate the Lowest Common Ancestor (LCA) taxonomic ID for a set of input taxonomic IDs.\n\nArguments\n\nids::Vector{Int}: Vector of NCBI taxonomic IDs\n\nReturns\n\nInt: The taxonomic ID of the lowest common ancestor\n\nDetails\n\nUses taxonkit to compute the LCA. Automatically sets up the required taxonomy database  if not already present in ~/.taxonkit/.\n\nDependencies\n\nRequires taxonkit (installed via Bioconda)\nRequires taxonomy database (downloaded automatically if missing)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2ncbi_taxonomy_table-Tuple{AbstractVector{Int64}}","page":"Home","title":"Mycelia.taxids2ncbi_taxonomy_table","text":"taxids2ncbi_taxonomy_table(\n    taxids::AbstractVector{Int64}\n) -> DataFrames.DataFrame\n\n\nConvert a vector of NCBI taxonomy IDs into a detailed taxonomy table using NCBI Datasets CLI.\n\nArguments\n\ntaxids::AbstractVector{Int}: Vector of NCBI taxonomy IDs to query\n\nReturns\n\nDataFrame: Table containing taxonomy information with columns including:\ntax_id\nspecies\ngenus\nfamily\norder\nclass\nphylum\nkingdom\n\nDependencies\n\nRequires ncbi-datasets-cli Conda package (automatically installed if missing)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2taxonkit_summarized_lineage_table-Tuple{AbstractVector{Int64}}","page":"Home","title":"Mycelia.taxids2taxonkit_summarized_lineage_table","text":"taxids2taxonkit_summarized_lineage_table(\n    taxids::AbstractVector{Int64}\n) -> DataFrames.DataFrame\n\n\nConvert a vector of taxonomy IDs to a summarized lineage table using taxonkit.\n\nArguments\n\ntaxids::AbstractVector{Int}: Vector of NCBI taxonomy IDs\n\nReturns\n\nDataFrame with the following columns:\n\ntaxid: Original input taxonomy ID\nspecies_taxid, species: Species level taxonomy ID and name\ngenus_taxid, genus: Genus level taxonomy ID and name  \nfamily_taxid, family: Family level taxonomy ID and name\nsuperkingdom_taxid, superkingdom: Superkingdom level taxonomy ID and name\n\nMissing values are used when a taxonomic rank is not available.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2taxonkit_taxid2lineage_ranks-Tuple{AbstractVector{Int64}}","page":"Home","title":"Mycelia.taxids2taxonkit_taxid2lineage_ranks","text":"taxids2taxonkit_taxid2lineage_ranks(\n    taxids::AbstractVector{Int64}\n) -> Dict{Int64, Dict{String, @NamedTuple{lineage::String, taxid::Union{Missing, Int64}}}}\n\n\nConvert taxonomic IDs to a structured lineage rank mapping.\n\nTakes a vector of taxonomic IDs and returns a nested dictionary mapping each input taxid  to its complete taxonomic lineage information. For each taxid, creates a dictionary where:\n\nKeys are taxonomic ranks (e.g., \"species\", \"genus\", \"family\")\nValues are NamedTuples containing:\nlineage::String: The taxonomic name at that rank\ntaxid::Union{Int, Missing}: The corresponding taxonomic ID (if available)\n\nExcludes \"no rank\" entries from the final output.\n\nReturns:     Dict{Int, Dict{String, NamedTuple{(:lineage, :taxid), Tuple{String, Union{Int, Missing}}}}}\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxonomic_id_to_children-Tuple{Any}","page":"Home","title":"Mycelia.taxonomic_id_to_children","text":"taxonomic_id_to_children(\n    tax_id;\n    DATABASE_ID,\n    USERNAME,\n    PASSWORD\n)\n\n\nQuery Neo4j database to find all descendant taxonomic IDs for a given taxonomic ID.\n\nArguments\n\ntax_id: Source taxonomic ID to find children for\nDATABASE_ID: Neo4j database identifier (required)\nUSERNAME: Neo4j database username (default: \"neo4j\")\nPASSWORD: Neo4j database password (required)\n\nReturns\n\nVector{Int}: Sorted array of unique child taxonomic IDs\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.test_cross_validation-Tuple{}","page":"Home","title":"Mycelia.test_cross_validation","text":"Test function for cross-validation with sample data.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.test_intelligent_assembly-Tuple{}","page":"Home","title":"Mycelia.test_intelligent_assembly","text":"Test function to verify the implementation with sample data.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.test_iterative_assembly-Tuple{}","page":"Home","title":"Mycelia.test_iterative_assembly","text":"Test function for iterative assembly with sample data.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.test_rl_framework-Tuple{}","page":"Home","title":"Mycelia.test_rl_framework","text":"test_rl_framework()\n\nTest the reinforcement learning framework with minimal examples.\n\nThis function provides a comprehensive test of the RL infrastructure using small synthetic datasets.\n\nReturns\n\nBool: Whether all tests passed\n\nExample\n\nsuccess = test_rl_framework()\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.train_assembly_agent-Tuple{Vector{String}, Vector{String}}","page":"Home","title":"Mycelia.train_assembly_agent","text":"train_assembly_agent(training_data::Vector{String}, validation_data::Vector{String}; \n                    episodes=1000, episode_length=100)\n\nTrain a reinforcement learning agent for assembly optimization.\n\nThis function implements the complete training loop for the hierarchical RL system.\n\nArguments\n\ntraining_data::Vector{String}: Paths to training FASTQ files\nvalidation_data::Vector{String}: Paths to validation FASTQ files\nepisodes::Int: Number of training episodes (default: 1000)\nepisode_length::Int: Maximum steps per episode (default: 100)\n\nReturns\n\nTuple{DQNPolicy, Vector{Float64}}: (trainedpolicy, trainingrewards)\n\nExample\n\ntraining_files = [\"train1.fastq\", \"train2.fastq\", \"train3.fastq\"]\nvalidation_files = [\"val1.fastq\", \"val2.fastq\"]\npolicy, rewards = train_assembly_agent(training_files, validation_files, episodes=500)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.train_with_curriculum-Tuple{Vector{Dict}, Vector{String}}","page":"Home","title":"Mycelia.train_with_curriculum","text":"train_with_curriculum(curriculum_schedule::Vector{Dict}, validation_data::Vector{String})\n\nTrain the RL agent using curriculum learning.\n\nArguments\n\ncurriculum_schedule::Vector{Dict}: Curriculum stages\nvalidation_data::Vector{String}: Validation datasets\n\nReturns\n\nTuple{DQNPolicy, Vector{Float64}}: (trainedpolicy, stagerewards)\n\nExample\n\ncurriculum = create_curriculum_schedule()\npolicy, rewards = train_with_curriculum(curriculum, validation_files)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.translate_nucleic_acid_fasta-Tuple{Any, Any}","page":"Home","title":"Mycelia.translate_nucleic_acid_fasta","text":"translate_nucleic_acid_fasta(\n    fasta_nucleic_acid_file,\n    fasta_amino_acid_file\n) -> Any\n\n\nTranslates nucleic acid sequences from a FASTA file into amino acid sequences.\n\nArguments\n\nfasta_nucleic_acid_file::String: Path to input FASTA file containing nucleic acid sequences\nfasta_amino_acid_file::String: Path where the translated amino acid sequences will be written\n\nReturns\n\nString: Path to the output FASTA file containing translated amino acid sequences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.transterm_output_to_gff-Tuple{Any}","page":"Home","title":"Mycelia.transterm_output_to_gff","text":"transterm_output_to_gff(transterm_output) -> Any\n\n\nConvert TransTerm terminator predictions output to GFF3 format.\n\nParses TransTerm output and generates a standardized GFF3 file with the following transformations:\n\nSets source field to \"transterm\"\nSets feature type to \"terminator\"  \nConverts terminator IDs to GFF attributes\nRenames fields to match GFF3 spec\n\nArguments\n\ntransterm_output::String: Path to the TransTerm output file\n\nReturns\n\nString: Path to the generated GFF3 file (original filename with .gff extension)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.trim_galore_paired-Tuple{}","page":"Home","title":"Mycelia.trim_galore_paired","text":"trim_galore_paired(; forward_reads, reverse_reads, outdir)\n\n\nTrim paired-end FASTQ reads using Trim Galore, a wrapper around Cutadapt and FastQC.\n\nArguments\n\nforward_reads::String: Path to forward reads FASTQ file\nreverse_reads::String: Path to reverse reads FASTQ file\noutdir::String: Output directory for trimmed files\n\nReturns\n\nTuple{String, String}: Paths to trimmed forward and reverse read files\n\nDependencies\n\nRequires trim_galore conda environment:\n\nmamba create -n trim_galore -c bioconda trim_galore\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.try_local_path_improvements-Tuple{FASTX.FASTQ.Record, Any, Int64, Float64}","page":"Home","title":"Mycelia.try_local_path_improvements","text":"Local heuristic improvements (fallback method). Returns (improvedread, likelihoodimprovement).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.try_statistical_path_resampling-Tuple{FASTX.FASTQ.Record, Any, Int64}","page":"Home","title":"Mycelia.try_statistical_path_resampling","text":"Try statistical path resampling for alternative high-likelihood paths. Returns (improved_read, likelihood) or nothing if no improvement.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.try_viterbi_path_improvement-Tuple{FASTX.FASTQ.Record, Any, Int64}","page":"Home","title":"Mycelia.try_viterbi_path_improvement","text":"Try to improve FASTQ read using Viterbi algorithm from viterbi-next.jl. Returns (improved_read, likelihood) or nothing if no improvement.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.type_to_string-Tuple{AbstractString}","page":"Home","title":"Mycelia.type_to_string","text":"type_to_string(T::AbstractString) -> Any\n\n\nConverts an AbstractString type to its string representation.\n\nArguments\n\nT::AbstractString: The string type to convert\n\nReturns\n\nA string representation of the input type\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.type_to_string-Tuple{Any}","page":"Home","title":"Mycelia.type_to_string","text":"type_to_string(T) -> Any\n\n\nConvert a type to its string representation, with special handling for Kmer types.\n\nArguments\n\nT: The type to convert to string\n\nReturns\n\nString representation of the type\nFor Kmer types: Returns \"Kmers.DNAKmer{K}\" where K is the kmer length\nFor other types: Returns the standard string representation\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.umap_embed-Tuple{AbstractMatrix{<:Real}}","page":"Home","title":"Mycelia.umap_embed","text":"umap_embed(\n    X::AbstractMatrix{<:Real};\n    n_neighbors,\n    min_dist,\n    n_components\n) -> UMAP.UMAP_{S, M, N, D, Matrix{Int64}, I} where {S<:Real, M<:AbstractMatrix{S}, N<:AbstractMatrix{S}, D<:AbstractMatrix{S}, I<:AbstractMatrix{S}}\n\n\numap_embed(scores::AbstractMatrix{<:Real};\n           n_neighbors::Int=15,\n           min_dist::Float64=0.1,\n           n_components::Int=2)\n\nEmbed your PC/EPCA scores (k×nsamples) into `ncomponents` via UMAP.\n\nWhen to use\n\nUse for visualizing high-dimensional data in 2 or 3 dimensions, especially when the data may have nonlinear structure. UMAP is suitable for both continuous and discrete data, and is robust to non-Gaussian distributions. Input should be a matrix of features or dimensionally-reduced scores (e.g., from PCA or EPCA).\n\nArguments\n\nscores      : (components × samples) matrix  \nn_neighbors : UMAP neighborhood size  \nmin_dist    : UMAP min_dist  \nn_components: output dimension (2 or 3)\n\nReturns\n\nmodel        : the trained UMAP.UMAP model  \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.update_bioconda_env-Tuple{Any}","page":"Home","title":"Mycelia.update_bioconda_env","text":"update_bioconda_env(pkg) -> Base.Process\n\n\nUpdate a package and its dependencies in its dedicated Conda environment.\n\nArguments\n\npkg::String: Name of the package/environment to update\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.update_fasta_with_vcf-Tuple{}","page":"Home","title":"Mycelia.update_fasta_with_vcf","text":"update_fasta_with_vcf(; in_fasta, vcf_file, out_fasta)\n\n\nApply variants from a VCF file to a reference FASTA sequence.\n\nArguments\n\nin_fasta: Path to input reference FASTA file\nvcf_file: Path to input VCF file containing variants\nout_fasta: Optional output path for modified FASTA. Defaults to replacing '.vcf' with '.normalized.vcf.fna'\n\nDetails\n\nNormalizes indels in the VCF using bcftools norm\nApplies variants to the reference sequence using bcftools consensus\nHandles temporary files and compression with bgzip/tabix\n\nRequirements\n\nRequires bioconda packages: htslib, tabix, bcftools\n\nReturns\n\nPath to the output FASTA file containing the modified sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.update_gff_with_mmseqs-Tuple{Any, Any}","page":"Home","title":"Mycelia.update_gff_with_mmseqs","text":"update_gff_with_mmseqs(\n    gff_file,\n    mmseqs_file\n) -> DataFrames.DataFrame\n\n\nUpdate GFF annotations with protein descriptions from MMseqs2 search results.\n\nArguments\n\ngff_file::String: Path to input GFF3 format file\nmmseqs_file::String: Path to MMseqs2 easy-search output file\n\nReturns\n\nDataFrame: Modified GFF table with updated attribute columns containing protein descriptions\n\nDetails\n\nTakes sequence matches from MMseqs2 and adds their descriptions as 'label' and 'product'  attributes in the GFF file. Only considers top hits from MMseqs2 results. Preserves existing  GFF attributes while prepending new annotations.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_edge_type_over_url_from_graph-Tuple{}","page":"Home","title":"Mycelia.upload_edge_type_over_url_from_graph","text":"upload_edge_type_over_url_from_graph(\n;\n    src_type,\n    dst_type,\n    edge_type,\n    graph,\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE,\n    window_size\n)\n\n\nUpload edges of a specific type from a MetaGraph to a Neo4j database, batching uploads in windows.\n\nArguments\n\nsrc_type: Type of source nodes to filter\ndst_type: Type of destination nodes to filter  \nedge_type: Type of edges to upload\ngraph: MetaGraph containing the nodes and edges\nADDRESS: Neo4j server URL\nUSERNAME: Neo4j username (default: \"neo4j\")\nPASSWORD: Neo4j password\nDATABASE: Neo4j database name (default: \"neo4j\")\nwindow_size: Number of edges to upload in each batch (default: 100)\n\nDetails\n\nFilters edges based on source, destination and edge types\nPreserves all edge properties except :TYPE when uploading\nUses MERGE operations to avoid duplicate nodes/relationships\nUploads are performed in batches for better performance\nProgress is shown via ProgressMeter\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_node_over_api-Tuple{Any, Any}","page":"Home","title":"Mycelia.upload_node_over_api","text":"upload_node_over_api(\n    graph,\n    v;\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE\n)\n\n\nUpload a single node from a MetaGraph to a Neo4j database using the HTTP API.\n\nArguments\n\ngraph: MetaGraph containing the node to be uploaded\nv: Vertex identifier in the graph\nADDRESS: Neo4j server address (e.g. \"http://localhost:7474\")\nUSERNAME: Neo4j authentication username (default: \"neo4j\")\nPASSWORD: Neo4j authentication password\nDATABASE: Target Neo4j database name (default: \"neo4j\")\n\nDetails\n\nGenerates and executes a Cypher MERGE command using the node's properties. The node's :TYPE  and :identifier properties are used for node labeling, while other non-empty properties  are added as node properties.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_node_table-Tuple{}","page":"Home","title":"Mycelia.upload_node_table","text":"upload_node_table(\n;\n    table,\n    window_size,\n    address,\n    password,\n    username,\n    database,\n    neo4j_import_dir\n)\n\n\nUpload a DataFrame to Neo4j as nodes in batched windows.\n\nArguments\n\ntable::DataFrame: Input DataFrame where each row becomes a node. Must contain a \"TYPE\" column.\naddress::String: Neo4j server address (e.g. \"bolt://localhost:7687\")\npassword::String: Neo4j database password\nneo4j_import_dir::String: Directory path accessible to Neo4j for importing files\nwindow_size::Int=1000: Number of rows to process in each batch\nusername::String=\"neo4j\": Neo4j database username\ndatabase::String=\"neo4j\": Target Neo4j database name\n\nNotes\n\nAll rows must have the same node type (specified in \"TYPE\" column)\nColumn names become node properties\nRequires write permissions on neo4jimportdir\nLarge tables are processed in batches of size window_size\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_node_type_over_url_from_graph-Tuple{}","page":"Home","title":"Mycelia.upload_node_type_over_url_from_graph","text":"upload_node_type_over_url_from_graph(\n;\n    node_type,\n    graph,\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE,\n    window_size\n)\n\n\nUpload nodes of a specific type from a graph to a Neo4j database using MERGE operations.\n\nArguments\n\nnode_type: The type label for the nodes to upload\ngraph: Source MetaGraph containing the nodes\nADDRESS: Neo4j server address (e.g. \"bolt://localhost:7687\")\nPASSWORD: Neo4j database password\nUSERNAME=\"neo4j\": Neo4j username (defaults to \"neo4j\")\nDATABASE=\"neo4j\": Target Neo4j database name (defaults to \"neo4j\")\nwindow_size=100: Number of nodes to upload in each batch (defaults to 100)\n\nDetails\n\nPerforms batched uploads of nodes using Neo4j MERGE operations. Node properties are  automatically extracted from the graph vertex properties, excluding the 'TYPE' property.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_nodes_over_api-Tuple{Any}","page":"Home","title":"Mycelia.upload_nodes_over_api","text":"upload_nodes_over_api(\n    graph;\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE\n)\n\n\nUploads all nodes from the given graph to a specified API endpoint.\n\nArguments\n\ngraph: The graph containing the nodes to be uploaded.\nADDRESS: The API endpoint address.\nUSERNAME: The username for authentication (default: \"neo4j\").\nPASSWORD: The password for authentication.\nDATABASE: The database name (default: \"neo4j\").\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_nodes_to_neo4j-Tuple{}","page":"Home","title":"Mycelia.upload_nodes_to_neo4j","text":"upload_nodes_to_neo4j(\n;\n    graph,\n    address,\n    username,\n    password,\n    format,\n    database,\n    neo4j_import_directory\n)\n\n\nUpload all nodes from a MetaGraph to a Neo4j database, processing each unique node type separately.\n\nArguments\n\ngraph: A MetaGraph containing nodes to be uploaded\naddress: Neo4j server address (e.g., \"bolt://localhost:7687\")\nusername: Neo4j authentication username (default: \"neo4j\")\npassword: Neo4j authentication password\nformat: Data format for upload (default: \"auto\")\ndatabase: Target Neo4j database name (default: \"neo4j\")\nneo4j_import_directory: Path to Neo4j's import directory for bulk loading\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.validate_assemblies_against_holdout-Tuple{Dict, Dict, Vector{<:FASTX.FASTQ.Record}, Int64, String}","page":"Home","title":"Mycelia.validate_assemblies_against_holdout","text":"Validate assemblies against holdout validation data through read mapping.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.validate_assembly-Tuple{Mycelia.AssemblyResult}","page":"Home","title":"Mycelia.validate_assembly","text":"validate_assembly(assembly::AssemblyResult; reference=nothing) -> Dict{String, Any}\n\nValidate assembly quality using various metrics and optional reference comparison.\n\nArguments\n\nassembly: Assembly result to validate\nreference: Optional reference sequence for comparison\n\nReturns\n\nDict{String, Any}: Comprehensive validation metrics\n\nDetails\n\nComputes assembly quality metrics including:\n\nN50, N90 statistics\nTotal assembly length and number of contigs\nCoverage uniformity (if reference provided)\nStructural variant detection (if reference provided)\nGap analysis and repeat characterization\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.vcat_with_missing-Tuple{Vararg{DataFrames.AbstractDataFrame}}","page":"Home","title":"Mycelia.vcat_with_missing","text":"vcat_with_missing(\n    dfs::DataFrames.AbstractDataFrame...\n) -> Union{DataFrames.DataFrame, Vector{Any}}\n\n\nVertically concatenate DataFrames with different column structures by automatically handling missing values.\n\nArguments\n\ndfs: Variable number of DataFrames to concatenate vertically\n\nReturns\n\nDataFrame: Combined DataFrame containing all rows and columns from input DataFrames,  with missing values where columns didn't exist in original DataFrames\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.visualize_genome_coverage-Tuple{Any}","page":"Home","title":"Mycelia.visualize_genome_coverage","text":"visualize_genome_coverage(coverage_table) -> Any\n\n\nCreates a multi-panel visualization of genome coverage across chromosomes.\n\nArguments\n\ncoverage_table: DataFrame containing columns \"chromosome\" and \"coverage\" with genomic coverage data\n\nReturns\n\nPlots.Figure: A composite figure with coverage plots for each chromosome\n\nDetails\n\nGenerates one subplot per chromosome, arranged vertically. Each subplot shows the coverage  distribution across genomic positions for that chromosome.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.viterbi_batch_process","page":"Home","title":"Mycelia.viterbi_batch_process","text":"viterbi_batch_process(graph::MetaGraph, sequences::Vector, config::ViterbiConfig) -> Vector{ViterbiPath}\n\nProcess multiple sequences in batches for memory efficiency.\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.viterbi_decode_next","page":"Home","title":"Mycelia.viterbi_decode_next","text":"viterbi_decode_next(graph::MetaGraph, observations::Vector, config::ViterbiConfig) -> ViterbiPath\n\nEnhanced Viterbi decoding with strand awareness and memory efficiency.\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.viterbi_maximum_likelihood_traversals-Tuple{Any}","page":"Home","title":"Mycelia.viterbi_maximum_likelihood_traversals","text":"viterbi_maximum_likelihood_traversals(\n    stranded_kmer_graph;\n    error_rate,\n    verbosity\n) -> Vector{FASTX.FASTA.Record}\n\n\nFinds maximum likelihood paths through a stranded k-mer graph using the Viterbi algorithm to correct sequencing errors.\n\nArguments\n\nstranded_kmer_graph: A directed graph where vertices represent k-mers and edges represent overlaps\nerror_rate::Float64: Expected per-base error rate (default: 1/(k+1)). Must be < 0.5\nverbosity::String: Output detail level (\"debug\", \"reads\", or \"dataset\")\n\nReturns\n\nVector of FASTX.FASTA.Record containing error-corrected sequences\n\nDetails\n\nUses dynamic programming to find most likely path through k-mer graph\nAccounts for matches, mismatches, insertions and deletions\nState likelihoods based on k-mer coverage counts\nTransition probabilities derived from error rate\nProgress tracking based on verbosity level\n\nNotes\n\nError rate should be probability of error (e.g. 0.01 for 1%), not accuracy\nHigher verbosity levels (\"debug\", \"reads\") provide detailed path finding information\n\"dataset\" verbosity shows only summary statistics\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.wcss-Tuple{Any}","page":"Home","title":"Mycelia.wcss","text":"wcss(clustering_result) -> Any\n\n\nCalculate the Within-Cluster Sum of Squares (WCSS) for a clustering result.\n\nArguments\n\nclustering_result: A clustering result object containing:\ncounts: Vector with number of points in each cluster\nassignments: Vector of cluster assignments for each point\ncosts: Vector of distances/costs from each point to its cluster center\n\nReturns\n\nFloat64: The total within-cluster sum of squared distances\n\nDescription\n\nWCSS measures the compactness of clusters by summing the squared distances  between each data point and its assigned cluster center.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_biosequence_gfa-Tuple{MetaGraphsNext.MetaGraph, AbstractString}","page":"Home","title":"Mycelia.write_biosequence_gfa","text":"write_biosequence_gfa(\n    graph::MetaGraphsNext.MetaGraph,\n    output_file::AbstractString\n)\n\n\nWrite a BioSequence graph to GFA format.\n\nArguments\n\ngraph: MetaGraphsNext BioSequence graph\noutput_file: Path to output GFA file\n\nExample\n\nwrite_biosequence_gfa(graph, \"assembly.gfa\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_fasta-Tuple{}","page":"Home","title":"Mycelia.write_fasta","text":"write_fasta(; outfile, records, gzip)\n\n\nWrites FASTA records to a file, optionally gzipped.\n\nArguments\n\noutfile::AbstractString: Path to the output FASTA file.  Will append \".gz\" if gzip is true and \".gz\" isn't already the extension.\nrecords::Vector{FASTX.FASTA.Record}: A vector of FASTA records.\ngzip::Bool: Optionally force compression of the output with gzip. By default will use the file name to infer.\n\nReturns\n\noutfile::String: The path to the output FASTA file (including \".gz\" if applicable).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_fastas_from_normalized_fastx_tables-Tuple{Vector{String}}","page":"Home","title":"Mycelia.write_fastas_from_normalized_fastx_tables","text":"write_fastas_from_normalized_fastx_tables(\n    table_paths::Vector{String};\n    output_dir::String = pwd(),\n    show_progress::Bool = true,\n    overwrite::Bool = false,\n    error_handler = (e, table_path)->display((e, table_path))\n) -> NamedTuple\n\nGiven a vector of normalized fastx table paths, writes out gzipped FASTA files in parallel. Each table must have columns: \"fastxsha256\", \"recordsha256\", \"record_sequence\". Automatically decompresses input files if they end with \".gz\". Returns a summary NamedTuple with successes, failures, failed tables, and output files.\n\nKeyword Arguments\n\noutput_dir: Directory to write .fna.gz files to.\nshow_progress: Show a progress bar (default: true).\noverwrite: Overwrite existing files (default: false).\nerror_handler: Function called with (exception, table_path) on error.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_fastq-Tuple{}","page":"Home","title":"Mycelia.write_fastq","text":"write_fastq(;records, filename, gzip=false)\n\nwrite_fastq(; records, filename, gzip)\n\n\nWrite FASTQ records to file using FASTX.jl. Validates extension: .fastq, .fq, .fastq.gz, or .fq.gz. If gzip is true or filename endswith .gz, output is gzipped. records must be an iterable of FASTX.FASTQ.Record.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_gfa_next-Tuple{MetaGraphsNext.MetaGraph, AbstractString}","page":"Home","title":"Mycelia.write_gfa_next","text":"write_gfa_next(\n    graph::MetaGraphsNext.MetaGraph,\n    outfile::AbstractString\n) -> AbstractString\n\n\nWrite a MetaGraphsNext k-mer graph to GFA (Graphical Fragment Assembly) format.\n\nThis function exports strand-aware k-mer graphs to standard GFA format, handling:\n\nCanonical k-mer vertices as segments (S lines)\nStrand-aware edges as links (L lines) with proper orientations\nCoverage information as depth annotations\n\nArguments\n\ngraph: MetaGraphsNext k-mer graph with strand-aware edges\noutfile: Path where the GFA file should be written\n\nReturns\n\nPath to the written GFA file\n\nGFA Format\n\nThe output follows GFA v1.0 specification:\n\nHeader (H) line with version\nSegment (S) lines: vertexid, canonicalk-mer_sequence, depth\nLink (L) lines: sourceid, sourceorientation, targetid, targetorientation, overlap\n\nExample\n\ngraph = build_kmer_graph_next(DNAKmer{3}, observations)\nwrite_gfa_next(graph, \"assembly.gfa\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_gff-Tuple{}","page":"Home","title":"Mycelia.write_gff","text":"write_gff(; gff, outfile)\n\n\nWrite GFF (General Feature Format) data to a tab-delimited file.\n\nArguments\n\ngff: DataFrame/Table containing GFF formatted data\noutfile: String path where the output file should be written\n\nReturns\n\nString: Path to the written output file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_quality_biosequence_gfa-Tuple{MetaGraphsNext.MetaGraph, AbstractString}","page":"Home","title":"Mycelia.write_quality_biosequence_gfa","text":"write_quality_biosequence_gfa(\n    graph::MetaGraphsNext.MetaGraph,\n    output_file::AbstractString\n)\n\n\nWrite a quality-aware BioSequence graph to GFA format with quality information.\n\nArguments\n\ngraph: Quality-aware BioSequence graph\noutput_file: Path to output GFA file\n\nExample\n\nwrite_quality_biosequence_gfa(graph, \"assembly_with_quality.gfa\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_tsvgz-Tuple{}","page":"Home","title":"Mycelia.write_tsvgz","text":"write_tsvgz(df::DataFrames.DataFrame, filename::String; buffer_in_memory::Bool=false, threaded::Bool=true, bufsize::Int=10*1024*1024, force::Bool=false)\n\nWrite a DataFrame to a gzipped TSV file.\n\nArguments\n\ndf: The DataFrame to write\nfilename: Path to the output file (will add .tsv.gz extension as needed)\nbuffer_in_memory: If false, uses temporary files for large data (default: false)\nbufsize: Buffer size in bytes for compression stream (default: 10MB)\nforce: If true, overwrite existing non-empty files (default: false)\n\nReturns\n\nString: The final filename with proper extension\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_vcf_table-Tuple{}","page":"Home","title":"Mycelia.write_vcf_table","text":"write_vcf_table(; vcf_file, vcf_table, fasta_file)\n\n\nWrite variant data to a VCF v4.3 format file.\n\nArguments\n\nvcf_file::String: Output path for the VCF file\nvcf_table::DataFrame: Table containing variant data with standard VCF columns\nfasta_file::String: Path to the reference genome FASTA file\n\nDetails\n\nAutomatically filters out equivalent variants where REF == ALT. Includes standard VCF headers for substitutions, insertions, deletions, and inversions. Adds GT (Genotype) and GQ (Genotype Quality) format fields.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.xam_to_contig_mapping_stats-Tuple{Any}","page":"Home","title":"Mycelia.xam_to_contig_mapping_stats","text":"xam_to_contig_mapping_stats(xam) -> Any\n\n\nGenerate detailed mapping statistics for each reference sequence/contig in a XAM (SAM/BAM/CRAM) file.\n\nArguments\n\nxam: Path to XAM file or XAM object\n\nReturns\n\nA DataFrame with per-contig statistics including:\n\nn_aligned_reads: Number of aligned reads\ntotal_aligned_bases: Sum of alignment lengths\ntotal_alignment_score: Sum of alignment scores\nMapping quality statistics (mean, std, median)\nAlignment length statistics (mean, std, median)\nAlignment score statistics (mean, std, median)\nPercent mismatches statistics (mean, std, median)\n\nNote: Only primary alignments (isprimary=true) and mapped reads (ismapped=true) are considered.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.xam_to_dataframe-Tuple{String}","page":"Home","title":"Mycelia.xam_to_dataframe","text":"xam_to_dataframe(xam_path::String) -> DataFrames.DataFrame\n\n\nConvert a SAM/BAM file to a DataFrame using the open_xam function.\n\nParameters:\n\nxam_path: Path to the SAM/BAM file\nheader: Whether to include the header (default: false)\n\nReturns:\n\nA DataFrame containing the parsed data\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.xam_to_dataframe-Tuple{XAM.SAM.Reader}","page":"Home","title":"Mycelia.xam_to_dataframe","text":"xam_to_dataframe(\n    reader::XAM.SAM.Reader\n) -> DataFrames.DataFrame\n\n\nConvert SAM/BAM records from a XAM.SAM.Reader into a DataFrame.\n\nParameters:\n\nreader: A XAM.SAM.Reader object for iterating over records\n\nReturns:\n\nA DataFrame containing all record data in a structured format\n\n\n\n\n\n","category":"method"}]
}
