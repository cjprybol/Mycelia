var documenterSearchIndex = {"docs":
[{"location":"#Mycelia-Documentation","page":"Home","title":"Mycelia Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the Mycelia documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"more","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install Julia (if not already installed)","category":"page"},{"location":"","page":"Home","title":"Home","text":"I have had trouble getting the visualization libraries Plots.jl and Makie.jl (and associated packages) to load correctly on HPC due to the complexities of the default LDLIBRARYPATH","category":"page"},{"location":"","page":"Home","title":"Home","text":"I imagine other research supercomputer users may have similar issues, although I don't have these issues on cloud vendors like GCP or AWS","category":"page"},{"location":"","page":"Home","title":"Home","text":"To enable Julia to install all of it's own necessary dependencies independent of the system, I reset the LDLIBRARYPATH variable prior to launching Julia !!","category":"page"},{"location":"","page":"Home","title":"Home","text":"This can be done easily when launching Julia from the command line by","category":"page"},{"location":"","page":"Home","title":"Home","text":"export LD_LIBRARY_PATH=\"\" && julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"And can be done for Julia jupyter kernels by setting the env key => value pair in the appropriate kernel.json file","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clone the repo directly","category":"page"},{"location":"","page":"Home","title":"Home","text":"cd /path/where/you/want/the/repo\n# for production usage\ngit clone https://github.com/cjprybol/Mycelia.git\n# for development\ngit clone git@github.com:cjprybol/Mycelia.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or as Julia package","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\n# for production usage\nPkg.add(url=\"https://github.com/cjprybol/Mycelia.git\")\n# for development\nPkg.develop(url=\"git@github.com:cjprybol/Mycelia.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Mycelia]","category":"page"},{"location":"#Mycelia.add_bioconda_env-Tuple{Any}","page":"Home","title":"Mycelia.add_bioconda_env","text":"add_bioconda_env(pkg; force) -> Union{Nothing, Base.Process}\n\n\nCreate a new Conda environment with a specified Bioconda package.\n\nArguments\n\npkg::String: Package name to install. Can include channel specification using  the format \"channel::package\"\n\nKeywords\n\nforce::Bool=false: If true, recreates the environment even if it already exists\n\nDetails\n\nThe function creates a new Conda environment named after the package and installs the package into it. It uses channel priority: conda-forge > bioconda > defaults. If CONDA_RUNNER is set to 'mamba', it will ensure mamba is installed first.\n\nExamples\n\n# Install basic package\nadd_bioconda_env(\"blast\")\n\n# Install from specific channel\nadd_bioconda_env(\"bioconda::blast\")\n\n# Force reinstallation\nadd_bioconda_env(\"blast\", force=true)\n\nNotes\n\nRequires Conda.jl to be installed and configured\nUses CONDA_RUNNER global variable to determine whether to use conda or mamba\nCleans conda cache after installation\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.add_edgemer_to_graph!-NTuple{4, Any}","page":"Home","title":"Mycelia.add_edgemer_to_graph!","text":"add_edgemer_to_graph!(\n    graph,\n    record_identifier,\n    index,\n    observed_edgemer\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.add_fastx_records_to_graph!-Tuple{Any, Any}","page":"Home","title":"Mycelia.add_fastx_records_to_graph!","text":"add_fastx_records_to_graph!(graph, fastxs) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.add_record_edgemers_to_graph!-Tuple{Any}","page":"Home","title":"Mycelia.add_record_edgemers_to_graph!","text":"add_record_edgemers_to_graph!(graph) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.amino_acids_to_codons-Tuple{}","page":"Home","title":"Mycelia.amino_acids_to_codons","text":"amino_acids_to_codons(\n\n) -> Dict{BioSymbols.AminoAcid, DataType}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.annotate_aa_fasta-Tuple{}","page":"Home","title":"Mycelia.annotate_aa_fasta","text":"annotate_aa_fasta(\n;\n    fasta,\n    identifier,\n    basedir,\n    mmseqsdb,\n    threads\n)\n\n\nAnnotate amino acid sequences in a FASTA file using MMseqs2 search against UniRef50 database.\n\nArguments\n\nfasta: Path to input FASTA file containing amino acid sequences\nidentifier: Name for the output directory (defaults to FASTA filename without extension)\nbasedir: Base directory for output (defaults to current directory)\nmmseqsdb: Path to MMseqs2 formatted UniRef50 database (defaults to ~/workspace/mmseqs/UniRef50)\nthreads: Number of CPU threads to use (defaults to system thread count)\n\nReturns\n\nPath to the output directory containing MMseqs2 search results\n\nThe function creates a new directory named by identifier under basedir, copies the input FASTA file, and runs MMseqs2 easy-search against the specified database. If the output directory already exists, the function skips processing and returns the directory path.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.annotate_fasta-Tuple{}","page":"Home","title":"Mycelia.annotate_fasta","text":"annotate_fasta(\n;\n    fasta,\n    identifier,\n    basedir,\n    mmseqsdb,\n    threads\n)\n\n\nPerform comprehensive annotation of a FASTA file including gene prediction, protein homology search, and terminator prediction.\n\nArguments\n\nfasta::String: Path to input FASTA file\nidentifier::String: Unique identifier for output directory (default: FASTA filename without extension)\nbasedir::String: Base directory for output (default: current working directory)\nmmseqsdb::String: Path to MMseqs2 UniRef50 database (default: \"~/workspace/mmseqs/UniRef50\")\nthreads::Int: Number of CPU threads to use (default: all available)\n\nProcessing Steps\n\nCreates output directory and copies input FASTA\nRuns Prodigal for gene prediction (nucleotide, amino acid, and GFF output)\nPerforms MMseqs2 homology search against UniRef50\nPredicts terminators using TransTerm\nCombines annotations into a unified GFF file\nGenerates GenBank format output\n\nReturns\n\nString: Path to the output directory containing all generated files\n\nFiles Generated\n\n.prodigal.fna: Predicted genes (nucleotide)\n.prodigal.faa: Predicted proteins\n.prodigal.gff: Prodigal GFF annotations\n.gff: Combined annotations\n.gff.genbank: Final GenBank format\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_alignment-Tuple{Any, Any}","page":"Home","title":"Mycelia.assess_alignment","text":"assess_alignment(\n    a,\n    b\n) -> @NamedTuple{total_matches::Int64, total_edits::Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_alignment_accuracy-Tuple{Any}","page":"Home","title":"Mycelia.assess_alignment_accuracy","text":"assess_alignment_accuracy(alignment_result) -> Any\n\n\nReturn proportion of matched bases in alignment to total matches + edits.\n\n0-1, not %\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_assembly_quality-Tuple{}","page":"Home","title":"Mycelia.assess_assembly_quality","text":"assess_assembly_quality(; assembly, observations, ks)\n\n\nEvaluate genome assembly quality by comparing k-mer distributions between assembled sequences and raw observations.\n\nArguments\n\nassembly: Input assembled sequences to evaluate\nobservations: Raw sequencing data for comparison\nks::Vector{Int}: Vector of k-mer sizes to analyze (default: k=17 to 23)\n\nReturns\n\nDataFrame containing quality metrics for each k-mer size:\n\nk: K-mer length used\ncosine_distance: Cosine similarity between k-mer distributions\njs_divergence: Jensen-Shannon divergence between distributions  \nqv: MerQury-style quality value score\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_dnamer_saturation-Tuple{AbstractString}","page":"Home","title":"Mycelia.assess_dnamer_saturation","text":"assess_dnamer_saturation(\n    fastx::AbstractString;\n    power,\n    outdir,\n    min_k,\n    max_k,\n    threshold,\n    kmers_to_assess\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_dnamer_saturation-Tuple{AbstractVector{<:AbstractString}, Any}","page":"Home","title":"Mycelia.assess_dnamer_saturation","text":"assess_dnamer_saturation(\n    fastxs::AbstractVector{<:AbstractString},\n    kmer_type;\n    kmers_to_assess,\n    power,\n    min_count\n) -> Union{@NamedTuple{sampling_points::Vector{Int64}, unique_kmer_counts::Vector{Int64}}, NamedTuple{(:sampling_points, :unique_kmer_counts, :eof), <:Tuple{Vector, Vector{Int64}, Bool}}}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_dnamer_saturation-Tuple{AbstractVector{<:AbstractString}}","page":"Home","title":"Mycelia.assess_dnamer_saturation","text":"assess_dnamer_saturation(\n    fastxs::AbstractVector{<:AbstractString};\n    power,\n    outdir,\n    min_k,\n    max_k,\n    threshold,\n    kmers_to_assess,\n    plot\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_optimal_kmer_alignment-Tuple{Any, Any}","page":"Home","title":"Mycelia.assess_optimal_kmer_alignment","text":"assess_optimal_kmer_alignment(\n    kmer,\n    observed_kmer\n) -> Tuple{@NamedTuple{total_matches::Int64, total_edits::Int64}, Union{Missing, Bool}}\n\n\nUsed to determine which orientation provides an optimal alignment for initiating path likelihood analyses in viterbi analysis\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.bam_to_fastq-Tuple{}","page":"Home","title":"Mycelia.bam_to_fastq","text":"bam_to_fastq(; bam, fastq)\n\n\nConvert a BAM file to FASTQ format with gzip compression.\n\nArguments\n\nbam: Path to input BAM file\nfastq: Optional output path. Defaults to input path with \".fq.gz\" extension\n\nReturns\n\nPath to the generated FASTQ file\n\nDetails\n\nUses samtools through conda environment\nAutomatically skips if output file exists\nOutput is gzip compressed\nRequires samtools to be available via conda\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.bandage_visualize-Tuple{}","page":"Home","title":"Mycelia.bandage_visualize","text":"bandage_visualize(; gfa, img)\n\n\nGenerate a visualization of a genome assembly graph using Bandage.\n\nArguments\n\ngfa: Path to input GFA (Graphical Fragment Assembly) file\nimg: Optional output image path. Defaults to GFA filename with .png extension\n\nReturns\n\nPath to the generated image file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.biosequences_to_counts_table-Tuple{}","page":"Home","title":"Mycelia.biosequences_to_counts_table","text":"biosequences_to_counts_table(; biosequences, k)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.biosequences_to_dense_counts_table-Tuple{}","page":"Home","title":"Mycelia.biosequences_to_dense_counts_table","text":"biosequences_to_dense_counts_table(; biosequences, k)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.blastdb2table-Tuple{}","page":"Home","title":"Mycelia.blastdb2table","text":"blastdb2table(; blastdb, outfile, force)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.blastdb_to_fasta-Tuple{}","page":"Home","title":"Mycelia.blastdb_to_fasta","text":"blastdb_to_fasta(; db, dbdir, compressed, outfile)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.build_directed_kmer_graph-Tuple{}","page":"Home","title":"Mycelia.build_directed_kmer_graph","text":"build_directed_kmer_graph(; fastq, k, plot)\n\n\nConstructs a directed graph representation of k-mer transitions from FASTQ sequencing data.\n\nArguments\n\nfastq: Path to input FASTQ file\nk: K-mer size (default: 1). Must be odd and prime. If k=1, optimal size is auto-determined\nplot: Boolean to display quality distribution plot (default: false)\n\nReturns\n\nMetaDiGraph with properties:\n\nassembly_k: k-mer size used\nkmer_counts: frequency of each k-mer\ntransition_likelihoods: edge weights between k-mers\nkmermeanquality, kmertotalquality: quality metrics\nbranchingnodes, unbranchingnodes: topological classification\nlikelyvalidkmer_indices: k-mers above mean quality threshold\nlikelysequencingartifact_indices: potential erroneous k-mers\n\nNote\n\nFor DNA assembly, quality scores are normalized across both strands.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.build_stranded_kmer_graph-Tuple{Any, AbstractVector{<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}}","page":"Home","title":"Mycelia.build_stranded_kmer_graph","text":"build_stranded_kmer_graph(\n    kmer_type,\n    observations::AbstractVector{<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}\n) -> MetaGraphs.MetaDiGraph{T, Float64} where T<:Integer\n\n\nCreate a weighted, strand-specific kmer (de bruijn) graph from a set of kmers and a series of sequence observations in FASTA format.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.canonicalize_kmer_counts!-Tuple{Any}","page":"Home","title":"Mycelia.canonicalize_kmer_counts!","text":"canonicalize_kmer_counts!(kmer_counts) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.canonicalize_kmer_counts-Tuple{Any}","page":"Home","title":"Mycelia.canonicalize_kmer_counts","text":"canonicalize_kmer_counts(kmer_counts) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.chromosome_coverage_table_to_plot-Tuple{Any}","page":"Home","title":"Mycelia.chromosome_coverage_table_to_plot","text":"chromosome_coverage_table_to_plot(cdf) -> Plots.Plot\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.codon_optimize-Tuple{}","page":"Home","title":"Mycelia.codon_optimize","text":"codon_optimize(\n;\n    normalized_codon_frequencies,\n    protein_sequence,\n    n_iterations\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.codons_to_amino_acids-Tuple{}","page":"Home","title":"Mycelia.codons_to_amino_acids","text":"codons_to_amino_acids(\n\n) -> Union{Dict{_A, BioSequences.LongAA} where _A, Dict{_A, V} where {_A, V<:(Kmers.Kmer{BioSequences.AminoAcidAlphabet, _A, _B} where {_B, _A})}}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.concatenate_files-Tuple{}","page":"Home","title":"Mycelia.concatenate_files","text":"concatenate_files(; files, file)\n\n\nJoin fasta files without any regard to record uniqueness.\n\nA cross-platform version of cat *.fasta > joint.fasta\n\nSee mergefastafiles\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.contig_is_circular-Tuple{String, String}","page":"Home","title":"Mycelia.contig_is_circular","text":"contig_is_circular(\n    graph_file::String,\n    contig_name::String\n) -> Any\n\n\nReturns bool indicating whether the contig is a circle\n\ngraphfile = path to assembly graph.gfa file contigname = name of the contig\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.contig_is_cleanly_assembled-Tuple{String, String}","page":"Home","title":"Mycelia.contig_is_cleanly_assembled","text":"contig_is_cleanly_assembled(\n    graph_file::String,\n    contig_name::String\n) -> Bool\n\n\nReturns bool indicating whether the contig is cleanly assembled.\n\nBy cleanly assembled we mean that the contig does not have other contigs attached in the same connected component.\n\ngraphfile = path to assembly graph.gfa file contigname = name of the contig\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.convert-Tuple{Any}","page":"Home","title":"Mycelia.convert","text":"convert(args)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.convert_sequence-Tuple{AbstractString}","page":"Home","title":"Mycelia.convert_sequence","text":"convert_sequence(seq::AbstractString)\n\nConverts the given sequence (output from FASTX.sequence) into the appropriate BioSequence type:\n\nDNA sequences are converted using BioSequences.LongDNA\nRNA sequences are converted using BioSequences.LongRNA\nAA sequences are converted using BioSequences.LongAA\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.copy_to_tempdir-Tuple{String}","page":"Home","title":"Mycelia.copy_to_tempdir","text":"copy_to_tempdir(file_path::String) -> String\n\n\nCreate a copy of a file in a temporary directory while preserving the original filename.\n\nArguments\n\nfile_path::String: Path to the source file to be copied\n\nReturns\n\nString: Path to the newly created temporary file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.copy_with_unique_identifier-Tuple{Any, Any, Any}","page":"Home","title":"Mycelia.copy_with_unique_identifier","text":"copy_with_unique_identifier(\n    infile,\n    out_directory,\n    unique_identifier;\n    force\n) -> Any\n\n\nCopy a file to a new location with a unique identifier prepended to the filename.\n\nArguments\n\ninfile::AbstractString: Path to the source file to copy\nout_directory::AbstractString: Destination directory for the copied file\nunique_identifier::AbstractString: String to prepend to the filename\nforce::Bool=true: If true, overwrite existing files\n\nReturns\n\nString: Path to the newly created file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_canonical_kmers-Union{Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, Any}} where KMER_TYPE","page":"Home","title":"Mycelia.count_canonical_kmers","text":"count_canonical_kmers(_::Type{KMER_TYPE}, sequences) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, AbstractString}} where KMER_TYPE","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    fastx_file::AbstractString\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{K}, Tuple{A}, Tuple{Type{Kmers.Mer{K, A}}, BioSequences.LongSequence}} where {A<:BioSequences.AminoAcidAlphabet, K}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.AminoAcidAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> OrderedCollections.OrderedDict{K, Int64} where K<:(Kmers.Kmer{BioSequences.AminoAcidAlphabet, _A, _B} where {_B, _A})\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{K}, Tuple{A}, Tuple{Type{Kmers.Mer{K, A}}, BioSequences.LongSequence}} where {A<:BioSequences.DNAAlphabet, K}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.DNAAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{K}, Tuple{A}, Tuple{Type{Kmers.Mer{K, A}}, BioSequences.LongSequence}} where {A<:BioSequences.RNAAlphabet, K}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.RNAAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{R}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, R}} where {KMER_TYPE, R<:Union{FASTX.FASTA.Reader, FASTX.FASTQ.Reader}}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    sequences::Union{FASTX.FASTA.Reader, FASTX.FASTQ.Reader}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{R}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, R}} where {KMER_TYPE, R<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    record::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{T}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, AbstractVector{T}}} where {KMER_TYPE, T<:AbstractString}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    fastx_files::AbstractArray{T<:AbstractString, 1}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{T}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, AbstractVector{T}}} where {KMER_TYPE, T<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    records::AbstractArray{T<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}, 1}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_matrix_to_probability_matrix-Tuple{Any}","page":"Home","title":"Mycelia.count_matrix_to_probability_matrix","text":"count_matrix_to_probability_matrix(counts_matrix) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_records-Tuple{Any}","page":"Home","title":"Mycelia.count_records","text":"count_records(fastx) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.countmap_columns-Tuple{Any}","page":"Home","title":"Mycelia.countmap_columns","text":"countmap_columns(table)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_database-Tuple{}","page":"Home","title":"Mycelia.create_database","text":"create_database(; database, address, username, password)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_node_constraints-Tuple{Any}","page":"Home","title":"Mycelia.create_node_constraints","text":"create_node_constraints(\n    graph;\n    address,\n    username,\n    password,\n    database\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_tarchive-Tuple{}","page":"Home","title":"Mycelia.create_tarchive","text":"create_tarchive(; directory, tarchive)\n\n\nCreates a gzipped tar archive of the specified directory along with verification files.\n\nArguments\n\ndirectory: Source directory path to archive\ntarchive: Optional output archive path (defaults to directory name with .tar.gz extension)\n\nGenerated Files\n\n{tarchive}: The compressed tar archive\n{tarchive}.log: Contents listing of the archive\n{tarchive}.hashdeep.dfxml: Cryptographic hashes (MD5, SHA1, SHA256) of the archive\n\nReturns\n\nPath to the created tar archive file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.cypher-Tuple{Any}","page":"Home","title":"Mycelia.cypher","text":"cypher(\n    cmd;\n    address,\n    username,\n    password,\n    format,\n    database\n) -> Cmd\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.deduplicate_fasta_file-Tuple{Any, Any}","page":"Home","title":"Mycelia.deduplicate_fasta_file","text":"deduplicate_fasta_file(in_fasta, out_fasta) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.detect_alphabet-Tuple{AbstractString}","page":"Home","title":"Mycelia.detect_alphabet","text":"detect_alphabet(seq::AbstractString) -> Symbol\n\nDetermines the alphabet of a sequence. The function scans through seq only once:\n\nIf a 'T' or 't' is found (and no 'U/u'), the sequence is classified as DNA.\nIf a 'U' or 'u' is found (and no 'T/t'), it is classified as RNA.\nIf both T and U occur, an error is thrown.\nIf a character outside the canonical nucleotide and ambiguity codes is encountered, the sequence is assumed to be protein.\nIf neither T nor U are found, the sequence is assumed to be DNA.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_fasta_coverage-Tuple{Any}","page":"Home","title":"Mycelia.determine_fasta_coverage","text":"determine_fasta_coverage(bam) -> Any\n\n\nCalculate per-base genomic coverage from a BAM file using bedtools.\n\nArguments\n\nbam::String: Path to input BAM file\n\nReturns\n\nString: Path to the generated coverage file (.coverage.txt)\n\nDetails\n\nUses bedtools genomecov to compute per-base coverage. Creates a coverage file  with the format: <chromosome> <position> <coverage_depth>.  If the coverage file already exists, returns the existing file path.\n\nDependencies\n\nRequires bedtools (automatically installed in conda environment)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_max_canonical_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.determine_max_canonical_kmers","text":"determine_max_canonical_kmers(k, ALPHABET) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_max_possible_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.determine_max_possible_kmers","text":"determine_max_possible_kmers(k, ALPHABET) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_primary_contig-Tuple{Any}","page":"Home","title":"Mycelia.determine_primary_contig","text":"determine_primary_contig(qualimap_results) -> Any\n\n\nDetermines the contig with the greatest number of total bases mapping to it\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_read_lengths-Tuple{Any}","page":"Home","title":"Mycelia.determine_read_lengths","text":"determine_read_lengths(\n    fastq_file;\n    total_reads\n) -> Vector{Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.distance_matrix_to_newick-Tuple{}","page":"Home","title":"Mycelia.distance_matrix_to_newick","text":"distance_matrix_to_newick(\n;\n    distance_matrix,\n    labels,\n    outfile\n)\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.document_frequency-Tuple{Any}","page":"Home","title":"Mycelia.document_frequency","text":"document_frequency(documents) -> Dict{_A, Int64} where _A\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_and_filter_sra_reads-Tuple{}","page":"Home","title":"Mycelia.download_and_filter_sra_reads","text":"download_and_filter_sra_reads(\n;\n    outdir,\n    srr_identifier\n) -> Union{Nothing, Bool}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_bandage","page":"Home","title":"Mycelia.download_bandage","text":"download_bandage() -> String\ndownload_bandage(outdir) -> Any\n\n\nDownloads and installs Bandage, a bioinformatics visualization tool for genome assembly graphs.\n\nArguments\n\noutdir=\"/usr/local/bin\": Target installation directory for the Bandage executable\n\nReturns\n\nPath to the installed Bandage executable\n\nDetails\n\nDownloads Bandage v0.8.1 for Ubuntu\nInstalls required system dependencies (libxcb-glx0, libx11-xcb-dev, libfontconfig, libgl1-mesa-glx)\nAttempts installation with sudo, falls back to root if sudo fails\nSkips download if Bandage is already installed at target location\n\nDependencies\n\nRequires system commands: wget, unzip, apt\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.download_blast_db-Tuple{}","page":"Home","title":"Mycelia.download_blast_db","text":"download_blast_db(; db, dbdir, source, wait)\n\n\nSmart downloading of blast dbs depending on interactive, non interactive context\n\nFor a list of all available databases, run: Mycelia.list_blastdbs()\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_genome_by_accession-Tuple{}","page":"Home","title":"Mycelia.download_genome_by_accession","text":"download_genome_by_accession(\n;\n    accession,\n    outdir,\n    compressed\n)\n\n\nDownloads a genomic sequence from NCBI's nucleotide database by its accession number.\n\nArguments\n\naccession::String: NCBI nucleotide accession number (e.g. \"NC_045512\")\noutdir::String: Output directory path. Defaults to current directory\ncompressed::Bool: If true, compresses output file with gzip. Defaults to true\n\nReturns\n\nString: Path to the downloaded file (.fna or .fna.gz)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_genome_by_ftp-Tuple{}","page":"Home","title":"Mycelia.download_genome_by_ftp","text":"download_genome_by_ftp(; ftp, outdir)\n\n\nDownloads a genome file from NCBI FTP server to the specified directory.\n\nArguments\n\nftp::String: NCBI FTP path for the genome (e.g. \"ftp://ftp.ncbi.nlm.nih.gov/.../\")\noutdir::String: Output directory path. Defaults to current working directory.\n\nReturns\n\nString: Path to the downloaded file\n\nNotes\n\nIf the target file already exists, returns the existing file path without re-downloading\nDownloads the genomic.fna.gz version of the genome\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_mmseqs_db-Tuple{}","page":"Home","title":"Mycelia.download_mmseqs_db","text":"download_mmseqs_db(; db, dbdir, force, wait)\n\n\nDownload mmseqs databases\n\n  Name                  Type            Taxonomy        Url                                                           \n- UniRef100             Aminoacid            yes        https://www.uniprot.org/help/uniref\n- UniRef90              Aminoacid            yes        https://www.uniprot.org/help/uniref\n- UniRef50              Aminoacid            yes        https://www.uniprot.org/help/uniref\n- UniProtKB             Aminoacid            yes        https://www.uniprot.org/help/uniprotkb\n- UniProtKB/TrEMBL      Aminoacid            yes        https://www.uniprot.org/help/uniprotkb\n- UniProtKB/Swiss-Prot  Aminoacid            yes        https://uniprot.org\n- NR                    Aminoacid            yes        https://ftp.ncbi.nlm.nih.gov/blast/db/FASTA\n- NT                    Nucleotide             -        https://ftp.ncbi.nlm.nih.gov/blast/db/FASTA\n- GTDB                  Aminoacid            yes        https://gtdb.ecogenomic.org\n- PDB                   Aminoacid              -        https://www.rcsb.org\n- PDB70                 Profile                -        https://github.com/soedinglab/hh-suite\n- Pfam-A.full           Profile                -        https://pfam.xfam.org\n- Pfam-A.seed           Profile                -        https://pfam.xfam.org\n- Pfam-B                Profile                -        https://xfam.wordpress.com/2020/06/30/a-new-pfam-b-is-released\n- CDD                   Profile                -        https://www.ncbi.nlm.nih.gov/Structure/cdd/cdd.shtml\n- eggNOG                Profile                -        http://eggnog5.embl.de\n- VOGDB                 Profile                -        https://vogdb.org\n- dbCAN2                Profile                -        http://bcb.unl.edu/dbCAN2\n- SILVA                 Nucleotide           yes        https://www.arb-silva.de\n- Resfinder             Nucleotide             -        https://cge.cbs.dtu.dk/services/ResFinder\n- Kalamari              Nucleotide           yes        https://github.com/lskatz/Kalamari\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.draw_dendrogram_tree-Tuple{MetaGraphs.MetaDiGraph}","page":"Home","title":"Mycelia.draw_dendrogram_tree","text":"draw_dendrogram_tree(\n    mg::MetaGraphs.MetaDiGraph;\n    width,\n    height,\n    fontsize,\n    margins,\n    mergenodesize,\n    lineweight,\n    filename\n) -> Luxor.Drawing\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.draw_radial_tree-Tuple{MetaGraphs.MetaDiGraph}","page":"Home","title":"Mycelia.draw_radial_tree","text":"draw_radial_tree(\n    mg::MetaGraphs.MetaDiGraph;\n    width,\n    height,\n    fontsize,\n    margins,\n    mergenodesize,\n    lineweight,\n    filename\n) -> Luxor.Drawing\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.drop_empty_columns!-Tuple{DataFrames.AbstractDataFrame}","page":"Home","title":"Mycelia.drop_empty_columns!","text":"drop_empty_columns!(\n    df::DataFrames.AbstractDataFrame\n) -> DataFrames.AbstractDataFrame\n\n\nIdentify all columns that have only missing or empty values, and remove those columns from the dataframe in-place.\n\nReturns a modified version of the original dataframe. \n\nSee also: dropemptycolumns\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.drop_empty_columns-Tuple{DataFrames.AbstractDataFrame}","page":"Home","title":"Mycelia.drop_empty_columns","text":"drop_empty_columns(df::DataFrames.AbstractDataFrame) -> Any\n\n\nIdentify all columns that have only missing or empty values, and remove those columns from the dataframe.\n\nReturns a modified copy of the dataframe.\n\nSee also: dropemptycolumns!\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.edge_path_to_sequence-Tuple{Any, Any}","page":"Home","title":"Mycelia.edge_path_to_sequence","text":"edge_path_to_sequence(kmer_graph, edge_path) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.edge_probability-Tuple{Any, Any}","page":"Home","title":"Mycelia.edge_probability","text":"edge_probability(stranded_kmer_graph, edge) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.edgemer_to_vertex_kmers-Tuple{Any}","page":"Home","title":"Mycelia.edgemer_to_vertex_kmers","text":"edgemer_to_vertex_kmers(\n    edgemer\n) -> Tuple{Kmers.Kmer{BioSequences.DNAAlphabet{2}}, Kmers.Kmer{BioSequences.DNAAlphabet{2}}}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.equally_spaced_samples-Tuple{Any, Any}","page":"Home","title":"Mycelia.equally_spaced_samples","text":"equally_spaced_samples(vector, n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.equivalent_fasta_sequences-Tuple{Any, Any}","page":"Home","title":"Mycelia.equivalent_fasta_sequences","text":"equivalent_fasta_sequences(fasta_1, fasta_2) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.error_rate_to_q_value-Tuple{Any}","page":"Home","title":"Mycelia.error_rate_to_q_value","text":"error_rate_to_q_value(error_rate) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.export_blast_db-Tuple{}","page":"Home","title":"Mycelia.export_blast_db","text":"export_blast_db(; path_to_db, fasta)\n\n\nExport sequences from a BLAST database to a gzipped FASTA file.\n\nArguments\n\npath_to_db: Path to the BLAST database\nfasta: Output path for the gzipped FASTA file (default: path_to_db * \".fna.gz\")\n\nDetails\n\nUses conda's BLAST environment to extract sequences using blastdbcmd. The output is automatically compressed using pigz. If the output file already exists, the function will skip extraction.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.export_blast_db_taxonomy_table-Tuple{}","page":"Home","title":"Mycelia.export_blast_db_taxonomy_table","text":"export_blast_db_taxonomy_table(; path_to_db, outfile)\n\n\nExports a taxonomy mapping table from a BLAST database in seqid2taxid format.\n\nArguments\n\npath_to_db::String: Path to the BLAST database\noutfile::String: Output file path (defaults to input path + \".seqid2taxid.txt.gz\")\n\nReturns\n\nString: Path to the created output file\n\nDetails\n\nCreates a compressed tab-delimited file mapping sequence IDs to taxonomy IDs. Uses blastdbcmd without GI identifiers for better cross-referencing compatibility. If the output file already exists, returns the path without regenerating.\n\nDependencies\n\nRequires BLAST+ tools installed via Bioconda.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.extract_pacbiosample_information-Tuple{Any}","page":"Home","title":"Mycelia.extract_pacbiosample_information","text":"extract_pacbiosample_information(\n    xml\n) -> DataFrames.DataFrame\n\n\nExtract biosample and barcode information from a PacBio XML metadata file.\n\nArguments\n\nxml: Path to PacBio XML metadata file\n\nReturns\n\nDataFrame with two columns:\n\nBioSampleName: Name of the biological sample\nBarcodeName: Associated DNA barcode identifier\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta2normalized_table","page":"Home","title":"Mycelia.fasta2normalized_table","text":"fasta2normalized_table(fasta_file; ...) -> Any\nfasta2normalized_table(fasta_file, outfile; force) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.fasta_and_gff_to_genbank-Tuple{}","page":"Home","title":"Mycelia.fasta_and_gff_to_genbank","text":"fasta_and_gff_to_genbank(; fasta, gff, genbank)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_genome_size-Tuple{Any}","page":"Home","title":"Mycelia.fasta_genome_size","text":"fasta_genome_size(fasta_file) -> Any\n\n\nCalculate the total size (in bases) of all sequences in a FASTA file.\n\nArguments\n\nfasta_file::AbstractString: Path to the FASTA file\n\nReturns\n\nInt: Sum of lengths of all sequences in the FASTA file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_list_to_dense_counts_table-Tuple{}","page":"Home","title":"Mycelia.fasta_list_to_dense_counts_table","text":"fasta_list_to_dense_counts_table(; fasta_list, k, alphabet)\n\n\nCreate a dense kmer counts table (canonical for DNA, stranded for RNA & AA) for each fasta provided in a list. Scales very well for large numbers of organisms/fasta files, but not for k. Recommended for k <= 13, although 17 may still be possible\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_table_to_fasta-Tuple{Any}","page":"Home","title":"Mycelia.fasta_table_to_fasta","text":"fasta_table_to_fasta(fasta_df) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_to_reference_kmer_counts-Tuple{}","page":"Home","title":"Mycelia.fasta_to_reference_kmer_counts","text":"fasta_to_reference_kmer_counts(; kmer_type, fasta)\n\n\nCounts k-mer occurrences in a FASTA file, considering both forward and reverse complement sequences.\n\nArguments\n\nkmer_type: Type specification for k-mers (e.g., DNAKmer{21})\nfasta: Path to FASTA file containing reference sequences\n\nReturns\n\nDict{kmer_type, Int}: Dictionary mapping each k-mer to its total count across all sequences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_to_table-Tuple{Any}","page":"Home","title":"Mycelia.fasta_to_table","text":"fasta_to_table(fasta) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_xam_mapping_stats-Tuple{}","page":"Home","title":"Mycelia.fasta_xam_mapping_stats","text":"fasta_xam_mapping_stats(; fasta, xam)\n\n\nCalculate mapping statistics by comparing sequence alignments (BAM/SAM) to a reference FASTA.\n\nArguments\n\nfasta::String: Path to reference FASTA file\nxam::String: Path to alignment file (BAM or SAM format)\n\nReturns\n\nDataFrame with columns:\n\ncontig: Reference sequence name\ncontig_length: Length of reference sequence\ntotal_aligned_bases: Total number of bases aligned to reference\nmean_depth: Average depth of coverage (totalalignedbases/contig_length)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastani_list-Tuple{}","page":"Home","title":"Mycelia.fastani_list","text":"fastani_list(\n;\n    query_list,\n    reference_list,\n    outfile,\n    threads,\n    force\n) -> Union{Nothing, Base.Process}\n\n\nRun fastani with a query and reference list\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasterq_dump-Tuple{}","page":"Home","title":"Mycelia.fasterq_dump","text":"fasterq_dump(\n;\n    outdir,\n    srr_identifier\n) -> Union{Nothing, Base.Process}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastq_record-Tuple{}","page":"Home","title":"Mycelia.fastq_record","text":"fastq_record(; identifier, sequence, quality_scores)\n\n\nConstruct a FASTX FASTQ record from its components.\n\nArguments\n\nidentifier::String: The sequence identifier without the '@' prefix\nsequence::String: The nucleotide sequence\nquality_scores::Vector{Int}: Quality scores (0-93) as raw integers\n\nReturns\n\nFASTX.FASTQRecord: A parsed FASTQ record\n\nNotes\n\nQuality scores are automatically capped at 93 to ensure FASTQ compatibility\nQuality scores are converted to ASCII by adding 33 (Phred+33 encoding)\nThe record is constructed in standard FASTQ format with four lines:\nHeader line (@ + identifier)\nSequence\nPlus line\nQuality scores (ASCII encoded)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_stats-Tuple{Any}","page":"Home","title":"Mycelia.fastx_stats","text":"fastx_stats(fastq) -> Base.Process\n\n\nCalculate basic statistics for FASTQ/FASTA sequence files using seqkit.\n\nArguments\n\nfastq::String: Path to input FASTQ/FASTA file\n\nDetails\n\nAutomatically installs and uses seqkit from Bioconda to compute sequence statistics including number of sequences, total bases, GC content, average length, etc.\n\nDependencies\n\nRequires Conda and Bioconda channel\nInstalls seqkit package if not present\n\nReturns\n\nPrints statistics to standard output in tabular format\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_to_contig_lengths-Tuple{Any}","page":"Home","title":"Mycelia.fastx_to_contig_lengths","text":"fastx_to_contig_lengths(\n    fastx\n) -> OrderedCollections.OrderedDict\n\n\nGenerate detailed mapping statistics for each reference sequence/contig in a XAM (SAM/BAM/CRAM) file.\n\nArguments\n\nxam: Path to XAM file or XAM object\n\nReturns\n\nA DataFrame with per-contig statistics including:\n\nn_aligned_reads: Number of aligned reads\ntotal_aligned_bases: Sum of alignment lengths\ntotal_alignment_score: Sum of alignment scores\nMapping quality statistics (mean, std, median)\nAlignment length statistics (mean, std, median)\nAlignment score statistics (mean, std, median)\nPercent mismatches statistics (mean, std, median)\n\nNote: Only primary alignments (isprimary=true) and mapped reads (ismapped=true) are considered.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_to_kmer_graph-Tuple{Any, AbstractString}","page":"Home","title":"Mycelia.fastx_to_kmer_graph","text":"fastx_to_kmer_graph(\n    KMER_TYPE,\n    fastx::AbstractString\n) -> MetaGraphs.MetaGraph\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_to_kmer_graph-Tuple{Any, AbstractVector{<:AbstractString}}","page":"Home","title":"Mycelia.fastx_to_kmer_graph","text":"fastx_to_kmer_graph(\n    KMER_TYPE,\n    fastxs::AbstractVector{<:AbstractString}\n) -> MetaGraphs.MetaGraph\n\n\nCreate an in-memory kmer-graph that records:\n\nall kmers\ncounts\nall observed edges between kmers\nedge orientations\nedge counts\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fibonacci_numbers_less_than-Tuple{Int64}","page":"Home","title":"Mycelia.fibonacci_numbers_less_than","text":"fibonacci_numbers_less_than(\n    n::Int64\n) -> Union{Vector{Any}, Vector{Int64}}\n\n\nGenerate a sequence of Fibonacci numbers strictly less than the input value.\n\nArguments\n\nn::Int: Upper bound (exclusive) for the Fibonacci sequence\n\nReturns\n\nVector{Int}: Array containing Fibonacci numbers less than n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.filesize_human_readable-Tuple{Any}","page":"Home","title":"Mycelia.filesize_human_readable","text":"filesize_human_readable(f) -> Any\n\n\nGets the size of a file and returns it in a human-readable format.\n\nArguments\n\nf: The path to the file, either as a String or an AbstractString.\n\nReturns\n\nA string representing the file size in a human-readable format (e.g., \"3.40 MB\").\n\nDetails\n\nThis function internally uses filesize(f) to get the file size in bytes, then leverages Base.format_bytes to convert it into a human-readable format with appropriate units (KB, MB, GB, etc.).\n\nExamples\n\njulia> filesize_human_readable(\"my_image.jpg\")\n\"2.15 MB\"\n\nSee Also\n\nfilesize: Gets the size of a file in bytes.\nBase.format_bytes: Converts a byte count into a human-readable string. \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.filter_long_reads-Tuple{}","page":"Home","title":"Mycelia.filter_long_reads","text":"filter_long_reads(\n;\n    in_fastq,\n    out_fastq,\n    min_mean_q,\n    keep_percent\n)\n\n\nFilter and process long reads from a FASTQ file using Filtlong.\n\nThis function filters long sequencing reads based on quality and length criteria,  then compresses the output using pigz.\n\nArguments\n\nin_fastq::String: Path to the input FASTQ file.\nout_fastq::String: Path to the output filtered and compressed FASTQ file.   Defaults to the input filename with \".filtlong.fq.gz\" appended.\nmin_mean_q::Int: Minimum mean quality score for reads to be kept. Default is 20.\nkeep_percent::Int: Percentage of reads to keep after filtering. Default is 95.\n\nReturns\n\nCmd: A pipeline command that can be run to execute the filtering and compression.\n\nDetails\n\nThis function uses Filtlong to filter long reads and pigz for compression. It requires the Bioconda environment for Filtlong to be set up, which is handled internally.\n\nExample\n\nfilter_cmd = filter_long_reads(\n    in_fastq = \"input.fastq.gz\",\n    out_fastq = \"filtered_output.fq.gz\",\n    min_mean_q = 25,\n    keep_percent = 90\n)\nrun(filter_cmd)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_matching_prefix-Tuple{String, String}","page":"Home","title":"Mycelia.find_matching_prefix","text":"find_matching_prefix(\n    filename1::String,\n    filename2::String;\n    strip_trailing_delimiters\n) -> String\n\n\nFind the longest common prefix between two filenames.\n\nArguments\n\nfilename1::String: First filename to compare\nfilename2::String: Second filename to compare\n\nKeywords\n\nstrip_trailing_delimiters::Bool=true: If true, removes trailing dots, hyphens, and underscores from the result\n\nReturns\n\nString: The longest common prefix found between the filenames\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_nonempty_columns-Tuple{Any}","page":"Home","title":"Mycelia.find_nonempty_columns","text":"find_nonempty_columns(df) -> Any\n\n\nIdentify all columns that have only missing or empty values\n\nReturns as a bit array\n\nSee also: dropemptycolumns, dropemptycolumns!\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_resampling_stretches-Tuple{}","page":"Home","title":"Mycelia.find_resampling_stretches","text":"find_resampling_stretches(\n;\n    record_kmer_solidity,\n    solid_branching_kmer_indices\n)\n\n\nIdentifies sequence regions that require resampling based on kmer solidity patterns.\n\nArguments\n\nrecord_kmer_solidity::BitVector: Boolean array where true indicates solid kmers\nsolid_branching_kmer_indices::Vector{Int}: Indices of solid branching kmers\n\nReturns\n\nVector{UnitRange{Int64}}: Array of ranges (start:stop) indicating stretches that need resampling\n\nDetails\n\nFinds continuous stretches of non-solid kmers and extends them to the nearest solid branching kmers on either side. These stretches represent regions that need resampling.\n\nIf a stretch doesn't have solid branching kmers on both sides, it is excluded from the result. Duplicate ranges are removed from the final output.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_true_ranges-Tuple{AbstractVector{Bool}}","page":"Home","title":"Mycelia.find_true_ranges","text":"find_true_ranges(\n    bool_vec::AbstractVector{Bool};\n    min_length\n) -> Vector\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.first_of_each_group-Tuple{DataFrames.GroupedDataFrame{DataFrames.DataFrame}}","page":"Home","title":"Mycelia.first_of_each_group","text":"first_of_each_group(\n    gdf::DataFrames.GroupedDataFrame{DataFrames.DataFrame}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fit_optimal_number_of_clusters","page":"Home","title":"Mycelia.fit_optimal_number_of_clusters","text":"fit_optimal_number_of_clusters(\n    distance_matrix\n) -> @NamedTuple{optimal_number_of_clusters::Int64, ks_assessed::Vector{Int64}, within_cluster_sum_of_squares::Vector{Float64}, silhouette_scores::Vector{Float64}}\nfit_optimal_number_of_clusters(\n    distance_matrix,\n    ks_to_try\n) -> NamedTuple{(:optimal_number_of_clusters, :ks_assessed, :within_cluster_sum_of_squares, :silhouette_scores), <:Tuple{Any, Any, Vector{Float64}, Vector{Float64}}}\n\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.fit_optimal_number_of_clusters_hclust","page":"Home","title":"Mycelia.fit_optimal_number_of_clusters_hclust","text":"fit_optimal_number_of_clusters_hclust(\n    distance_matrix\n) -> NamedTuple{(:optimal_number_of_clusters, :ks_assessed, :silhouette_scores, :hclust_result), <:Tuple{Int64, Vector{Int64}, Vector{Float64}, Clustering.Hclust}}\nfit_optimal_number_of_clusters_hclust(\n    distance_matrix,\n    ks_to_try\n) -> NamedTuple{(:optimal_number_of_clusters, :ks_assessed, :silhouette_scores, :hclust_result), <:Tuple{Any, Any, Vector{Float64}, Clustering.Hclust}}\n\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.frequency_matrix_to_cosine_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.frequency_matrix_to_cosine_distance_matrix","text":"frequency_matrix_to_cosine_distance_matrix(\n    probability_matrix\n) -> Any\n\n\nCreate cosine distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to cosine similarity (relative frequency)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.frequency_matrix_to_euclidean_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.frequency_matrix_to_euclidean_distance_matrix","text":"frequency_matrix_to_euclidean_distance_matrix(\n    counts_table\n) -> Any\n\n\nCreate a Euclidean distance matrix from a column-major counts matrix (features as rows and entities as columns), where distance is proportional to total feature count magnitude (size).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.genbank_to_codon_frequencies-Tuple{Any}","page":"Home","title":"Mycelia.genbank_to_codon_frequencies","text":"genbank_to_codon_frequencies(\n    genbank;\n    allow_all\n) -> Dict{BioSymbols.AminoAcid, Dict{Kmers.Kmer{BioSequences.DNAAlphabet{2}, 3, 1}, Int64}}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.genbank_to_fasta-Tuple{}","page":"Home","title":"Mycelia.genbank_to_fasta","text":"genbank_to_fasta(; genbank, fasta, force)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_all_possible_canonical_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.generate_all_possible_canonical_kmers","text":"generate_all_possible_canonical_kmers(k, alphabet) -> Any\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_all_possible_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.generate_all_possible_kmers","text":"generate_all_possible_kmers(k, alphabet) -> Any\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_transterm_coordinates_from_fasta-Tuple{Any}","page":"Home","title":"Mycelia.generate_transterm_coordinates_from_fasta","text":"generate_transterm_coordinates_from_fasta(fasta) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_transterm_coordinates_from_gff-Tuple{Any}","page":"Home","title":"Mycelia.generate_transterm_coordinates_from_gff","text":"generate_transterm_coordinates_from_gff(gff_file) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_base_extension-Tuple{String}","page":"Home","title":"Mycelia.get_base_extension","text":"get_base_extension(filename::String) -> SubString{String}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_correct_quality-Tuple{Symbol, Int64, Int64}","page":"Home","title":"Mycelia.get_correct_quality","text":"get_correct_quality(tech::Symbol, pos::Int, read_length::Int) -> Int\n\nSimulates a Phred quality score (using the Sanger convention) for a correctly observed base. For Illumina, the quality score is modeled to decay linearly from ~40 at the start to ~20 at the end of the read. For other technologies, the score is sampled from a normal distribution with parameters typical for that platform.\n\nReturns an integer quality score.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_error_quality-Tuple{Symbol}","page":"Home","title":"Mycelia.get_error_quality","text":"get_error_quality(tech::Symbol) -> Int\n\nSimulates a Phred quality score (using the Sanger convention) for a base observed with an error. Error bases are assigned lower quality scores than correctly observed bases. For Illumina, scores typically range between 5 and 15; for nanopore and pacbio, slightly lower values are used; and for ultima, a modest quality score is assigned.\n\nReturns an integer quality score.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_genbank-Tuple{}","page":"Home","title":"Mycelia.get_genbank","text":"get_genbank(\n;\n    db,\n    accession,\n    ftp\n) -> Union{Nothing, GenomicAnnotations.GenBank.Reader}\n\n\nGet dna (db = \"nuccore\") or protein (db = \"protein\") sequences from NCBI or get fasta directly from FTP site\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_gff-Tuple{}","page":"Home","title":"Mycelia.get_gff","text":"get_gff(; db, accession, ftp) -> Any\n\n\nGet dna (db = \"nuccore\") or protein (db = \"protein\") sequences from NCBI or get fasta directly from FTP site\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_kmer_index-Tuple{Any, Any}","page":"Home","title":"Mycelia.get_kmer_index","text":"get_kmer_index(kmers, kmer) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_sequence-Tuple{}","page":"Home","title":"Mycelia.get_sequence","text":"get_sequence(\n;\n    db,\n    accession,\n    ftp\n) -> Union{Nothing, FASTX.FASTA.Reader}\n\n\nGet dna (db = \"nuccore\") or protein (db = \"protein\") sequences from NCBI or get fasta directly from FTP site\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.gfa_to_fasta-Tuple{}","page":"Home","title":"Mycelia.gfa_to_fasta","text":"gfa_to_fasta(; gfa, fasta)\n\n\nConvert a GFA (Graphical Fragment Assembly) file to FASTA format.\n\nArguments\n\ngfa::String: Path to input GFA file\nfasta::String=gfa * \".fna\": Path for output FASTA file. Defaults to input filename with \".fna\" extension\n\nReturns\n\nString: Path to the generated FASTA file\n\nDetails\n\nUses gfatools (via Conda) to perform the conversion. The function will:\n\nEnsure gfatools is available in the Conda environment\nExecute the conversion using gfatools gfa2fa\nWrite sequences to the specified FASTA file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.gfa_to_structure_table-Tuple{Any}","page":"Home","title":"Mycelia.gfa_to_structure_table","text":"gfa_to_structure_table(\n    gfa\n) -> NamedTuple{(:contig_table, :records), <:Tuple{DataFrames.DataFrame, Any}}\n\n\nConvert a GFA (Graphical Fragment Assembly) file into a structured representation.\n\nArguments\n\ngfa: Path to GFA file or GFA content as string\n\nReturns\n\nNamed tuple containing:\n\ncontig_table: DataFrame with columns:\nconnected_component: Integer ID for each component\ncontigs: Comma-separated list of contig IDs\nis_circular: Boolean indicating if component forms a cycle\nis_closed: Boolean indicating if single contig forms a cycle\nlengths: Comma-separated list of contig lengths\nrecords: FASTA records from the GFA\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.githash-Tuple{}","page":"Home","title":"Mycelia.githash","text":"githash(; short) -> SubString{String}\n\n\nReturns the current git commit hash of the repository.\n\nArguments\n\nshort::Bool=false: If true, returns abbreviated 8-character hash\n\nReturns\n\nA string containing the git commit hash (full 40 characters by default)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.graph_to_gfa-Tuple{}","page":"Home","title":"Mycelia.graph_to_gfa","text":"graph_to_gfa(; graph, outfile)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.hclust_to_metagraph-Tuple{Clustering.Hclust}","page":"Home","title":"Mycelia.hclust_to_metagraph","text":"hclust_to_metagraph(\n    hcl::Clustering.Hclust\n) -> MetaGraphs.MetaDiGraph{Int64, Float64}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.heirarchically_cluster_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.heirarchically_cluster_distance_matrix","text":"heirarchically_cluster_distance_matrix(\n    distance_matrix\n) -> Clustering.Hclust\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.identify_optimal_number_of_clusters-Tuple{Any}","page":"Home","title":"Mycelia.identify_optimal_number_of_clusters","text":"identify_optimal_number_of_clusters(\n    distance_matrix\n) -> Tuple{Clustering.Hclust, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.install_hashdeep-Tuple{}","page":"Home","title":"Mycelia.install_hashdeep","text":"install_hashdeep() -> Union{Nothing, Base.Process}\n\n\nEnsures the hashdeep utility is installed on the system.\n\nChecks if hashdeep is available in PATH and attempts to install it via apt package manager if not found. Will try with sudo privileges first, then without sudo if that fails.\n\nDetails\n\nChecks PATH for existing hashdeep executable\nAttempts installation using apt package manager\nRequires a Debian-based Linux distribution\n\nReturns\n\nNothing, but prints status messages during execution\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.is_equivalent-Tuple{Any, Any}","page":"Home","title":"Mycelia.is_equivalent","text":"is_equivalent(a, b) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.isolate_normalized_primary_contig-Tuple{Any, Any, Any, Any, Int64}","page":"Home","title":"Mycelia.isolate_normalized_primary_contig","text":"isolate_normalized_primary_contig(\n    assembled_fasta,\n    assembled_gfa,\n    qualimap_report_txt,\n    identifier,\n    k::Int64;\n    primary_contig_fasta\n) -> String\n\n\nPrimary contig is defined as the contig with the most bases mapped to it\n\nIn the context of picking out phage from metagenomic assemblies the longest contig is often bacteria whereas the highest coverage contigs are often primer-dimers or other PCR amplification artifacts.\n\nTaking the contig that has the most bases mapped to it as a product of length * depth is cherry picked as our phage\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.iterative_polishing","page":"Home","title":"Mycelia.iterative_polishing","text":"iterative_polishing(\n    fastq\n) -> Vector{T} where T<:(NamedTuple{(:fastq, :k), <:Tuple{Any, Any}})\niterative_polishing(\n    fastq,\n    max_k\n) -> Vector{T} where T<:(NamedTuple{(:fastq, :k), <:Tuple{Any, Any}})\niterative_polishing(\n    fastq,\n    max_k,\n    plot\n) -> Vector{T} where T<:(NamedTuple{(:fastq, :k), <:Tuple{Any, Any}})\n\n\nPerforms iterative error correction on FASTQ sequences using progressively larger k-mer sizes.\n\nStarting with the default k-mer size, this function repeatedly applies polishing steps, incrementing the k-mer size until either reaching max_k or encountering instability.\n\nArguments\n\nfastq: Path to input FASTQ file or FastqRecord object\nmax_k: Maximum k-mer size to attempt (default: 89)\nplot: Whether to generate diagnostic plots (default: false)\n\nReturns\n\nVector of polishing results, where each element contains:\n\nk: k-mer size used\nfastq: resulting polished sequences\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.jaccard_distance-Tuple{Any, Any}","page":"Home","title":"Mycelia.jaccard_distance","text":"jaccard_distance(set1, set2) -> Any\n\n\nCalculate the Jaccard distance between two sets, which is the complement of the Jaccard similarity.\n\nThe Jaccard distance is defined as: J_d(AB) = 1 - J_s(AB) = 1 - fracA  BA  B\n\nArguments\n\nset1: First set to compare\nset2: Second set to compare\n\nReturns\n\nFloat64: A value in [0,1] where 0 indicates identical sets and 1 indicates disjoint sets\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.jaccard_similarity-Tuple{Any, Any}","page":"Home","title":"Mycelia.jaccard_similarity","text":"jaccard_similarity(set1, set2) -> Any\n\n\nCompute the Jaccard similarity coefficient between two sets.\n\nThe Jaccard similarity is defined as the size of the intersection divided by the size of the union of two sets:\n\nJ(A,B) = |A  B| / |A  B|\n\nArguments\n\nset1: First set for comparison\nset2: Second set for comparison\n\nReturns\n\nFloat64: A value between 0.0 and 1.0, where:\n1.0 indicates identical sets\n0.0 indicates completely disjoint sets\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.jellyfish_count-Tuple{}","page":"Home","title":"Mycelia.jellyfish_count","text":"jellyfish_count(\n;\n    fastx,\n    k,\n    threads,\n    max_mem,\n    canonical,\n    outfile,\n    conda_check\n)\n\n\nCount k-mers in a FASTA/FASTQ file using Jellyfish.\n\nArguments\n\nfastx::String: Path to input FASTA/FASTQ file (can be gzipped)\nk::Integer: k-mer length\nthreads::Integer=Sys.CPU_THREADS: Number of threads to use\nmax_mem::Integer=Int(Sys.free_memory()): Maximum memory in bytes (defaults to system free memory)\ncanonical::Bool=false: Whether to count canonical k-mers (both strands combined)\noutfile::String=auto: Output filename (auto-generated based on input and parameters)\nconda_check::Bool=true: Whether to verify Jellyfish conda installation\n\nReturns\n\nString: Path to gzipped TSV file containing k-mer counts\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.jellyfish_counts_to_kmer_frequency_histogram","page":"Home","title":"Mycelia.jellyfish_counts_to_kmer_frequency_histogram","text":"jellyfish_counts_to_kmer_frequency_histogram(\n    jellyfish_counts_file\n) -> Any\njellyfish_counts_to_kmer_frequency_histogram(\n    jellyfish_counts_file,\n    outfile\n) -> Any\n\n\nConvert a Jellyfish k-mer count file into a frequency histogram.\n\nArguments\n\njellyfish_counts_file::String: Path to the gzipped TSV file containing Jellyfish k-mer counts\noutfile::String=replace(jellyfish_counts_file, r\"\\.tsv\\.gz$\" => \".count_histogram.tsv\"): Optional output file path\n\nReturns\n\nString: Path to the generated histogram file\n\nDescription\n\nProcesses a Jellyfish k-mer count file to create a frequency histogram where:\n\nColumn 1: Number of k-mers that share the same count\nColumn 2: The count they share\n\nUses system sorting with LC_ALL=C for optimal performance on large files.\n\nNotes\n\nRequires gzip, sort, uniq, and sed command line tools\nUses intermediate disk storage for sorting large files\nSkips processing if output file already exists\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.jitter-Tuple{Any, Any}","page":"Home","title":"Mycelia.jitter","text":"jitter(x, n) -> Any\n\n\nAdd random noise to create a vector of jittered values.\n\nGenerates n values by adding random noise to the input value x.  The noise is uniformly distributed between -1/3 and 1/3.\n\nArguments\n\nx: Base value to add jitter to\nn: Number of jittered values to generate\n\nReturns\n\nVector of length n containing jittered values around x\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_dict_to_vector-Tuple{Any, Any}","page":"Home","title":"Mycelia.kmer_counts_dict_to_vector","text":"kmer_counts_dict_to_vector(\n    kmer_to_index_map,\n    kmer_counts\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_to_cosine_similarity-Tuple{Any, Any}","page":"Home","title":"Mycelia.kmer_counts_to_cosine_similarity","text":"kmer_counts_to_cosine_similarity(\n    kmer_counts_1,\n    kmer_counts_2\n) -> Any\n\n\nCalculate the cosine similarity between two k-mer count dictionaries.\n\nArguments\n\nkmer_counts_1::Dict{String,Int}: First dictionary mapping k-mer sequences to their counts\nkmer_counts_2::Dict{String,Int}: Second dictionary mapping k-mer sequences to their counts\n\nReturns\n\nFloat64: Cosine distance between the two k-mer count vectors, in range [0,1] where 0 indicates identical distributions and 1 indicates maximum dissimilarity\n\nDetails\n\nConverts k-mer count dictionaries into vectors using a unified set of keys, then computes cosine distance. Missing k-mers are treated as count 0. Result is invariant to input order and total counts (normalized internally).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_to_js_divergence-Tuple{Any, Any}","page":"Home","title":"Mycelia.kmer_counts_to_js_divergence","text":"kmer_counts_to_js_divergence(\n    kmer_counts_1,\n    kmer_counts_2\n) -> Any\n\n\nCalculate the Jensen-Shannon divergence between two k-mer frequency distributions.\n\nArguments\n\nkmer_counts_1: Dictionary mapping k-mers to their counts in first sequence\nkmer_counts_2: Dictionary mapping k-mers to their counts in second sequence\n\nReturns\n\nNormalized Jensen-Shannon divergence score between 0 and 1, where:\n0 indicates identical distributions\n1 indicates maximally different distributions\n\nNotes\n\nThe measure is symmetric: JS(P||Q) = JS(Q||P)\nCounts are automatically normalized to probability distributions\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_to_merqury_qv-Union{Tuple{}, Tuple{N}, Tuple{k}} where {k, N}","page":"Home","title":"Mycelia.kmer_counts_to_merqury_qv","text":"kmer_counts_to_merqury_qv(\n;\n    raw_data_counts,\n    assembly_counts\n)\n\n\nCalculate assembly Quality Value (QV) score using the Merqury method.\n\nEstimates base-level accuracy by comparing k-mer distributions between raw sequencing data and assembly. Higher QV scores indicate better assembly quality.\n\nArguments\n\nraw_data_counts::AbstractDict{Kmers.DNAKmer{k,N}, Int}: K-mer counts from raw sequencing data\nassembly_counts::AbstractDict{Kmers.DNAKmer{k,N}, Int}: K-mer counts from assembly\n\nReturns\n\nFloat64: Quality Value score in Phred scale (-10log(error rate))\n\nMethod\n\nQV is calculated using:\n\nKtotal = number of unique kmers in assembly\nKshared = number of kmers shared between raw data and assembly\nP = (Kshared/Ktotal)^(1/k) = estimated base-level accuracy\nQV = -10log(1-P)\n\nReference\n\nRhie et al. \"Merqury: reference-free quality, completeness, and phasing assessment for genome assemblies\" Genome Biology (2020)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_path_to_sequence-Tuple{Any}","page":"Home","title":"Mycelia.kmer_path_to_sequence","text":"kmer_path_to_sequence(kmer_path) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ks-Tuple{}","page":"Home","title":"Mycelia.ks","text":"ks(; min, max) -> Vector{Int64}\n\n\nGenerates a specialized sequence of prime numbers combining:\n\nOdd primes up to 23 (flip_point)\nPrimes nearest to Fibonacci numbers above 23 up to max\n\nArguments\n\nmin::Int=0: Lower bound for the sequence\nmax::Int=10_000: Upper bound for the sequence\n\nReturns\n\nVector of Int containing the specialized prime sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.lawrencium_sbatch-Tuple{}","page":"Home","title":"Mycelia.lawrencium_sbatch","text":"lawrencium_sbatch(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    partition,\n    qos,\n    account,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd\n)\n\n\nSubmit a job to SLURM scheduler on Lawrence Berkeley Lab's Lawrencium cluster.\n\nArguments\n\njob_name: Name identifier for the SLURM job\nmail_user: Email address for job notifications\nmail_type: Notification type (\"ALL\", \"BEGIN\", \"END\", \"FAIL\", or \"NONE\")\nlogdir: Directory for SLURM output and error logs\npartition: Lawrencium compute partition\nqos: Quality of Service level\naccount: Project account for billing\nnodes: Number of nodes to allocate\nntasks: Number of tasks to spawn\ntime: Wall time limit in format \"days-hours:minutes:seconds\"\ncpus_per_task: CPU cores per task\nmem_gb: Memory per node in GB\ncmd: Shell command to execute\n\nReturns\n\ntrue if submission was successful\n\nNote\n\nFunction includes 5-second delays before and after submission for queue stability.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_blastdbs-Tuple{}","page":"Home","title":"Mycelia.list_blastdbs","text":"list_blastdbs(; source) -> Vector{String}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_classes-Tuple{}","page":"Home","title":"Mycelia.list_classes","text":"list_classes() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_databases-Tuple{}","page":"Home","title":"Mycelia.list_databases","text":"list_databases(; address, username, password)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_families-Tuple{}","page":"Home","title":"Mycelia.list_families","text":"list_families() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_full_taxonomy-Tuple{}","page":"Home","title":"Mycelia.list_full_taxonomy","text":"list_full_taxonomy() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_genera-Tuple{}","page":"Home","title":"Mycelia.list_genera","text":"list_genera() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_kingdoms-Tuple{}","page":"Home","title":"Mycelia.list_kingdoms","text":"list_kingdoms() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_orders-Tuple{}","page":"Home","title":"Mycelia.list_orders","text":"list_orders() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_phylums-Tuple{}","page":"Home","title":"Mycelia.list_phylums","text":"list_phylums() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_rank-Tuple{Any}","page":"Home","title":"Mycelia.list_rank","text":"top\nsuperkingdom/domain\nkingdom\nphylum\nclass\norder\nfamily\ngenus\nspecies\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_ranks-Tuple{}","page":"Home","title":"Mycelia.list_ranks","text":"list_ranks(; synonyms) -> Vector{String}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_species-Tuple{}","page":"Home","title":"Mycelia.list_species","text":"list_species() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_subtaxa-Tuple{Any}","page":"Home","title":"Mycelia.list_subtaxa","text":"list_subtaxa(taxid) -> Vector{Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_superkingdoms-Tuple{}","page":"Home","title":"Mycelia.list_superkingdoms","text":"list_superkingdoms() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_toplevel-Tuple{}","page":"Home","title":"Mycelia.list_toplevel","text":"list_toplevel() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_blast_db_taxonomy_table-Tuple{Any}","page":"Home","title":"Mycelia.load_blast_db_taxonomy_table","text":"load_blast_db_taxonomy_table(\n    compressed_blast_db_taxonomy_table_file\n) -> DataFrames.DataFrame\n\n\nLoads a BLAST database taxonomy mapping table from a gzipped file into a DataFrame.\n\nArguments\n\ncompressed_blast_db_taxonomy_table_file::String: Path to a gzipped file containing BLAST taxonomy mappings\n\nReturns\n\nDataFrame: A DataFrame with columns :sequence_id and :taxid containing the sequence-to-taxonomy mappings\n\nFormat\n\nInput file should be a space-delimited text file (gzipped) with two columns:\n\nsequence identifier\ntaxonomy identifier (taxid)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_genbank_metadata-Tuple{}","page":"Home","title":"Mycelia.load_genbank_metadata","text":"load_genbank_metadata() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_graph-Tuple{Any}","page":"Home","title":"Mycelia.load_graph","text":"load_graph(file) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_graph-Tuple{String}","page":"Home","title":"Mycelia.load_graph","text":"load_graph(file::String) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_jellyfish_counts-Tuple{Any}","page":"Home","title":"Mycelia.load_jellyfish_counts","text":"load_jellyfish_counts(\n    jellyfish_counts\n) -> DataFrames.DataFrame\n\n\nLoad k-mer counts from a Jellyfish output file into a DataFrame.\n\nArguments\n\njellyfish_counts::String: Path to a gzipped TSV file (*.jf.tsv.gz) containing Jellyfish k-mer counts\n\nReturns\n\nDataFrame: Table with columns:\nkmer: Biologically encoded k-mers as DNAKmer{k} objects\ncount: Integer count of each k-mer's occurrences\n\nNotes\n\nInput file must be a gzipped TSV with exactly two columns (k-mer sequences and counts)\nK-mer length is automatically detected from the first entry\nFilename must end with '.jf.tsv.gz'\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_jld2-Tuple{Any}","page":"Home","title":"Mycelia.load_jld2","text":"load_jld2(filename) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_matrix_jld2-Tuple{Any}","page":"Home","title":"Mycelia.load_matrix_jld2","text":"load_matrix_jld2(filename) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_ncbi_metadata-Tuple{Any}","page":"Home","title":"Mycelia.load_ncbi_metadata","text":"load_ncbi_metadata(db) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_ncbi_taxonomy-Tuple{}","page":"Home","title":"Mycelia.load_ncbi_taxonomy","text":"load_ncbi_taxonomy(\n;\n    path_to_taxdump\n) -> MetaGraphs.MetaDiGraph{T, Float64} where T<:Integer\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_refseq_metadata-Tuple{}","page":"Home","title":"Mycelia.load_refseq_metadata","text":"load_refseq_metadata() -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.local_blast_database_info-Tuple{}","page":"Home","title":"Mycelia.local_blast_database_info","text":"local_blast_database_info(; blastdbs_dir) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.merge_colors-Tuple{Any, Any}","page":"Home","title":"Mycelia.merge_colors","text":"merge_colors(c1, c2) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.merge_fasta_files-Tuple{}","page":"Home","title":"Mycelia.merge_fasta_files","text":"merge_fasta_files(; fasta_files, fasta_file)\n\n\nJoin fasta files while adding origin prefixes to the identifiers.\n\nDoes not guarantee uniqueness but will warn if conflicts arise\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.metasha256-Tuple{Vector{<:AbstractString}}","page":"Home","title":"Mycelia.metasha256","text":"metasha256(\n    vector_of_sha256s::Vector{<:AbstractString}\n) -> String\n\n\nCompute a single SHA256 hash from multiple SHA256 hashes.\n\nTakes a vector of hex-encoded SHA256 hashes and produces a new SHA256 hash by:\n\nSorting the input hashes lexicographically\nConcatenating them in sorted order\nComputing a new SHA256 hash over the concatenated data\n\nArguments\n\nvector_of_sha256s: Vector of hex-encoded SHA256 hash strings\n\nReturns\n\nA hex-encoded string representing the computed meta-hash\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_index-Tuple{}","page":"Home","title":"Mycelia.minimap_index","text":"minimap_index(\n;\n    fasta,\n    mem_gb,\n    mapping_type,\n    threads,\n    as_string,\n    denominator\n)\n\n\nGenerate a minimap2 index command and output file path for mapping DNA sequencing reads.\n\nRun this on the machine you intend to use to map the reads to confirm the index will fit.\n\nArguments\n\nfasta: Path to the reference FASTA file to be indexed\nmem_gb: Available system memory in gigabytes for indexing\nmapping_type: Sequencing technology preset. One of:\n\"map-hifi\": PacBio HiFi reads\n\"map-ont\": Oxford Nanopore reads\n\"map-pb\": PacBio CLR reads\n\"sr\": Short reads\n\"lr:hq\": High-quality long reads\nthreads: Number of threads to use for indexing\nas_string: Return command as String instead of Cmd (default: false)\ndenominator: Divisor for calculating index size (default: 10)\n\nReturns\n\nNamed tuple containing:\n\ncmd: The minimap2 indexing command (as String or Cmd)\noutfile: Path to the output index file (.mmi)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_map-Tuple{}","page":"Home","title":"Mycelia.minimap_map","text":"minimap_map(\n;\n    fasta,\n    fastq,\n    mapping_type,\n    as_string,\n    mem_gb,\n    threads,\n    denominator\n)\n\n\nGenerate minimap2 alignment commands for sequence mapping.\n\naligning and compressing. No sorting or filtering.\n\nUse shell_only=true to get string command to submit to SLURM\n\nCreates a command to align reads in FASTQ format to a reference FASTA using minimap2,  followed by SAM compression with pigz. Handles resource allocation and conda environment setup.\n\nArguments\n\nfasta: Path to reference FASTA file\nfastq: Path to query FASTQ file\nmapping_type: Alignment preset (\"map-hifi\", \"map-ont\", \"map-pb\", \"sr\", or \"lr:hq\")\nas_string: If true, returns shell command as string; if false, returns command array\nmem_gb: Available memory in GB for indexing (defaults to system free memory)\nthreads: Number of CPU threads to use (defaults to system threads)\ndenominator: Divisor for calculating minimap2 index size\n\nReturns\n\nNamed tuple containing:\n\ncmd: Shell command (as string or array)\noutfile: Path to compressed output SAM file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_map_paired_end-Tuple{}","page":"Home","title":"Mycelia.minimap_map_paired_end","text":"minimap_map_paired_end(\n;\n    fasta,\n    forward,\n    reverse,\n    mem_gb,\n    threads,\n    outdir,\n    as_string,\n    mapping_type,\n    denominator\n)\n\n\nMaps paired-end reads to a reference genome using minimap2 and compresses the output.\n\nArguments\n\nfasta::String: Path to reference genome FASTA file\nforward::String: Path to forward reads FASTQ file\nreverse::String: Path to reverse reads FASTQ file  \nmem_gb::Integer: Available system memory in GB\nthreads::Integer: Number of threads to use\noutdir::String: Output directory (defaults to forward reads directory)\nas_string::Bool: Return command as string instead of Cmd array\nmapping_type::String: Mapping preset, e.g. \"sr\" for short reads (default)\ndenominator::Float64: Memory scaling factor for minimap2 index\n\nReturns\n\nNamed tuple containing:\n\ncmd: Command(s) to execute (String or Vector{Cmd})\noutfile: Path to compressed output SAM file (*.sam.gz)\n\nDependencies\n\nRequires bioconda packages: minimap2, samtools, pigz\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_map_paired_end_with_index-Tuple{}","page":"Home","title":"Mycelia.minimap_map_paired_end_with_index","text":"minimap_map_paired_end_with_index(\n;\n    fasta,\n    forward,\n    reverse,\n    mem_gb,\n    threads,\n    outdir,\n    as_string,\n    mapping_type,\n    denominator\n)\n\n\nMap paired-end reads to a reference sequence using minimap2.\n\nArguments\n\nfasta::String: Path to reference FASTA file\nforward::String: Path to forward reads FASTQ file\nreverse::String: Path to reverse reads FASTQ file\nmem_gb::Integer: Available system memory in GB\nthreads::Integer: Number of threads to use\noutdir::String: Output directory (defaults to forward reads directory)\nas_string::Bool=false: Return command as string instead of Cmd array\nmapping_type::String=\"sr\": Minimap2 preset [\"map-hifi\", \"map-ont\", \"map-pb\", \"sr\", \"lr:hq\"]\ndenominator::Float64: Memory scaling factor for index size\n\nReturns\n\nNamed tuple containing:\n\ncmd: Command(s) to execute (String or Array{Cmd})\noutfile: Path to compressed output SAM file (*.sam.gz)\n\nNotes\n\nRequires minimap2, samtools, and pigz conda environments\nAutomatically compresses output using pigz\nIndex file must exist at $(fasta).x$(mapping_type).I$(index_size).mmi\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_map_with_index-Tuple{}","page":"Home","title":"Mycelia.minimap_map_with_index","text":"minimap_map_with_index(\n;\n    fasta,\n    mem_gb,\n    mapping_type,\n    threads,\n    fastq,\n    as_string,\n    denominator\n)\n\n\nGenerate minimap2 mapping commands with a pre-built index file.\n\nArguments\n\nfasta: Path to the reference FASTA file\nmem_gb: Available system memory in gigabytes for index generation\nmapping_type: Mapping preset. Must be one of: \"map-hifi\", \"map-ont\", \"map-pb\", \"sr\", or \"lr:hq\"\nthreads: Number of threads to use for mapping and compression\nfastq: Path to input FASTQ file\nas_string: If true, returns command as a string; if false, returns as command array\ndenominator: Divisor for index size calculation (default: 10)\n\nReturns\n\nNamed tuple containing:\n\ncmd: The minimap2 mapping command (string or array)\noutfile: Path to the output compressed SAM file\n\nNotes\n\nRequires pre-built index file with pattern: ${fasta}.x${mapping_type}.I${index_size}.mmi\nAutomatically installs required conda environments (minimap2, samtools, pigz)\nOutput is automatically compressed with pigz\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.mmseqs_pairwise_search-Tuple{}","page":"Home","title":"Mycelia.mmseqs_pairwise_search","text":"mmseqs_pairwise_search(; fasta, output)\n\n\nPerform all-vs-all sequence search using MMseqs2's easy-search command.\n\nArguments\n\nfasta::String: Path to input FASTA file containing sequences to compare\noutput::String: Output directory path (default: input filename + \".mmseqseasysearch_pairwise\")\n\nReturns\n\nString: Path to the output directory\n\nDetails\n\nExecutes MMseqs2 with sensitive search parameters (7 sensitivity steps) and outputs results in  tabular format with the following columns:\n\nquery, qheader: Query sequence ID and header\ntarget, theader: Target sequence ID and header  \npident: Percentage sequence identity\nfident: Fraction of identical matches\nnident: Number of identical matches\nalnlen: Alignment length\nmismatch: Number of mismatches\ngapopen: Number of gap openings\nqstart, qend, qlen: Query sequence coordinates and length\ntstart, tend, tlen: Target sequence coordinates and length\nevalue: Expected value\nbits: Bit score\n\nRequires MMseqs2 to be available through Bioconda.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.mutate_sequence-Tuple{Any}","page":"Home","title":"Mycelia.mutate_sequence","text":"mutate_sequence(reference_sequence) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.n_maximally_distinguishable_colors-Tuple{Any}","page":"Home","title":"Mycelia.n_maximally_distinguishable_colors","text":"n_maximally_distinguishable_colors(n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.name2taxid-Tuple{Any}","page":"Home","title":"Mycelia.name2taxid","text":"name2taxid(name) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.names2taxids-Tuple{AbstractVector{<:AbstractString}}","page":"Home","title":"Mycelia.names2taxids","text":"names2taxids(names::AbstractVector{<:AbstractString}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ncbi_ftp_path_to_url-Tuple{}","page":"Home","title":"Mycelia.ncbi_ftp_path_to_url","text":"ncbi_ftp_path_to_url(; ftp_path, extension)\n\n\nExtensions include:\n\ngenomic.fna.gz\ngenomic.gff.gz\nprotein.faa.gz\nassembly_report.txt\nassembly_stats.txt\ncdsfromgenomic.fna.gz\nfeature_count.txt.gz\nfeature_table.txt.gz\ngenomic.gbff.gz\ngenomic.gtf.gz\nprotein.gpff.gz\ntranslated_cds.faa.gz\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ncbi_genome_download_accession-Tuple{}","page":"Home","title":"Mycelia.ncbi_genome_download_accession","text":"function ncbi_genome_download_accession(;\n        accession,\n        outdir = pwd(),\n        outpath = joinpath(outdir, accession * \".zip\"),\n        include_string = \"genome\"\n    )\n\nDownload an accession using NCBI datasets command line tool\n\nthe .zip download output to outpath will be unzipped\n\nreturns the outfolder\n\nncbi's default include string is  include_string = \"gff3,rna,cds,protein,genome,seq-report\"\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ncbi_taxon_summary-Tuple{Any}","page":"Home","title":"Mycelia.ncbi_taxon_summary","text":"ncbi_taxon_summary(taxa_id) -> DataFrames.DataFrame\n\n\nRetrieve taxonomic information for a given NCBI taxonomy ID.\n\nArguments\n\ntaxa_id: NCBI taxonomy identifier (integer)\n\nReturns\n\nDataFrame: Taxonomy summary containing fields like tax_id, rank, species, etc.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.nearest_prime-Tuple{Int64}","page":"Home","title":"Mycelia.nearest_prime","text":"nearest_prime(n::Int64) -> Int64\n\n\nFind the closest prime number to the given integer n.\n\nReturns the nearest prime number to n. If two prime numbers are equally distant  from n, returns the smaller one.\n\nArguments\n\nn::Int: The input integer to find the nearest prime for\n\nReturns\n\nInt: The closest prime number to n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.nersc_sbatch-Tuple{}","page":"Home","title":"Mycelia.nersc_sbatch","text":"nersc_sbatch(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    scriptdir,\n    qos,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd,\n    constraint\n)\n\n\nSubmit a batch job to NERSC's SLURM workload manager.\n\nArguments\n\njob_name: Identifier for the SLURM job\nmail_user: Email address for job notifications\nmail_type: Notification type (\"ALL\", \"BEGIN\", \"END\", \"FAIL\", or \"NONE\")\nlogdir: Directory for storing job output/error logs\nscriptdir: Directory for storing generated SLURM scripts\nqos: Quality of Service level (\"regular\", \"premium\", or \"preempt\")\nnodes: Number of nodes to allocate\nntasks: Number of tasks to run\ntime: Maximum wall time in format \"days-HH:MM:SS\"\ncpus_per_task: CPU cores per task\nmem_gb: Memory per node in GB\ncmd: Command(s) to execute (String or Vector{String})\nconstraint: Node type constraint (\"cpu\" or \"gpu\")\n\nReturns\n\ntrue if job submission succeeds\nfalse if submission fails\n\nQoS Options\n\nregular: Standard priority queue\npremium: High priority queue (5x throughput limit)\npreempt: Reduced credit usage but jobs may be interrupted\n\nhttps://docs.nersc.gov/jobs/policy/ https://docs.nersc.gov/systems/perlmutter/architecture/#cpu-nodes\n\ndefault is to use shared qos\n\nuse\n\nregular\npreempt (reduced credit usage but not guaranteed to finish)\npremium (priorty runs limited to 5x throughput)\n\nhttps://docs.nersc.gov/systems/perlmutter/running-jobs/#tips-and-tricks\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.nersc_sbatch_shared-Tuple{}","page":"Home","title":"Mycelia.nersc_sbatch_shared","text":"nersc_sbatch_shared(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    qos,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd,\n    constraint\n)\n\n\nSubmit a job to NERSC's SLURM scheduler using the shared QOS (Quality of Service).\n\nArguments\n\njob_name: Identifier for the job\nmail_user: Email address for job notifications\nmail_type: Notification type (\"ALL\", \"BEGIN\", \"END\", \"FAIL\", \"REQUEUE\", \"STAGE_OUT\")\nlogdir: Directory for storing job output and error logs\nqos: Quality of Service level (\"shared\", \"regular\", \"preempt\", \"premium\")\nnodes: Number of nodes to allocate\nntasks: Number of tasks to run\ntime: Maximum wall time in format \"days-hours:minutes:seconds\"\ncpus_per_task: Number of CPUs per task\nmem_gb: Memory per node in GB (default: 2GB per CPU)\ncmd: Command to execute\nconstraint: Node type constraint (\"cpu\" or \"gpu\")\n\nResource Limits\n\nMaximum memory per node: 512GB\nMaximum cores per node: 128\nDefault memory allocation: 2GB per CPU requested\n\nQOS Options\n\nshared: Default QOS for shared node usage\nregular: Standard priority\npreempt: Reduced credit usage but preemptible\npremium: 5x throughput priority (limited usage)\n\nReturns\n\ntrue if job submission succeeds\n\nhttps://docs.nersc.gov/jobs/policy/ https://docs.nersc.gov/systems/perlmutter/architecture/#cpu-nodes\n\ndefault is to use shared qos\n\nuse\n\nregular\npreempt (reduced credit usage but not guaranteed to finish)\npremium (priority runs limited to 5x throughput)\n\nmax request is 512Gb memory and 128 cores per node\n\nhttps://docs.nersc.gov/systems/perlmutter/running-jobs/#tips-and-tricks\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.node_type_to_dataframe-Tuple{}","page":"Home","title":"Mycelia.node_type_to_dataframe","text":"node_type_to_dataframe(; node_type, graph)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_codon_frequencies-Tuple{Any}","page":"Home","title":"Mycelia.normalize_codon_frequencies","text":"normalize_codon_frequencies(\n    codon_frequencies\n) -> Dict{BioSymbols.AminoAcid, Dict{Kmers.Kmer{BioSequences.DNAAlphabet{2}, 3, 1}, Float64}}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_countmap-Tuple{Any}","page":"Home","title":"Mycelia.normalize_countmap","text":"normalize_countmap(countmap) -> Dict\n\n\nNormalize a dictionary of counts into a probability distribution where values sum to 1.0.\n\nArguments\n\ncountmap::Dict: Dictionary mapping keys to count values\n\nReturns\n\nDict: New dictionary with same keys but values normalized by total sum\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.normalize_distance_matrix","text":"normalize_distance_matrix(distance_matrix) -> Any\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_vcf-Tuple{}","page":"Home","title":"Mycelia.normalize_vcf","text":"normalize_vcf(; reference_fasta, vcf_file)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalized_current_datetime-Tuple{}","page":"Home","title":"Mycelia.normalized_current_datetime","text":"normalized_current_datetime() -> String\n\n\nReturns the current date and time as a normalized string with all non-word characters removed.\n\nThe output format is based on ISO datetime (YYYYMMDDThhmmss) but strips any special characters like hyphens, colons or dots.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.observe-Tuple{R} where R<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}","page":"Home","title":"Mycelia.observe","text":"observe(\n    record::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record};\n    error_rate\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.observe-Union{Tuple{BioSequences.LongSequence{T}}, Tuple{T}} where T","page":"Home","title":"Mycelia.observe","text":"observe(sequence::BioSequences.LongSequence{T}; error_rate=nothing, tech::Symbol=:illumina) where T\n\nSimulates the observation of a biological polymer (DNA, RNA, or protein) by introducing realistic errors along with basequality scores. The simulation takes into account both random and systematic error components. In particular, for technologies:\n\nillumina: (mostly substitution errors) the perbase quality decays along the read (from ~Q40 at the start to ~Q20 at the end);\nnanopore: errors are more frequent and include both substitutions and indels (with overall lower quality scores, and an extra homopolymer penalty);\npacbio: errors are dominated by indels (with quality scores typical of raw reads);\nultima: (UG 100/ppmSeq) correct bases are assigned very high quality (~Q60) while errors are extremely rare and, if they occur, are given a modest quality.\n\nAn error is introduced at each position with a (possibly positiondependent) probability. For Illumina, the error probability increases along the read; additionally, if a base is part of a homopolymer run (length  3) and the chosen technology is one that struggles with homopolymers (nanopore, pacbio, ultima), then the local error probability is multiplied by a constant factor.\n\nReturns a tuple (new_seq, quality_scores) where:\n\nnew_seq is a BioSequences.LongSequence{T} containing the observed sequence (which may be longer or shorter than the input if insertions or deletions occur), and \nquality_scores is a vector of integers representing the Phred quality scores (using the Sanger convention) for each base in the output sequence.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.open_fastx-Tuple{AbstractString}","page":"Home","title":"Mycelia.open_fastx","text":"open_fastx(\n    path::AbstractString\n) -> Union{FASTX.FASTA.Reader, FASTX.FASTQ.Reader{T} where T<:(TranscodingStreams.TranscodingStream{C, S} where {S<:IO, C<:TranscodingStreams.Codec})}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.open_genbank-Tuple{Any}","page":"Home","title":"Mycelia.open_genbank","text":"open_genbank(\n    genbank_file\n) -> Vector{GenomicAnnotations.Record}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.open_gff-Tuple{String}","page":"Home","title":"Mycelia.open_gff","text":"open_gff(path::String) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_blast_report-Tuple{Any}","page":"Home","title":"Mycelia.parse_blast_report","text":"parse_blast_report(blast_report) -> DataFrames.DataFrame\n\n\nExpects output type 7 from BLAST, default output type 6 doesn't have the header comments and won't auto-parse\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_gfa-Tuple{Any}","page":"Home","title":"Mycelia.parse_gfa","text":"parse_gfa(gfa) -> MetaGraphs.MetaGraph{Int64, Float64}\n\n\nParse a GFA (Graphical Fragment Assembly) file into a MetaGraph representation.\n\nArguments\n\ngfa: Path to GFA format file\n\nReturns\n\nA MetaGraph where:\n\nVertices represent segments (contigs)\nEdges represent links between segments\nVertex properties include :id with segment identifiers\nGraph property :records contains the original FASTA records\n\nFormat Support\n\nHandles standard GFA v1 lines:\n\nH: Header lines (skipped)\nS: Segments (stored as nodes with FASTA records)\nL: Links (stored as edges)\nP: Paths (stored in paths dictionary)\nA: HiFiAsm specific lines (skipped)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_jsonl-Tuple{String}","page":"Home","title":"Mycelia.parse_jsonl","text":"parse_jsonl(filepath::String) -> Vector{Dict{String, Any}}\n\n\nParse a JSONL (JSON Lines) file into a vector of dictionaries.\n\nArguments\n\nfilepath::String: Path to the JSONL file to parse\n\nReturns\n\nVector{Dict{String, Any}}: Vector containing parsed JSON objects, one per line\n\nDescription\n\nReads a JSONL file line by line, parsing each line as a separate JSON object. Uses pre-allocation and progress tracking for efficient processing of large files.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_mmseqs_easy_taxonomy_lca_tsv-Tuple{Any}","page":"Home","title":"Mycelia.parse_mmseqs_easy_taxonomy_lca_tsv","text":"parse_mmseqs_easy_taxonomy_lca_tsv(\n    lca_tsv\n) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_mmseqs_easy_taxonomy_tophit_report-Tuple{Any}","page":"Home","title":"Mycelia.parse_mmseqs_easy_taxonomy_tophit_report","text":"parse_mmseqs_easy_taxonomy_tophit_report(\n    tophit_report\n) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_mmseqs_tophit_aln-Tuple{Any}","page":"Home","title":"Mycelia.parse_mmseqs_tophit_aln","text":"parse_mmseqs_tophit_aln(tophit_aln) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_qualimap_contig_coverage-Tuple{Any}","page":"Home","title":"Mycelia.parse_qualimap_contig_coverage","text":"parse_qualimap_contig_coverage(\n    qualimap_report_txt\n) -> DataFrames.DataFrame\n\n\nParse the contig coverage information from qualimap bamqc text report, which looks like the following:\n\n# this is spades\n>>>>>>> Coverage per contig\n\n\tNODE_1_length_107478_cov_9.051896\t107478\t21606903\t201.0355886786133\t60.39424208607496\n\tNODE_2_length_5444_cov_1.351945\t5444\t153263\t28.152645113886848\t5.954250612823136\n\tNODE_3_length_1062_cov_0.154390\t1062\t4294\t4.043314500941619\t1.6655384692688975\n\tNODE_4_length_776_cov_0.191489\t776\t3210\t4.13659793814433\t2.252009588980858\n\n# below is megahit\n>>>>>>> Coverage per contig\n\n\tk79_175\t235\t3862\t16.43404255319149\t8.437436249612457\n\tk79_89\t303\t3803\t12.551155115511552\t5.709975376279777\n\tk79_262\t394\t6671\t16.931472081218274\t7.579217802849293\n\tk79_90\t379\t1539\t4.060686015831134\t1.2929729111266581\n\tk79_91\t211\t3749\t17.767772511848342\t11.899185693011933\n\tk79_0\t2042\t90867\t44.49902056807052\t18.356525483516613\n\nTo make this more robust, consider reading in the names of the contigs from the assembled fasta\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_rtg_eval_output-Tuple{Any}","page":"Home","title":"Mycelia.parse_rtg_eval_output","text":"parse_rtg_eval_output(f) -> DataFrames.DataFrame\n\n\nParse RTG evaluation output from a gzipped tab-separated file.\n\nArguments\n\nf: Path to a gzipped TSV file containing RTG evaluation output\n\nFormat\n\nExpected file format:\n\nHeader line starting with '#' and tab-separated column names\nData rows in tab-separated format\nEmpty files return a DataFrame with empty columns matching header\n\nReturns\n\nA DataFrame where:\n\nColumn names are taken from the header line (stripped of '#')\nData is parsed as Float64 values\nEmpty files result in empty columns preserving header structure\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_transterm_output-Tuple{Any}","page":"Home","title":"Mycelia.parse_transterm_output","text":"parse_transterm_output(\n    transterm_output\n) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_virsorter_score_tsv-Tuple{Any}","page":"Home","title":"Mycelia.parse_virsorter_score_tsv","text":"parse_virsorter_score_tsv(\n    virsorter_score_tsv\n) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_xam_to_mapped_records_table","page":"Home","title":"Mycelia.parse_xam_to_mapped_records_table","text":"parse_xam_to_mapped_records_table(\n    xam\n) -> DataFrames.DataFrame\nparse_xam_to_mapped_records_table(\n    xam,\n    primary_only\n) -> DataFrames.DataFrame\n\n\nParse SAM/BAM files into a DataFrame containing mapped read alignments.\n\nArguments\n\nxam::String: Path to input SAM/BAM file (supports .sam, .bam, or .sam.gz)\nprimary_only::Bool=false: Flag to filter for primary alignments only (currently unused)\n\nReturns\n\nDataFrame with columns:\n\ntemplate: Read template name\nflag: SAM flag\nreference: Reference sequence name\nposition: Alignment position range\nmappingquality: Mapping quality score\ntlen: Template length\nalignlength: Alignment length\nismapped: Boolean indicating if read is mapped\nisprimary: Boolean indicating if alignment is primary\nalignment_score: Alignment score (AS tag)\nmismatches: Number of mismatches (NM tag)\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.parse_xam_to_primary_mapping_table-Tuple{Any}","page":"Home","title":"Mycelia.parse_xam_to_primary_mapping_table","text":"parse_xam_to_primary_mapping_table(\n    xam\n) -> DataFrames.DataFrame\n\n\nParse a SAM/BAM alignment file and extract template-to-reference mapping information.\n\nArguments\n\nxam::String: Path to input alignment file (.sam, .sam.gz, or .bam format)\n\nReturns\n\nDataFrame: Table with columns:\ntemplate: Read template names\nreference: Reference sequence names\n\nOnly includes primary alignments (not secondary/supplementary) that are mapped to references. Skips header lines starting with '@'.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_xam_to_summary_table-Tuple{Any}","page":"Home","title":"Mycelia.parse_xam_to_summary_table","text":"parse_xam_to_summary_table(xam) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_xam_to_taxonomic_mapping_quality","page":"Home","title":"Mycelia.parse_xam_to_taxonomic_mapping_quality","text":"parse_xam_to_taxonomic_mapping_quality(\n    xam\n) -> DataFrames.DataFrame\nparse_xam_to_taxonomic_mapping_quality(\n    xam,\n    primary_only\n) -> DataFrames.DataFrame\n\n\nParse alignment data from SAM/BAM files into a structured DataFrame containing mapping quality and taxonomic information.\n\nArguments\n\nxam::String: Path to input file (.sam, .bam, or .sam.gz)\nprimary_only::Bool=false: When true, include only primary alignments (currently not implemented)\n\nReturns\n\nDataFrames.DataFrame with columns:\n\ntemplate: Read name\nflag: SAM flag\nreference: Reference sequence name  \nposition: Alignment position range\nmappingquality: Mapping quality score\ntlen: Template length\nalignlength: Alignment length\nismapped: Boolean indicating if read is mapped\nisprimary: Boolean indicating if alignment is primary\nalignment_score: Alignment score (AS tag)\nmismatches: Number of mismatches (NM tag)\n\nNotes\n\nSkips unmapped reads\nAutomatically detects and handles SAM/BAM/compressed SAM formats\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.path_to_sequence-Tuple{Any, Any}","page":"Home","title":"Mycelia.path_to_sequence","text":"path_to_sequence(kmers, path) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.pixels_to_points-Tuple{Any}","page":"Home","title":"Mycelia.pixels_to_points","text":"pixels_to_points(pixels) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_graph-Tuple{Any}","page":"Home","title":"Mycelia.plot_graph","text":"plot_graph(graph) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_kmer_frequency_spectra-Tuple{Any}","page":"Home","title":"Mycelia.plot_kmer_frequency_spectra","text":"plot_kmer_frequency_spectra(\n    counts;\n    log_scale,\n    kwargs...\n) -> Plots.Plot\n\n\nPlots a histogram of kmer counts against # of kmers with those counts\n\nReturns the plot object for adding additional layers and saving\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_optimal_cluster_assessment_results-Tuple{Any}","page":"Home","title":"Mycelia.plot_optimal_cluster_assessment_results","text":"plot_optimal_cluster_assessment_results(\n    clustering_results\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.points_to_pixels-Tuple{Any}","page":"Home","title":"Mycelia.points_to_pixels","text":"points_to_pixels(points) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.polish_fastq-Tuple{}","page":"Home","title":"Mycelia.polish_fastq","text":"polish_fastq(; fastq, k)\n\n\nPolish FASTQ reads using a k-mer graph-based approach to correct potential sequencing errors.\n\nArguments\n\nfastq::String: Path to input FASTQ file\nk::Int=1: Initial k-mer size parameter. Final assembly k-mer size may differ.\n\nProcess\n\nBuilds a directed k-mer graph from input reads\nProcesses each read through the graph to find optimal paths\nWrites corrected reads to a new FASTQ file\nAutomatically compresses output with gzip\n\nReturns\n\nNamed tuple with:\n\nfastq::String: Path to output gzipped FASTQ file\nk::Int: Final assembly k-mer size used\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.prefetch-Tuple{}","page":"Home","title":"Mycelia.prefetch","text":"prefetch(; SRR, outdir)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.process_fastq_record-Tuple{}","page":"Home","title":"Mycelia.process_fastq_record","text":"process_fastq_record(\n;\n    record,\n    kmer_graph,\n    yen_k_shortest_paths_and_weights,\n    yen_k\n)\n\n\nProcess and error-correct a FASTQ sequence record using a kmer graph and path resampling.\n\nArguments\n\nrecord: FASTQ record containing the sequence to process\nkmer_graph: MetaGraph containing the kmer network and associated properties\nyen_k_shortest_paths_and_weights: Cache of pre-computed k-shortest paths between nodes\nyen_k: Number of alternative paths to consider during resampling (default: 3)\n\nDescription\n\nPerforms error correction by:\n\nTrimming low-quality sequence ends\nIdentifying stretches requiring resampling between solid branching kmers\nSelecting alternative paths through the kmer graph based on:\nPath quality scores\nTransition likelihoods\nPath length similarity to original sequence\n\nReturns\n\nModified FASTQ record with error-corrected sequence and updated quality scores\nOriginal record if no error correction was needed\n\nRequired Graph Properties\n\nThe kmer_graph must contain the following properties:\n\n:ordered_kmers\n:likelyvalidkmer_indices  \n:kmer_indices\n:branching_nodes\n:assembly_k\n:transition_likelihoods\n:kmermeanquality\n:kmertotalquality\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.q_value_to_error_rate-Tuple{Any}","page":"Home","title":"Mycelia.q_value_to_error_rate","text":"q_value_to_error_rate(q_value) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rand_of_each_group-Tuple{DataFrames.GroupedDataFrame{DataFrames.DataFrame}}","page":"Home","title":"Mycelia.rand_of_each_group","text":"rand_of_each_group(\n    gdf::DataFrames.GroupedDataFrame{DataFrames.DataFrame}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.random_fasta_record-Tuple{}","page":"Home","title":"Mycelia.random_fasta_record","text":"random_fasta_record(\n;\n    moltype,\n    seed,\n    L\n) -> FASTX.FASTA.Record\n\n\nGenerates a random FASTA record with a specified molecular type and sequence length.\n\nArguments\n\nmoltype::Symbol=:DNA: The type of molecule to generate (:DNA, :RNA, or :AA for amino acids).\nseed: The random seed used for sequence generation (default: a random integer).\nL: The length of the sequence (default: a random integer up to typemax(UInt16)).\n\nReturns\n\nA FASTX.FASTA.Record containing:\nA randomly generated UUID identifier.\nA randomly generated sequence of the specified type.\n\nErrors\n\nThrows an error if moltype is not one of :DNA, :RNA, or :AA.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.random_symmetric_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.random_symmetric_distance_matrix","text":"random_symmetric_distance_matrix(n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rclone_copy-Tuple{Any, Any}","page":"Home","title":"Mycelia.rclone_copy","text":"rclone_copy(source, dest; config, max_attempts, sleep_timer)\n\n\nCopy files between local and remote storage using rclone with automated retry logic.\n\nArguments\n\nsource::String: Source path or remote (e.g. \"local/path\" or \"gdrive:folder\")\ndest::String: Destination path or remote (e.g. \"gdrive:folder\" or \"local/path\")\n\nKeywords\n\nconfig::String=\"\": Optional path to rclone config file\nmax_attempts::Int=3: Maximum number of retry attempts\nsleep_timer::Int=60: Initial sleep duration between retries in seconds (doubles after each attempt)\n\nDetails\n\nUses optimized rclone settings for large files:\n\n2GB chunk size\n1TB upload cutoff\nRate limited to 1 transaction per second\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rclone_list_directories-Tuple{Any}","page":"Home","title":"Mycelia.rclone_list_directories","text":"rclone_list_directories(path) -> Any\n\n\nList all directories at the specified rclone path.\n\nArguments\n\npath::String: Remote path to list directories from (e.g. \"remote:/path/to/dir\")\n\nReturns\n\nVector{String}: Full paths to all directories found at the specified location\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_fastani-Tuple{String}","page":"Home","title":"Mycelia.read_fastani","text":"read_fastani(path::String) -> DataFrames.DataFrame\n\n\nImports results of fastani\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_gff-Tuple{AbstractString}","page":"Home","title":"Mycelia.read_gff","text":"read_gff(gff::AbstractString) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_gff-Tuple{Any}","page":"Home","title":"Mycelia.read_gff","text":"read_gff(gff_io) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_kraken_report-Tuple{Any}","page":"Home","title":"Mycelia.read_kraken_report","text":"read_kraken_report(kraken_report) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_mmseqs_easy_search-Tuple{Any}","page":"Home","title":"Mycelia.read_mmseqs_easy_search","text":"read_mmseqs_easy_search(mmseqs_file) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.reverse_translate-Tuple{BioSequences.LongAA}","page":"Home","title":"Mycelia.reverse_translate","text":"reverse_translate(\n    protein_sequence::BioSequences.LongAA\n) -> BioSequences.LongSequence{BioSequences.DNAAlphabet{2}}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rolling_centered_avg-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Home","title":"Mycelia.rolling_centered_avg","text":"rolling_centered_avg(data::AbstractArray{T, 1}; window_size)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_blast-Tuple{}","page":"Home","title":"Mycelia.run_blast","text":"run_blast(\n;\n    out_dir,\n    fasta,\n    blast_db,\n    blast_command,\n    force,\n    remote,\n    wait\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_blastn-Tuple{}","page":"Home","title":"Mycelia.run_blastn","text":"run_blastn(\n;\n    out_dir,\n    fasta,\n    blast_db,\n    task,\n    force,\n    remote,\n    wait\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_clustal_omega-Tuple{}","page":"Home","title":"Mycelia.run_clustal_omega","text":"run_clustal_omega(; fasta, outfmt)\n\n\nRun Clustal Omega multiple sequence alignment on a FASTA file.\n\nArguments\n\nfasta::String: Path to input FASTA file\noutfmt::String=\"clustal\": Output format for the alignment\n\nReturns\n\nString: Path to the output alignment file\n\nSupported Output Formats\n\n\"fasta\": FASTA format\n\"clustal\": Clustal format\n\"msf\": MSF format  \n\"phylip\": PHYLIP format\n\"selex\": SELEX format\n\"stockholm\": Stockholm format\n\"vienna\": Vienna format\n\nNotes\n\nUses Bioconda to manage the Clustal Omega installation\nCaches results - will return existing output file if already generated\nHandles single sequence files gracefully by returning output path without error\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_ectyper-Tuple{Any}","page":"Home","title":"Mycelia.run_ectyper","text":"run_ectyper(fasta_file) -> Any\n\n\nRun ECTyper for serotyping E. coli genome assemblies.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing assembled genome(s)\n\nReturns\n\nString: Path to output directory containing ECTyper results\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_hifiasm-Tuple{}","page":"Home","title":"Mycelia.run_hifiasm","text":"run_hifiasm(; fastq, outdir)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_mlst-Tuple{Any}","page":"Home","title":"Mycelia.run_mlst","text":"run_mlst(fasta_file) -> String\n\n\nRun Multi-Locus Sequence Typing (MLST) analysis on a genome assembly.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing the genome assembly\n\nReturns\n\nPath to the output file containing MLST results (<input>.mlst.out)\n\nDetails\n\nUses the mlst tool from PubMLST to identify sequence types by comparing allelic  profiles of housekeeping genes against curated MLST schemes.\n\nDependencies\n\nRequires Bioconda and the mlst package\nAutomatically sets up conda environment if not present\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_mmseqs_easy_search-Tuple{}","page":"Home","title":"Mycelia.run_mmseqs_easy_search","text":"run_mmseqs_easy_search(\n;\n    query_fasta,\n    target_database,\n    out_dir,\n    outfile,\n    format_output,\n    threads,\n    force\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_padloc-Tuple{Any}","page":"Home","title":"Mycelia.run_padloc","text":"run_padloc(fasta_file) -> Union{Nothing, Base.Process}\n\n\nRun the 'padloc' tool from the 'padlocbio' conda environment on a given FASTA file.\n\nhttps://doi.org/10.1093/nar/gkab883 https://github.com/padlocbio/padloc\n\nThis function first ensures that the 'padloc' environment is available via Bioconda.  It then attempts to update the 'padloc' database.  If a 'padloc' output file (with a '_padloc.csv' suffix) does not already exist for the input FASTA file,  it runs 'padloc' with the specified FASTA file as input.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_prodigal-Tuple{}","page":"Home","title":"Mycelia.run_prodigal","text":"run_prodigal(; fasta_file, out_dir)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_pyrodigal-Tuple{}","page":"Home","title":"Mycelia.run_pyrodigal","text":"run_pyrodigal(; fasta_file, out_dir)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_samtools_flagstat","page":"Home","title":"Mycelia.run_samtools_flagstat","text":"run_samtools_flagstat(xam) -> Any\nrun_samtools_flagstat(xam, samtools_flagstat) -> Any\n\n\nGenerate alignment statistics for a SAM/BAM/CRAM file using samtools flagstat.\n\nArguments\n\nxam::AbstractString: Path to input SAM/BAM/CRAM alignment file\nsamtools_flagstat::AbstractString: Output path for flagstat results (default: input_path.samtools-flagstat.txt)\n\nReturns\n\nString: Path to the generated flagstat output file\n\nDetails\n\nRuns samtools flagstat to calculate statistics on the alignment file, including:\n\nTotal reads\nSecondary alignments\nSupplementary alignments  \nDuplicates\nMapped/unmapped reads\nProper pairs\nRead 1/2 counts\n\nRequirements\n\nRequires samtools to be available via Bioconda\nInput file must be in SAM, BAM or CRAM format\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.run_transterm-Tuple{}","page":"Home","title":"Mycelia.run_transterm","text":"run_transterm(; fasta, gff)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_trnascan-Tuple{}","page":"Home","title":"Mycelia.run_trnascan","text":"run_trnascan(; fna_file, outdir)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.samtools_index_fasta-Tuple{}","page":"Home","title":"Mycelia.samtools_index_fasta","text":"samtools_index_fasta(; fasta)\n\n\nCreates an index file (.fai) for a FASTA reference sequence using samtools.\n\nThe FASTA index allows efficient random access to the reference sequence. This is  required by many bioinformatics tools that need to quickly fetch subsequences  from the reference.\n\nArguments\n\nfasta: Path to the input FASTA file\n\nSide Effects\n\nCreates a {fasta}.fai index file in the same directory as input\nInstalls samtools via conda if not already present\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.save_graph-Tuple{Graphs.AbstractGraph, String}","page":"Home","title":"Mycelia.save_graph","text":"save_graph(\n    graph::Graphs.AbstractGraph,\n    outfile::String\n) -> String\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.save_matrix_jld2-Tuple{}","page":"Home","title":"Mycelia.save_matrix_jld2","text":"save_matrix_jld2(; matrix, filename)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.scg_sbatch-Tuple{}","page":"Home","title":"Mycelia.scg_sbatch","text":"scg_sbatch(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    partition,\n    account,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd\n)\n\n\nSubmit a job to SLURM using sbatch with specified parameters.\n\nArguments\n\njob_name::String: Name identifier for the SLURM job\nmail_user::String: Email address for job notifications\nmail_type::String: Type of mail notifications (default: \"ALL\")\nlogdir::String: Directory for error and output logs (default: \"~/workspace/slurmlogs\")\npartition::String: SLURM partition to submit job to\naccount::String: Account to charge for compute resources\nnodes::Int: Number of nodes to allocate (default: 1)\nntasks::Int: Number of tasks to run (default: 1)\ntime::String: Maximum wall time in format \"days-hours:minutes:seconds\" (default: \"1-00:00:00\")\ncpus_per_task::Int: CPUs per task (default: 1)\nmem_gb::Int: Memory in GB, defaults to 32GB per CPU\ncmd::String: Command to execute\n\nReturns\n\nBool: Returns true if submission succeeds\n\nNotes\n\nFunction includes 5-second delays before and after submission\nMemory is automatically scaled with CPU count\nLog files are named with job ID (%j) and job name (%x)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.seq2sha256-Tuple{AbstractString}","page":"Home","title":"Mycelia.seq2sha256","text":"seq2sha256(seq::AbstractString) -> String\n\n\nCompute the SHA-256 hash of a sequence string.\n\nArguments\n\nseq::AbstractString: Input sequence to be hashed\n\nReturns\n\nString: Hexadecimal representation of the SHA-256 hash\n\nDetails\n\nThe input sequence is converted to uppercase before hashing.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.seq2sha256-Tuple{BioSequences.BioSequence}","page":"Home","title":"Mycelia.seq2sha256","text":"seq2sha256(seq::BioSequences.BioSequence) -> String\n\n\nConvert a biological sequence to its SHA256 hash value.\n\nCalculates a cryptographic hash of the sequence by first converting it to a string representation. This method dispatches to the string version of seq2sha256.\n\nArguments\n\nseq::BioSequences.BioSequence: The biological sequence to hash\n\nReturns\n\nString: A 64-character hexadecimal string representing the SHA256 hash\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sequence_to_stranded_path-Tuple{Any, Any}","page":"Home","title":"Mycelia.sequence_to_stranded_path","text":"sequence_to_stranded_path(\n    stranded_kmers,\n    sequence\n) -> Vector{Pair{Int64, Bool}}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.setup_taxonkit_taxonomy-Tuple{}","page":"Home","title":"Mycelia.setup_taxonkit_taxonomy","text":"setup_taxonkit_taxonomy() -> String\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.showall_blastdbs-Tuple{}","page":"Home","title":"Mycelia.showall_blastdbs","text":"showall_blastdbs(; source) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_nanopore_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_nanopore_reads","text":"simulate_nanopore_reads(; fasta, quantity, outfile)\n\n\nSimulate Oxford Nanopore sequencing reads using the Badread tool with 2023 error models.\n\nArguments\n\nfasta::String: Path to input reference FASTA file\nquantity::String: Either fold coverage (e.g. \"50x\") or total bases to sequence (e.g. \"1000000\")\noutfile::String: Output path for gzipped FASTQ file. Defaults to input filename with modified extension\n\nReturns\n\nString: Path to the generated output FASTQ file\n\nSee also: simulate_pacbio_reads, simulate_nearly_perfect_long_reads, simulate_short_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_nearly_perfect_long_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_nearly_perfect_long_reads","text":"simulate_nearly_perfect_long_reads()\n\n\nSimulate high-quality long reads with minimal errors using Badread.\n\nArguments\n\nreference::String: Path to reference FASTA file\nquantity::String: Coverage depth (e.g. \"50x\") or total bases (e.g. \"1000000\")\nlength_mean::Int=40000: Mean read length\nlength_sd::Int=20000: Standard deviation of read length\n\nReturns\n\nVector of simulated reads in FASTQ format\n\nDetails\n\nGenerates nearly perfect long reads by setting error rates and artifacts to minimum values. Uses ideal quality scores and disables common sequencing artifacts like chimeras and adapters.\n\nSee also: simulate_pacbio_reads, simulate_nanopore_reads, simulate_short_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_pacbio_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_pacbio_reads","text":"simulate_pacbio_reads(; fasta, quantity, outfile)\n\n\nSimulate PacBio HiFi reads using the Badread error model.\n\nArguments\n\nfasta::String: Path to input FASTA file containing reference sequence\nquantity::String: Coverage depth (e.g. \"50x\") or total bases (e.g. \"1000000\") - NOT TOTAL READS\noutfile::String: Output filepath for simulated reads. Defaults to input filename with \".badread.pacbio2021.{quantity}.fq.gz\" suffix\n\nReturns\n\nString: Path to the generated output file\n\nNotes\n\nRequires Badread tool from Bioconda\nUses PacBio 2021 error and quality score models\nAverage read length ~15kb\nOutput is gzipped FASTQ format\n\nSee also: simulate_nanopore_reads, simulate_nearly_perfect_long_reads, simulate_short_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_short_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_short_reads","text":"simulate_short_reads(; in_fasta, coverage, outbase)\n\n\nSimulate Illumina paired-end short reads from a FASTA file using ART simulator.\n\nArguments\n\nin_fasta::String: Input FASTA file path\ncoverage::Number: Desired read coverage/depth\noutbase::String: Prefix for output files (default: \"in_fastaart{coverage}x.\")\n\nOutputs\n\nGenerates two gzipped FASTQ files:\n\n${outbase}1.fq.gz: Forward reads\n${outbase}2.fq.gz: Reverse reads\n\nDetails\n\nUses ART Illumina with the following parameters:\n\nRead length: 150bp\nFragment length: 500bp (SD: 10bp)\nSequencing system: HiSeq 2500 (HS25)\n\nDependencies\n\nRequires ART simulator (automatically installed via Bioconda)\n\nSee also: simulate_nanopore_reads, simulate_nearly_perfect_long_reads, simulate_pacbio_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_variants-Tuple{FASTX.FASTA.Record}","page":"Home","title":"Mycelia.simulate_variants","text":"simulate_variants(\n    fasta_record::FASTX.FASTA.Record;\n    n_variants,\n    window_size,\n    variant_size_disbribution,\n    variant_type_likelihoods\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_variants-Tuple{String}","page":"Home","title":"Mycelia.simulate_variants","text":"simulate_variants(fasta_file::String) -> String\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sort_fastq","page":"Home","title":"Mycelia.sort_fastq","text":"sort_fastq(input_fastq) -> String\nsort_fastq(input_fastq, output_fastq) -> Any\n\n\nThis turns a 4-line FASTQ entry into a single tab separated line, adds a column with the length of each read, passes it to Unix sort, removes the length column, and converts it back into a FASTQ file.\n\nsorts longest to shortest!!\n\nhttp://thegenomefactory.blogspot.com/2012/11/sorting-fastq-files-by-sequence-length.html\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.split_gff_attributes_into_columns-Tuple{Any}","page":"Home","title":"Mycelia.split_gff_attributes_into_columns","text":"split_gff_attributes_into_columns(gff_df) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.subsample_reads_seqkit-Tuple{}","page":"Home","title":"Mycelia.subsample_reads_seqkit","text":"subsample_reads_seqkit(\n;\n    in_fastq,\n    out_fastq,\n    n_reads,\n    proportion_reads\n)\n\n\nSubsample reads from a FASTQ file using seqkit.\n\nArguments\n\nin_fastq::String: Path to input FASTQ file\nout_fastq::String=\"\": Path to output FASTQ file. If empty, auto-generated based on input filename\nn_reads::Union{Missing,Int}=missing: Number of reads to sample\nproportion_reads::Union{Missing,Float64}=missing: Proportion of reads to sample (0.0-1.0)\n\nReturns\n\nString: Path to the output FASTQ file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.system_mem_to_minimap_index_size-Tuple{}","page":"Home","title":"Mycelia.system_mem_to_minimap_index_size","text":"system_mem_to_minimap_index_size(\n;\n    system_mem_gb,\n    denominator\n)\n\n\nCalculate appropriate minimap index size based on available system memory.\n\nConverts total system memory to a recommended minimap index size by dividing the available memory by a denominator factor. Returns the size as a string with 'G' suffix.\n\nArguments\n\nsystem_mem_gb::Number: Total system memory in gigabytes\ndenominator::Number=DEFAULT_MINIMAP_DENOMINATOR: Divisor to scale down memory allocation\n\nReturns\n\nString: Formatted memory size string (e.g. \"4G\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.system_overview-Tuple{}","page":"Home","title":"Mycelia.system_overview","text":"system_overview(\n;\n    path\n) -> @NamedTuple{system_threads::Int64, julia_threads::Int64, total_memory::String, available_memory::String, occupied_memory::String, total_storage::String, available_storage::String, occupied_storage::String}\n\n\nParse a JSONL (JSON Lines) file into a vector of dictionaries.\n\nArguments\n\nfilepath::String: Path to the JSONL file to parse\n\nReturns\n\nVector{Dict{String, Any}}: Vector containing parsed JSON objects, one per line\n\nDescription\n\nReads a JSONL file line by line, parsing each line as a separate JSON object. Uses pre-allocation and progress tracking for efficient processing of large files.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.tar_extract-Tuple{}","page":"Home","title":"Mycelia.tar_extract","text":"tar_extract(; tarchive, directory)\n\n\nExtract contents of a gzipped tar archive file to a specified directory.\n\nArguments\n\ntarchive::AbstractString: Path to the .tar.gz file to extract\ndirectory::AbstractString=dirname(tarchive): Target directory for extraction (defaults to the archive's directory)\n\nReturns\n\nAbstractString: Path to the directory where contents were extracted\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2lca-Tuple{Vector{Int64}}","page":"Home","title":"Mycelia.taxids2lca","text":"taxids2lca(ids::Vector{Int64}) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2ncbi_taxonomy_table-Tuple{AbstractVector{Int64}}","page":"Home","title":"Mycelia.taxids2ncbi_taxonomy_table","text":"taxids2ncbi_taxonomy_table(\n    taxids::AbstractVector{Int64}\n) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2taxonkit_summarized_lineage_table-Tuple{AbstractVector{Int64}}","page":"Home","title":"Mycelia.taxids2taxonkit_summarized_lineage_table","text":"taxids2taxonkit_summarized_lineage_table(\n    taxids::AbstractVector{Int64}\n) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2taxonkit_taxid2lineage_ranks-Tuple{AbstractVector{Int64}}","page":"Home","title":"Mycelia.taxids2taxonkit_taxid2lineage_ranks","text":"taxids2taxonkit_taxid2lineage_ranks(\n    taxids::AbstractVector{Int64}\n) -> Dict{Int64, Dict{String, @NamedTuple{lineage::String, taxid::Union{Missing, Int64}}}}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxonomic_id_to_children-Tuple{Any}","page":"Home","title":"Mycelia.taxonomic_id_to_children","text":"taxonomic_id_to_children(\n    tax_id;\n    DATABASE_ID,\n    USERNAME,\n    PASSWORD\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.translate_nucleic_acid_fasta-Tuple{Any, Any}","page":"Home","title":"Mycelia.translate_nucleic_acid_fasta","text":"translate_nucleic_acid_fasta(\n    fasta_nucleic_acid_file,\n    fasta_amino_acid_file\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.transterm_output_to_gff-Tuple{Any}","page":"Home","title":"Mycelia.transterm_output_to_gff","text":"transterm_output_to_gff(transterm_output) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.trim_galore-Tuple{}","page":"Home","title":"Mycelia.trim_galore","text":"trim_galore(\n;\n    outdir,\n    identifier\n) -> Union{Nothing, Base.Process}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.type_to_string-Tuple{AbstractString}","page":"Home","title":"Mycelia.type_to_string","text":"type_to_string(T::AbstractString) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.type_to_string-Tuple{Any}","page":"Home","title":"Mycelia.type_to_string","text":"type_to_string(T) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.update_bioconda_env-Tuple{Any}","page":"Home","title":"Mycelia.update_bioconda_env","text":"update_bioconda_env(pkg) -> Base.Process\n\n\nUpdate a package and its dependencies in its dedicated Conda environment.\n\nArguments\n\npkg::String: Name of the package/environment to update\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.update_fasta_with_vcf-Tuple{}","page":"Home","title":"Mycelia.update_fasta_with_vcf","text":"update_fasta_with_vcf(; in_fasta, vcf_file, out_fasta)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.update_gff_with_mmseqs-Tuple{Any, Any}","page":"Home","title":"Mycelia.update_gff_with_mmseqs","text":"update_gff_with_mmseqs(gff_file, mmseqs_file)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_edge_type_over_url_from_graph-Tuple{}","page":"Home","title":"Mycelia.upload_edge_type_over_url_from_graph","text":"upload_edge_type_over_url_from_graph(\n;\n    src_type,\n    dst_type,\n    edge_type,\n    graph,\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE,\n    window_size\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_node_over_api-Tuple{Any, Any}","page":"Home","title":"Mycelia.upload_node_over_api","text":"upload_node_over_api(\n    graph,\n    v;\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_node_table-Tuple{}","page":"Home","title":"Mycelia.upload_node_table","text":"upload_node_table(\n;\n    table,\n    window_size,\n    address,\n    password,\n    username,\n    database,\n    neo4j_import_dir\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_node_type_over_url_from_graph-Tuple{}","page":"Home","title":"Mycelia.upload_node_type_over_url_from_graph","text":"upload_node_type_over_url_from_graph(\n;\n    node_type,\n    graph,\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE,\n    window_size\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_nodes_over_api-Tuple{Any}","page":"Home","title":"Mycelia.upload_nodes_over_api","text":"upload_nodes_over_api(\n    graph;\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_nodes_to_neo4j-Tuple{}","page":"Home","title":"Mycelia.upload_nodes_to_neo4j","text":"upload_nodes_to_neo4j(\n;\n    graph,\n    address,\n    username,\n    password,\n    format,\n    database,\n    neo4j_import_directory\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.vcat_with_missing-Tuple{Vararg{DataFrames.AbstractDataFrame}}","page":"Home","title":"Mycelia.vcat_with_missing","text":"vcat_with_missing(\n    dfs::DataFrames.AbstractDataFrame...\n) -> Union{DataFrames.DataFrame, Vector{Any}}\n\n\nVertically concatenate DataFrames with different column structures by automatically handling missing values.\n\nArguments\n\ndfs: Variable number of DataFrames to concatenate vertically\n\nReturns\n\nDataFrame: Combined DataFrame containing all rows and columns from input DataFrames,  with missing values where columns didn't exist in original DataFrames\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.visualize_genome_coverage-Tuple{Any}","page":"Home","title":"Mycelia.visualize_genome_coverage","text":"visualize_genome_coverage(coverage_table) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.viterbi_maximum_likelihood_traversals-Tuple{Any}","page":"Home","title":"Mycelia.viterbi_maximum_likelihood_traversals","text":"viterbi_maximum_likelihood_traversals(\n    stranded_kmer_graph;\n    error_rate,\n    verbosity\n) -> Vector{FASTX.FASTA.Record}\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.wcss-Tuple{Any}","page":"Home","title":"Mycelia.wcss","text":"wcss(clustering_result) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_fasta-Tuple{}","page":"Home","title":"Mycelia.write_fasta","text":"write_fasta(; outfile, records, gzip)\n\n\nWrites FASTA records to a file, optionally gzipped.\n\nArguments\n\noutfile::AbstractString: Path to the output FASTA file.  Will append \".gz\" if gzip is true.\nrecords::Vector{FASTX.FASTA.Record}: A vector of FASTA records.\ngzip::Bool=false: Whether to compress the output with gzip.\n\nReturns\n\noutfile::String: The path to the output FASTA file (including \".gz\" if applicable).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_gff-Tuple{}","page":"Home","title":"Mycelia.write_gff","text":"write_gff(; gff, outfile)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_vcf_table-Tuple{}","page":"Home","title":"Mycelia.write_vcf_table","text":"write_vcf_table(; vcf_file, vcf_table, fasta_file)\n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.xam_to_contig_mapping_stats-Tuple{Any}","page":"Home","title":"Mycelia.xam_to_contig_mapping_stats","text":"xam_to_contig_mapping_stats(xam) -> Any\n\n\nGenerate detailed mapping statistics for each reference sequence/contig in a XAM (SAM/BAM/CRAM) file.\n\nArguments\n\nxam: Path to XAM file or XAM object\n\nReturns\n\nA DataFrame with per-contig statistics including:\n\nn_aligned_reads: Number of aligned reads\ntotal_aligned_bases: Sum of alignment lengths\ntotal_alignment_score: Sum of alignment scores\nMapping quality statistics (mean, std, median)\nAlignment length statistics (mean, std, median)\nAlignment score statistics (mean, std, median)\nPercent mismatches statistics (mean, std, median)\n\nNote: Only primary alignments (isprimary=true) and mapped reads (ismapped=true) are considered.\n\n\n\n\n\n","category":"method"}]
}
