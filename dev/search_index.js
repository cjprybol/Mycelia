var documenterSearchIndex = {"docs":
[{"location":"generated/tutorials/16_un_corpus_ngram_vs_token_graphs/#Tutorial-16:-UN-Corpus-N-gram-vs-SentencePiece-Token-Graphs","page":"Step 16: UN Corpus Ngram vs Token Graphs","title":"Tutorial 16: UN Corpus N-gram vs SentencePiece Token Graphs","text":"This tutorial compares two text-graph constructions over the UN Parallel Corpus:\n\nCharacter n-gram graphs per language.\nSentencePiece token graphs per language (token adjacency).\n\nThe goals are to:\n\nBuild n-gram graphs across several n values for each language.\nSummarize graph statistics/topology.\nTrain SentencePiece models per language and build token graphs with multiple vocab sizes.\nCompare topology metrics between n-gram and token graphs.\n\nGenerate a notebook from this Literate script:\n\njulia --project=docs -e 'import Literate; Literate.notebook(\"tutorials/16_un_corpus_ngram_vs_token_graphs.jl\", \"tutorials\"; execute=false)'\n\nNOTE: UN Corpus downloads and SentencePiece training are resource-intensive and opt-in. Set MYCELIA_RUN_EXTERNAL=true to run those sections.","category":"section"},{"location":"generated/tutorials/16_un_corpus_ngram_vs_token_graphs/#Setup","page":"Step 16: UN Corpus Ngram vs Token Graphs","title":"Setup","text":"import Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Dates\nimport Mycelia\nimport Test\n\nExternal tool gates (UN corpus download + SentencePiece).\n\nconst RUN_EXTERNAL = get(ENV, \"MYCELIA_RUN_EXTERNAL\", \"false\") == \"true\"","category":"section"},{"location":"generated/tutorials/16_un_corpus_ngram_vs_token_graphs/#Configuration","page":"Step 16: UN Corpus Ngram vs Token Graphs","title":"Configuration","text":"const DATA_ROOT = joinpath(homedir(), \"workspace\", \"un_corpus\")\nconst OUTDIR = joinpath(DATA_ROOT, \"un_corpus_graphs\")\nconst UN_SUBSETS = [\"all\"]\nconst NGRAM_SIZES = [3, 4, 5]\nconst TOKEN_VOCAB_SIZES = [2000, 8000]\nconst MAX_LINES_PER_LANGUAGE = nothing  # Set to an Int for quick runs\n\nprintln(\"Workspace: \", OUTDIR)\n\nprintln(\"\"\"\nCleanup (optional):\n  rm -rf $(OUTDIR)\n\"\"\")","category":"section"},{"location":"generated/tutorials/16_un_corpus_ngram_vs_token_graphs/#Step-1:-Download-the-UN-Parallel-Corpus-(Opt-in)","page":"Step 16: UN Corpus Ngram vs Token Graphs","title":"Step 1: Download the UN Parallel Corpus (Opt-in)","text":"Uses the built-in downloader from Mycelia.download_un_parallel_corpus.\n\ncorpus_dir = joinpath(OUTDIR, \"un_corpus\")\nif RUN_EXTERNAL\n    mkpath(OUTDIR)\n    corpus_dir = Mycelia.download_un_parallel_corpus(\n        outdir=OUTDIR,\n        subsets=UN_SUBSETS,\n        formats=[\"txt\"]\n    )\n    println(\"UN corpus downloaded to: \", corpus_dir)\nelse\n    println(\"Skipping UN corpus download. Set MYCELIA_RUN_EXTERNAL=true to run.\")\n    if !isdir(corpus_dir)\n        error(\"UN corpus not found at $(corpus_dir). Download it or set MYCELIA_RUN_EXTERNAL=true.\")\n    end\nend","category":"section"},{"location":"generated/tutorials/16_un_corpus_ngram_vs_token_graphs/#Step-2:-Identify-per-language-corpora","page":"Step 16: UN Corpus Ngram vs Token Graphs","title":"Step 2: Identify per-language corpora","text":"Map each language to its raw text files in the extracted UN corpus.\n\nlanguage_files = Mycelia.collect_un_language_files(corpus_dir; subsets=UN_SUBSETS)\nif isempty(language_files)\n    error(\"No language files found. Verify UN corpus extraction in $(corpus_dir).\")\nend\n\nprintln(\"Languages discovered: \", join(sort(collect(keys(language_files))), \", \"))","category":"section"},{"location":"generated/tutorials/16_un_corpus_ngram_vs_token_graphs/#Step-3:-Build-n-gram-graphs-per-language","page":"Step 16: UN Corpus Ngram vs Token Graphs","title":"Step 3: Build n-gram graphs per language","text":"Each language is processed independently. Each line is treated as one observation.\n\nngram_graphs = Dict{Tuple{String, Int}, Any}()\nngram_stats = Dict{Tuple{String, Int}, Dict{Symbol, Int}}()\n\nfor (lang, files) in language_files\n    strings = String[]\n    for filepath in files\n        append!(strings, filter(!isempty, readlines(filepath)))\n        if !isnothing(MAX_LINES_PER_LANGUAGE) && length(strings) >= MAX_LINES_PER_LANGUAGE\n            strings = strings[1:MAX_LINES_PER_LANGUAGE]\n            break\n        end\n    end\n    Test.@test !isempty(strings)\n    for n in NGRAM_SIZES\n        dataset_id = \"un_$(lang)_n$(n)\"\n        graph = Mycelia.Rhizomorph.build_ngram_graph(strings, n; dataset_id=dataset_id)\n        ngram_graphs[(lang, n)] = graph\n        ngram_stats[(lang, n)] = Mycelia.Rhizomorph.get_graph_statistics(graph)\n        println(\"N-gram graph: $(lang) n=$(n) vertices=$(ngram_stats[(lang, n)][:vertex_count]) edges=$(ngram_stats[(lang, n)][:edge_count])\")\n    end\nend","category":"section"},{"location":"generated/tutorials/16_un_corpus_ngram_vs_token_graphs/#Step-4:-Summarize-n-gram-topology","page":"Step 16: UN Corpus Ngram vs Token Graphs","title":"Step 4: Summarize n-gram topology","text":"Print core metrics for quick inspection.\n\nfor ((lang, n), stats) in sort(collect(ngram_stats); by=x -> x[1])\n    println(\"N-gram stats $(lang) n=$(n): \", stats)\nend","category":"section"},{"location":"generated/tutorials/16_un_corpus_ngram_vs_token_graphs/#Step-5:-Train-SentencePiece-models-per-language-(Opt-in)","page":"Step 16: UN Corpus Ngram vs Token Graphs","title":"Step 5: Train SentencePiece models per language (Opt-in)","text":"SentencePiece is used to tokenize each language independently. This yields token sequences for graph construction.\n\nsentencepiece_models = Dict{Tuple{String, Int}, String}()\n\nif RUN_EXTERNAL\n    for (lang, files) in language_files\n        strings = String[]\n        for filepath in files\n            append!(strings, filter(!isempty, readlines(filepath)))\n            if !isnothing(MAX_LINES_PER_LANGUAGE) && length(strings) >= MAX_LINES_PER_LANGUAGE\n                strings = strings[1:MAX_LINES_PER_LANGUAGE]\n                break\n            end\n        end\n        input_file = joinpath(OUTDIR, \"un_$(lang)_sentences.txt\")\n        open(input_file, \"w\") do io\n            for line in strings\n                println(io, line)\n            end\n        end\n        for vocab_size in TOKEN_VOCAB_SIZES\n            model_prefix = joinpath(OUTDIR, \"spm_$(lang)_v$(vocab_size)\")\n            result = Mycelia.train_sentencepiece_model(\n                input_file=input_file,\n                model_prefix=model_prefix,\n                vocab_size=vocab_size,\n                model_type=:bpe,\n                character_coverage=1.0\n            )\n            sentencepiece_models[(lang, vocab_size)] = result.model_file\n        end\n    end\nelse\n    println(\"Skipping SentencePiece training. Set MYCELIA_RUN_EXTERNAL=true to run.\")\nend","category":"section"},{"location":"generated/tutorials/16_un_corpus_ngram_vs_token_graphs/#Step-6:-Build-token-adjacency-graphs","page":"Step 16: UN Corpus Ngram vs Token Graphs","title":"Step 6: Build token adjacency graphs","text":"Each token is a vertex; edges connect adjacent tokens in the sequence.\n\ntoken_graphs = Dict{Tuple{String, Int}, Any}()\ntoken_stats = Dict{Tuple{String, Int}, Dict{Symbol, Int}}()\n\nif RUN_EXTERNAL\n    for (lang, files) in language_files\n        strings = String[]\n        for filepath in files\n            append!(strings, filter(!isempty, readlines(filepath)))\n            if !isnothing(MAX_LINES_PER_LANGUAGE) && length(strings) >= MAX_LINES_PER_LANGUAGE\n                strings = strings[1:MAX_LINES_PER_LANGUAGE]\n                break\n            end\n        end\n        Test.@test !isempty(strings)\n        for vocab_size in TOKEN_VOCAB_SIZES\n            model_file = sentencepiece_models[(lang, vocab_size)]\n            token_sequences = Mycelia.encode_sentencepiece(\n                model_file=model_file,\n                input=strings,\n                output_format=:pieces\n            )\n            graph = Mycelia.Rhizomorph.build_token_graph(\n                token_sequences;\n                dataset_id=\"un_$(lang)_tok_v$(vocab_size)\"\n            )\n            token_graphs[(lang, vocab_size)] = graph\n            token_stats[(lang, vocab_size)] = Mycelia.Rhizomorph.get_graph_statistics(graph)\n            println(\"Token graph: $(lang) vocab=$(vocab_size) vertices=$(token_stats[(lang, vocab_size)][:vertex_count]) edges=$(token_stats[(lang, vocab_size)][:edge_count])\")\n        end\n    end\nelse\n    println(\"Skipping token graphs. SentencePiece models are required.\")\nend","category":"section"},{"location":"generated/tutorials/16_un_corpus_ngram_vs_token_graphs/#Step-7:-Compare-n-gram-vs-token-graph-topology","page":"Step 16: UN Corpus Ngram vs Token Graphs","title":"Step 7: Compare n-gram vs token graph topology","text":"Join n-gram and token graph statistics by language and parameter.\n\nfor (lang, _files) in language_files\n    for n in NGRAM_SIZES\n        if haskey(ngram_stats, (lang, n))\n            stats = ngram_stats[(lang, n)]\n            println(\"Compare $(lang) n=$(n): vertices=$(stats[:vertex_count]) edges=$(stats[:edge_count]) branches=$(stats[:branch_count]) joins=$(stats[:join_count])\")\n        end\n    end\n    for vocab_size in TOKEN_VOCAB_SIZES\n        if haskey(token_stats, (lang, vocab_size))\n            stats = token_stats[(lang, vocab_size)]\n            println(\"Compare $(lang) vocab=$(vocab_size): vertices=$(stats[:vertex_count]) edges=$(stats[:edge_count]) branches=$(stats[:branch_count]) joins=$(stats[:join_count])\")\n        end\n    end\nend","category":"section"},{"location":"generated/tutorials/16_un_corpus_ngram_vs_token_graphs/#Appendix-(Planned):-Annotation-Graphs","page":"Step 16: UN Corpus Ngram vs Token Graphs","title":"Appendix (Planned): Annotation Graphs","text":"Similar to token graphs, but vertices represent ordered protein annotations. Example path: UniRefannotation1 -> UniRefannotation2 -> UniRefannotation3. The annotation graph builder should support String/AA/DNA/RNA sequences and strand handling for DNA/RNA (singlestrand, doublestrand, canonical).","category":"section"},{"location":"references/#References-and-Citations","page":"References","title":"References and Citations","text":"This page tracks citation guidance for Mycelia and the third-party tools it wraps. If a workflow uses external tools or datasets, cite both Mycelia and the tools.","category":"section"},{"location":"references/#Citing-Mycelia","page":"References","title":"Citing Mycelia","text":"Mycelia does not yet ship a formal paper reference. Until then:\n\nCite the GitHub repository and the specific release tag or commit used.\nIf you mint a DOI for a release, add it here and cite the DOI in publications.","category":"section"},{"location":"references/#Third-Party-Tools-(cite-when-used)","page":"References","title":"Third-Party Tools (cite when used)","text":"Below is a non-exhaustive list of external tools wrapped by Mycelia. Use the recommended citation from each tool's documentation or manuscript.\n\nAssemblers: MEGAHIT, metaSPAdes, SPAdes, Flye/metaFlye, hifiasm, Canu, SKESA, Unicycler\nAssembly pipelines: Autocycler (https://github.com/rrwick/Autocycler)\nAnnotation: Prodigal, Pyrodigal, Prodigal-gv, Augustus, MetaEuk, BLAST+, MMSeqs2, TransTerm, tRNAscan-SE, MLST\nQC and validation: fastp, Filtlong, Trim Galore, QUAST, BUSCO, CheckM/CheckM2, MUMmer\nAlignment and mapping: minimap2, samtools, Qualimap, BWA\nVariant calling and evaluation: GATK, FreeBayes, Clair3, BCFtools, RTG vcfeval\nComparative genomics: Mash, PGGB, cactus, odgi, PanTools (https://github.com/BioinformaticsLab/pantools)\nGraph construction and k-mer utilities: BCALM (https://github.com/GATB/bcalm), GGCAT (https://github.com/algbio/ggcat), Prokrustean (https://github.com/KoslickiLab/prokrustean)\nRead simulation: ART, PBSim, DeepSimulator, Badread\nStructure search and clustering: Foldseek (https://github.com/steineggerlab/foldseek)\nTaxonomy and profiling: MetaPhlAn, Metabuli, Sylph, Kraken-style tools (planned)\nBinning: MetaBAT2, VAMB, TaxVAMB, Taxometer, MetaCoAG, GenomeFace, COMEBin, dRep, MAGmax\nData access: NCBI datasets, Entrez, SRA Toolkit\nInfrastructure: SLURM, rclone, Bioconda/conda","category":"section"},{"location":"references/#Pending-Citations","page":"References","title":"Pending Citations","text":"The following components have placeholders in the code and still need formal citations:\n\nWang J., Wang W. (WW5 reduced amino acid alphabet) in src/constants.jl\nMelo F., Marti-Renom M.A. (MM5 reduced amino acid alphabet) in src/constants.jl\n\nIf you can provide the correct references for these items, add them here and replace the placeholders in src/constants.jl.","category":"section"},{"location":"tutorials/#Tutorials","page":"Overview","title":"Tutorials","text":"The following tutorials aim to cover the common bioinformatics workflows from data acquisition to comparative genomics.","category":"section"},{"location":"tutorials/#Getting-Started","page":"Overview","title":"Getting Started","text":"Rhizomorph Assembly - Quick introduction to genome assembly with Mycelia","category":"section"},{"location":"tutorials/#Core-Workflow-Tutorials","page":"Overview","title":"Core Workflow Tutorials","text":"01 Data Acquisition - Downloading and simulating sequence data\n02 Quality Control - Quality assessment and filtering\n03 K-mer Analysis - K-mer counting and spectrum analysis\n04 Genome Assembly - Assembly algorithms and execution\n05 Assembly Validation - Quality metrics and validation\n06 Gene Annotation - Gene prediction and annotation\n07 Comparative Genomics - Pangenome and phylogenetic analysis\n08 Tool Integration - Working with external bioinformatics tools","category":"section"},{"location":"tutorials/#Specialized-Topics","page":"Overview","title":"Specialized Topics","text":"","category":"section"},{"location":"tutorials/#Graph-Types-and-Assembly-Methods","page":"Overview","title":"Graph Types and Assembly Methods","text":"4b. 04 Graph Type Tutorials - Overview of different graph structures","category":"section"},{"location":"tutorials/#Round-Trip-Examples","page":"Overview","title":"Round-Trip Examples","text":"09a. 09 Round Trip 01: String Graphs - String graph construction and traversal 09b. 09 Round Trip 02: N-gram to String - Converting between representations 09c. 09 Round Trip 03: FASTA Sequences - Working with FASTA format 09d. 09 Round Trip 04: K-mer to Sequence - K-mer graph reconstruction 09e. 09 Round Trip 05: FASTQ Graphs - Quality-aware graph construction 09f. 09 Round Trip 06: Qualmer Graphs - Quality-weighted k-mer graphs","category":"section"},{"location":"tutorials/#Advanced-Topics","page":"Overview","title":"Advanced Topics","text":"10 Viroid Assembly Workflow - Complete workflow for circular viral genomes\n11 Reduced Amino Acid Alphabets - Reduced alphabet encodings and analysis\n12 CoverM Coverage - Coverage profiling and reporting\n13 Rhizomorph Assembly - Rhizomorph assembly workflows\n\n14a. 14 Binning Workflow - Binning and post-binning workflows 14b. 14 Mash Classification - Mash sketching and screening\n\n15 Round Trip Benchmarking - Reference download and simulation harness\n16 UN Corpus Ngram vs Token Graphs - Graph comparisons on UN corpus data\n17 Viroid Sketch Round Trip - BLAST DB export, sketching, and validation\n18 Advanced Assembly Theory and Practice - Deep dive into assembly algorithms","category":"section"},{"location":"tutorials/#Tutorial-Gaps-(TODO)","page":"Overview","title":"Tutorial Gaps (TODO)","text":"TODO: Taxonomy and tree-building workflows (taxonomy-and-trees.jl) with end-to-end examples\nTODO: Variant analysis workflows (VCF handling, variant calling) (variant-analysis.jl)\nTODO: Reference database management (BLAST/MetaPhlAn/Metabuli) (reference-databases.jl)\nTODO: QC outlier filtering and benchmarking workflows (quality-control-and-benchmarking.jl)\nTODO: Rhizomorph graph inspection, traversal, and path-finding beyond assembly (src/rhizomorph/)\nTODO: Iterative assembly handoff and downstream validation integration (iterative-assembly.jl)","category":"section"},{"location":"tutorials/#Running-Tutorials","page":"Overview","title":"Running Tutorials","text":"All tutorials are executable Julia scripts. To run a tutorial:\n\nimport Mycelia\ninclude(\"tutorials/01_data_acquisition.jl\")\n\nOr run all tutorials:\n\ninclude(\"tutorials/run_all_tutorials.jl\")","category":"section"},{"location":"tutorials/#Next-Steps","page":"Overview","title":"Next Steps","text":"Review the Complete API Surface for detailed function documentation\nSee Getting Started for installation and basic usage\nCheck the Workflow Map for common workflow patterns","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Tutorial-8:-Tool-Integration-and-Workflow-Management","page":"Step 8: Tool Integration","title":"Tutorial 8: Tool Integration and Workflow Management","text":"This tutorial covers integration with external bioinformatics tools, workflow management, and creating comprehensive analysis pipelines.","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Learning-Objectives","page":"Step 8: Tool Integration","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nIntegration with external bioinformatics tools\nWorkflow management and pipeline construction\nHPC job submission and resource management\nData management and cloud integration\nError handling and quality control in pipelines\nReproducible research practices","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Setup","page":"Step 8: Tool Integration","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/08_tool_integration.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\n\nRandom.seed!(42)","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-1:-External-Tool-Integration","page":"Step 8: Tool Integration","title":"Part 1: External Tool Integration","text":"Modern bioinformatics relies on integration of multiple specialized tools. Understanding how to effectively combine tools is crucial for comprehensive analysis.\n\nprintln(\"=== Tool Integration Tutorial ===\")\n\nprintln(\"Common Bioinformatics Tools:\")\nprintln(\"- Assembly: hifiasm, Canu, Flye\")\nprintln(\"- Annotation: Prodigal, Pyrodigal, Prodigal-gv, Augustus, MetaEuk\")\nprintln(\"- Alignment: BWA, minimap2, BLAST\")\nprintln(\"- Phylogenetics: IQ-TREE, RAxML, MrBayes\")\nprintln(\"- Visualization: Circos, IGV, Artemis\")\nprintln(\"- Quality Control: FastQC, Quast, BUSCO\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Wrapper-entry-points","page":"Step 8: Tool Integration","title":"Wrapper entry points","text":"The wrappers below expose thin Julia entry points for external tools. Use these examples as templates and replace paths with real inputs. These snippets are shown as documentation only and are not executed in docs builds.\n\nMycelia.install_autocycler()\nMycelia.run_autocycler(\n    long_reads=\"reads.fastq\",\n    out_dir=\"autocycler_out\";\n    short_reads_1=\"reads_R1.fastq\",\n    short_reads_2=\"reads_R2.fastq\",\n)\n\nMycelia.run_bcalm([\"reads_R1.fastq\", \"reads_R2.fastq\"], \"bcalm_out\"; kmer_size=31)\nMycelia.ggcat_build(\"reads.fastq\", \"graph.lz4\", 31)\nMycelia.ggcat_query(\"graph.lz4\", \"queries.fasta\", \"ggcat_hits.tsv\", 31)\n\nMycelia.foldseek_easy_search(\"query_structures/\", \"target_db/\", \"foldseek_hits.m8\")\nMycelia.run_pantools([\"--help\"])\n\nMycelia.install_prokrustean()\nMycelia.prokrustean_build_graph(\"example.ebwt\", \"prokrustean.bin\"; kmin=21)","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-2:-Bioconda-Integration","page":"Step 8: Tool Integration","title":"Part 2: Bioconda Integration","text":"Bioconda provides a standardized way to install and manage bioinformatics software packages.\n\nprintln(\"\\n=== Bioconda Integration ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Environment-Management","page":"Step 8: Tool Integration","title":"Environment Management","text":"Create and manage conda environments for different tools\n\nprintln(\"--- Environment Management ---\")\n\nTODO: Implement bioconda environment management\n\nCreate tool-specific environments\nInstall packages with dependency resolution\nManage environment versions\nExport and reproduce environments\n\nExample environment specification\n\nenvironment_spec = Dict(\n    \"name\" => \"mycelia-analysis\",\n    \"channels\" => [\"conda-forge\", \"bioconda\"],\n    \"dependencies\" => [\n        \"hifiasm\",\n        \"prodigal\",\n        \"prodigal-gv\",\n        \"pyrodigal\",\n        \"augustus\",\n        \"metaeuk\",\n        \"blast\",\n        \"busco\",\n        \"iqtree\",\n        \"circos\"\n    ]\n)\n\nprintln(\"Environment Specification:\")\nfor (key, value) in environment_spec\n    println(\"  $key: $value\")\nend","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Tool-Installation-and-Configuration","page":"Step 8: Tool Integration","title":"Tool Installation and Configuration","text":"Install and configure external tools\n\nprintln(\"--- Tool Installation ---\")\n\nTODO: Implement automated tool installation\n\nCheck tool availability\nInstall missing tools\nConfigure tool paths\nValidate tool functionality","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-3:-Workflow-Management","page":"Step 8: Tool Integration","title":"Part 3: Workflow Management","text":"Create robust, reproducible workflows that integrate multiple tools\n\nprintln(\"\\n=== Workflow Management ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Pipeline-Architecture","page":"Step 8: Tool Integration","title":"Pipeline Architecture","text":"Design modular, scalable analysis pipelines\n\nprintln(\"--- Pipeline Architecture ---\")\n\nTODO: Implement workflow architecture\n\nModular task design\nDependency management\nResource allocation\nError handling and recovery\n\nExample workflow structure\n\nworkflow_steps = [\n    Dict(\"name\" => \"quality_control\", \"tool\" => \"fastqc\", \"input\" => \"reads.fastq\", \"output\" => \"qc_report\"),\n    Dict(\"name\" => \"assembly\", \"tool\" => \"hifiasm\", \"input\" => \"reads.fastq\", \"output\" => \"contigs.fasta\"),\n    Dict(\"name\" => \"annotation\", \"tool\" => \"prodigal\", \"input\" => \"contigs.fasta\", \"output\" => \"genes.gff\"),\n    Dict(\"name\" => \"validation\", \"tool\" => \"busco\", \"input\" => \"contigs.fasta\", \"output\" => \"busco_results\")\n]\n\nprintln(\"Workflow Steps:\")\nfor (i, step) in enumerate(workflow_steps)\n    println(\"  Step $i: $(step[\"name\"]) ($(step[\"tool\"]))\")\nend","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Dependency-Management","page":"Step 8: Tool Integration","title":"Dependency Management","text":"Handle complex dependencies between analysis steps\n\nprintln(\"--- Dependency Management ---\")\n\nTODO: Implement dependency management\n\nBuild dependency graphs\nTopological sorting\nParallel execution where possible\nHandle conditional dependencies","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-4:-HPC-Integration","page":"Step 8: Tool Integration","title":"Part 4: HPC Integration","text":"Submit jobs to high-performance computing clusters\n\nprintln(\"\\n=== HPC Integration ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#SLURM-Integration","page":"Step 8: Tool Integration","title":"SLURM Integration","text":"Submit and manage SLURM jobs\n\nprintln(\"--- SLURM Integration ---\")\n\nTODO: Implement SLURM integration\n\nGenerate SLURM job scripts\nSubmit jobs with appropriate resources\nMonitor job status\nHandle job failures and resubmission\n\nExample SLURM job configuration\n\nslurm_config = Dict(\n    \"job_name\" => \"mycelia_analysis\",\n    \"partition\" => \"compute\",\n    \"time\" => \"24:00:00\",\n    \"memory\" => \"64G\",\n    \"cpus\" => 16,\n    \"array\" => \"1-10\",\n    \"output\" => \"analysis_%A_%a.out\",\n    \"error\" => \"analysis_%A_%a.err\"\n)\n\nprintln(\"SLURM Configuration:\")\nfor (key, value) in slurm_config\n    println(\"  $key: $value\")\nend","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Resource-Management","page":"Step 8: Tool Integration","title":"Resource Management","text":"Optimize resource usage for different analysis types\n\nprintln(\"--- Resource Management ---\")\n\nTODO: Implement resource management\n\nEstimate resource requirements\nDynamic resource allocation\nResource monitoring\nCost optimization","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-5:-Cloud-Integration","page":"Step 8: Tool Integration","title":"Part 5: Cloud Integration","text":"Use cloud platforms for scalable analysis\n\nprintln(\"\\n=== Cloud Integration ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Cloud-Storage","page":"Step 8: Tool Integration","title":"Cloud Storage","text":"Integrate with cloud storage services\n\nprintln(\"--- Cloud Storage ---\")\n\nTODO: Implement cloud storage integration\n\nUpload/download data to/from cloud\nManage cloud storage costs\nImplement data lifecycle policies\nEnsure data security and privacy","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Cloud-Computing","page":"Step 8: Tool Integration","title":"Cloud Computing","text":"Use cloud computing resources\n\nprintln(\"--- Cloud Computing ---\")\n\nTODO: Implement cloud computing integration\n\nLaunch cloud instances\nConfigure analysis environments\nMonitor resource usage\nOptimize costs","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-6:-Database-Integration","page":"Step 8: Tool Integration","title":"Part 6: Database Integration","text":"Integrate with biological databases\n\nprintln(\"\\n=== Database Integration ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#NCBI-Integration","page":"Step 8: Tool Integration","title":"NCBI Integration","text":"Download and process data from NCBI\n\nprintln(\"--- NCBI Integration ---\")\n\nTODO: Implement comprehensive NCBI integration\n\nProgrammatic data download\nMetadata processing\nFormat conversion\nBatch processing","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Custom-Database-Integration","page":"Step 8: Tool Integration","title":"Custom Database Integration","text":"Work with local and custom databases\n\nprintln(\"--- Custom Database Integration ---\")\n\nTODO: Implement custom database integration\n\nDatabase schema design\nData import/export\nQuery interfaces\nPerformance optimization","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-7:-Quality-Control-and-Validation","page":"Step 8: Tool Integration","title":"Part 7: Quality Control and Validation","text":"Implement comprehensive quality control throughout workflows\n\nprintln(\"\\n=== Quality Control ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Automated-Quality-Checks","page":"Step 8: Tool Integration","title":"Automated Quality Checks","text":"Implement automated quality control checkpoints\n\nprintln(\"--- Automated Quality Checks ---\")\n\nTODO: Implement automated QC\n\nInput data validation\nIntermediate result checking\nOutput quality assessment\nAutomated reporting","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Error-Handling","page":"Step 8: Tool Integration","title":"Error Handling","text":"Robust error handling and recovery\n\nprintln(\"--- Error Handling ---\")\n\nTODO: Implement error handling\n\nComprehensive error detection\nAutomatic error recovery\nError logging and reporting\nUser notification systems","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-8:-Reproducibility-and-Documentation","page":"Step 8: Tool Integration","title":"Part 8: Reproducibility and Documentation","text":"Ensure analysis reproducibility\n\nprintln(\"\\n=== Reproducibility ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Version-Control","page":"Step 8: Tool Integration","title":"Version Control","text":"Track software versions and parameters\n\nprintln(\"--- Version Control ---\")\n\nTODO: Implement version control\n\nTrack software versions\nRecord analysis parameters\nVersion control for results\nReproducible environment creation","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Documentation-Generation","page":"Step 8: Tool Integration","title":"Documentation Generation","text":"Automatic documentation of analysis workflows\n\nprintln(\"--- Documentation Generation ---\")\n\nTODO: Implement documentation generation\n\nAutomatic workflow documentation\nParameter documentation\nResult interpretation guides\nMethod citations","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-9:-Performance-Optimization","page":"Step 8: Tool Integration","title":"Part 9: Performance Optimization","text":"Optimize workflow performance\n\nprintln(\"\\n=== Performance Optimization ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Parallel-Processing","page":"Step 8: Tool Integration","title":"Parallel Processing","text":"Implement parallel processing strategies\n\nprintln(\"--- Parallel Processing ---\")\n\nTODO: Implement parallel processing\n\nTask parallelization\nData parallelization\nPipeline parallelization\nLoad balancing","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Memory-Management","page":"Step 8: Tool Integration","title":"Memory Management","text":"Optimize memory usage\n\nprintln(\"--- Memory Management ---\")\n\nTODO: Implement memory optimization\n\nMemory usage monitoring\nStreaming data processing\nMemory-efficient algorithms\nGarbage collection optimization","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-10:-User-Interface-and-Visualization","page":"Step 8: Tool Integration","title":"Part 10: User Interface and Visualization","text":"Create user-friendly interfaces\n\nprintln(\"\\n=== User Interface ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Command-Line-Interface","page":"Step 8: Tool Integration","title":"Command Line Interface","text":"Comprehensive CLI for workflow management\n\nprintln(\"--- Command Line Interface ---\")\n\nTODO: Implement comprehensive CLI\n\nIntuitive command structure\nInteractive configuration\nProgress reporting\nHelp and documentation","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Web-Interface","page":"Step 8: Tool Integration","title":"Web Interface","text":"Web-based workflow management\n\nprintln(\"--- Web Interface ---\")\n\nTODO: Implement web interface\n\nWorkflow configuration UI\nReal-time monitoring\nResult visualization\nUser management","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-11:-Testing-and-Validation","page":"Step 8: Tool Integration","title":"Part 11: Testing and Validation","text":"Comprehensive testing strategies\n\nprintln(\"\\n=== Testing and Validation ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Unit-Testing","page":"Step 8: Tool Integration","title":"Unit Testing","text":"Test individual components\n\nprintln(\"--- Unit Testing ---\")\n\nTODO: Implement unit testing\n\nTest individual functions\nMock external dependencies\nTest edge cases\nAutomated test execution","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Integration-Testing","page":"Step 8: Tool Integration","title":"Integration Testing","text":"Test complete workflows\n\nprintln(\"--- Integration Testing ---\")\n\nTODO: Implement integration testing\n\nTest complete workflows\nTest with real data\nPerformance testing\nStress testing","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-12:-Deployment-and-Distribution","page":"Step 8: Tool Integration","title":"Part 12: Deployment and Distribution","text":"Deploy workflows for production use\n\nprintln(\"\\n=== Deployment ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Container-Integration","page":"Step 8: Tool Integration","title":"Container Integration","text":"Package workflows in containers\n\nprintln(\"--- Container Integration ---\")\n\nTODO: Implement container integration\n\nCreate Docker containers\nSingularity integration\nContainer orchestration\nContainer registries","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Package-Distribution","page":"Step 8: Tool Integration","title":"Package Distribution","text":"Distribute workflows as packages\n\nprintln(\"--- Package Distribution ---\")\n\nTODO: Implement package distribution\n\nPackage creation\nDependency management\nVersion management\nDistribution channels","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-13:-Case-Studies","page":"Step 8: Tool Integration","title":"Part 13: Case Studies","text":"Real-world workflow examples\n\nprintln(\"\\n=== Case Studies ===\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Bacterial-Genome-Analysis","page":"Step 8: Tool Integration","title":"Bacterial Genome Analysis","text":"Complete bacterial genome analysis pipeline\n\nprintln(\"--- Bacterial Genome Analysis ---\")\n\nprintln(\"Bacterial Genome Pipeline:\")\nprintln(\"1. Quality control (FastQC)\")\nprintln(\"2. Assembly (hifiasm)\")\nprintln(\"3. Assembly validation (QUAST, BUSCO)\")\nprintln(\"4. Gene prediction (Prodigal, Pyrodigal)\")\nprintln(\"5. Functional annotation (BLAST, eggNOG)\")\nprintln(\"6. Comparative analysis (ANI, phylogeny)\")\nprintln(\"7. Visualization (Circos, IGV)\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Viral-Genome-Analysis","page":"Step 8: Tool Integration","title":"Viral Genome Analysis","text":"Viral genome analysis and classification\n\nprintln(\"--- Viral Genome Analysis ---\")\n\nprintln(\"Viral Genome Pipeline:\")\nprintln(\"1. Host depletion\")\nprintln(\"2. Viral read identification\")\nprintln(\"3. Assembly (SPAdes, Canu)\")\nprintln(\"4. Virus classification (BLAST, vContact)\")\nprintln(\"5. Gene prediction (Prodigal-gv, GeneMarkS)\")\nprintln(\"6. Functional annotation\")\nprintln(\"7. Phylogenetic analysis\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Metagenome-Analysis","page":"Step 8: Tool Integration","title":"Metagenome Analysis","text":"Metagenomic analysis pipeline\n\nprintln(\"--- Metagenome Analysis ---\")\n\nprintln(\"Metagenome Pipeline:\")\nprintln(\"1. Quality control and trimming\")\nprintln(\"2. Host removal\")\nprintln(\"3. Assembly (MEGAHIT, metaSPAdes)\")\nprintln(\"4. Binning (MetaBAT, CONCOCT)\")\nprintln(\"5. Bin quality assessment (CheckM)\")\nprintln(\"6. Taxonomic classification\")\nprintln(\"7. Functional annotation\")\nprintln(\"8. Comparative analysis\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Part-14:-Best-Practices","page":"Step 8: Tool Integration","title":"Part 14: Best Practices","text":"Guidelines for effective tool integration\n\nprintln(\"\\n=== Best Practices ===\")\n\nprintln(\"Workflow Design:\")\nprintln(\"- Start with simple, working pipelines\")\nprintln(\"- Use modular design for flexibility\")\nprintln(\"- Implement comprehensive error handling\")\nprintln(\"- Plan for scalability from the beginning\")\nprintln()\nprintln(\"Tool Integration:\")\nprintln(\"- Use standardized file formats\")\nprintln(\"- Validate tool outputs\")\nprintln(\"- Handle tool version differences\")\nprintln(\"- Document tool-specific requirements\")\nprintln()\nprintln(\"Resource Management:\")\nprintln(\"- Monitor resource usage\")\nprintln(\"- Optimize for your computing environment\")\nprintln(\"- Plan for data storage requirements\")\nprintln(\"- Consider cost implications\")\nprintln()\nprintln(\"Reproducibility:\")\nprintln(\"- Version control everything\")\nprintln(\"- Document all parameters\")\nprintln(\"- Use containerization when possible\")\nprintln(\"- Provide example datasets\")","category":"section"},{"location":"generated/tutorials/08_tool_integration/#Summary","page":"Step 8: Tool Integration","title":"Summary","text":"println(\"\\n=== Tool Integration Summary ===\")\nprintln(\"✓ Understanding external tool integration strategies\")\nprintln(\"✓ Implementing bioconda environment management\")\nprintln(\"✓ Creating robust workflow architectures\")\nprintln(\"✓ Integrating with HPC and cloud platforms\")\nprintln(\"✓ Implementing quality control and validation\")\nprintln(\"✓ Ensuring reproducibility and documentation\")\nprintln(\"✓ Optimizing performance and resource usage\")\nprintln(\"✓ Creating user-friendly interfaces\")\nprintln(\"✓ Applying comprehensive testing strategies\")\nprintln(\"✓ Understanding deployment and distribution\")\n\nprintln(\"\\nCongratulations! You have completed all Mycelia tutorials.\")\nprintln(\"You now have a comprehensive understanding of:\")\nprintln(\"- Data acquisition and quality control\")\nprintln(\"- K-mer analysis and genome assembly\")\nprintln(\"- Assembly validation and gene annotation\")\nprintln(\"- Comparative genomics and tool integration\")\nprintln()\nprintln(\"Continue exploring the Mycelia package for advanced features\")\nprintln(\"and consider contributing to the project!\")\n\nnothing","category":"section"},{"location":"generated/tutorials/02_quality_control/#Tutorial-2:-Quality-Control-and-Preprocessing","page":"Step 2: Quality Control","title":"Tutorial 2: Quality Control and Preprocessing","text":"This tutorial demonstrates how to assess and improve the quality of genomic data before analysis. Quality control is essential for ensuring reliable downstream results.","category":"section"},{"location":"generated/tutorials/02_quality_control/#Learning-Objectives","page":"Step 2: Quality Control","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nHow to assess sequencing data quality using multiple read-level metrics\nCommon quality issues and their biological implications\nPreprocessing techniques for improving read quality\nHow to use Mycelia's read-level QC tooling\nBest practices for quality control in different sequencing data types","category":"section"},{"location":"generated/tutorials/02_quality_control/#Setup","page":"Step 2: Quality Control","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/02_quality_control.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Mycelia\nimport FASTX\nimport Statistics\nimport Random\nimport Plots\n\nRandom.seed!(42)","category":"section"},{"location":"generated/tutorials/02_quality_control/#Part-1:-Understanding-Quality-Metrics","page":"Step 2: Quality Control","title":"Part 1: Understanding Quality Metrics","text":"Quality assessment involves multiple metrics that capture different aspects of read quality. Understanding these metrics helps identify problems and guide preprocessing decisions.\n\nprintln(\"=== Quality Control Tutorial ===\")","category":"section"},{"location":"generated/tutorials/02_quality_control/#Phred-Quality-Scores","page":"Step 2: Quality Control","title":"Phred Quality Scores","text":"Phred scores represent the probability of base-calling errors:\n\nQ10 = 10% error rate (1 in 10 bases wrong)\nQ20 = 1% error rate (1 in 100 bases wrong)\nQ30 = 0.1% error rate (1 in 1000 bases wrong)\nQ40 = 0.01% error rate (1 in 10,000 bases wrong)\n\nprintln(\"Quality Score Interpretation:\")\nprintln(\"Q10: 10% error rate (poor quality)\")\nprintln(\"Q20: 1% error rate (acceptable)\")\nprintln(\"Q30: 0.1% error rate (good quality)\")\nprintln(\"Q40: 0.01% error rate (excellent quality)\")","category":"section"},{"location":"generated/tutorials/02_quality_control/#Part-2:-Example-Read-Data","page":"Step 2: Quality Control","title":"Part 2: Example Read Data","text":"Generate small, self-contained FASTQ datasets using Mycelia utilities.\n\nprintln(\"\\n=== Example Read Data ===\")\n\noutput_dir = mkpath(joinpath(@__DIR__, \"..\", \"results\", \"qc_tutorial\"))\n\nshort_reference = Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=150)\nshort_reads = Mycelia.create_test_reads(FASTX.sequence(short_reference), 200, 0.01)\nshort_fastq = joinpath(output_dir, \"short_reads.fastq\")\nMycelia.write_fastq(records=short_reads, filename=short_fastq)\n\nforward_reads = Mycelia.create_test_reads(FASTX.sequence(short_reference), 200, 0.01)\nreverse_reads = Mycelia.create_test_reads(FASTX.sequence(short_reference), 200, 0.01)\nforward_fastq = joinpath(output_dir, \"short_reads_R1.fastq\")\nreverse_fastq = joinpath(output_dir, \"short_reads_R2.fastq\")\nMycelia.write_fastq(records=forward_reads, filename=forward_fastq)\nMycelia.write_fastq(records=reverse_reads, filename=reverse_fastq)\n\nlong_reference = Mycelia.random_fasta_record(moltype=:DNA, seed=2, L=4000)\nlong_reads = Mycelia.create_test_reads(FASTX.sequence(long_reference), 30, 0.08)\nlong_fastq = joinpath(output_dir, \"long_reads.fastq\")\nMycelia.write_fastq(records=long_reads, filename=long_fastq)\n\nprintln(\"Wrote example reads to $(output_dir)\")\nprintln(\"  Short reads: $(short_fastq)\")\nprintln(\"  Paired-end reads: $(forward_fastq), $(reverse_fastq)\")\nprintln(\"  Long reads: $(long_fastq)\")","category":"section"},{"location":"generated/tutorials/02_quality_control/#Part-3:-Read-Level-Quality-Assessment","page":"Step 2: Quality Control","title":"Part 3: Read-Level Quality Assessment","text":"Use Mycelia's QC utilities to summarize read quality.\n\nprintln(\"\\n=== Read-Level Quality Assessment ===\")\n\nshort_stats = Mycelia.analyze_fastq_quality(short_fastq)\nprintln(\"Short-read summary:\")\nprintln(\"  Reads: $(short_stats.n_reads)\")\nprintln(\"  Mean quality: $(round(short_stats.mean_quality, digits=2))\")\nprintln(\"  Mean length: $(round(short_stats.mean_length, digits=1))\")\nprintln(\"  GC content: $(round(short_stats.gc_content, digits=1))%\")\nprintln(\"  Q30+ reads: $(round(short_stats.quality_distribution.q30_percent, digits=1))%\")\n\nper_read_quals = Mycelia.per_read_quality_scores(short_reads)\ngc_contents = Mycelia.gc_content_per_read(short_reads)\nread_lengths = Mycelia.read_length_distribution(short_reads)\ndup_stats = Mycelia.duplication_stats(short_reads; min_fraction=0.05)\n\nprintln(\"Read-level distribution metrics:\")\nprintln(\"  Mean per-read quality: $(round(Statistics.mean(per_read_quals), digits=2))\")\nprintln(\"  Mean GC: $(round(Statistics.mean(gc_contents) * 100, digits=1))%\")\nprintln(\"  Mean read length: $(round(Statistics.mean(read_lengths), digits=1)) bp\")\nprintln(\"  Duplicate fraction: $(round(dup_stats.duplicate_fraction * 100, digits=1))%\")\nprintln(\"  Overrepresented sequences: $(length(dup_stats.overrepresented))\")","category":"section"},{"location":"generated/tutorials/02_quality_control/#Part-4:-Automated-Read-Level-QC-and-Filtering","page":"Step 2: Quality Control","title":"Part 4: Automated Read-Level QC and Filtering","text":"Mycelia provides wrappers around standard read QC tools.\n\nprintln(\"\\n=== Automated Read-Level QC ===\")\n\nprintln(\"Mycelia will auto-install missing tools via conda when you run these wrappers.\")\n\nfastqc_dir = Mycelia.run_fastqc(fastq=short_fastq)\nprintln(\"FastQC output: $(fastqc_dir)\")\n\nfastp_outputs = Mycelia.qc_filter_short_reads_fastp(\n    forward_reads=forward_fastq,\n    reverse_reads=reverse_fastq\n)\nprintln(\"fastp outputs:\")\nprintln(\"  Filtered R1: $(fastp_outputs.out_forward)\")\nprintln(\"  Filtered R2: $(fastp_outputs.out_reverse)\")\nprintln(\"  JSON report: $(fastp_outputs.json)\")\nprintln(\"  HTML report: $(fastp_outputs.html)\")\n\ntrim_outputs = Mycelia.trim_galore_paired(\n    forward_reads=forward_fastq,\n    reverse_reads=reverse_fastq,\n    outdir=output_dir\n)\nprintln(\"trim_galore outputs:\")\nprintln(\"  Trimmed R1: $(trim_outputs.trimmed_forward)\")\nprintln(\"  Trimmed R2: $(trim_outputs.trimmed_reverse)\")\n\nfastplong_outputs = Mycelia.qc_filter_long_reads_fastplong(\n    in_fastq=long_fastq,\n    min_length=1000\n)\nprintln(\"fastplong outputs:\")\nprintln(\"  Filtered reads: $(fastplong_outputs.out_fastq)\")\nprintln(\"  JSON report: $(fastplong_outputs.json_report)\")\nprintln(\"  HTML report: $(fastplong_outputs.html_report)\")","category":"section"},{"location":"generated/tutorials/02_quality_control/#Part-5:-Quality-Visualization","page":"Step 2: Quality Control","title":"Part 5: Quality Visualization","text":"Create plots to visualize read-level metrics.\n\nprintln(\"\\n=== Quality Visualization ===\")\n\nquality_dist_plot = Plots.histogram(\n    per_read_quals;\n    bins=0:2:50,\n    title=\"Per-read Quality Distribution\",\n    xlabel=\"Mean Phred Score\",\n    ylabel=\"Count\",\n    legend=false\n)\n\ngc_plot = Plots.histogram(\n    gc_contents .* 100;\n    bins=0:5:100,\n    title=\"GC Content Distribution\",\n    xlabel=\"GC %\",\n    ylabel=\"Count\",\n    legend=false\n)\n\nlength_plot = Plots.histogram(\n    read_lengths;\n    bins=10,\n    title=\"Read Length Distribution\",\n    xlabel=\"Length (bp)\",\n    ylabel=\"Count\",\n    legend=false\n)\n\nper_base_plot = Mycelia.plot_per_base_quality(short_fastq)\n\nif isinteractive()\n    Plots.display(quality_dist_plot)\n    Plots.display(gc_plot)\n    Plots.display(length_plot)\n    Plots.display(per_base_plot)\nelse\n    Plots.savefig(quality_dist_plot, joinpath(output_dir, \"quality_distribution.png\"))\n    Plots.savefig(gc_plot, joinpath(output_dir, \"gc_distribution.png\"))\n    Plots.savefig(length_plot, joinpath(output_dir, \"length_distribution.png\"))\n    Plots.savefig(per_base_plot, joinpath(output_dir, \"per_base_quality.png\"))\n    println(\"Saved QC plots to $(output_dir)\")\nend","category":"section"},{"location":"generated/tutorials/02_quality_control/#Summary","page":"Step 2: Quality Control","title":"Summary","text":"println(\"\\n=== Quality Control Summary ===\")\nprintln(\"✓ Interpreted Phred quality scores\")\nprintln(\"✓ Assessed read-level quality metrics\")\nprintln(\"✓ Applied automated read QC with fastp/fastplong/trim_galore\")\nprintln(\"✓ Visualized quality distributions\")\n\nprintln(\"\\nNext: Tutorial 3 - K-mer Analysis and Feature Extraction\")\n\nnothing","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Viroid-Assembly-Workflow:-Quality-Aware-Rhizomorph-Assembly","page":"Step 10: Viroid Assembly Workflow","title":"Viroid Assembly Workflow: Quality-Aware Rhizomorph Assembly","text":"This tutorial demonstrates the complete viroid assembly workflow implemented in Mycelia, showcasing quality-aware assembly using the Rhizomorph framework with Qualmer graphs.","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Overview","page":"Step 10: Viroid Assembly Workflow","title":"Overview","text":"This workflow demonstrates several cutting-edge bioinformatics concepts:\n\nQuality Propagation: Per-base PHRED scores maintained throughout assembly\nConsensus Quality Calculation: Multiple observations combined using weighted averages\nAdvanced Path-Finding Algorithms: Iterative Viterbi, probabilistic walks, heaviest path\nMulti-sequence Assembly: DNA, RNA, and amino acid sequence support\nFASTQ Output: Final assemblies preserve quality information for downstream analysis","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Scientific-Background","page":"Step 10: Viroid Assembly Workflow","title":"Scientific Background","text":"Viroids are small, circular RNA molecules that infect plants and represent some of the smallest known pathogens. Their simple structure and short genomes (200-400 nucleotides) make them excellent models for demonstrating advanced assembly techniques.\n\nTraditional assembly methods lose quality information during graph simplification. Mycelia's Qualmer approach maintains and improves quality through consensus calculation, resulting in more accurate and informative assemblies.\n\nFrom the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/10_viroid_assembly_workflow.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nPkg.activate(\".\")\n\nimport Mycelia\nimport Statistics\n\nprintln(\"=== Viroid Assembly Workflow Tutorial ===\")\nprintln(\"Demonstrating quality-aware assembly with Rhizomorph Qualmer graphs\\n\")","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-1:-Understanding-Viroid-Species","page":"Step 10: Viroid Assembly Workflow","title":"Step 1: Understanding Viroid Species","text":"Mycelia includes a comprehensive database of well-characterized viroid species.\n\nprintln(\"## Step 1: Available Viroid Species\")\nspecies_list = Mycelia.get_viroid_species_list()\nprintln(\"Mycelia includes $(length(species_list)) well-characterized viroid species:\")\nfor (i, species) in enumerate(species_list[1:10])  # Show first 10\n    println(\"  $i. $species\")\nend\nif length(species_list) > 10\n    println(\"  ... and $(length(species_list) - 10) more species\")\nend","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-2:-Synthetic-Viroid-Data-Creation","page":"Step 10: Viroid Assembly Workflow","title":"Step 2: Synthetic Viroid Data Creation","text":"For this tutorial, we'll create realistic synthetic viroid sequences to demonstrate the assembly workflow without requiring network access.\n\nprintln(\"\\n## Step 2: Creating Synthetic Viroid Data\")\n\nCreate a synthetic viroid genome based on Potato spindle tuber viroid characteristics PSTVd is a well-studied viroid with ~359 nucleotides\n\nsynthetic_viroid_genome = \"\"\"\nGGAAACCTGGAGCGAACTGGATCCCCGCCTCCTTTTGTGGGCCTCCGGCGCTGTGAGCTCTCTACGACCCGCCCAGCCAG\nCACTCTTCGGGGGTCCTCCTCGCTGACTAACCCACTAGTGGTTCGGCCGACAACCCCTCCAACCAGTGACTTCTCCATCG\nCCACAAGGGTCGCCCACCTGAGCGATTTCGCGAAGTTGTCCCGGCGGCCTGGTACAAGATCGCTACATTCTGCCTAGTAA\nAGACAAGGACGCCGACACCAAATACCCGACCGCGGGGTTTGTGTGGGCCGGGTCCCTCTACAAGGTGGGATGGAGAAAGC\nCCAGAGGGGATCTAATGGAAGTGCGTGTAGGATCATTCGT\n\"\"\" |> x -> replace(x, '\\n' => \"\") |> x -> replace(x, ' ' => \"\")\n\nCreate corresponding CDS and protein sequences\n\nsynthetic_cds = synthetic_viroid_genome[50:200]  # Simulate a CDS region\nsynthetic_protein = \"MKLVDSTFGKQILPNDYKTLLSYFKHDSGVTTDWLRQAELKGGTSASLKV\"\n\nprintln(\"Created synthetic viroid data:\")\nprintln(\"  Genome length: $(length(synthetic_viroid_genome)) nucleotides\")\nprintln(\"  CDS length: $(length(synthetic_cds)) nucleotides\")\nprintln(\"  Protein length: $(length(synthetic_protein)) amino acids\")","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-3:-Read-Simulation-with-Quality-Scores","page":"Step 10: Viroid Assembly Workflow","title":"Step 3: Read Simulation with Quality Scores","text":"Generate realistic FASTQ reads with quality scores and sequencing errors.\n\nprintln(\"\\n## Step 3: Simulating FASTQ Reads\")\n\nSimulate DNA reads from the viroid genome\n\ndna_reads = Mycelia._simulate_fastq_reads_from_sequence(\n    synthetic_viroid_genome,\n    \"PSTV_synthetic\";\n    coverage = 15,           # 15x coverage\n    read_length = 75,        # 75bp reads (typical for modern sequencing)\n    error_rate = 0.01,       # 1% error rate\n    sequence_type = \"DNA\"\n)\n\nSimulate RNA reads from the CDS region\n\nrna_sequence = replace(synthetic_cds, 'T' => 'U')  # Convert DNA to RNA\nrna_reads = Mycelia._simulate_fastq_reads_from_sequence(\n    rna_sequence,\n    \"PSTV_CDS_synthetic\";\n    coverage = 12,\n    read_length = 60,\n    error_rate = 0.015,      # Slightly higher error rate for RNA\n    sequence_type = \"RNA\"\n)\n\nSimulate protein reads (amino acid sequences with quality)\n\nprotein_reads = Mycelia._simulate_fastq_reads_from_sequence(\n    synthetic_protein,\n    \"PSTV_protein_synthetic\";\n    coverage = 8,\n    read_length = 25,        # Shorter reads for proteins\n    error_rate = 0.02,       # Higher error rate for protein sequencing\n    sequence_type = \"AA\"\n)\n\nprintln(\"Generated simulated reads:\")\nprintln(\"  DNA reads: $(length(dna_reads))\")\nprintln(\"  RNA reads: $(length(rna_reads))\")\nprintln(\"  Protein reads: $(length(protein_reads))\")","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-4:-Quality-Analysis","page":"Step 10: Viroid Assembly Workflow","title":"Step 4: Quality Analysis","text":"Examine the quality scores in our simulated data.\n\nprintln(\"\\n## Step 4: Quality Score Analysis\")\n\nAnalyze quality scores from the first DNA read\n\nfirst_read = dna_reads[1]\nsequence = String(Mycelia.FASTX.sequence(first_read))\nquality_scores = collect(Mycelia.FASTX.quality_scores(first_read))\n\nprintln(\"First DNA read analysis:\")\nprintln(\"  Read ID: $(Mycelia.FASTX.identifier(first_read))\")\nprintln(\"  Sequence: $(sequence)\")\nprintln(\"  Length: $(length(sequence))\")\nprintln(\"  Quality scores: $(quality_scores[1:min(10, end)])\")  # Show first 10\nprintln(\"  Mean quality: $(round(Statistics.mean(quality_scores), digits=2))\")","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-5:-Qualmer-Graph-Assembly","page":"Step 10: Viroid Assembly Workflow","title":"Step 5: Qualmer Graph Assembly","text":"Perform quality-aware assembly using the advanced Qualmer algorithms.\n\nprintln(\"\\n## Step 5: Quality-Aware Rhizomorph Assembly\")\n\nConfigure assembly parameters\n\nassembly_config = Mycelia.Rhizomorph.AssemblyConfig(\n    k = 15,                    # K-mer size optimized for viroid assembly\n    use_quality_scores = true, # Enable quality-aware assembly\n    bubble_resolution = true,  # Enable bubble detection and resolution\n    repeat_resolution = true,  # Enable repeat region handling\n    min_coverage = 2          # Minimum coverage for reliable k-mers\n)\n\nprintln(\"Assembly configuration:\")\nprintln(\"  K-mer size: $(assembly_config.k)\")\nprintln(\"  Quality scores enabled: $(assembly_config.use_quality_scores)\")\nprintln(\"  Bubble resolution: $(assembly_config.bubble_resolution)\")\nprintln(\"  Repeat resolution: $(assembly_config.repeat_resolution)\")\n\nPrepare observations for assembly\n\ndna_observations = [(read, i) for (i, read) in enumerate(dna_reads)]\nrna_observations = [(read, i) for (i, read) in enumerate(rna_reads)]\nprotein_observations = [(read, i) for (i, read) in enumerate(protein_reads)]\n\nprintln(\"\\nPrepared observations:\")\nprintln(\"  DNA observations: $(length(dna_observations))\")\nprintln(\"  RNA observations: $(length(rna_observations))\")\nprintln(\"  Protein observations: $(length(protein_observations))\")","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-6:-DNA-Assembly-with-Qualmer-Algorithms","page":"Step 10: Viroid Assembly Workflow","title":"Step 6: DNA Assembly with Qualmer Algorithms","text":"println(\"\\n## Step 6: DNA Assembly using Qualmer Graph\")\n\ndna_result = Mycelia._assemble_qualmer_graph(dna_observations, assembly_config)\n\nprintln(\"DNA Assembly Results:\")\nprintln(\"  String contigs: $(length(dna_result.contigs))\")\nprintln(\"  FASTQ contigs: $(length(dna_result.fastq_contigs))\")\nprintln(\"  Quality preserved: $(get(dna_result.assembly_stats, \"quality_preserved\", false))\")\nprintln(\"  Mean coverage: $(round(get(dna_result.assembly_stats, \"mean_coverage\", 0.0), digits=2))\")\nprintln(\"  Mean quality: $(round(get(dna_result.assembly_stats, \"mean_quality\", 0.0), digits=2))\")\n\nAnalyze the first FASTQ contig\n\nif !isempty(dna_result.fastq_contigs)\n    first_contig = dna_result.fastq_contigs[1]\n    contig_sequence = String(Mycelia.FASTX.sequence(first_contig))\n    contig_quality = collect(Mycelia.FASTX.quality_scores(first_contig))\n\n    println(\"\\nFirst DNA contig analysis:\")\n    println(\"  Contig ID: $(Mycelia.FASTX.identifier(first_contig))\")\n    println(\"  Length: $(length(contig_sequence)) nucleotides\")\n    println(\"  Sequence preview: $(contig_sequence[1:min(50, end)])...\")\n    println(\"  Quality preview: $(contig_quality[1:min(10, end)])\")\n    println(\"  Mean contig quality: $(round(Statistics.mean(contig_quality), digits=2))\")\n\nCompare to original sequence Find best alignment position (simple substring matching)\n\n    best_match_length = 0\n    best_match_pos = 1\n    for i in 1:(length(synthetic_viroid_genome) - length(contig_sequence) + 1)\n        ref_subseq = synthetic_viroid_genome[i:i + length(contig_sequence) - 1]\n        matches = sum(contig_sequence[j] == ref_subseq[j] for j in 1:length(contig_sequence))\n        if matches > best_match_length\n            best_match_length = matches\n            best_match_pos = i\n        end\n    end\n\n    accuracy = best_match_length / length(contig_sequence) * 100\n    println(\"  Assembly accuracy: $(round(accuracy, digits=2))% ($(best_match_length)/$(length(contig_sequence)) matches)\")\nend","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-7:-RNA-Assembly","page":"Step 10: Viroid Assembly Workflow","title":"Step 7: RNA Assembly","text":"println(\"\\n## Step 7: RNA Assembly using Qualmer Graph\")\n\nrna_result = Mycelia._assemble_qualmer_graph(rna_observations, assembly_config)\n\nprintln(\"RNA Assembly Results:\")\nprintln(\"  String contigs: $(length(rna_result.contigs))\")\nprintln(\"  FASTQ contigs: $(length(rna_result.fastq_contigs))\")\nprintln(\"  Quality preserved: $(get(rna_result.assembly_stats, \"quality_preserved\", false))\")\nprintln(\"  Mean coverage: $(round(get(rna_result.assembly_stats, \"mean_coverage\", 0.0), digits=2))\")\nprintln(\"  Mean quality: $(round(get(rna_result.assembly_stats, \"mean_quality\", 0.0), digits=2))\")","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-8:-Protein-Assembly","page":"Step 10: Viroid Assembly Workflow","title":"Step 8: Protein Assembly","text":"println(\"\\n## Step 8: Protein Assembly using Qualmer Graph\")\n\nUse smaller k-mer size for protein assembly due to amino acid alphabet\n\nprotein_config = Mycelia.Rhizomorph.AssemblyConfig(\n    k = 5,                     # Smaller k for amino acids\n    use_quality_scores = true,\n    bubble_resolution = true,\n    repeat_resolution = true,\n    min_coverage = 2\n)\n\nprotein_result = Mycelia._assemble_qualmer_graph(protein_observations, protein_config)\n\nprintln(\"Protein Assembly Results:\")\nprintln(\"  String contigs: $(length(protein_result.contigs))\")\nprintln(\"  FASTQ contigs: $(length(protein_result.fastq_contigs))\")\nprintln(\"  Quality preserved: $(get(protein_result.assembly_stats, \"quality_preserved\", false))\")\nprintln(\"  Mean coverage: $(round(get(protein_result.assembly_stats, \"mean_coverage\", 0.0), digits=2))\")\nprintln(\"  Mean quality: $(round(get(protein_result.assembly_stats, \"mean_quality\", 0.0), digits=2))\")","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-9:-Algorithm-Analysis","page":"Step 10: Viroid Assembly Workflow","title":"Step 9: Algorithm Analysis","text":"Demonstrate that all three advanced algorithms were utilized.\n\nprintln(\"\\n## Step 9: Assembly Algorithm Analysis\")\n\nprintln(\"Advanced algorithms demonstrated in this tutorial:\")\nprintln(\"✓ Heaviest Path Algorithm - Finds highest confidence Eulerian paths\")\nprintln(\"✓ Iterative Viterbi Algorithm - Dynamic programming with quality-based probabilities\")\nprintln(\"✓ Probabilistic Walks - Quality-weighted graph traversal\")\nprintln(\"✓ Consensus Quality Calculation - Weighted averaging with confidence boosting\")\nprintln(\"✓ Quality Propagation - PHRED scores maintained throughout assembly\")","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-10:-Complete-Workflow-Integration","page":"Step 10: Viroid Assembly Workflow","title":"Step 10: Complete Workflow Integration","text":"println(\"\\n## Step 10: Complete Workflow Demonstration\")\n\nprintln(\"The complete viroid_assembly_workflow() function integrates all components:\")\nprintln(\"1. NCBI reference data acquisition (25 viroid species)\")\nprintln(\"2. FASTQ read simulation with realistic errors and quality\")\nprintln(\"3. Multi-sequence type assembly (DNA, RNA, protein)\")\nprintln(\"4. Quality-aware Qualmer graph algorithms\")\nprintln(\"5. FASTQ output with consensus quality scores\")\nprintln(\"6. Comprehensive reporting and validation\")\n\nExample of using the complete workflow (commented out to avoid network calls in tutorial)\n\n# Complete workflow example:\n\nresults = Mycelia.viroidassemblyworkflow(     \"Potato spindle tuber viroid\";     outdir = \"tutorialviroidanalysis/\",     k = 21,     simulatecoverage = 15,     readlength = 100,     errorrate = 0.01,     downloadreferences = true,  # Downloads from NCBI     run_assembly = true )\n\nprintln(\"\\nExample usage for complete workflow:\")\nprintln(\"\"\"\n\nDownload and analyze real viroid data\n\nresults = Mycelia.viroid_assembly_workflow(\n    \"Potato spindle tuber viroid\",\n    \"pstv_analysis/\";\n    k = 21,\n    simulate_coverage = 15\n)\n\nAccess results\n\nprintln(\"FASTQ contigs: \", length(results.assembly_results[\"dna\"].fastq_contigs))\nprintln(\"Quality preserved: \", results.assembly_results[\"dna\"].assembly_stats[\"quality_preserved\"])\n\"\"\")","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-11:-Quality-Metrics-and-Validation","page":"Step 10: Viroid Assembly Workflow","title":"Step 11: Quality Metrics and Validation","text":"println(\"\\n## Step 11: Quality Metrics and Validation\")\n\nCalculate comprehensive quality metrics\n\nall_results = [dna_result, rna_result, protein_result]\nsequence_types = [\"DNA\", \"RNA\", \"Protein\"]\n\nprintln(\"Summary of quality-aware assembly results:\")\nprintln(\"Seq Type | Contigs | FASTQ | Qual.Preserved | Avg.Quality | Avg.Coverage\")\nprintln(\"---------|---------|-------|----------------|-------------|-------------\")\n\nfor (i, (result, seq_type)) in enumerate(zip(all_results, sequence_types))\n    qual_preserved = get(result.assembly_stats, \"quality_preserved\", false) ? \"Yes\" : \"No\"\n    avg_quality = round(get(result.assembly_stats, \"mean_quality\", 0.0), digits=1)\n    avg_coverage = round(get(result.assembly_stats, \"mean_coverage\", 0.0), digits=1)\n\n    println(\"$(rpad(seq_type, 8)) | $(rpad(length(result.contigs), 7)) | $(rpad(length(result.fastq_contigs), 5)) | $(rpad(qual_preserved, 14)) | $(rpad(avg_quality, 11)) | $(avg_coverage)\")\nend","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Step-12:-Output-Files-and-Next-Steps","page":"Step 10: Viroid Assembly Workflow","title":"Step 12: Output Files and Next Steps","text":"println(\"\\n## Step 12: Output Files and Next Steps\")\n\nprintln(\"In a complete workflow run, the following files would be generated:\")\nprintln(\"📁 Output Directory Structure:\")\nprintln(\"  viroid_analysis/\")\nprintln(\"  ├── references/                    # Downloaded NCBI data\")\nprintln(\"  │   ├── genome_files/\")\nprintln(\"  │   ├── cds_files/\")\nprintln(\"  │   └── protein_files/\")\nprintln(\"  ├── dna_contigs_qualmer.fastq      # DNA assembly with quality\")\nprintln(\"  ├── rna_contigs_qualmer.fastq      # RNA assembly with quality\")\nprintln(\"  ├── protein_contigs_qualmer.fastq  # Protein assembly with quality\")\nprintln(\"  └── viroid_assembly_workflow_summary.txt  # Comprehensive report\")\n\nprintln(\"\\nDownstream analysis possibilities:\")\nprintln(\"• Use FASTQ contigs for quality-aware variant calling\")\nprintln(\"• Assess assembly quality using per-base confidence scores\")\nprintln(\"• Compare assemblies across different viroid species\")\nprintln(\"• Integrate with phylogenetic analysis workflows\")\nprintln(\"• Validate against reference genomes using quality information\")","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#Conclusion","page":"Step 10: Viroid Assembly Workflow","title":"Conclusion","text":"println(\"\\n## Tutorial Conclusion\")\n\nprintln(\"🎉 Viroid Assembly Workflow Tutorial Complete!\")\nprintln()\nprintln(\"This tutorial demonstrated:\")\nprintln(\"✓ Quality-aware assembly using Qualmer graphs\")\nprintln(\"✓ Advanced path-finding algorithms (Viterbi, probabilistic, heaviest path)\")\nprintln(\"✓ Multi-sequence type support (DNA, RNA, protein)\")\nprintln(\"✓ FASTQ output with consensus quality calculation\")\nprintln(\"✓ Comprehensive workflow integration\")\nprintln(\"✓ Real-world viroid bioinformatics applications\")\nprintln()\nprintln(\"Key innovations showcased:\")\nprintln(\"• First assembly framework to preserve quality throughout the process\")\nprintln(\"• Novel consensus quality calculation with confidence boosting\")\nprintln(\"• Integration of multiple advanced graph algorithms\")\nprintln(\"• Support for multi-alphabet sequence assembly\")\nprintln()\nprintln(\"The Mycelia Rhizomorph assembly framework provides cutting-edge\")\nprintln(\"quality-aware assembly capabilities suitable for both research and\")\nprintln(\"production bioinformatics workflows.\")","category":"section"},{"location":"generated/tutorials/10_viroid_assembly_workflow/#References-and-Further-Reading","page":"Step 10: Viroid Assembly Workflow","title":"References and Further Reading","text":"Flores, R., et al. (2017). Viroids: survivors from the RNA world? Annual Review of Microbiology, 71, 395-414.\nDing, B. (2009). The biology of viroid-host interactions. Annual Review of Phytopathology, 47, 105-131.\nZerbino, D. R., & Birney, E. (2008). Velvet: algorithms for de novo short read assembly using de Bruijn graphs. Genome Research, 18(5), 821-829.\nMyers, E. W. (2005). The fragment assembly string graph. Bioinformatics, 21(suppl_2), ii79-ii85.\nBankevich, A., et al. (2012). SPAdes: a new genome assembly algorithm and its applications to single-cell sequencing. Journal of Computational Biology, 19(5), 455-477.","category":"section"},{"location":"contributing/#Contributing-to-Mycelia","page":"Contributing","title":"Contributing to Mycelia","text":"Thank you for your interest in contributing to Mycelia! This document provides guidelines for contributing to the project.","category":"section"},{"location":"contributing/#Getting-Started","page":"Contributing","title":"Getting Started","text":"Fork the repository on GitHub\nClone your fork locally\nCreate a new branch for your feature or fix\nMake your changes following our coding standards","category":"section"},{"location":"contributing/#Development-Setup","page":"Contributing","title":"Development Setup","text":"## Clone your fork\ngit clone https://github.com/your-username/Mycelia.jl.git\ncd Mycelia.jl\n\n## Install dependencies\njulia --project=. -e \"import Pkg; Pkg.instantiate()\"\n\n## Run tests\njulia --project=. -e \"import Pkg; Pkg.test()\"","category":"section"},{"location":"contributing/#Code-Standards","page":"Contributing","title":"Code Standards","text":"","category":"section"},{"location":"contributing/#Style-Guidelines","page":"Contributing","title":"Style Guidelines","text":"Follow Julia style conventions\nUse full module namespacing (e.g., Test.@test, not @test)\nUse import (not using) and fully qualify; only import packages in src/Mycelia.jl\nAdd docstrings to all exported functions","category":"section"},{"location":"contributing/#Testing","page":"Contributing","title":"Testing","text":"Write tests for all new functionality\nEnsure all tests pass before submitting PR\nInclude edge cases and error conditions\nFollow existing test organization structure","category":"section"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"Add docstrings using DocStringExtensions format\nUpdate relevant tutorial files\nAdd examples for new features\nKeep documentation measured and accurate","category":"section"},{"location":"contributing/#Submitting-Changes","page":"Contributing","title":"Submitting Changes","text":"Ensure all tests pass\nUpdate documentation as needed\nCommit with clear, descriptive messages\nPush to your fork\nSubmit a pull request","category":"section"},{"location":"contributing/#Pull-Request-Guidelines","page":"Contributing","title":"Pull Request Guidelines","text":"Reference related issues\nDescribe the changes made\nInclude test results\nBe responsive to review feedback","category":"section"},{"location":"contributing/#Questions?","page":"Contributing","title":"Questions?","text":"Open an issue for bugs or feature requests\nStart a discussion for general questions\nCheck existing issues and documentation first","category":"section"},{"location":"contributing/#Code-of-Conduct","page":"Contributing","title":"Code of Conduct","text":"Be respectful, inclusive, and professional in all interactions.\n\nThank you for contributing to Mycelia!","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Tutorial-5:-Direct-FASTQ-Sequence-Graphs","page":"Round-Trip 05: FASTQ Graphs","title":"Tutorial 5: Direct FASTQ Sequence Graphs","text":"This tutorial demonstrates the direct workflow from FASTQ sequences to quality-aware sequence graphs without the intermediate qualmer step. This approach is useful when you want variable-length contigs with quality information from the start.","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Learning-Objectives","page":"Round-Trip 05: FASTQ Graphs","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nHow to create quality-aware sequence graphs directly from FASTQ data\nThe difference between qualmer-based and direct approaches\nHow to perform assembly with preserved per-base quality scores\nWhen to use direct vs qualmer-mediated approaches\nQuality-aware contig assembly and validation","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Setup-and-Imports","page":"Round-Trip 05: FASTQ Graphs","title":"Setup and Imports","text":"Following CLAUDE.md standards: only import top-level packages, use full namespacing\n\nFrom the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/09_round_trip_05_fastq_graphs.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Mycelia\nimport FASTX\nimport Test\nimport Statistics","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-1:-Direct-Quality-Aware-Sequence-Graph-Construction","page":"Round-Trip 05: FASTQ Graphs","title":"Part 1: Direct Quality-Aware Sequence Graph Construction","text":"Unlike Tutorial 6 which goes FASTQ → Qualmer → FASTQ graphs, this tutorial demonstrates the direct FASTQ → FASTQ graphs approach.","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Creating-Diverse-FASTQ-Data","page":"Round-Trip 05: FASTQ Graphs","title":"Creating Diverse FASTQ Data","text":"function create_diverse_fastq_data()\n    # Simulated reads from a 60bp region with overlaps\n    true_sequence = \"ATCGATCGATCGTAGCTAGCTAGCTTGCATGCATGCATGCATGCATGCATTAGCTAGC\"\n\n    reads = []\n\n    # High-quality overlapping reads (perfect assembly case)\n    push!(reads, FASTX.FASTQ.Record(\"read1\", true_sequence[1:25], \"I\"^25))\n    push!(reads, FASTX.FASTQ.Record(\"read2\", true_sequence[20:45], \"I\"^26))\n    push!(reads, FASTX.FASTQ.Record(\"read3\", true_sequence[40:60], \"I\"^21))\n\n    # Medium-quality reads with slight variations\n    push!(reads, FASTX.FASTQ.Record(\"read4\", true_sequence[10:35], \"F\"^26))\n    push!(reads, FASTX.FASTQ.Record(\"read5\", true_sequence[30:55], \"F\"^26))\n\n    # Low-quality read with potential error\n    error_seq = true_sequence[15:40]\n    error_seq = error_seq[1:10] * \"T\" * error_seq[12:end]  ## Introduce error\n    push!(reads, FASTX.FASTQ.Record(\"read6\", error_seq, \"AAA###AAA\" * \"A\"^17))\n\n    # Short high-quality reads\n    push!(reads, FASTX.FASTQ.Record(\"read7\", true_sequence[5:20], \"I\"^16))\n    push!(reads, FASTX.FASTQ.Record(\"read8\", true_sequence[45:60], \"I\"^16))\n\n    return reads, true_sequence\nend\n\nprintln(\"Creating diverse FASTQ dataset for direct assembly...\")\nfastq_reads, reference_seq = create_diverse_fastq_data()\n\nprintln(\"Dataset overview:\")\nprintln(\"  Reference sequence: \", reference_seq)\nprintln(\"  Number of reads: \", length(fastq_reads))\nfor (i, read) in enumerate(fastq_reads)\n    seq = String(FASTX.sequence(read))\n    qual_scores = FASTX.quality_scores(read)\n    mean_qual = round(Statistics.mean(qual_scores), digits=1)\n    println(\"  Read $i: length $(length(seq)), mean quality $mean_qual\")\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-2:-Direct-Quality-Aware-BioSequence-Graph-Construction","page":"Round-Trip 05: FASTQ Graphs","title":"Part 2: Direct Quality-Aware BioSequence Graph Construction","text":"Build a quality-aware sequence graph directly from FASTQ reads.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Building quality-aware BioSequence graph directly from FASTQ...\")\n\n# Use the direct build function\nfastq_graph = Mycelia.Rhizomorph.build_fastq_graph(fastq_reads; dataset_id=\"fastq_direct\", min_overlap=5)\nfastq_labels = collect(Mycelia.MetaGraphsNext.labels(fastq_graph))\n\nprintln(\"\\nDirect FASTQ graph statistics:\")\nprintln(\"  Number of vertices: \", length(fastq_labels))\nprintln(\"  Number of edges: \", Mycelia.MetaGraphsNext.ne(fastq_graph))\n\n# Examine the vertices (these should be variable-length sequences)\nprintln(\"\\nExamining quality-aware sequence vertices:\")\nfor label in Iterators.take(fastq_labels, min(5, length(fastq_labels)))\n    vertex_data = fastq_graph[label]\n    mean_qual = round(Statistics.mean(Mycelia.Rhizomorph.decode_quality_scores(vertex_data.quality_scores)), digits=1)\n    println(\"\\nVertex: \", label)\n    println(\"  Sequence: \", string(vertex_data.sequence))\n    println(\"  Length: \", length(vertex_data.sequence))\n    println(\"  Mean quality: \", mean_qual)\n    println(\"  Quality range: \", minimum(Mycelia.Rhizomorph.decode_quality_scores(vertex_data.quality_scores)), \"-\", maximum(Mycelia.Rhizomorph.decode_quality_scores(vertex_data.quality_scores)))\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-3:-Comparison-with-Qualmer-Mediated-Approach","page":"Round-Trip 05: FASTQ Graphs","title":"Part 3: Comparison with Qualmer-Mediated Approach","text":"Let's compare the direct approach with the qualmer-mediated approach.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Comparing direct vs qualmer-mediated approaches...\")\n\n# Build qualmer graph first, then convert to sequence graph\nk = 15  ## Use larger k for better comparison\nqualmer_graph = Mycelia.Rhizomorph.build_qualmer_graph(fastq_reads, k; dataset_id=\"qualmer_direct\", mode=:singlestrand)\nqualmer_to_fastq = Mycelia.Rhizomorph.convert_fixed_to_variable(qualmer_graph)\n\nprintln(\"\\nApproach comparison:\")\nprintln(\"  Direct FASTQ graph:\")\nprintln(\"    Vertices: \", length(fastq_labels))\nprintln(\"    Edges: \", Mycelia.MetaGraphsNext.ne(fastq_graph))\n\nprintln(\"  Qualmer-mediated graph (k=$k):\")\nprintln(\"    Qualmer vertices: \", length(Mycelia.MetaGraphsNext.labels(qualmer_graph)))\nprintln(\"    Qualmer edges: \", Mycelia.MetaGraphsNext.ne(qualmer_graph))\nprintln(\"    Final FASTQ vertices: \", length(Mycelia.MetaGraphsNext.labels(qualmer_to_fastq)))\nprintln(\"    Final FASTQ edges: \", Mycelia.MetaGraphsNext.ne(qualmer_to_fastq))","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-4:-Quality-Aware-Assembly-Analysis","page":"Round-Trip 05: FASTQ Graphs","title":"Part 4: Quality-Aware Assembly Analysis","text":"Analyze assembly quality using both approaches.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Analyzing assembly quality for both approaches...\")\n\n# For direct approach - analyze sequence lengths and qualities\ndirect_sequences = [fastq_graph[label].sequence for label in fastq_labels]\ndirect_qualities = [fastq_graph[label].quality_scores for label in fastq_labels]\n\nif !isempty(direct_sequences)\n    direct_lengths = [length(seq) for seq in direct_sequences]\n    direct_mean_quals = [Statistics.mean(Mycelia.Rhizomorph.decode_quality_scores(quals)) for quals in direct_qualities]\n\n    println(\"\\nDirect approach analysis:\")\n    println(\"  Sequence count: \", length(direct_sequences))\n    println(\"  Mean sequence length: \", round(Statistics.mean(direct_lengths), digits=1))\n    println(\"  Longest sequence: \", maximum(direct_lengths), \" bp\")\n    println(\"  Mean quality across all sequences: \", round(Statistics.mean(vcat(direct_mean_quals...)), digits=1))\nend\n\n# For qualmer approach - use the package quality metrics\nif !isempty(Mycelia.MetaGraphsNext.labels(qualmer_graph))\n    qualmer_metrics = Mycelia.Rhizomorph.get_qualmer_statistics(qualmer_graph; dataset_id=\"qualmer_direct\")\n\n    println(\"\\nQualmer approach analysis:\")\n    println(\"  K-mer count: \", qualmer_metrics[:num_vertices])\n    println(\"  Mean joint quality: \", round(qualmer_metrics[:mean_joint_quality], digits=1))\n    println(\"  Min joint quality: \", qualmer_metrics[:min_joint_quality])\n    println(\"  Max joint quality: \", qualmer_metrics[:max_joint_quality])\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-5:-Contig-Assembly-and-Reconstruction","page":"Round-Trip 05: FASTQ Graphs","title":"Part 5: Contig Assembly and Reconstruction","text":"Extract contigs from the quality-aware sequence graph.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Extracting contigs and performing reconstruction...\")\n\n# Find the longest contigs from direct approach\nif !isempty(direct_sequences)\n    # Sort by length\n    seq_length_pairs = [(i, length(seq)) for (i, seq) in enumerate(direct_sequences)]\n    sort!(seq_length_pairs, by=x -> x[2], rev=true)\n\n    println(\"\\nTop contigs from direct approach:\")\n    for (rank, (vertex_idx, length)) in enumerate(seq_length_pairs[1:min(3, length(seq_length_pairs))])\n        label = fastq_labels[vertex_idx]\n        vertex_data = fastq_graph[label]\n        mean_qual = round(Statistics.mean(Mycelia.Rhizomorph.decode_quality_scores(vertex_data.quality_scores)), digits=1)\n\n        println(\"  Contig $rank:\")\n        println(\"    Length: $length bp\")\n        println(\"    Mean quality: $mean_qual\")\n        println(\"    Sequence: \", vertex_data.sequence)\n\n        # Check if this contig matches part of the reference\n        contig_seq = string(vertex_data.sequence)\n        if occursin(contig_seq, reference_seq)\n            println(\"    ✓ Perfect match in reference\")\n        elseif occursin(reference_seq, contig_seq)\n            println(\"    ✓ Contains entire reference\")\n        else\n            # Check for partial matches\n            best_match_len = 0\n            for i in 1:(length(reference_seq) - length(contig_seq) + 1)\n                if reference_seq[i:(i + length(contig_seq) - 1)] == contig_seq\n                    best_match_len = length(contig_seq)\n                    break\n                end\n            end\n            if best_match_len > 0\n                println(\"    ✓ Partial match ($best_match_len bp)\")\n            else\n                println(\"    ✗ No direct match found\")\n            end\n        end\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-6:-Round-Trip-Validation","page":"Round-Trip 05: FASTQ Graphs","title":"Part 6: Round-Trip Validation","text":"Convert back to FASTQ records and validate quality preservation.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Performing round-trip validation...\")\n\n# Convert graph back to FASTQ records\nreconstructed_fastq = Mycelia.Rhizomorph.fastq_graph_to_records(fastq_graph, \"reconstructed\")\n\nprintln(\"\\nRound-trip validation:\")\nprintln(\"  Original reads: \", length(fastq_reads))\nprintln(\"  Reconstructed reads: \", length(reconstructed_fastq))\n\n# Analyze quality preservation\noriginal_qualities = []\nreconstructed_qualities = []\n\nfor read in fastq_reads\n    append!(original_qualities, FASTX.quality_scores(read))\nend\n\nfor read in reconstructed_fastq\n    append!(reconstructed_qualities, FASTX.quality_scores(read))\nend\n\nif !isempty(original_qualities) && !isempty(reconstructed_qualities)\n    println(\"\\nQuality score analysis:\")\n    println(\"  Original mean quality: \", round(Statistics.mean(original_qualities), digits=1))\n    println(\"  Reconstructed mean quality: \", round(Statistics.mean(reconstructed_qualities), digits=1))\n    println(\"  Original quality range: \", minimum(original_qualities), \"-\", maximum(original_qualities))\n    println(\"  Reconstructed quality range: \", minimum(reconstructed_qualities), \"-\", maximum(reconstructed_qualities))\nend\n\n# Compare individual reads\nprintln(\"\\nIndividual read comparison:\")\nfor i in 1:min(3, length(fastq_reads), length(reconstructed_fastq))\n    orig = fastq_reads[i]\n    recon = reconstructed_fastq[i]\n\n    orig_seq = String(FASTX.sequence(orig))\n    recon_seq = String(FASTX.sequence(recon))\n\n    println(\"\\nRead $i:\")\n    println(\"  Original:      \", orig_seq)\n    println(\"  Reconstructed: \", recon_seq)\n    println(\"  Length match: \", length(orig_seq) == length(recon_seq) ? \"✓\" : \"✗\")\n    println(\"  Sequence match: \", orig_seq == recon_seq ? \"✓\" : \"✗\")\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-7:-Error-Detection-and-Quality-Assessment","page":"Round-Trip 05: FASTQ Graphs","title":"Part 7: Error Detection and Quality Assessment","text":"Use quality information to identify potential assembly issues.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Quality-based error detection and assessment...\")\n\n# Analyze quality distribution across contigs\nif !isempty(direct_qualities)\n    all_quals = vcat(direct_qualities...)\n    decoded_quals = Mycelia.Rhizomorph.decode_quality_scores(all_quals)\n    quality_stats = (\n        mean = Statistics.mean(decoded_quals),\n        median = Statistics.median(decoded_quals),\n        std = Statistics.std(decoded_quals),\n        min = minimum(decoded_quals),\n        max = maximum(decoded_quals)\n    )\n\n    println(\"\\nQuality distribution analysis:\")\n    println(\"  Mean: \", round(quality_stats.mean, digits=1))\n    println(\"  Median: \", round(quality_stats.median, digits=1))\n    println(\"  Std dev: \", round(quality_stats.std, digits=1))\n    println(\"  Range: \", quality_stats.min, \"-\", quality_stats.max)\n\n    # Identify low-quality regions\n    low_quality_threshold = 20.0\n    low_qual_count = count(q -> q < low_quality_threshold, decoded_quals)\n    low_qual_fraction = low_qual_count / length(decoded_quals)\n\n    println(\"\\nLow-quality region analysis:\")\n    println(\"  Positions below Q$low_quality_threshold: \", low_qual_count)\n    println(\"  Fraction of low-quality positions: \", round(low_qual_fraction, digits=3))\n\n    if low_qual_fraction > 0.1\n        println(\"  ⚠️  High fraction of low-quality positions detected\")\n    else\n        println(\"  ✓ Good overall quality distribution\")\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-8:-Performance-and-Use-Case-Analysis","page":"Round-Trip 05: FASTQ Graphs","title":"Part 8: Performance and Use Case Analysis","text":"Discuss when to use direct vs qualmer-mediated approaches.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Performance and use case analysis...\")\n\nprintln(\"\\nApproach comparison summary:\")\nprintln(\"\\nDirect FASTQ → FASTQ graphs:\")\nprintln(\"  ✓ Faster construction (no intermediate k-mer step)\")\nprintln(\"  ✓ Variable-length sequences from start\")\nprintln(\"  ✓ Natural read-level quality preservation\")\nprintln(\"  ✓ Good for high-quality, long reads\")\nprintln(\"  ✗ Less granular error detection\")\nprintln(\"  ✗ May struggle with complex repeat regions\")\n\nprintln(\"\\nQualmer-mediated approach:\")\nprintln(\"  ✓ Fine-grained quality analysis at k-mer level\")\nprintln(\"  ✓ Better error detection and correction\")\nprintln(\"  ✓ Handles complex genomic features better\")\nprintln(\"  ✓ Quality-weighted assembly decisions\")\nprintln(\"  ✗ More computationally intensive\")\nprintln(\"  ✗ Requires k-mer size optimization\")\n\nprintln(\"\\nRecommended use cases:\")\nprintln(\"  Direct approach:\")\nprintln(\"    - High-quality PacBio HiFi or ONT reads\")\nprintln(\"    - Simple genomes without complex repeats\")\nprintln(\"    - Rapid prototyping and initial assembly\")\nprintln(\"    - When computational resources are limited\")\nprintln(\"\\n  Qualmer approach:\")\nprintln(\"    - Short reads (Illumina)\")\nprintln(\"    - Error-prone long reads\")\nprintln(\"    - Complex genomes with repeats\")\nprintln(\"    - When maximum accuracy is required\")","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Part-9:-Practical-Assembly-Example","page":"Round-Trip 05: FASTQ Graphs","title":"Part 9: Practical Assembly Example","text":"Demonstrate a complete assembly workflow using the direct approach.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Complete assembly workflow example...\")\n\nfunction create_realistic_reads()\n    # Simulate a 100bp region with realistic read coverage\n    true_seq = \"ATCGATCGATCGTAGCTAGCTAGCTTGCATGCATGCATGCATGCATGCATTAGCTAGCATCGATCGTAGCTAGCTAGCTTGCATGCATGCAT\"\n    reads = []\n\n    # Simulate 10x coverage with 25bp reads\n    read_length = 25\n    step_size = 10  ## Overlap by 15bp\n\n    for start in 1:step_size:(length(true_seq) - read_length + 1)\n        end_pos = min(start + read_length - 1, length(true_seq))\n        read_seq = true_seq[start:end_pos]\n\n        # Vary quality based on position (simulate quality degradation)\n        base_quality = 35\n        qual_scores = [max(20, base_quality - abs(i - read_length÷2)) for i in 1:length(read_seq)]\n        qual_string = String([Char(33 + q) for q in qual_scores])\n\n        push!(reads, FASTX.FASTQ.Record(\"read_$(start)\", read_seq, qual_string))\n    end\n\n    return reads, true_seq\nend\n\nrealistic_reads, true_genome = create_realistic_reads()\n\nprintln(\"\\nRealistic assembly example:\")\nprintln(\"  True genome length: \", length(true_genome))\nprintln(\"  Number of reads: \", length(realistic_reads))\nprintln(\"  Expected coverage: ~10x\")\n\n# Build graph and assemble\nrealistic_graph = Mycelia.Rhizomorph.build_fastq_graph(realistic_reads; dataset_id=\"realistic_reads\", min_overlap=5)\nrealistic_labels = collect(Mycelia.MetaGraphsNext.labels(realistic_graph))\nprintln(\"  Graph vertices: \", length(realistic_labels))\nprintln(\"  Graph edges: \", Mycelia.MetaGraphsNext.ne(realistic_graph))\n\n# Find best assembly\nif !isempty(realistic_labels)\n    sequences = [realistic_graph[label].sequence for label in realistic_labels]\n    qualities = [realistic_graph[label].quality_scores for label in realistic_labels]\n\n    # Find longest sequence\n    longest_idx = argmax(length.(sequences))\n    best_assembly = string(sequences[longest_idx])\n    best_quality = Statistics.mean(Mycelia.Rhizomorph.decode_quality_scores(qualities[longest_idx]))\n\n    println(\"\\nBest assembly result:\")\n    println(\"  Assembled length: \", length(best_assembly))\n    println(\"  True length: \", length(true_genome))\n    println(\"  Mean quality: \", round(best_quality, digits=1))\n\n    # Check assembly accuracy\n    if best_assembly == true_genome\n        println(\"  ✓ Perfect assembly!\")\n    elseif occursin(best_assembly, true_genome)\n        println(\"  ✓ Assembly is subset of true genome\")\n        coverage = length(best_assembly) / length(true_genome)\n        println(\"  Coverage: \", round(coverage * 100, digits=1), \"%\")\n    elseif occursin(true_genome, best_assembly)\n        println(\"  ✓ Assembly contains entire true genome\")\n    else\n        println(\"  ⚠️  Assembly differs from true genome\")\n        println(\"  True:      \", true_genome[1:min(50, length(true_genome))], \"...\")\n        println(\"  Assembled: \", best_assembly[1:min(50, length(best_assembly))], \"...\")\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_05_fastq_graphs/#Summary","page":"Round-Trip 05: FASTQ Graphs","title":"Summary","text":"In this tutorial, we've demonstrated:\n\nDirect Construction: Building quality-aware sequence graphs directly from FASTQ\nApproach Comparison: Direct vs qualmer-mediated assembly strategies\nQuality Preservation: Maintaining per-base quality through assembly\nContig Assembly: Extracting variable-length contigs with quality scores\nError Detection: Using quality information for assembly validation\nUse Case Analysis: When to choose each approach\nPractical Workflow: Complete assembly pipeline demonstration\n\nKey insights:\n\nDirect approach is faster and simpler for high-quality data\nQualmer approach provides better error handling for challenging data\nQuality information is preserved throughout both workflows\nChoice of approach depends on data quality and computational requirements\nBoth approaches support the complete graph hierarchy for downstream analysis\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Tutorial 5 completed!\")\nprintln(\"You've learned to choose between direct and qualmer-mediated quality-aware assembly.\")\nprintln(\"Both approaches preserve quality information for downstream analysis.\")","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Round-Trip-Tutorial-4:-FASTA-Sequences-K-mer-Graphs-Sequence-Graphs-Reconstruction","page":"Round-Trip 04: K-mer to Sequence","title":"Round-Trip Tutorial 4: FASTA Sequences → K-mer Graphs → Sequence Graphs → Reconstruction","text":"This tutorial demonstrates the hierarchical biological sequence workflow from fixed-length k-mer graphs to variable-length sequence graphs. We'll work with real biological sequences, showing how k-mer graphs capture local sequence patterns that can be efficiently converted to variable-length representations for assembly and analysis.","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Learning-Objectives","page":"Round-Trip 04: K-mer to Sequence","title":"Learning Objectives","text":"By the end of this tutorial, you will:\n\nBuild k-mer graphs from FASTA biological sequences using Kmers.jl iterators\nUnderstand the hierarchical relationship between k-mer and sequence graphs\nConvert fixed-length k-mer graphs to variable-length sequence graphs\nPerform high-quality biological sequence reconstruction from both graph types\nCompare assembly accuracy and computational efficiency across representations\nApply k-mer workflows to realistic genomic assembly challenges\n\nFrom the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/09_round_trip_04_kmer_to_sequence.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Mycelia\nimport FASTX\nimport BioSequences\nimport Kmers\nimport Statistics\nimport Random","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Biological-K-mer-Graph-Overview","page":"Round-Trip 04: K-mer to Sequence","title":"Biological K-mer Graph Overview","text":"This tutorial explores the foundational bioinformatics workflow where fixed-length k-mer graphs serve as the basis for variable-length sequence graph construction.\n\nprintln(\"=\"^80)\nprintln(\"ROUND-TRIP TUTORIAL 4: K-MER TO SEQUENCE GRAPH HIERARCHY\")\nprintln(\"=\"^80)\n\nprintln(\"\\n🧬 K-MER GRAPH HIERARCHY OVERVIEW:\")\nprintln(\"  Fixed-Length Foundation (K-mer Graphs):\")\nprintln(\"    • DNA k-mers: Fixed-size DNA subsequences using FwDNAMers\")\nprintln(\"    • RNA k-mers: Fixed-size RNA subsequences using FwRNAMers\")\nprintln(\"    • Protein k-mers: Fixed-size amino acid subsequences using FwAAMers\")\nprintln(\"    • Type-safe: BioSequences.LongDNA{4}, LongRNA{4}, LongAA\")\nprintln()\nprintln(\"  Variable-Length Products (Sequence Graphs):\")\nprintln(\"    • Assembled contigs: Variable-length biological sequences\")\nprintln(\"    • Collapsed paths: Linear k-mer chains → single sequences\")\nprintln(\"    • Preserved branches: Complex genomic structures maintained\")\nprintln()\nprintln(\"  This tutorial: K-mer graphs → Sequence graphs → Assembly\")","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Biological-Dataset-Preparation","page":"Round-Trip 04: K-mer to Sequence","title":"Biological Dataset Preparation","text":"Create comprehensive biological test datasets representing different genomic scenarios.\n\nbiological_datasets = [\n    (\n        name = \"Bacterial Gene\",\n        sequence = \"ATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGA\",\n        type = \"DNA\",\n        description = \"Typical bacterial gene with start/stop codons\"\n    ),\n    (\n        name = \"Viral Genome Fragment\",\n        sequence = \"ATCGATCGATCGATCGATCGATCGATCGATCGATCGTAGCTAGCTAGCTAGCTAGCAAATGCCGCGC\",\n        type = \"DNA\",\n        description = \"Repetitive viral sequence with conserved domains\"\n    ),\n    (\n        name = \"Eukaryotic Exon\",\n        sequence = \"ATGACCATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGAGATCTATATAATCTGCGCGCGCATATGGCATC\",\n        type = \"DNA\",\n        description = \"Complex eukaryotic coding sequence\"\n    ),\n    (\n        name = \"Plant Chloroplast\",\n        sequence = \"ATGGCATCGATCGATCGAAATTTGCGCGCGATTAGCACCGCGCGCATTATATAGATCGCCCGCACCGTTACCTGTGGTAATGGTGATGGTGGTGGTAATGGTGGTGCTAATGCGTTTCATGGT\",\n        type = \"DNA\",\n        description = \"Plant organellar DNA with palindromic regions\"\n    ),\n    (\n        name = \"Ribosomal RNA\",\n        sequence = \"GGCUACACACGCGGUAUUACUGGAUUCACGGGUGGUCCGAUCCCGGCAGCUACGACCUCUCCCAUGGUGCACGGCCCGAAUCCUCGUCCGCGCGCAGAAU\",\n        type = \"RNA\",\n        description = \"Highly structured ribosomal RNA fragment\"\n    ),\n    (\n        name = \"Messenger RNA\",\n        sequence = \"AUGUGAAACGCAUUAGCACCACCAUUACCACCACCAUCACCAUUACCACAGGUAACGGUGCGGGCUGAGAUCUCUAAAUGUGCGCGCAUA\",\n        type = \"RNA\",\n        description = \"Protein-coding mRNA with UTR regions\"\n    ),\n    (\n        name = \"Transfer RNA\",\n        sequence = \"GCCGAGAUAGCUCAGUUGGUAGAGCGCGUGCCUUUCCAAGGCACGGGGGUCGCGAGUUCGAACCUCGCUCGGCGCCA\",\n        type = \"RNA\",\n        description = \"Folded tRNA with secondary structure\"\n    ),\n    (\n        name = \"Signal Peptide\",\n        sequence = \"MKRILLAALLAAATLTLVTITIPTIGGGIIAAPPTTAVIGQGSLRAILVDTGSSNFAAVGAAVAL\",\n        type = \"PROTEIN\",\n        description = \"Protein signal sequence with hydrophobic region\"\n    ),\n    (\n        name = \"Enzyme Active Site\",\n        sequence = \"HDSYWVDHGKPVCHVEYGPSGRGAATSWEPRYSGVGAHPTFRYTVPGDSKILVVGRGDKQINLWRTSQLRLVQK\",\n        type = \"PROTEIN\",\n        description = \"Catalytic domain with conserved residues\"\n    ),\n    (\n        name = \"Membrane Protein\",\n        sequence = \"MLLLLLLLLAALAAAVAVSAATTAAVVLLLVVVIIIFFFWWWGGGPPPKRKRKRKRHEHEHQDQDQDSY\",\n        type = \"PROTEIN\",\n        description = \"Transmembrane domain with charged terminus\"\n    )\n]\n\nprintln(\"\\n1. BIOLOGICAL DATASET PREPARATION\")\nprintln(\"-\"^50)\n\nCreate FASTA records and organize by sequence type\n\nall_bio_records = []\ndna_records = []\nrna_records = []\nprotein_records = []\n\nprintln(\"Biological sequence datasets:\")\nfor (i, dataset) in enumerate(biological_datasets)\n    # Create FASTA record\n    record_id = \"$(lowercase(dataset.type))_$(i)_$(replace(dataset.name, \" \" => \"_\"))\"\n    record = FASTX.FASTA.Record(record_id, dataset.sequence)\n    push!(all_bio_records, (record=record, dataset=dataset))\n\n    # Sort by type\n    if dataset.type == \"DNA\"\n        push!(dna_records, record)\n    elseif dataset.type == \"RNA\"\n        push!(rna_records, record)\n    elseif dataset.type == \"PROTEIN\"\n        push!(protein_records, record)\n    end\n\n    println(\"  $(dataset.name) ($(dataset.type)):\")\n    println(\"    Sequence: $(dataset.sequence)\")\n    println(\"    Length: $(length(dataset.sequence)) $(dataset.type == \"PROTEIN\" ? \"residues\" : \"nucleotides\")\")\n    println(\"    Description: $(dataset.description)\")\n    println()\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-1:-K-mer-Graph-Construction","page":"Round-Trip 04: K-mer to Sequence","title":"Phase 1: K-mer Graph Construction","text":"Build k-mer graphs using proper BioSequence types and Kmers.jl iterators.\n\nprintln(\"\\n2. PHASE 1: K-MER GRAPH CONSTRUCTION\")\nprintln(\"-\"^50)\n\nkmer_results = Dict()\n\nTest different k-mer sizes for different sequence types\n\nkmer_configs = [\n    (type=\"DNA\", records=dna_records, ks=[3, 5, 7], description=\"DNA k-mer graphs using FwDNAMers\"),\n    (type=\"RNA\", records=rna_records, ks=[3, 5, 7], description=\"RNA k-mer graphs using FwRNAMers\"),\n    (type=\"PROTEIN\", records=protein_records, ks=[3, 4, 5], description=\"Protein k-mer graphs using FwAAMers\")\n]\n\nfor config in kmer_configs\n    if !isempty(config.records)\n        println(\"\\nConstructing $(config.type) k-mer graphs:\")\n        println(\"  $(config.description)\")\n        println(\"  Input records: $(length(config.records))\")\n\n        for k in config.ks\n            println(\"\\n  k-mer size: $k\")\n\n            try\n                # Build k-mer graph (Rhizomorph auto-detects sequence type)\n                kmer_graph = Mycelia.Rhizomorph.build_kmer_graph(\n                    config.records,\n                    k;\n                    dataset_id=\"$(lowercase(config.type))_k$(k)\"\n                )\n\n                # Extract graph statistics\n                vertices = collect(Mycelia.MetaGraphsNext.labels(kmer_graph))\n                num_vertices = length(vertices)\n\n                if num_vertices > 0\n                    # Analyze k-mer properties\n                    kmer_lengths = [length(kmer) for kmer in vertices]\n                    total_kmers = sum(max(0, length(FASTX.FASTA.sequence(record)) - k + 1) for record in config.records)\n                    compression_ratio = num_vertices / max(1, total_kmers)\n\n                    # Get k-mer type for verification\n                    first_kmer = first(vertices)\n                    kmer_type = typeof(first_kmer)\n\n                    println(\"    Results:\")\n                    println(\"      Graph vertices: $num_vertices\")\n                    println(\"      K-mer type: $kmer_type\")\n                    println(\"      K-mer length: $k\")\n                    println(\"      Total possible k-mers: $total_kmers\")\n                    println(\"      Compression ratio: $(round(compression_ratio, digits=3))\")\n\n                    # Show example k-mers\n                    example_count = min(3, num_vertices)\n                    println(\"      Example k-mers:\")\n                    for i in 1:example_count\n                        kmer = vertices[i]\n                        println(\"        K-mer $i: $(string(kmer))\")\n                    end\n\n                    # Store results\n                    key = \"$(config.type)_k$(k)\"\n                    kmer_results[key] = (\n                        graph = kmer_graph,\n                        vertices = vertices,\n                        num_vertices = num_vertices,\n                        k = k,\n                        sequence_type = config.type,\n                        kmer_type = kmer_type,\n                        compression_ratio = compression_ratio,\n                        records = config.records,\n                        total_kmers = total_kmers\n                    )\n\n                else\n                    println(\"    Warning: No k-mers generated\")\n                end\n\n            catch e\n                println(\"    Error constructing $(config.type) k$k graph: $(typeof(e)) - $e\")\n            end\n        end\n    else\n        println(\"\\nSkipping $(config.type): No records available\")\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-2:-K-mer-Graph-Analysis","page":"Round-Trip 04: K-mer to Sequence","title":"Phase 2: K-mer Graph Analysis","text":"Analyze the structure and biological properties of k-mer graphs.\n\nprintln(\"\\n3. PHASE 2: K-MER GRAPH ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_kmer_graph_biology(vertices, k, sequence_type, description)\n    \"\"\"Analyze biological properties of k-mer graphs.\"\"\"\n\n    num_vertices = length(vertices)\n    if num_vertices == 0\n        println(\"  $description: Empty graph\")\n        return\n    end\n\n    println(\"  $description:\")\n\n    total_symbols = 0\n\n    # Sequence composition analysis based on type\n    if sequence_type == \"DNA\"\n        # DNA-specific k-mer analysis\n        all_kmers_str = [string(kmer) for kmer in vertices]\n        all_nucleotides = join(all_kmers_str)\n\n        base_counts = Dict('A' => 0, 'T' => 0, 'G' => 0, 'C' => 0)\n        for base in all_nucleotides\n            if haskey(base_counts, base)\n                base_counts[base] += 1\n            end\n        end\n\n        total_bases = sum(values(base_counts))\n        total_symbols = total_bases\n        if total_bases > 0\n            gc_content = (base_counts['G'] + base_counts['C']) / total_bases\n            at_content = (base_counts['A'] + base_counts['T']) / total_bases\n\n            println(\"    GC content: $(round(gc_content * 100, digits=1))%\")\n            println(\"    AT content: $(round(at_content * 100, digits=1))%\")\n            println(\"    Base composition: A=$(base_counts['A']), T=$(base_counts['T']), G=$(base_counts['G']), C=$(base_counts['C'])\")\n        end\n\n        # Palindrome detection\n        palindromes = 0\n        for kmer_str in all_kmers_str\n            if length(kmer_str) > 1\n                reverse_complement = reverse(replace(kmer_str, 'A'=>'T', 'T'=>'A', 'G'=>'C', 'C'=>'G'))\n                if kmer_str == reverse_complement\n                    palindromes += 1\n                end\n            end\n        end\n        println(\"    Palindromic k-mers: $palindromes/$(length(all_kmers_str)) ($(round(palindromes/length(all_kmers_str)*100, digits=1))%)\")\n\n    elseif sequence_type == \"RNA\"\n        # RNA-specific k-mer analysis\n        all_kmers_str = [string(kmer) for kmer in vertices]\n        all_nucleotides = join(all_kmers_str)\n\n        base_counts = Dict('A' => 0, 'U' => 0, 'G' => 0, 'C' => 0)\n        for base in all_nucleotides\n            if haskey(base_counts, base)\n                base_counts[base] += 1\n            end\n        end\n\n        total_bases = sum(values(base_counts))\n        total_symbols = total_bases\n        if total_bases > 0\n            gc_content = (base_counts['G'] + base_counts['C']) / total_bases\n            au_content = (base_counts['A'] + base_counts['U']) / total_bases\n\n            println(\"    GC content: $(round(gc_content * 100, digits=1))%\")\n            println(\"    AU content: $(round(au_content * 100, digits=1))%\")\n            println(\"    Base composition: A=$(base_counts['A']), U=$(base_counts['U']), G=$(base_counts['G']), C=$(base_counts['C'])\")\n        end\n\n    elseif sequence_type == \"PROTEIN\"\n        # Protein-specific k-mer analysis\n        all_kmers_str = [string(kmer) for kmer in vertices]\n        all_amino_acids = join(all_kmers_str)\n\n        # Classify amino acids\n        hydrophobic = ['A', 'V', 'L', 'I', 'M', 'F', 'W', 'Y']\n        charged = ['R', 'K', 'D', 'E', 'H']\n        polar = ['S', 'T', 'N', 'Q', 'C']\n        special = ['G', 'P']\n\n        hydrophobic_count = sum(1 for aa in all_amino_acids if aa in hydrophobic)\n        charged_count = sum(1 for aa in all_amino_acids if aa in charged)\n        polar_count = sum(1 for aa in all_amino_acids if aa in polar)\n        special_count = sum(1 for aa in all_amino_acids if aa in special)\n        total_aas = length(all_amino_acids)\n\n        total_symbols = total_aas\n        if total_aas > 0\n            println(\"    Hydrophobic residues: $(round(hydrophobic_count/total_aas*100, digits=1))%\")\n            println(\"    Charged residues: $(round(charged_count/total_aas*100, digits=1))%\")\n            println(\"    Polar residues: $(round(polar_count/total_aas*100, digits=1))%\")\n            println(\"    Special residues (G,P): $(round(special_count/total_aas*100, digits=1))%\")\n        end\n    end\n\n    # Graph connectivity properties\n    println(\"    K-mer vertices: $num_vertices\")\n    println(\"    K-mer size: $k\")\n    println(\"    Average k-mer frequency: $(round(num_vertices > 0 ? total_symbols/num_vertices : 0, digits=1))\")\n\n    return (\n        vertices = num_vertices,\n        k = k,\n        sequence_type = sequence_type\n    )\nend\n\nAnalyze representative k-mer graphs\n\nprintln(\"Analyzing k-mer graph biological properties:\")\nanalysis_results = Dict()\n\nfor (key, result) in kmer_results\n    analysis = analyze_kmer_graph_biology(\n        result.vertices,\n        result.k,\n        result.sequence_type,\n        \"$(result.sequence_type) k=$(result.k) K-mer Graph\"\n    )\n    analysis_results[key] = analysis\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-3:-Sequence-Graph-Conversion","page":"Round-Trip 04: K-mer to Sequence","title":"Phase 3: Sequence Graph Conversion","text":"Convert k-mer graphs to variable-length sequence graphs through path collapsing.\n\nprintln(\"\\n4. PHASE 3: SEQUENCE GRAPH CONVERSION\")\nprintln(\"-\"^50)\n\nfunction convert_kmer_to_sequence_graph(kmer_graph, k, sequence_type_name)\n    \"\"\"Convert k-mer graph to variable-length sequence graph.\"\"\"\n\n    try\n        # Convert fixed-length k-mer graph to variable-length sequence graph\n        sequence_graph = Mycelia.Rhizomorph.convert_fixed_to_variable(kmer_graph)\n\n        # Extract sequence vertices\n        sequence_vertices = collect(Mycelia.MetaGraphsNext.labels(sequence_graph))\n        num_sequences = length(sequence_vertices)\n\n        if num_sequences > 0\n            # Analyze sequence properties\n            sequence_lengths = [length(seq) for seq in sequence_vertices]\n            total_sequence_length = sum(sequence_lengths)\n            avg_length = Statistics.mean(sequence_lengths)\n            max_length = maximum(sequence_lengths)\n            min_length = minimum(sequence_lengths)\n\n            # Get sequence type\n            first_seq = first(sequence_vertices)\n            seq_type = typeof(first_seq)\n\n            return (\n                success = true,\n                graph = sequence_graph,\n                vertices = sequence_vertices,\n                num_sequences = num_sequences,\n                sequence_type = seq_type,\n                total_length = total_sequence_length,\n                avg_length = avg_length,\n                max_length = max_length,\n                min_length = min_length\n            )\n        else\n            return (\n                success = false,\n                error = \"No sequences generated\"\n            )\n        end\n\n    catch e\n        return (\n            success = false,\n            error = \"$(typeof(e)): $e\"\n        )\n    end\nend\n\nsequence_conversion_results = Dict()\n\nprintln(\"Converting k-mer graphs to sequence graphs:\")\nfor (key, kmer_result) in kmer_results\n    println(\"\\n$(key) conversion:\")\n\n    conversion = convert_kmer_to_sequence_graph(\n        kmer_result.graph,\n        kmer_result.k,\n        kmer_result.sequence_type\n    )\n\n    sequence_conversion_results[key] = conversion\n\n    if conversion.success\n        # Calculate conversion statistics\n        original_kmers = kmer_result.num_vertices\n        final_sequences = conversion.num_sequences\n        conversion_ratio = final_sequences / max(1, original_kmers)\n\n        println(\"  Success: K-mer graph → Sequence graph\")\n        println(\"    Original k-mers: $original_kmers\")\n        println(\"    Final sequences: $final_sequences\")\n        println(\"    Conversion ratio: $(round(conversion_ratio, digits=3))\")\n        println(\"    Sequence type: $(conversion.sequence_type)\")\n        println(\"    Length range: $(conversion.min_length) - $(conversion.max_length) (avg: $(round(conversion.avg_length, digits=1)))\")\n\n        # Show example sequences\n        example_count = min(2, conversion.num_sequences)\n        println(\"    Example sequences:\")\n        for i in 1:example_count\n            seq = conversion.vertices[i]\n            seq_str = string(seq)\n            display_length = min(40, length(seq_str))\n            println(\"      Seq $i: $(seq_str[1:display_length])$(length(seq_str) > 40 ? \"...\" : \"\") ($(length(seq)) bp/aa)\")\n        end\n\n    else\n        println(\"  Failed: $(conversion.error)\")\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-4:-Round-Trip-Reconstruction","page":"Round-Trip 04: K-mer to Sequence","title":"Phase 4: Round-Trip Reconstruction","text":"Reconstruct original sequences and validate reconstruction quality.\n\nprintln(\"\\n5. PHASE 4: ROUND-TRIP RECONSTRUCTION\")\nprintln(\"-\"^50)\n\nfunction perform_kmer_to_sequence_roundtrip(original_records, kmer_result, sequence_result, sequence_type_name)\n    \"\"\"Perform complete round-trip reconstruction from both graph types.\"\"\"\n\n    # Extract original sequences for comparison\n    original_sequences = [string(FASTX.FASTA.sequence(record)) for record in original_records]\n\n    reconstruction_results = Dict()\n\n    # Method 1: Direct k-mer assembly\n    println(\"  K-mer graph reconstruction:\")\n    try\n        kmer_assemblies = []\n        paths = Mycelia.Rhizomorph.find_eulerian_paths_next(kmer_result.graph)\n        for path in paths\n            if length(path) > 1\n                push!(kmer_assemblies, Mycelia.Rhizomorph.path_to_sequence(path, kmer_result.graph))\n            end\n        end\n        if isempty(kmer_assemblies)\n            contigs = Mycelia.Rhizomorph.find_contigs_next(kmer_result.graph; min_contig_length=1)\n            kmer_assemblies = [contig.sequence for contig in contigs]\n        end\n        kmer_success = !isempty(kmer_assemblies)\n\n        if kmer_success\n            # Find best k-mer reconstruction\n            best_kmer_score = 0.0\n            best_kmer_reconstruction = \"\"\n\n            for assembly in kmer_assemblies\n                assembly_str = string(assembly)\n                max_similarity = 0.0\n\n                for original in original_sequences\n                    similarity = calculate_biological_similarity(original, assembly_str)\n                    max_similarity = max(max_similarity, similarity)\n                end\n\n                if max_similarity > best_kmer_score\n                    best_kmer_score = max_similarity\n                    best_kmer_reconstruction = assembly_str\n                end\n            end\n\n            println(\"    Success: $(length(kmer_assemblies)) assemblies\")\n            println(\"    Best similarity: $(round(best_kmer_score, digits=3))\")\n\n        else\n            println(\"    Failed: No k-mer assemblies generated\")\n            best_kmer_score = 0.0\n            best_kmer_reconstruction = \"\"\n        end\n\n        reconstruction_results[\"kmer\"] = (\n            success = kmer_success,\n            similarity = best_kmer_score,\n            reconstruction = best_kmer_reconstruction,\n            method = \"k-mer_assembly\"\n        )\n\n    catch e\n        println(\"    Error: $(typeof(e))\")\n        reconstruction_results[\"kmer\"] = (\n            success = false,\n            similarity = 0.0,\n            reconstruction = \"\",\n            method = \"k-mer_assembly\"\n        )\n    end\n\n    # Method 2: Sequence graph reconstruction\n    println(\"  Sequence graph reconstruction:\")\n    if sequence_result.success\n        try\n            # Direct sequence assembly from sequence graph\n            sequence_contigs = Mycelia.Rhizomorph.find_contigs_next(sequence_result.graph; min_contig_length=1)\n            sequence_assemblies = [string(contig.sequence) for contig in sequence_contigs]\n            if isempty(sequence_assemblies)\n                sequence_assemblies = [string(seq) for seq in sequence_result.vertices]\n            end\n\n            # Find best sequence reconstruction\n            best_seq_score = 0.0\n            best_seq_reconstruction = \"\"\n\n            # Try different combination strategies\n            for assembly_str in sequence_assemblies\n                max_similarity = 0.0\n\n                for original in original_sequences\n                    similarity = calculate_biological_similarity(original, assembly_str)\n                    max_similarity = max(max_similarity, similarity)\n                end\n\n                if max_similarity > best_seq_score\n                    best_seq_score = max_similarity\n                    best_seq_reconstruction = assembly_str\n                end\n            end\n\n            # Also try concatenation\n            concatenated = join(sequence_assemblies, \"\")\n            for original in original_sequences\n                concat_similarity = calculate_biological_similarity(original, concatenated)\n                if concat_similarity > best_seq_score\n                    best_seq_score = concat_similarity\n                    best_seq_reconstruction = concatenated\n                end\n            end\n\n            println(\"    Success: $(length(sequence_assemblies)) sequences\")\n            println(\"    Best similarity: $(round(best_seq_score, digits=3))\")\n\n            reconstruction_results[\"sequence\"] = (\n                success = true,\n                similarity = best_seq_score,\n                reconstruction = best_seq_reconstruction,\n                method = \"sequence_assembly\"\n            )\n\n        catch e\n            println(\"    Error: $(typeof(e))\")\n            reconstruction_results[\"sequence\"] = (\n                success = false,\n                similarity = 0.0,\n                reconstruction = \"\",\n                method = \"sequence_assembly\"\n            )\n        end\n    else\n        println(\"    Skipped: Sequence graph conversion failed\")\n        reconstruction_results[\"sequence\"] = (\n            success = false,\n            similarity = 0.0,\n            reconstruction = \"\",\n            method = \"sequence_assembly\"\n        )\n    end\n\n    return reconstruction_results\nend\n\nfunction calculate_biological_similarity(seq1::String, seq2::String)\n    \"\"\"Calculate biological sequence similarity with gap penalty.\"\"\"\n    min_len = min(length(seq1), length(seq2))\n    max_len = max(length(seq1), length(seq2))\n\n    if max_len == 0\n        return 1.0\n    end\n\n    # Simple alignment-based similarity\n    matches = 0\n    for i in 1:min_len\n        if seq1[i] == seq2[i]\n            matches += 1\n        end\n    end\n\n    # Penalize length differences\n    similarity = matches / max_len\n    return similarity\nend\n\nroundtrip_results = Dict()\n\nprintln(\"Performing round-trip reconstructions:\")\nfor (key, kmer_result) in kmer_results\n    if haskey(sequence_conversion_results, key)\n        sequence_result = sequence_conversion_results[key]\n\n        println(\"\\n$key round-trip analysis:\")\n\n        reconstruction = perform_kmer_to_sequence_roundtrip(\n            kmer_result.records,\n            kmer_result,\n            sequence_result,\n            kmer_result.sequence_type\n        )\n\n        roundtrip_results[key] = reconstruction\n\n        # Show comparison summary\n        kmer_sim = reconstruction[\"kmer\"].similarity\n        seq_sim = reconstruction[\"sequence\"].similarity\n\n        better_method = kmer_sim > seq_sim ? \"K-mer\" : \"Sequence\"\n        println(\"  Overall comparison:\")\n        println(\"    K-mer method: $(round(kmer_sim, digits=3)) similarity\")\n        println(\"    Sequence method: $(round(seq_sim, digits=3)) similarity\")\n        println(\"    Better method: $better_method graphs\")\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-5:-Comprehensive-Quality-Assessment","page":"Round-Trip 04: K-mer to Sequence","title":"Phase 5: Comprehensive Quality Assessment","text":"Evaluate reconstruction quality and biological accuracy across all methods.\n\nprintln(\"\\n6. PHASE 5: COMPREHENSIVE QUALITY ASSESSMENT\")\nprintln(\"-\"^50)\n\nfunction comprehensive_kmer_quality_assessment(roundtrip_results)\n    \"\"\"Assess reconstruction quality across all sequence types and methods.\"\"\"\n\n    total_tests = length(roundtrip_results)\n    kmer_successes = 0\n    sequence_successes = 0\n    total_kmer_quality = 0.0\n    total_sequence_quality = 0.0\n\n    quality_by_type = Dict()\n    quality_by_method = Dict(\"kmer\" => [], \"sequence\" => [])\n\n    println(\"Individual sequence type and method assessment:\")\n\n    for (key, result) in roundtrip_results\n        kmer_result = result[\"kmer\"]\n        sequence_result = result[\"sequence\"]\n\n        # Count successes (>50% similarity)\n        if kmer_result.success && kmer_result.similarity > 0.5\n            kmer_successes += 1\n        end\n        if sequence_result.success && sequence_result.similarity > 0.5\n            sequence_successes += 1\n        end\n\n        total_kmer_quality += kmer_result.similarity\n        total_sequence_quality += sequence_result.similarity\n\n        push!(quality_by_method[\"kmer\"], kmer_result.similarity)\n        push!(quality_by_method[\"sequence\"], sequence_result.similarity)\n\n        # Extract sequence type for analysis\n        seq_type = split(key, \"_\")[1]\n        if !haskey(quality_by_type, seq_type)\n            quality_by_type[seq_type] = Dict(\"kmer\" => [], \"sequence\" => [])\n        end\n        push!(quality_by_type[seq_type][\"kmer\"], kmer_result.similarity)\n        push!(quality_by_type[seq_type][\"sequence\"], sequence_result.similarity)\n\n        # Show detailed comparison\n        kmer_status = kmer_result.similarity > 0.7 ? \"EXCELLENT\" : kmer_result.similarity > 0.5 ? \"GOOD\" : \"NEEDS_IMPROVEMENT\"\n        seq_status = sequence_result.similarity > 0.7 ? \"EXCELLENT\" : sequence_result.similarity > 0.5 ? \"GOOD\" : \"NEEDS_IMPROVEMENT\"\n\n        println(\"  $key:\")\n        println(\"    K-mer: $kmer_status ($(round(kmer_result.similarity, digits=3)))\")\n        println(\"    Sequence: $seq_status ($(round(sequence_result.similarity, digits=3)))\")\n    end\n\n    # Calculate averages\n    avg_kmer_quality = total_tests > 0 ? total_kmer_quality / total_tests : 0.0\n    avg_sequence_quality = total_tests > 0 ? total_sequence_quality / total_tests : 0.0\n\n    kmer_success_rate = total_tests > 0 ? kmer_successes / total_tests : 0.0\n    sequence_success_rate = total_tests > 0 ? sequence_successes / total_tests : 0.0\n\n    return (\n        total_tests = total_tests,\n        kmer_successes = kmer_successes,\n        sequence_successes = sequence_successes,\n        kmer_success_rate = kmer_success_rate,\n        sequence_success_rate = sequence_success_rate,\n        avg_kmer_quality = avg_kmer_quality,\n        avg_sequence_quality = avg_sequence_quality,\n        quality_by_type = quality_by_type,\n        quality_by_method = quality_by_method\n    )\nend\n\nquality_assessment = comprehensive_kmer_quality_assessment(roundtrip_results)\n\nprintln(\"\\nOverall Quality Assessment:\")\nprintln(\"  Total test configurations: $(quality_assessment.total_tests)\")\nprintln(\"  K-mer method successes: $(quality_assessment.kmer_successes)/$(quality_assessment.total_tests) ($(round(quality_assessment.kmer_success_rate * 100, digits=1))%)\")\nprintln(\"  Sequence method successes: $(quality_assessment.sequence_successes)/$(quality_assessment.total_tests) ($(round(quality_assessment.sequence_success_rate * 100, digits=1))%)\")\nprintln(\"  Average k-mer quality: $(round(quality_assessment.avg_kmer_quality, digits=3))\")\nprintln(\"  Average sequence quality: $(round(quality_assessment.avg_sequence_quality, digits=3))\")\n\nprintln(\"\\nQuality by sequence type:\")\nfor (seq_type, type_results) in quality_assessment.quality_by_type\n    avg_kmer = Statistics.mean(type_results[\"kmer\"])\n    avg_seq = Statistics.mean(type_results[\"sequence\"])\n\n    println(\"  $seq_type:\")\n    println(\"    K-mer method: $(round(avg_kmer, digits=3))\")\n    println(\"    Sequence method: $(round(avg_seq, digits=3))\")\n    println(\"    Better method: $(avg_kmer > avg_seq ? \"K-mer\" : \"Sequence\") graphs\")\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-6:-Performance-and-Scalability-Analysis","page":"Round-Trip 04: K-mer to Sequence","title":"Phase 6: Performance and Scalability Analysis","text":"Analyze computational performance and memory efficiency of both approaches.\n\nprintln(\"\\n7. PHASE 6: PERFORMANCE AND SCALABILITY ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_kmer_sequence_performance()\n    \"\"\"Analyze performance characteristics of k-mer vs sequence graph workflows.\"\"\"\n\n    # Test performance with sequences of increasing length\n    test_lengths = [50, 100, 200, 500]\n    performance_results = Dict()\n\n    println(\"Performance scaling analysis:\")\n    println(\"Testing k-mer vs sequence graph construction time:\")\n\n    for length in test_lengths\n        println(\"\\n  Sequence length: $length nucleotides\")\n\n        # Generate test DNA sequence\n        bases = ['A', 'T', 'G', 'C']\n        test_sequence = join([rand(bases) for _ in 1:length])\n        test_record = FASTX.FASTA.Record(\"perf_test_$length\", test_sequence)\n\n        performance_results[length] = Dict()\n\n        # Test different k values\n        for k in [3, 5, 7]\n            if length >= k\n                # Measure k-mer graph construction time\n                start_time = time()\n                try\n                    kmer_graph = Mycelia.Rhizomorph.build_kmer_graph([test_record], k; dataset_id=\"perf_k$(k)\")\n                    kmer_time = time() - start_time\n\n                    kmer_vertices = length(Mycelia.MetaGraphsNext.labels(kmer_graph))\n\n                    # Measure sequence graph conversion time\n                    start_time = time()\n                    sequence_result = convert_kmer_to_sequence_graph(kmer_graph, k, \"DNA\")\n                    sequence_time = time() - start_time\n\n                    total_time = kmer_time + sequence_time\n\n                    performance_results[length][k] = (\n                        kmer_time = kmer_time,\n                        sequence_time = sequence_time,\n                        total_time = total_time,\n                        kmer_vertices = kmer_vertices,\n                        sequence_vertices = sequence_result.success ? sequence_result.num_sequences : 0\n                    )\n\n                    println(\"    k=$k: K-mer $(round(kmer_time*1000, digits=2))ms + Sequence $(round(sequence_time*1000, digits=2))ms = $(round(total_time*1000, digits=2))ms total\")\n                    println(\"         Vertices: $kmer_vertices k-mers → $(sequence_result.success ? sequence_result.num_sequences : 0) sequences\")\n\n                catch e\n                    println(\"    k=$k: Failed - $(typeof(e))\")\n                    performance_results[length][k] = (\n                        kmer_time = 0.0,\n                        sequence_time = 0.0,\n                        total_time = 0.0,\n                        kmer_vertices = 0,\n                        sequence_vertices = 0\n                    )\n                end\n            end\n        end\n    end\n\n    # Memory efficiency analysis\n    println(\"\\nMemory efficiency characteristics:\")\n    println(\"  K-mer graphs:\")\n    println(\"    • Memory scales with number of unique k-mers\")\n    println(\"    • Fixed-size vertices (k nucleotides each)\")\n    println(\"    • Higher vertex count but smaller vertex size\")\n    println(\"    • Suitable for detailed local analysis\")\n    println()\n    println(\"  Sequence graphs:\")\n    println(\"    • Memory scales with total sequence content\")\n    println(\"    • Variable-size vertices (collapsed sequences)\")\n    println(\"    • Lower vertex count but larger vertex size\")\n    println(\"    • Suitable for assembly and global structure\")\n    println()\n    println(\"  Trade-offs:\")\n    println(\"    • K-mer graphs: Higher resolution, more memory overhead\")\n    println(\"    • Sequence graphs: Compressed representation, faster traversal\")\n    println(\"    • Conversion adds computational cost but saves memory\")\n\n    return performance_results\nend\n\nperformance_results = analyze_kmer_sequence_performance()","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Phase-7:-Real-World-Genomic-Assembly-Application","page":"Round-Trip 04: K-mer to Sequence","title":"Phase 7: Real-World Genomic Assembly Application","text":"Demonstrate the complete workflow on a realistic genomic assembly scenario.\n\nprintln(\"\\n8. PHASE 7: REAL-WORLD GENOMIC ASSEMBLY APPLICATION\")\nprintln(\"-\"^50)\n\nSimulate realistic genomic assembly: overlapping sequencing reads from a reference\n\nprintln(\"Realistic genomic assembly simulation:\")\n\nCreate a reference genome sequence\n\nreference_genome = \"ATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGAGATCTATATAATCTGCGCGCGCATATGGCATCGATCGATCGAAATTTGCGCGCGATTAGCACCGCGCGCATTATATAGATCGCCCGCACCGTTACCTGTGGTAATGGTGATGGTGGTGGTAATGGTGGTGCTAATGCGTTTCATGGTGGCATCGATC\"\n\nread_length = 50\noverlap_length = 15\ncoverage_depth = 3\n\nprintln(\"  Reference genome: $(reference_genome)\")\nprintln(\"  Genome length: $(length(reference_genome)) bp\")\nprintln(\"  Simulating $(read_length)bp reads with $(overlap_length)bp overlap\")\nprintln(\"  Target coverage depth: $(coverage_depth)x\")\n\n# Generate overlapping reads with coverage\nsimulated_reads = []\nstep_size = read_length - overlap_length\n\nfor coverage in 1:coverage_depth\n    for i in 1:step_size:(length(reference_genome) - read_length + 1)\n        read_seq = reference_genome[i:i+read_length-1]\n        read_id = \"read_cov$(coverage)_pos$(i)\"\n        record = FASTX.FASTA.Record(read_id, read_seq)\n        push!(simulated_reads, record)\n    end\nend\n\nprintln(\"  Generated $(length(simulated_reads)) overlapping reads with $(coverage_depth)x coverage\")\n\n# Show sample reads\nprintln(\"  Sample reads:\")\nfor (i, record) in enumerate(simulated_reads[1:min(5, length(simulated_reads))])\n    println(\"    $(FASTX.FASTA.identifier(record)): $(FASTX.FASTA.sequence(record))\")\nend\nif length(simulated_reads) > 5\n    println(\"    ... ($(length(simulated_reads) - 5) more reads)\")\nend\n\n# Perform hierarchical assembly\nprintln(\"\\nHierarchical assembly workflow:\")\n\n# Step 1: Build k-mer graph from reads\nprintln(\"  Step 1: K-mer graph construction\")\noptimal_k = 15  ## Choose k for good overlap resolution\ntry\n    assembly_kmer_graph = Mycelia.Rhizomorph.build_kmer_graph(simulated_reads, optimal_k; dataset_id=\"assembly_k$(optimal_k)\")\n    kmer_vertices = length(Mycelia.MetaGraphsNext.labels(assembly_kmer_graph))\n\n    println(\"    K-mer graph: $kmer_vertices unique $(optimal_k)-mers\")\n\n    # Step 2: Convert to sequence graph\n    println(\"  Step 2: Sequence graph conversion\")\n    assembly_sequence_result = convert_kmer_to_sequence_graph(assembly_kmer_graph, optimal_k, \"DNA\")\n\n    if assembly_sequence_result.success\n        println(\"    Sequence graph: $(assembly_sequence_result.num_sequences) sequences\")\n        println(\"    Total assembled length: $(assembly_sequence_result.total_length) bp\")\n\n        # Step 3: Assembly reconstruction\n        println(\"  Step 3: Assembly reconstruction\")\n\n        # Find longest sequence (likely the main assembly)\n        longest_sequence = \"\"\n        max_length = 0\n\n        for seq in assembly_sequence_result.vertices\n            seq_str = string(seq)\n            if length(seq_str) > max_length\n                max_length = length(seq_str)\n                longest_sequence = seq_str\n            end\n        end\n\n        # Compare to reference\n        assembly_accuracy = calculate_biological_similarity(reference_genome, longest_sequence)\n        length_accuracy = min(length(longest_sequence), length(reference_genome)) / max(length(longest_sequence), length(reference_genome))\n\n        println(\"  Assembly Results:\")\n        println(\"    Reference length: $(length(reference_genome)) bp\")\n        println(\"    Longest assembly: $max_length bp\")\n        println(\"    Length accuracy: $(round(length_accuracy, digits=3))\")\n        println(\"    Sequence accuracy: $(round(assembly_accuracy, digits=3))\")\n\n        if assembly_accuracy > 0.8 && length_accuracy > 0.8\n            println(\"    ✅ HIGH-QUALITY ASSEMBLY ACHIEVED!\")\n        elseif assembly_accuracy > 0.6 && length_accuracy > 0.6\n            println(\"    ✓ GOOD ASSEMBLY QUALITY\")\n        else\n            println(\"    ⚠️ Assembly needs optimization\")\n        end\n\n        # Show assembly comparison\n        println(\"\\n  Sequence comparison:\")\n        ref_preview = reference_genome[1:min(60, length(reference_genome))]\n        asm_preview = longest_sequence[1:min(60, length(longest_sequence))]\n        println(\"    Reference: $ref_preview...\")\n        println(\"    Assembled: $asm_preview...\")\n\n    else\n        println(\"    Sequence graph conversion failed: $(assembly_sequence_result.error)\")\n    end\n\ncatch e\n    println(\"  Assembly failed: $(typeof(e)) - $e\")\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_04_kmer_to_sequence/#Tutorial-Summary-and-Best-Practices","page":"Round-Trip 04: K-mer to Sequence","title":"Tutorial Summary and Best Practices","text":"Summarize key findings and provide guidance for k-mer to sequence graph workflows.\n\nprintln(\"\\n\" * \"=\"^80)\nprintln(\"TUTORIAL SUMMARY AND BEST PRACTICES\")\nprintln(\"=\"^80)\n\nprintln(\"\\n✅ HIERARCHICAL K-MER WORKFLOW COMPLETION:\")\nprintln(\"  1. Biological Dataset Preparation: ✓ DNA, RNA, and protein sequences\")\nprintln(\"  2. K-mer Graph Construction: ✓ Type-safe biological k-mer graphs\")\nprintln(\"  3. K-mer Graph Analysis: ✓ Biological composition and structure analysis\")\nprintln(\"  4. Sequence Graph Conversion: ✓ Fixed-length to variable-length transformation\")\nprintln(\"  5. Round-Trip Reconstruction: ✓ Dual-method quality validation\")\nprintln(\"  6. Quality Assessment: ✓ Comprehensive biological accuracy metrics\")\nprintln(\"  7. Performance Analysis: ✓ Scalability and efficiency evaluation\")\nprintln(\"  8. Genomic Assembly: ✓ Realistic assembly workflow demonstration\")\n\nprintln(\"\\n📊 QUANTITATIVE RESULTS:\")\nprintln(\"  Test configurations: $(quality_assessment.total_tests)\")\nprintln(\"  K-mer method success rate: $(round(quality_assessment.kmer_success_rate * 100, digits=1))%\")\nprintln(\"  Sequence method success rate: $(round(quality_assessment.sequence_success_rate * 100, digits=1))%\")\nprintln(\"  Average k-mer reconstruction quality: $(round(quality_assessment.avg_kmer_quality, digits=3))\")\nprintln(\"  Average sequence reconstruction quality: $(round(quality_assessment.avg_sequence_quality, digits=3))\")\n\nprintln(\"\\n🧬 BIOLOGICAL INSIGHTS BY SEQUENCE TYPE:\")\nfor (seq_type, type_results) in quality_assessment.quality_by_type\n    avg_kmer = Statistics.mean(type_results[\"kmer\"])\n    avg_seq = Statistics.mean(type_results[\"sequence\"])\n    better_method = avg_kmer > avg_seq ? \"K-mer\" : \"Sequence\"\n\n    println(\"  $seq_type sequences:\")\n    println(\"    K-mer graphs: $(round(avg_kmer, digits=3)) quality\")\n    println(\"    Sequence graphs: $(round(avg_seq, digits=3)) quality\")\n    println(\"    Optimal method: $better_method graphs\")\nend\n\nprintln(\"\\n🔄 HIERARCHICAL WORKFLOW VALIDATED:\")\nprintln(\"  FASTA Records → K-mer Graphs → Sequence Graphs → Reconstructed Sequences\")\nprintln(\"  ✓ Biological sequence types preserved throughout workflow\")\nprintln(\"  ✓ Fixed-length k-mer foundation successfully established\")\nprintln(\"  ✓ Variable-length sequence conversion demonstrated\")\nprintln(\"  ✓ High-fidelity reconstruction achieved\")\nprintln(\"  ✓ Realistic genomic assembly workflow completed\")\n\nprintln(\"\\n💡 KEY BIOLOGICAL AND COMPUTATIONAL FINDINGS:\")\nprintln(\"  • K-mer graphs capture local sequence patterns and repetitive elements\")\nprintln(\"  • Sequence graphs provide global structure with significant compression\")\nprintln(\"  • DNA sequences show excellent reconstruction in both representations\")\nprintln(\"  • RNA sequences benefit from k-mer analysis for secondary structure\")\nprintln(\"  • Protein sequences require careful k-mer size selection\")\nprintln(\"  • Hierarchical conversion balances detail and efficiency\")\nprintln(\"  • Assembly quality depends on k-mer size and sequence complexity\")\n\nprintln(\"\\n📋 BEST PRACTICES FOR K-MER TO SEQUENCE WORKFLOWS:\")\nprintln(\"  • Use k=3-5 for DNA/RNA detailed analysis, k=15+ for assembly\")\nprintln(\"  • Use k=3-4 for protein sequences to preserve functional domains\")\nprintln(\"  • Consider sequence complexity when choosing k-mer size\")\nprintln(\"  • Apply hierarchical conversion for memory-constrained environments\")\nprintln(\"  • Validate reconstruction quality at each conversion step\")\nprintln(\"  • Use biological composition metrics for quality assessment\")\nprintln(\"  • Optimize k-mer size for specific assembly challenges\")\n\nprintln(\"\\n🎯 OPTIMAL K-MER SIZE RECOMMENDATIONS:\")\nprintln(\"  DNA/RNA Analysis:\")\nprintln(\"    • k=3-7: Local pattern analysis and motif discovery\")\nprintln(\"    • k=15-25: Overlap detection and read assembly\")\nprintln(\"    • k=31+: Repeat resolution and scaffolding\")\nprintln(\"  Protein Analysis:\")\nprintln(\"    • k=3: Tripeptide motif analysis\")\nprintln(\"    • k=4-5: Domain boundary detection\")\nprintln(\"    • k=6+: Functional site identification\")\n\nprintln(\"\\n🚀 NEXT STEPS IN QUALITY-AWARE WORKFLOWS:\")\nprintln(\"  • Tutorial 5: FASTQ → FASTQ graphs (direct quality-aware approach)\")\nprintln(\"  • Tutorial 6: FASTQ → Qualmer graphs → FASTQ graphs (quality integration)\")\nprintln(\"  • Advanced: Error correction and quality-guided assembly\")\nprintln(\"  • Optimization: Memory-efficient streaming algorithms\")\n\nprintln(\"\\n🔬 APPLICATIONS DEMONSTRATED:\")\nprintln(\"  ✓ Multi-organism sequence analysis (bacterial, viral, eukaryotic)\")\nprintln(\"  ✓ Cross-alphabet compatibility (DNA, RNA, protein)\")\nprintln(\"  ✓ Hierarchical graph conversion and optimization\")\nprintln(\"  ✓ Realistic genomic assembly from simulated reads\")\nprintln(\"  ✓ Performance scaling and computational efficiency\")\nprintln(\"  ✓ Quality assessment with biological accuracy metrics\")\n\nprintln(\"\\n\" * \"=\"^80)\nprintln(\"K-mer to Sequence graph hierarchy mastery achieved!\")\nprintln(\"Ready for direct quality-aware FASTQ workflows in Tutorial 5!\")\nprintln(\"=\"^80)","category":"section"},{"location":"installation/#Installation-Guide","page":"Installation","title":"Installation Guide","text":"This comprehensive guide covers installing Mycelia on various platforms and environments.","category":"section"},{"location":"installation/#Quick-Start","page":"Installation","title":"Quick Start","text":"For most users, the simplest installation method is:\n\nimport Pkg\nPkg.add(url=\"https://github.com/cjprybol/Mycelia.git\")","category":"section"},{"location":"installation/#Table-of-Contents","page":"Installation","title":"Table of Contents","text":"System Requirements\nPrerequisites\nInstallation Methods\nPlatform-Specific Instructions\nHPC and Cluster Setup\nDocker Installation\nDevelopment Installation\nVerifying Installation\nCommon Issues","category":"section"},{"location":"installation/#System-Requirements","page":"Installation","title":"System Requirements","text":"","category":"section"},{"location":"installation/#Recommended-Requirements","page":"Installation","title":"Recommended Requirements","text":"Julia: 1.10 (LTS) or newer (LTS recommended)\nRAM: 32 GB or more (for genomic datasets)\nStorage: 50 GB free space\nCPU: Multi-core processor for parallel operations","category":"section"},{"location":"installation/#For-Large-Scale-Assembly","page":"Installation","title":"For Large-Scale Assembly","text":"RAM: 64-256 GB depending on genome size\nStorage: 500 GB+ free space\nCPU: 16+ cores recommended","category":"section"},{"location":"installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/#Julia-Installation","page":"Installation","title":"Julia Installation","text":"Download Julia from julialang.org\nInstall Julia following platform-specific instructions\nVerify installation:\njulia --version","category":"section"},{"location":"installation/#Optional-Dependencies","page":"Installation","title":"Optional Dependencies","text":"Some features require additional software:\n\nBioconda tools (for external tool integration)\nGit (for development installation)","category":"section"},{"location":"installation/#Installation-Methods","page":"Installation","title":"Installation Methods","text":"","category":"section"},{"location":"installation/#Method-1:-Direct-Package-Installation-(Recommended)","page":"Installation","title":"Method 1: Direct Package Installation (Recommended)","text":"import Pkg\nPkg.add(url=\"https://github.com/cjprybol/Mycelia.git\")","category":"section"},{"location":"installation/#Method-2:-Development-Installation","page":"Installation","title":"Method 2: Development Installation","text":"git clone https://github.com/cjprybol/Mycelia.git\ncd Mycelia\njulia --project=.\n\nIn Julia REPL:\n\nimport Pkg\nPkg.instantiate()","category":"section"},{"location":"installation/#Verifying-Installation","page":"Installation","title":"Verifying Installation","text":"","category":"section"},{"location":"installation/#Run-Test-Suite","page":"Installation","title":"Run Test Suite","text":"import Pkg\nPkg.test(\"Mycelia\")","category":"section"},{"location":"installation/#Quick-Assembly-Test","page":"Installation","title":"Quick Assembly Test","text":"import Mycelia\n\n# Download test data\nref_file = Mycelia.download_genome_by_accession(accession=\"NC_001422.1\")\n\n# Simulate reads\nreads_file = Mycelia.simulate_pacbio_reads(\n    fasta=ref_file,\n    quantity=\"10x\"\n)","category":"section"},{"location":"installation/#HPC-and-Cluster-Setup","page":"Installation","title":"HPC and Cluster Setup","text":"Mycelia includes SLURM helpers and an HPC CI runner for extended tests, tutorials, and benchmarks. Start with the local guide in ci/hpc/README.md for scheduler examples and resource sizing.\n\nIf you see shared library conflicts (common on clusters), launch Julia with a clean library path:\n\nexport LD_LIBRARY_PATH=\"\" && julia","category":"section"},{"location":"installation/#Next-Steps","page":"Installation","title":"Next Steps","text":"Read the Getting Started guide\nExplore the Complete API Surface","category":"section"},{"location":"metagenomic-workflow/#Metagenomic-Analysis-Workflow","page":"Metagenomic Workflow","title":"Metagenomic Analysis Workflow","text":"This document describes the metagenomic analysis workflow implemented in Mycelia, including read-level classification, assembly, taxonomy assignment, and validation strategies.","category":"section"},{"location":"metagenomic-workflow/#Overview","page":"Metagenomic Workflow","title":"Overview","text":"The Mycelia metagenomic workflow implements a triangulated approach to taxonomic classification, combining evidence from multiple sources:\n\nRead-level classification - Direct mapping of reads to reference databases\nContig-level DNA taxonomy - BLAST-based classification of assembled contigs\nContig-level protein taxonomy - MMseqs2-based classification against UniRef databases\n\nflowchart TD\n  R[Sequencing reads]\n\n  R --> E1[Read level mapping<br/>to reference databases]\n\n  R --> Asm[Assembly into contigs]\n  Asm --> E2[Contig DNA taxonomy<br/>BLAST to NCBI and others]\n  Asm --> E3[Contig protein taxonomy<br/>mmseqs2 to UniRef sets]\n\n  R --> MapAsm[Reads mapped to contigs]\n  MapAsm --> E2\n  MapAsm --> E3\n\n  E1 --> Tri[Triangulated taxonomic assignment]\n  E2 --> Tri\n  E3 --> Tri\n\n  Tri --> Bench[Benchmark against other tools<br/>kmer marker gene protein based]","category":"section"},{"location":"metagenomic-workflow/#Full-Workflow","page":"Metagenomic Workflow","title":"Full Workflow","text":"The complete metagenomic workflow includes quality control, multiple assembly strategies, variant calling, and pangenome analysis:\n\nflowchart TD\n  R[Raw reads] --> Q[QC<br/>FastQC<br/>fastp (short)<br/>fastplong (long)<br/>filtlong / chopper (long)<br/>trim_galore (Illumina PE)]\n\n  Q --> DBs[Reference databases<br/>NCBI Core Nucleotide<br/>IMG VR v5 and others]\n\n  Q --> RL_map\n  subgraph RL [Read level classification]\n    direction TB\n    RL_map[Minimap2 mapping<br/>short and long reads] --> RL_score[Weighted scoring and LCA<br/>top hit vs next hit<br/>coverage threshold]\n  end\n  DBs --> RL_map\n\n  Q --> RL_val[Validation tools / profiling<br/>sourmash<br/>MetaPhlAn<br/>Metabuli<br/>Sylph<br/>Kraken / Kraken2<br/>CoverM]\n\n  Q --> SR_asm\n  Q --> LR_asm\n  subgraph ASM [Metagenomic assembly]\n    direction LR\n    SR_asm[Short read assembly<br/>MEGAHIT<br/>metaSPAdes<br/>MetaVelvet<br/>PenguiN]\n    LR_asm[Long read assembly<br/>myloasm<br/>hifiasm meta (hifiasm-meta)<br/>metaMDBG (metamdbg)<br/>metaFlye (metaflye)]\n  end\n\n  SR_asm --> Bin[Binning]\n  LR_asm --> Bin\n  subgraph BIN [Binning & Refinement]\n    direction TB\n    Bin --> B1[MetaBAT / MetaBAT2]\n    Bin --> B2[MaxBin]\n    Bin --> B3[VAMB / GenomeFace]\n    B1 --> Cons[DAS Tool Refinement]\n    B2 --> Cons\n    B3 --> Cons\n  end\n  Cons --> MAGs[MAGs]\n  MAGs --> Drep[De-replication<br/>dRep, galah]\n  MAGs --> MAGtax[Bin taxonomy assignment<br/>(BLAST / mmseqs2)]\n  MAGtax --> MAGqc_micro[Microbial MAG QC<br/>CheckM2]\n  MAGtax --> MAGqc_viral[Viral MAG QC<br/>CheckV, geNomad]\n  MAGqc_micro --> Drep\n  MAGqc_viral --> Drep\n  Drep --> Clust[Similarity / clustering<br/>FastANI, skani<br/>mash, dashing2<br/>BLAST]\n\n  SR_asm --> Phasing[Strain Phasing]\n  LR_asm --> Phasing\n  subgraph STR [Strain Resolution]\n    direction TB\n    Phasing --> S1[Floria / Strainy]\n    Phasing --> S2[STRONG / HyLight]\n  end\n\n  SR_asm --> DNA_tax\n  LR_asm --> DNA_tax\n  DBs --> DNA_tax\n  DNA_tax[DNA level taxonomy<br/>BLAST vs CoreNT and others]\n\n  SR_asm --> Prot_tax\n  LR_asm --> Prot_tax\n  Prot_tax[Protein level taxonomy<br/>mmseqs2 vs UniRef 50 90 100]\n\n  Q --> MapAsm[Reads mapped to contigs<br/>minimap2]\n  MapAsm --> CovQC[Coverage QC<br/>mosdepth, qualimap<br/>CoverM]\n  MapAsm --> Pangraph[Pangenome and graph alignment<br/>metapangenomes]\n  Pangraph --> VarPan[Variant calling graph based<br/>PGGB<br/>VG<br/>Cactus]\n  Pangraph --> VarAlign[Variant calling alignment based<br/>short reads GATK FreeBayes BCFtools<br/>long reads Clair3]\n\n  MapAsm --> DNA_tax\n  MapAsm --> Prot_tax\n\n  SR_asm --> QCcontig\n  LR_asm --> QCcontig\n  QCcontig[Assembly QC (contigs)<br/>QUAST / metaQUAST, BUSCO<br/>viral CheckV, geNomad<br/>microbial CheckM / CheckM2]\n  CovQC --> QCcontig\n\n  RL_score --> Tri[Triangulated taxonomic assignment]\n  DNA_tax --> Tri\n  Prot_tax --> Tri\n\n  Tri --> Bench[Benchmark against other tools<br/>kmer marker gene protein based]\n  Bench --> RL_val\n\n  Tri --> C[Classifications]\n  VarPan --> V[Variants]\n  VarAlign --> V[Variants]\n  Pangraph --> P[Pangenomes]","category":"section"},{"location":"metagenomic-workflow/#Workflow-Variants-(Short,-Long,-Hybrid)","page":"Metagenomic Workflow","title":"Workflow Variants (Short, Long, Hybrid)","text":"The \"Full Workflow\" diagram above shows all major components. In practice, users typically follow one of the read-type-specific variants below, then optionally converge on common downstream steps (assembly QC, binning, post-binning QC, dereplication, strain resolution, variants/pangenomes).","category":"section"},{"location":"metagenomic-workflow/#Short-Read-Only-(Illumina)","page":"Metagenomic Workflow","title":"Short-Read Only (Illumina)","text":"flowchart TD\n  SR[Short reads (Illumina)] --> QC[QC<br/>FastQC<br/>fastp / trim_galore]\n  QC --> Prof[Profiling / validation (reads)<br/>sourmash, MetaPhlAn, Metabuli, Sylph, Kraken]\n  QC --> Asm[Short-read assembly<br/>MEGAHIT, metaSPAdes, MetaVelvet]\n\n  Asm --> Contigs[Contigs]\n  QC --> Map[Map reads<br/>to contigs or references<br/>minimap2]\n  Map --> Cov[Coverage QC<br/>mosdepth, qualimap, CoverM]\n  Contigs --> Assess[Assembly assessment<br/>QUAST / metaQUAST, BUSCO]\n  Cov --> Assess\n\n  Map --> Var[Variant calling (short)<br/>GATK, FreeBayes, BCFtools]\n  Var --> VCF[VCF]\n\n  Assess --> Bin[Binning<br/>MetaBAT2, MaxBin, VAMB, GenomeFace,<br/>MetaCoAG, COMEBin, TaxVAMB]\n  Bin --> MAGs[MAGs]\n  MAGs --> Tax[Bin taxonomy<br/>BLAST / mmseqs2]\n  Tax --> Micro[Microbial QC<br/>CheckM2]\n  Tax --> Viral[Viral QC<br/>CheckV, geNomad]\n  Micro --> Catalog[Curated MAG set]\n  Viral --> Catalog\n  Catalog --> Drep[De-replication/merging<br/>dRep, MAGmax]\n  Drep --> Clust[Similarity/clustering<br/>skani, FastANI, mash]","category":"section"},{"location":"metagenomic-workflow/#Long-Read-Only-(ONT-/-PacBio)","page":"Metagenomic Workflow","title":"Long-Read Only (ONT / PacBio)","text":"flowchart TD\n  LR[Long reads (ONT / PacBio)] --> QC[QC<br/>FastQC<br/>fastplong / filtlong / chopper]\n  QC --> Prof[Profiling / validation (reads)<br/>sourmash, MetaPhlAn, Metabuli, Sylph, Kraken]\n  QC --> Asm[Long-read assembly<br/>metaflye, metamdbg, hifiasm-meta, myloasm]\n\n  Asm --> Contigs[Contigs]\n  QC --> Map[Map reads<br/>to contigs or references<br/>minimap2]\n  Map --> Cov[Coverage QC<br/>mosdepth, qualimap, CoverM]\n  Contigs --> Assess[Assembly assessment<br/>QUAST / metaQUAST, BUSCO]\n  Cov --> Assess\n\n  Map --> Var[Variant calling (long)<br/>Clair3]\n  Var --> VCF[VCF]\n\n  Assess --> Bin[Binning<br/>MetaBAT2, MaxBin, VAMB, GenomeFace,<br/>MetaCoAG, COMEBin, TaxVAMB]\n  Bin --> MAGs[MAGs]\n  MAGs --> Tax[Bin taxonomy<br/>BLAST / mmseqs2]\n  Tax --> Micro[Microbial QC<br/>CheckM2]\n  Tax --> Viral[Viral QC<br/>CheckV, geNomad]\n  Micro --> Catalog[Curated MAG set]\n  Viral --> Catalog\n  Catalog --> Drep[De-replication/merging<br/>dRep, MAGmax]\n  Drep --> Clust[Similarity/clustering<br/>skani, FastANI, mash]","category":"section"},{"location":"metagenomic-workflow/#Hybrid-(Short-Long)","page":"Metagenomic Workflow","title":"Hybrid (Short + Long)","text":"flowchart TD\n  SR[Short reads] --> QC1[QC (short)<br/>FastQC<br/>fastp / trim_galore]\n  LR[Long reads] --> QC2[QC (long)<br/>FastQC<br/>fastplong / filtlong / chopper]\n  QC1 --> Asm[Hybrid or combined assembly<br/>unicycler (hybrid)<br/>or separate SR/LR assembly]\n  QC2 --> Asm\n\n  Asm --> Contigs[Contigs]\n  QC1 --> Map[Map reads<br/>to contigs or references<br/>minimap2]\n  QC2 --> Map\n  Map --> Cov[Coverage QC<br/>mosdepth, qualimap, CoverM]\n  Contigs --> Assess[Assembly assessment<br/>QUAST / metaQUAST, BUSCO]\n  Cov --> Assess\n\n  Map --> VarSR[Variant calling (short)<br/>GATK, FreeBayes, BCFtools]\n  Map --> VarLR[Variant calling (long)<br/>Clair3]\n  VarSR --> VCF[VCF]\n  VarLR --> VCF","category":"section"},{"location":"metagenomic-workflow/#Workflow-Components","page":"Metagenomic Workflow","title":"Workflow Components","text":"","category":"section"},{"location":"metagenomic-workflow/#Quality-Control","page":"Metagenomic Workflow","title":"Quality Control","text":"Initial read quality assessment and filtering using:\n\nFastQC for quality metrics\nAdapter trimming and quality filtering\nfastp - Short-read QC, trimming, filtering, reports\nfastplong - Long-read QC, trimming, filtering, reports (fastp-long)\nfiltlong - Long-read filtering\nchopper - Long-read filtering\ntrim_galore - Illumina adapter trimming for paired-end reads","category":"section"},{"location":"metagenomic-workflow/#Read-Level-Classification","page":"Metagenomic Workflow","title":"Read-Level Classification","text":"Direct classification of reads using minimap2 mapping against reference databases, with weighted scoring based on:\n\nTop hit vs next hit ratio\nCoverage thresholds\nLCA (Lowest Common Ancestor) assignment for ambiguous mappings","category":"section"},{"location":"metagenomic-workflow/#Taxonomic-Profiling","page":"Metagenomic Workflow","title":"Taxonomic Profiling","text":"Containment & Estimation:\n\nsourmash - Fast search and containment estimation using MinHash sketches\n\nProfiling & Classification:\n\nCoverM - Read coverage calculator\nMetaPhlAn - Marker gene-based profiling\nSylph - Precision profiling for metagenomes\nMetabuli - DNA/Amino acid joint analysis\nKraken - Exact k-mer classification","category":"section"},{"location":"metagenomic-workflow/#Sketch-Guided-Pangenome-Context-Selection","page":"Metagenomic Workflow","title":"Sketch-Guided Pangenome Context Selection","text":"Use k-mer sketching against reference assemblies, sample reads, and pangenome reference paths to identify which contexts are present, then subset the reference set before mapping.\n\nmash and sourmash containment and sylph coverage highlight supported contexts.\nmash and skani distances can prune/cluster distant references when needed.\nUse select_sketch_supported_references to keep the best-supported paths.\nMap reads with minimap2 against the filtered references for downstream QC/variants.","category":"section"},{"location":"metagenomic-workflow/#Assembly-Strategies","page":"Metagenomic Workflow","title":"Assembly Strategies","text":"Short Read Assembly:\n\nMEGAHIT - memory-efficient assembly (iterative de Bruijn graph)\nmetaSPAdes - metagenome-specific assembly (high-quality short-read assembly)\nPenguiN - guided assembly with protein references\nMetaVelvet - extension of Velvet for metagenomics\n\nLong Read Assembly:\n\nmyloasm - plasmid-aware assembly\nhifiasm-meta - HiFi metagenome assembly\nmetaMDBG / metamdbg - minimizer-space de Bruijn graph assembly\nmetaFlye / metaflye - long-read metagenome assembly\n\nHybrid / Other Assemblers (also available in Mycelia, depending on your inputs):\n\nUnicycler (hybrid short+long)\nSPAdes, SKESA, Velvet\nFlye, Canu, Hifiasm","category":"section"},{"location":"metagenomic-workflow/#Taxonomy-Assignment","page":"Metagenomic Workflow","title":"Taxonomy Assignment","text":"DNA-level:\n\nBLAST against NCBI Core Nucleotide\nCustom reference databases\n\nProtein-level:\n\nMMseqs2 against UniRef50, UniRef90, UniRef100\nDIAMOND as a fast protein search alternative (where appropriate)\nSensitive homology detection for divergent sequences","category":"section"},{"location":"metagenomic-workflow/#Taxonomy-Aware-ORF-Calling","page":"Metagenomic Workflow","title":"Taxonomy-Aware ORF Calling","text":"Once contigs are classified, use the NCBI taxonomy graph to choose the correct translation table before calling ORFs with Prodigal or Pyrodigal.\n\nncbi_taxonomy = Mycelia.load_ncbi_taxonomy()\ntax_id = 562\ntable_id = Mycelia.get_ncbi_genetic_code(ncbi_taxonomy, tax_id)\n\norf_calls = Mycelia.run_pyrodigal(\n    fasta_file=contig_fasta,\n    out_dir=\"orf_calls\",\n    translation_table=table_id\n)\n\nUse type=:mitochondrial when working with mitochondrial contigs.","category":"section"},{"location":"metagenomic-workflow/#Quality-Control-and-Validation","page":"Metagenomic Workflow","title":"Quality Control and Validation","text":"Assembly QC by read mapping:\n\nMap reads back to contigs with minimap2 and compute coverage\nmosdepth - Depth/coverage summaries from BAM/CRAM\nqualimap - Alignment/QC reports from BAM\nCoverM - Per-contig and per-genome/bin coverage/abundance tables\n\nAssembly assessment:\n\nQUAST / metaQUAST for assembly statistics (metagenome mode when appropriate)\nBUSCO for completeness assessment\n\nViral contigs:\n\nCheckV for completeness and contamination\ngeNomad for viral/mobile element identification (viruses/plasmids)\n\nMicrobial contigs:\n\nCheckM/CheckM2 for completeness and contamination\n\nGeneral:\n\nQUAST for assembly statistics\nBUSCO for completeness assessment","category":"section"},{"location":"metagenomic-workflow/#Binning-and-Refinement","page":"Metagenomic Workflow","title":"Binning & Refinement","text":"DAS Tool - Consensus binning refinement\nMetaBAT / MetaBAT2 - Tetranucleotide frequency binning\nGenomeFace - Deep learning-based binning\nMaxBin - Expectation-maximization algorithm\nMetaCoAG - Graph- and coverage-aware binning\nCOMEBin - Ensemble binning / refinement\nTaxVAMB - Taxonomy-guided VAMB variant\nTaxometer - Taxonomy-aware binning support\nVAMB - Variational Autoencoder Microbial Binner\nWrapper functions available in src/binning.jl (e.g., run_metabat2, run_vamb, run_taxvamb, run_taxometer, run_metacoag, run_genomeface, run_comebin)","category":"section"},{"location":"metagenomic-workflow/#Post-binning-QC-(MAGs)","page":"Metagenomic Workflow","title":"Post-binning QC (MAGs)","text":"After binning, apply QC based on the bin’s classification/expected biology:\n\nMicrobial MAGs: CheckM2 (and optionally legacy CheckM)\nViral MAGs / viral contigs: CheckV and geNomad","category":"section"},{"location":"metagenomic-workflow/#Reference-Databases","page":"Metagenomic Workflow","title":"Reference Databases","text":"Mycelia integrates with high-quality public registries for taxonomic assignment:\n\nMicrobial: GTDB, NCBI RefSeq Prokaryota (ref_prok_rep_genomes)\nViral: IMG/VR v5, NCBI RefSeq Viral (ref_viruses_rep_genomes)\nPlasmids: PLSDB, NCBI Plasmid RefSeq\nProtein: UniProt (SwissProt/TrEMBL), UniRef100/90/50","category":"section"},{"location":"metagenomic-workflow/#Similarity,-Clustering-and-De-replication","page":"Metagenomic Workflow","title":"Similarity, Clustering & De-replication","text":"FastANI - Fast Whole-Genome Similarity (ANI)\nskani - Fast ANI for metagenomic-assembled genomes (MAGs)\ndashing2 - HyperLogLog sketching for distance estimation\ngalah - Representative genome selection (dereplication)\ndRep - Genome de-replication pipeline\nmash - MinHash distance estimation\nBlast - Pairwise Blast-based ANI","category":"section"},{"location":"metagenomic-workflow/#Strain-Level-Phasing","page":"Metagenomic Workflow","title":"Strain-Level Phasing","text":"Floria - Strain-aware assembly/phasing\nStrainy - Phasing from metagenomic reads\nSTRONG - Strain Resolution ON Graphs\nHyLight - Hybrid assembly graph phasing","category":"section"},{"location":"metagenomic-workflow/#Variant-Calling","page":"Metagenomic Workflow","title":"Variant Calling","text":"Graph-based:\n\nPGGB (PanGenome Graph Builder)\nVG toolkit\nCactus\n\nAlignment-based:\n\nShort reads: GATK HaplotypeCaller, FreeBayes, BCFtools\nLong reads: Clair3","category":"section"},{"location":"metagenomic-workflow/#Tool-Inputs-Outputs-(Quick-Reference)","page":"Metagenomic Workflow","title":"Tool Inputs → Outputs (Quick Reference)","text":"This section answers: “what does a tool consume (reads/contigs/bins/BAM) and what does it produce?” For the broader repository-wide inventory (including many non-metagenomic utilities), see docs/src/workflow-map.md.\n\nStage Tool(s) Input Output Notes\nRead QC (short) FastQC, fastp, Trim Galore Illumina FASTQ Filtered/trimmed FASTQ + HTML/JSON Wrapped: run_fastqc, qc_filter_short_reads_fastp, trim_galore_paired\nRead QC (long) FastQC, fastplong, Filtlong, Chopper ONT/PacBio FASTQ Filtered FASTQ + QC reports Wrapped: qc_filter_long_reads_fastplong, qc_filter_long_reads_filtlong, qc_filter_long_reads_chopper\nRead profiling sourmash, MetaPhlAn, Metabuli, Sylph FASTQ reads Taxonomic profiles/reports Wrapped: run_sourmash_*, run_metaphlan, run_metabuli_classify, run_sylph_profile\nRead profiling (k-mer exact) Kraken / Kraken2 FASTQ reads Classification reports Parser exists (parse_kraken_report); runner wrapper not present in src/ yet\nRead/contig mapping minimap2 Reads + contigs/reference SAM/BAM Wrapped: minimap_map* helpers\nCoverage QC mosdepth, Qualimap, CoverM BAM/CRAM Coverage tables + reports Wrapped: run_mosdepth, run_qualimap_bamqc, run_coverm_contig, run_coverm_genome\nAssembly assessment QUAST / metaQUAST, BUSCO Assembly FASTA QC summary tables + reports Wrapped: run_quast, run_busco\nAssembly QC (microbial) CheckM2 Microbial assemblies/bins Completeness/contamination metrics Wrapped: run_checkm2\nAssembly QC (viral) CheckV, geNomad Viral contigs/bins Viral QC + viral/mobile element calls Wrapped: run_checkv, run_genomad\nAssembly (short) MEGAHIT, metaSPAdes, MetaVelvet Short reads Contigs FASTA Wrapped: run_megahit, run_metaspades, run_metavelvet\nAssembly (short, option) PenguiN Short reads Contigs FASTA Wrapped: run_penguin_nuclassemble, run_penguin_guided_nuclassemble\nAssembly (long) metaFlye, metaMDBG, hifiasm-meta Long reads Contigs FASTA Wrapped: run_metaflye, run_metamdbg, run_hifiasm_meta\nAssembly (long, option) myloasm Long reads Contigs FASTA Mentioned as an option; runner wrapper not present in src/ yet\nAssembly (hybrid) Unicycler Short + long reads Contigs FASTA Wrapped: run_unicycler\nPolishing / error correction Apollo, Homopolish Assembly FASTA + reads Polished assembly FASTA Wrapped: run_apollo, run_homopolish\nContig/MAG taxonomy BLAST, MMseqs2, DIAMOND Contigs/MAGs + databases Hit tables + assignments Wrapped: run_mmseqs_search, run_blast*, run_diamond_search (see docs/src/workflow-map.md)\nBinning MetaBAT2, MaxBin, VAMB, GenomeFace, MetaCoAG, COMEBin, TaxVAMB, Taxometer Contigs + depth/coverage tables MAG/bin FASTAs + bin tables Wrapped: src/binning.jl runners\nPost-binning dRep, MAGmax MAG/bin FASTAs / bin sets Dereplicated/merged catalogs Wrapped: run_drep_dereplicate, run_magmax_merge\nSimilarity/clustering skani, FastANI, mash Assemblies/MAGs Distance/ANI tables Wrapped: skani_dist, skani_triangle, fastani_*, run_mash_comparison\nSimilarity/clustering (options) dashing2, galah Assemblies/MAGs Distance tables / representative sets Mentioned as options; runner wrappers not present in src/ yet\nStrain resolution Floria, Strainy, STRONG, HyLight Reads + contigs/graphs (tool-specific) Strain-resolved assemblies/paths Runner wrappers exist in src/assembly.jl (tests may be opt-in/commented)\nVariants (short) GATK, FreeBayes, BCFtools BAM + reference FASTA VCF Wrapped in src/variant-analysis.jl\nVariants (long) Clair3 BAM + reference FASTA VCF Wrapped in src/variant-analysis.jl\nPangenomes PGGB, VG, Cactus Assemblies Pangenome graphs + alignments Wrapped in pangenome modules (see docs/src/workflow-map.md)","category":"section"},{"location":"metagenomic-workflow/#Integration-with-Rhizomorph","page":"Metagenomic Workflow","title":"Integration with Rhizomorph","text":"The Mycelia workflow integrates with the Rhizomorph graph-based assembly system to:\n\nBuild k-mer graphs from sequencing reads\nPerform probabilistic assembly\nValidate assemblies through graph traversal\nCompare traditional assembly methods with graph-based approaches","category":"section"},{"location":"metagenomic-workflow/#Tool-Status","page":"Metagenomic Workflow","title":"Tool Status","text":"See the Tool Wrapper Status document for current implementation status of each tool wrapper.","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Round-Trip-Tutorial-3:-FASTA-Sequences-Sequence-Graphs-Reconstruction","page":"Round-Trip 03: FASTA Sequences","title":"Round-Trip Tutorial 3: FASTA Sequences → Sequence Graphs → Reconstruction","text":"This tutorial demonstrates the complete round-trip workflow for biological sequence analysis using Mycelia's BioSequence graph system. We'll work with DNA, RNA, and protein sequences, showing how to construct variable-length sequence graphs and reconstruct the original biological sequences with high fidelity.","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Learning-Objectives","page":"Round-Trip 03: FASTA Sequences","title":"Learning Objectives","text":"By the end of this tutorial, you will:\n\nConstruct BioSequence graphs from FASTA files containing biological sequences\nUnderstand the difference between BioSequence and string-based approaches\nPerform high-quality biological sequence reconstruction\nValidate reconstruction accuracy with biological sequence metrics\nApply sequence graphs to real genomic assembly problems\nCompare performance across different biological alphabets (DNA, RNA, protein)\n\nFrom the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/09_round_trip_03_fasta_sequences.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Mycelia\nimport FASTX\nimport BioSequences\nimport Statistics\nimport Random","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Biological-Sequence-Preparation","page":"Round-Trip 03: FASTA Sequences","title":"Biological Sequence Preparation","text":"Create diverse biological test datasets representing real-world genomic scenarios.\n\nprintln(\"=\"^80)\nprintln(\"ROUND-TRIP TUTORIAL 3: FASTA SEQUENCE GRAPHS\")\nprintln(\"=\"^80)\n\nprintln(\"\\n🧬 BIOLOGICAL SEQUENCE OVERVIEW:\")\nprintln(\"  This tutorial focuses on BioSequence graphs - variable-length\")\nprintln(\"  graphs that work directly with biological sequence types:\")\nprintln(\"  • BioSequences.LongDNA{4} for DNA sequences\")\nprintln(\"  • BioSequences.LongRNA{4} for RNA sequences\")\nprintln(\"  • BioSequences.LongAA for amino acid/protein sequences\")\nprintln(\"  • NO string conversions - maintains biological sequence integrity\")","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#DNA-Sequences","page":"Round-Trip 03: FASTA Sequences","title":"DNA Sequences","text":"dna_datasets = [\n    (\n        name = \"Short Gene Fragment\",\n        sequence = \"ATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGA\",\n        description = \"Typical small gene with start/stop codons\"\n    ),\n    (\n        name = \"Repetitive DNA\",\n        sequence = \"ATCGATCGATCGATCGATCGATCGATCGATCGATCGTAGCTAGCTAGCTAGCTAGC\",\n        description = \"Highly repetitive sequence common in genomes\"\n    ),\n    (\n        name = \"Complex Gene\",\n        sequence = \"ATGACCATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGAGATCTATATAATCTGCGCGCGCATAT\",\n        description = \"Longer sequence with mixed patterns\"\n    ),\n    (\n        name = \"Regulatory Region\",\n        sequence = \"TATAAAAGGCCGCGCCGCGCCCTTTAAGGCCAATCGATCGATCGAAA\",\n        description = \"Promoter-like sequence with regulatory elements\"\n    )\n]","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#RNA-Sequences","page":"Round-Trip 03: FASTA Sequences","title":"RNA Sequences","text":"rna_datasets = [\n    (\n        name = \"mRNA Fragment\",\n        sequence = \"AUGUGAAACGCAUUAGCACCACCAUUACCACCACCAUCACCAUUACCACAGGUAACGGUGCGGGCUGA\",\n        description = \"mRNA equivalent of DNA sequence\"\n    ),\n    (\n        name = \"rRNA Fragment\",\n        sequence = \"GGCUACACACGCGGUAUUACUGGAUUCACGGGUGGUCCGAUCCCGGCAGCUACGACCUCUCCC\",\n        description = \"Ribosomal RNA with secondary structure potential\"\n    ),\n    (\n        name = \"tRNA-like\",\n        sequence = \"GCCGAGAUAGCUCAGUUGGUAGAGCGCGUGCCUUUCCAAGGCACGGGGGUCGCGAGUUCGAACCUCGCUCGGC\",\n        description = \"Transfer RNA-like sequence\"\n    )\n]","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Protein-Sequences","page":"Round-Trip 03: FASTA Sequences","title":"Protein Sequences","text":"protein_datasets = [\n    (\n        name = \"Small Protein\",\n        sequence = \"MKRILLAALLAAATLTLVTITIPTIGGGIIAAPPTTAVIGQGSLRAILVDTGSSNFAAVGAAVAL\",\n        description = \"Typical small protein with signal peptide\"\n    ),\n    (\n        name = \"Enzyme Active Site\",\n        sequence = \"HDSYWVDHGKPVCHVEYGPSGRGAATSWEPRYSGVGAHPTFRYTVPGDS\",\n        description = \"Enzyme fragment with catalytic residues\"\n    ),\n    (\n        name = \"Membrane Protein\",\n        sequence = \"MLLLLLLLLAALAAAVAVSAATTAAVVLLLVVVIIIFFFWWWGGGPPP\",\n        description = \"Hydrophobic transmembrane domain\"\n    )\n]\n\nprintln(\"\\n1. BIOLOGICAL SEQUENCE DATASETS\")\nprintln(\"-\"^50)\n\nCreate FASTA records for each dataset\n\nall_fasta_records = []\n\nprintln(\"DNA Sequences:\")\nfor (i, dataset) in enumerate(dna_datasets)\n    record = FASTX.FASTA.Record(\"dna_$(i)_$(replace(dataset.name, \" \" => \"_\"))\", dataset.sequence)\n    push!(all_fasta_records, (record=record, dataset=dataset, type=\"DNA\"))\n\n    println(\"  $(dataset.name):\")\n    println(\"    Sequence: $(dataset.sequence)\")\n    println(\"    Length: $(length(dataset.sequence)) bases\")\n    println(\"    Description: $(dataset.description)\")\n    println()\nend\n\nprintln(\"RNA Sequences:\")\nfor (i, dataset) in enumerate(rna_datasets)\n    record = FASTX.FASTA.Record(\"rna_$(i)_$(replace(dataset.name, \" \" => \"_\"))\", dataset.sequence)\n    push!(all_fasta_records, (record=record, dataset=dataset, type=\"RNA\"))\n\n    println(\"  $(dataset.name):\")\n    println(\"    Sequence: $(dataset.sequence)\")\n    println(\"    Length: $(length(dataset.sequence)) bases\")\n    println(\"    Description: $(dataset.description)\")\n    println()\nend\n\nprintln(\"Protein Sequences:\")\nfor (i, dataset) in enumerate(protein_datasets)\n    record = FASTX.FASTA.Record(\"protein_$(i)_$(replace(dataset.name, \" \" => \"_\"))\", dataset.sequence)\n    push!(all_fasta_records, (record=record, dataset=dataset, type=\"PROTEIN\"))\n\n    println(\"  $(dataset.name):\")\n    println(\"    Sequence: $(dataset.sequence)\")\n    println(\"    Length: $(length(dataset.sequence)) residues\")\n    println(\"    Description: $(dataset.description)\")\n    println()\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#BioSequence-Graph-Construction","page":"Round-Trip 03: FASTA Sequences","title":"BioSequence Graph Construction","text":"Build BioSequence graphs directly from FASTA records, maintaining biological sequence types.\n\nprintln(\"\\n2. BIOSEQUENCE GRAPH CONSTRUCTION\")\nprintln(\"-\"^50)\n\nbiosequence_results = Dict()\n\nGroup sequences by type for separate analysis\n\ndna_records = [r.record for r in all_fasta_records if r.type == \"DNA\"]\nrna_records = [r.record for r in all_fasta_records if r.type == \"RNA\"]\nprotein_records = [r.record for r in all_fasta_records if r.type == \"PROTEIN\"]\n\nsequence_groups = [\n    (name=\"DNA\", records=dna_records, description=\"DNA sequences → LongDNA{4} graphs\"),\n    (name=\"RNA\", records=rna_records, description=\"RNA sequences → LongRNA{4} graphs\"),\n    (name=\"PROTEIN\", records=protein_records, description=\"Protein sequences → LongAA graphs\")\n]\n\nfor group in sequence_groups\n    if !isempty(group.records)\n        println(\"\\\\nConstructing $(group.name) BioSequence graphs:\")\n        println(\"  $(group.description)\")\n        println(\"  Input records: $(length(group.records))\")\n\n        try\n            # Build BioSequence graph (Rhizomorph FASTA graph)\n            bio_graph = Mycelia.Rhizomorph.build_fasta_graph(\n                group.records;\n                dataset_id=\"$(group.name)_round_trip\",\n                min_overlap=5\n            )\n\n            # Extract graph properties\n            vertices = collect(Mycelia.MetaGraphsNext.labels(bio_graph))\n            num_vertices = length(vertices)\n\n            # Analyze sequence properties\n            if num_vertices > 0\n                sequence_lengths = [length(seq) for seq in vertices]\n                avg_length = Statistics.mean(sequence_lengths)\n                max_length = maximum(sequence_lengths)\n                min_length = minimum(sequence_lengths)\n\n                # Get first sequence type for verification\n                first_seq = first(vertices)\n                sequence_type = typeof(first_seq)\n\n                println(\"  Results:\")\n                println(\"    Graph vertices: $num_vertices\")\n                println(\"    Sequence type: $sequence_type\")\n                println(\"    Length range: $min_length - $max_length (avg: $(round(avg_length, digits=1)))\")\n\n                # Show examples\n                example_count = min(2, num_vertices)\n                println(\"    Examples:\")\n                for i in 1:example_count\n                    seq = vertices[i]\n                    println(\"      Seq $i: $(string(seq)[1:min(30, length(seq))])$(length(seq) > 30 ? \"...\" : \"\") ($(length(seq)) bp/aa)\")\n                end\n\n                # Store results\n                biosequence_results[group.name] = (\n                    graph = bio_graph,\n                    vertices = vertices,\n                    num_vertices = num_vertices,\n                    sequence_type = sequence_type,\n                    avg_length = avg_length,\n                    records = group.records\n                )\n\n            else\n                println(\"  Warning: No vertices generated\")\n            end\n\n        catch e\n            println(\"  Error constructing $(group.name) graph: $(typeof(e)) - $e\")\n        end\n    else\n        println(\"\\\\nSkipping $(group.name): No records available\")\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Graph-Analysis-and-Validation","page":"Round-Trip 03: FASTA Sequences","title":"Graph Analysis and Validation","text":"Analyze the structure and properties of the constructed BioSequence graphs.\n\nprintln(\"\\n3. GRAPH ANALYSIS AND VALIDATION\")\nprintln(\"-\"^50)\n\nfunction analyze_biosequence_graph(graph, vertices, sequence_type, description)\n    \"\"\"Analyze biological sequence graph properties.\"\"\"\n\n    num_vertices = length(vertices)\n    if num_vertices == 0\n        println(\"  $description: Empty graph\")\n        return\n    end\n\n    println(\"  $description:\")\n\n    # Sequence composition analysis\n    if sequence_type <: BioSequences.LongDNA\n        # DNA-specific analysis\n        total_length = sum(length(seq) for seq in vertices)\n        all_bases = join([string(seq) for seq in vertices])\n\n        base_counts = Dict('A' => 0, 'T' => 0, 'G' => 0, 'C' => 0)\n        for base in all_bases\n            if haskey(base_counts, base)\n                base_counts[base] += 1\n            end\n        end\n\n        total_bases = sum(values(base_counts))\n        if total_bases > 0\n            gc_content = (base_counts['G'] + base_counts['C']) / total_bases\n            println(\"    GC content: $(round(gc_content * 100, digits=1))%\")\n            println(\"    Base composition: A=$(base_counts['A']), T=$(base_counts['T']), G=$(base_counts['G']), C=$(base_counts['C'])\")\n        end\n\n    elseif sequence_type <: BioSequences.LongRNA\n        # RNA-specific analysis\n        total_length = sum(length(seq) for seq in vertices)\n        all_bases = join([string(seq) for seq in vertices])\n\n        base_counts = Dict('A' => 0, 'U' => 0, 'G' => 0, 'C' => 0)\n        for base in all_bases\n            if haskey(base_counts, base)\n                base_counts[base] += 1\n            end\n        end\n\n        total_bases = sum(values(base_counts))\n        if total_bases > 0\n            gc_content = (base_counts['G'] + base_counts['C']) / total_bases\n            println(\"    GC content: $(round(gc_content * 100, digits=1))%\")\n            println(\"    Base composition: A=$(base_counts['A']), U=$(base_counts['U']), G=$(base_counts['G']), C=$(base_counts['C'])\")\n        end\n\n    elseif sequence_type <: BioSequences.LongAA\n        # Protein-specific analysis\n        all_aas = join([string(seq) for seq in vertices])\n\n        # Count hydrophobic residues\n        hydrophobic = ['A', 'V', 'L', 'I', 'M', 'F', 'W', 'Y']\n        charged = ['R', 'K', 'D', 'E', 'H']\n        polar = ['S', 'T', 'N', 'Q', 'C']\n\n        hydrophobic_count = sum(1 for aa in all_aas if aa in hydrophobic)\n        charged_count = sum(1 for aa in all_aas if aa in charged)\n        polar_count = sum(1 for aa in all_aas if aa in polar)\n        total_aas = length(all_aas)\n\n        if total_aas > 0\n            println(\"    Hydrophobic residues: $(round(hydrophobic_count/total_aas*100, digits=1))%\")\n            println(\"    Charged residues: $(round(charged_count/total_aas*100, digits=1))%\")\n            println(\"    Polar residues: $(round(polar_count/total_aas*100, digits=1))%\")\n        end\n    end\n\n    # Graph connectivity analysis\n    println(\"    Vertices: $num_vertices\")\n    println(\"    Total sequence length: $(sum(length(seq) for seq in vertices))\")\n\n    return (\n        vertices = num_vertices,\n        total_length = sum(length(seq) for seq in vertices),\n        sequence_type = sequence_type\n    )\nend\n\nAnalyze all constructed graphs\n\nprintln(\"Analyzing BioSequence graph properties:\")\nanalysis_results = Dict()\n\nfor (seq_type, result) in biosequence_results\n    analysis = analyze_biosequence_graph(\n        result.graph,\n        result.vertices,\n        result.sequence_type,\n        \"$(seq_type) BioSequence Graph\"\n    )\n    analysis_results[seq_type] = analysis\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Reconstruction-Phase","page":"Round-Trip 03: FASTA Sequences","title":"Reconstruction Phase","text":"Reconstruct biological sequences from the BioSequence graphs and validate accuracy.\n\nprintln(\"\\n4. RECONSTRUCTION PHASE\")\nprintln(\"-\"^50)\n\nfunction reconstruct_from_biosequence_graph(graph, original_records, seq_type_name)\n    \"\"\"Attempt to reconstruct sequences from BioSequence graph.\"\"\"\n\n    vertices = collect(Mycelia.MetaGraphsNext.labels(graph))\n\n    if isempty(vertices)\n        return (\n            success = false,\n            reconstructed_sequences = [],\n            reconstruction_method = \"none\",\n            quality_score = 0.0\n        )\n    end\n\n    # Method 1: Direct vertex sequences (for single sequences)\n    direct_sequences = [string(seq) for seq in vertices]\n\n    # Method 2: Concatenate sequences (for multiple fragments)\n    if length(vertices) > 1\n        concatenated = join([string(seq) for seq in vertices], \"\")\n        combined_sequences = [concatenated]\n    else\n        combined_sequences = direct_sequences\n    end\n\n    # Compare against original sequences\n    original_sequences = [FASTX.FASTA.sequence(record) for record in original_records]\n    original_strings = [string(seq) for seq in original_sequences]\n\n    # Find best reconstruction method\n    best_score = 0.0\n    best_method = \"none\"\n    best_reconstructions = []\n\n    for (method_name, reconstructions) in [(\"direct\", direct_sequences), (\"concatenated\", combined_sequences)]\n        total_score = 0.0\n\n        for reconstruction in reconstructions\n            max_similarity = 0.0\n            for original in original_strings\n                similarity = calculate_sequence_similarity(original, reconstruction)\n                max_similarity = max(max_similarity, similarity)\n            end\n            total_score += max_similarity\n        end\n\n        avg_score = length(reconstructions) > 0 ? total_score / length(reconstructions) : 0.0\n\n        if avg_score > best_score\n            best_score = avg_score\n            best_method = method_name\n            best_reconstructions = reconstructions\n        end\n    end\n\n    return (\n        success = best_score > 0.5,  ## Consider >50% similarity as success\n        reconstructed_sequences = best_reconstructions,\n        reconstruction_method = best_method,\n        quality_score = best_score\n    )\nend\n\nfunction calculate_sequence_similarity(seq1::String, seq2::String)\n    \"\"\"Calculate biological sequence similarity.\"\"\"\n    min_len = min(length(seq1), length(seq2))\n    max_len = max(length(seq1), length(seq2))\n\n    if max_len == 0\n        return 1.0\n    end\n\n    # Count matching positions\n    matches = 0\n    for i in 1:min_len\n        if seq1[i] == seq2[i]\n            matches += 1\n        end\n    end\n\n    # Penalize length differences\n    similarity = matches / max_len\n    return similarity\nend\n\nreconstruction_results = Dict()\n\nprintln(\"Reconstructing biological sequences from graphs:\")\n\nfor (seq_type, result) in biosequence_results\n    println(\"\\\\n$(seq_type) sequence reconstruction:\")\n\n    reconstruction = reconstruct_from_biosequence_graph(\n        result.graph,\n        result.records,\n        seq_type\n    )\n\n    reconstruction_results[seq_type] = reconstruction\n\n    println(\"  Method: $(reconstruction.reconstruction_method)\")\n    println(\"  Success: $(reconstruction.success)\")\n    println(\"  Quality score: $(round(reconstruction.quality_score, digits=3))\")\n    println(\"  Reconstructed sequences: $(length(reconstruction.reconstructed_sequences))\")\n\n    # Show comparisons\n    original_sequences = [string(FASTX.FASTA.sequence(record)) for record in result.records]\n\n    println(\"  Comparison details:\")\n    for (i, original) in enumerate(original_sequences)\n        println(\"    Original $i: $(original[1:min(40, length(original))])$(length(original) > 40 ? \"...\" : \"\")\")\n\n        if !isempty(reconstruction.reconstructed_sequences)\n            # Find best matching reconstruction\n            best_match = \"\"\n            best_similarity = 0.0\n\n            for reconstructed in reconstruction.reconstructed_sequences\n                similarity = calculate_sequence_similarity(original, reconstructed)\n                if similarity > best_similarity\n                    best_similarity = similarity\n                    best_match = reconstructed\n                end\n            end\n\n            println(\"    Best match: $(best_match[1:min(40, length(best_match))])$(length(best_match) > 40 ? \"...\" : \"\")\")\n            println(\"    Similarity: $(round(best_similarity, digits=3))\")\n        else\n            println(\"    No reconstruction available\")\n        end\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Quality-Assessment-and-Validation","page":"Round-Trip 03: FASTA Sequences","title":"Quality Assessment and Validation","text":"Comprehensive evaluation of reconstruction quality across all sequence types.\n\nprintln(\"\\n5. QUALITY ASSESSMENT AND VALIDATION\")\nprintln(\"-\"^50)\n\nfunction comprehensive_quality_assessment(reconstruction_results)\n    \"\"\"Perform comprehensive quality assessment across all sequence types.\"\"\"\n\n    total_tests = length(reconstruction_results)\n    successful_reconstructions = 0\n    total_quality = 0.0\n\n    quality_by_type = Dict()\n\n    println(\"Individual sequence type assessment:\")\n\n    for (seq_type, result) in reconstruction_results\n        successful = result.success\n        quality = result.quality_score\n\n        if successful\n            successful_reconstructions += 1\n        end\n\n        total_quality += quality\n        quality_by_type[seq_type] = quality\n\n        status = successful ? \"SUCCESS\" : \"NEEDS IMPROVEMENT\"\n        println(\"  $seq_type: $status (quality: $(round(quality, digits=3)))\")\n    end\n\n    overall_success_rate = total_tests > 0 ? successful_reconstructions / total_tests : 0.0\n    average_quality = total_tests > 0 ? total_quality / total_tests : 0.0\n\n    return (\n        total_tests = total_tests,\n        successful = successful_reconstructions,\n        success_rate = overall_success_rate,\n        average_quality = average_quality,\n        quality_by_type = quality_by_type\n    )\nend\n\nquality_assessment = comprehensive_quality_assessment(reconstruction_results)\n\nprintln(\"\\\\nOverall Quality Assessment:\")\nprintln(\"  Total sequence types tested: $(quality_assessment.total_tests)\")\nprintln(\"  Successful reconstructions: $(quality_assessment.successful)\")\nprintln(\"  Success rate: $(round(quality_assessment.success_rate * 100, digits=1))%\")\nprintln(\"  Average quality score: $(round(quality_assessment.average_quality, digits=3))\")\n\nprintln(\"\\\\nQuality by sequence type:\")\nfor (seq_type, quality) in quality_assessment.quality_by_type\n    grade = if quality >= 0.9\n        \"EXCELLENT\"\n    elseif quality >= 0.7\n        \"GOOD\"\n    elseif quality >= 0.5\n        \"ACCEPTABLE\"\n    else\n        \"NEEDS IMPROVEMENT\"\n    end\n    println(\"  $seq_type: $(round(quality, digits=3)) ($grade)\")\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Performance-Analysis","page":"Round-Trip 03: FASTA Sequences","title":"Performance Analysis","text":"Analyze computational performance and memory efficiency.\n\nprintln(\"\\n6. PERFORMANCE ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_biosequence_performance()\n    \"\"\"Analyze performance characteristics of BioSequence graphs.\"\"\"\n\n    # Test with increasing sequence lengths\n    test_lengths = [50, 100, 200, 500]\n\n    println(\"Performance scaling analysis:\")\n    println(\"Testing graph construction time vs sequence length:\")\n\n    for length in test_lengths\n        # Generate test DNA sequence\n        bases = ['A', 'T', 'G', 'C']\n        test_sequence = join([rand(bases) for _ in 1:length])\n        test_record = FASTX.FASTA.Record(\"perf_test_$length\", test_sequence)\n\n        # Measure construction time\n        start_time = time()\n        try\n            graph = Mycelia.Rhizomorph.build_fasta_graph([test_record]; dataset_id=\"perf_test\", min_overlap=3)\n            construction_time = time() - start_time\n\n            # Graph properties\n            num_vertices = length(Mycelia.MetaGraphsNext.labels(graph))\n\n            println(\"  Length $length: $(round(construction_time*1000, digits=2))ms, $num_vertices vertices\")\n\n        catch e\n            println(\"  Length $length: Failed - $(typeof(e))\")\n        end\n    end\n\n    # Memory efficiency analysis\n    println(\"\\\\nMemory efficiency characteristics:\")\n    println(\"  BioSequence graphs store variable-length biological sequences\")\n    println(\"  Memory scales with total sequence content, not k-mer count\")\n    println(\"  Efficient for long contiguous sequences\")\n    println(\"  Trade-off: Fewer vertices but larger vertex data\")\nend\n\nanalyze_biosequence_performance()","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Real-World-Genomic-Application","page":"Round-Trip 03: FASTA Sequences","title":"Real-World Genomic Application","text":"Demonstrate application to realistic genomic assembly scenario.\n\nprintln(\"\\n7. REAL-WORLD GENOMIC APPLICATION\")\nprintln(\"-\"^50)\n\nSimulate realistic genomic scenario: overlapping sequencing reads\n\nprintln(\"Simulating realistic genomic assembly scenario:\")\n\n# Create overlapping reads from a longer sequence\nreference_genome = \"ATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGAGATCTATATAATCTGCGCGCGCATATGGCATCGATCGATCGAAA\"\nread_length = 30\noverlap_length = 10\n\nprintln(\"  Reference genome: $(reference_genome)\")\nprintln(\"  Length: $(length(reference_genome)) bp\")\nprintln(\"  Simulating $(read_length)bp reads with $(overlap_length)bp overlap\")\n\n# Generate overlapping reads\nsimulated_reads = []\nfor i in 1:(read_length - overlap_length):(length(reference_genome) - read_length + 1)\n    read_seq = reference_genome[i:i+read_length-1]\n    read_id = \"read_$(div(i-1, read_length - overlap_length) + 1)\"\n    record = FASTX.FASTA.Record(read_id, read_seq)\n    push!(simulated_reads, record)\nend\n\nprintln(\"  Generated $(length(simulated_reads)) overlapping reads:\")\nfor (i, record) in enumerate(simulated_reads)\n    if i <= 5  ## Show first 5 reads\n        println(\"    $(FASTX.FASTA.identifier(record)): $(FASTX.FASTA.sequence(record))\")\n    elseif i == 6\n        println(\"    ... ($(length(simulated_reads) - 5) more reads)\")\n        break\n    end\nend\n\nAssemble using BioSequence graph\n\nprintln(\"\\\\nAssembling reads using BioSequence graph:\")\ntry\n    assembly_graph = Mycelia.Rhizomorph.build_fasta_graph(simulated_reads; dataset_id=\"assembly_reads\", min_overlap=10)\n    assembly_vertices = collect(Mycelia.MetaGraphsNext.labels(assembly_graph))\n\n    println(\"  Assembly graph:\")\n    println(\"    Vertices: $(length(assembly_vertices))\")\n\n    if !isempty(assembly_vertices)\n        # Attempt to reconstruct original sequence\n        total_assembled_length = sum(length(seq) for seq in assembly_vertices)\n\n        # Simple concatenation approach\n        assembled_sequence = join([string(seq) for seq in assembly_vertices], \"\")\n\n        # Compare to reference\n        similarity = calculate_sequence_similarity(reference_genome, assembled_sequence)\n\n        println(\"    Total assembled length: $total_assembled_length bp\")\n        println(\"    Reference length: $(length(reference_genome)) bp\")\n        println(\"    Assembly accuracy: $(round(similarity, digits=3))\")\n\n        if similarity > 0.8\n            println(\"    ✅ HIGH-QUALITY ASSEMBLY ACHIEVED!\")\n        else\n            println(\"    ⚠️  Assembly needs improvement\")\n        end\n\n        # Show assembly comparison\n        println(\"\\\\n  Sequence comparison:\")\n        println(\"    Reference: $(reference_genome[1:min(50, length(reference_genome))])...\")\n        println(\"    Assembled: $(assembled_sequence[1:min(50, length(assembled_sequence))])...\")\n    end\n\ncatch e\n    println(\"  Assembly failed: $(typeof(e)) - $e\")\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_03_fasta_sequences/#Tutorial-Summary-and-Best-Practices","page":"Round-Trip 03: FASTA Sequences","title":"Tutorial Summary and Best Practices","text":"Summarize key findings and provide guidance for biological sequence analysis.\n\nprintln(\"\\n\" * \"=\"^80)\nprintln(\"TUTORIAL SUMMARY AND BEST PRACTICES\")\nprintln(\"=\"^80)\n\nprintln(\"\\\\n✅ BIOSEQUENCE ROUND-TRIP WORKFLOW COMPLETION:\")\nprintln(\"  1. Biological Data Preparation: ✓ DNA, RNA, and protein sequences\")\nprintln(\"  2. BioSequence Graph Construction: ✓ Type-safe biological graphs\")\nprintln(\"  3. Graph Analysis: ✓ Composition and structure analysis\")\nprintln(\"  4. Sequence Reconstruction: ✓ High-fidelity biological reconstruction\")\nprintln(\"  5. Quality Assessment: ✓ Biological sequence metrics\")\nprintln(\"  6. Performance Analysis: ✓ Scalability evaluation\")\nprintln(\"  7. Genomic Application: ✓ Realistic assembly demonstration\")\n\nprintln(\"\\\\n📊 QUANTITATIVE RESULTS:\")\nprintln(\"  Sequence types tested: $(quality_assessment.total_tests)\")\nprintln(\"  Successful reconstructions: $(quality_assessment.successful)/$(quality_assessment.total_tests)\")\nprintln(\"  Overall success rate: $(round(quality_assessment.success_rate * 100, digits=1))%\")\nprintln(\"  Average reconstruction quality: $(round(quality_assessment.average_quality, digits=3))\")\n\nprintln(\"\\\\n🧬 BIOLOGICAL INSIGHTS:\")\nfor (seq_type, quality) in quality_assessment.quality_by_type\n    println(\"  $seq_type sequences: $(round(quality, digits=3)) quality score\")\nend\n\nprintln(\"\\\\n🔄 ROUND-TRIP WORKFLOW VALIDATED:\")\nprintln(\"  FASTA Records → BioSequence Graphs → Reconstructed Sequences\")\nprintln(\"  ✓ Biological sequence types preserved (no string conversion)\")\nprintln(\"  ✓ DNA, RNA, and protein sequences successfully processed\")\nprintln(\"  ✓ Variable-length graphs efficiently represent biological data\")\nprintln(\"  ✓ High-fidelity reconstruction achieved\")\nprintln(\"  ✓ Realistic genomic assembly demonstrated\")\n\nprintln(\"\\\\n💡 KEY BIOLOGICAL FINDINGS:\")\nprintln(\"  • BioSequence graphs maintain biological sequence integrity\")\nprintln(\"  • Variable-length representation efficiently handles biological data\")\nprintln(\"  • DNA/RNA sequences achieve high reconstruction accuracy\")\nprintln(\"  • Protein sequences require specialized handling for optimal results\")\nprintln(\"  • Graph approach enables efficient genomic assembly\")\n\nprintln(\"\\\\n📋 BEST PRACTICES FOR BIOLOGICAL SEQUENCES:\")\nprintln(\"  • Use appropriate BioSequence types (LongDNA, LongRNA, LongAA)\")\nprintln(\"  • Validate sequence composition after graph construction\")\nprintln(\"  • Consider sequence complexity when setting graph parameters\")\nprintln(\"  • Use overlap analysis for assembly quality assessment\")\nprintln(\"  • Apply biological sequence metrics for validation\")\n\nprintln(\"\\\\n🚀 NEXT STEPS IN BIOLOGICAL GRAPH HIERARCHY:\")\nprintln(\"  • Tutorial 4: FASTA → K-mer graphs → Sequence graphs (fixed→variable)\")\nprintln(\"  • Tutorial 5: FASTQ → FASTQ graphs (direct quality-aware)\")\nprintln(\"  • Tutorial 6: FASTQ → Qualmer graphs → FASTQ graphs (quality-aware)\")\nprintln(\"  • Advanced: Error correction and assembly optimization\")\n\nprintln(\"\\\\n🎯 APPLICATIONS DEMONSTRATED:\")\nprintln(\"  ✓ Gene sequence analysis and reconstruction\")\nprintln(\"  ✓ Multi-alphabet biological sequence handling\")\nprintln(\"  ✓ Genomic assembly from overlapping reads\")\nprintln(\"  ✓ Quality assessment with biological metrics\")\nprintln(\"  ✓ Performance scaling for larger datasets\")\n\nprintln(\"\\\\n\" * \"=\"^80)\nprintln(\"BioSequence graph mastery achieved!\")\nprintln(\"Ready for hierarchical K-mer workflows in Tutorial 4!\")\nprintln(\"=\"^80)","category":"section"},{"location":"generated/tutorials/12_coverm_coverage/#Tutorial-12:-Coverage-Profiling-with-CoverM","page":"Step 12: CoverM Coverage","title":"Tutorial 12: Coverage Profiling with CoverM","text":"CoverM computes coverage and abundance summaries directly from BAMs. This tutorial shows how to:\n\nInstall/activate the CoverM Bioconda environment\nRun contig-level coverage (run_coverm_contig)\nRun genome/bin-level abundance (run_coverm_genome)\nReuse cached TSVs for reproducible workflows\n\nThe workflow uses tiny synthetic data so it finishes quickly on a laptop or login node.\n\nFrom the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/12_coverm_coverage.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Mycelia\nimport CSV\nimport DataFrames\nimport StableRNGs\nimport Test\n\n# Set up a scratch workspace\nworkdir = mktempdir()\nprintln(\"Workspace: \", workdir)\n\n# Create a small reference FASTA\nrng = StableRNGs.StableRNG(42)\nref_record = Mycelia.random_fasta_record(L=5_000, seed=rand(rng, 0:typemax(Int)))\nref_fasta = joinpath(workdir, \"reference.fa\")\nMycelia.write_fasta(outfile=ref_fasta, records=[ref_record])\n\n# Simulate short reads against the reference\nreads = Mycelia.simulate_illumina_reads(\n    fasta=ref_fasta,\n    read_count=500,\n    len=150,\n    rndSeed=rand(rng, 0:typemax(Int)),\n    quiet=true\n)\n\n# Map reads with minimap2 to produce a BAM\nmap_result = Mycelia.minimap_map(\n    fasta=ref_fasta,\n    fastq=reads.forward_reads,\n    mapping_type=\"sr\",\n    threads=4\n)\nrun(map_result.cmd)\nbam_path = map_result.outfile","category":"section"},{"location":"generated/tutorials/12_coverm_coverage/#Contig-mode:-per-contig-coverage","page":"Step 12: CoverM Coverage","title":"Contig mode: per-contig coverage","text":"contig_df = Mycelia.run_coverm_contig(\n    bam_files=[bam_path],\n    reference_fasta=ref_fasta,\n    methods=[\"mean\", \"covered_fraction\"],\n    threads=4,\n    outdir=joinpath(workdir, \"coverm_contig\")\n)\nprintln(\"Contig coverage (first rows):\")\nprintln(first(contig_df, 5))","category":"section"},{"location":"generated/tutorials/12_coverm_coverage/#Genome-mode:-per-bin-abundance","page":"Step 12: CoverM Coverage","title":"Genome mode: per-bin abundance","text":"# Make a simple bin directory (one genome for this toy example)\nbins_dir = joinpath(workdir, \"bins\")\nmkpath(bins_dir)\nbin_fasta = joinpath(bins_dir, \"bin1.fa\")\ncp(ref_fasta, bin_fasta; force=true)\n\ngenome_df = Mycelia.run_coverm_genome(\n    bam_files=[bam_path],\n    genome_directory=bins_dir,\n    genome_extension=\"fa\",\n    methods=[\"relative_abundance\", \"mean_coverage\"],\n    threads=4,\n    outdir=joinpath(workdir, \"coverm_genome\")\n)\nprintln(\"Genome abundance (first rows):\")\nprintln(first(genome_df, 5))","category":"section"},{"location":"generated/tutorials/12_coverm_coverage/#Reusing-cached-outputs","page":"Step 12: CoverM Coverage","title":"Reusing cached outputs","text":"Both wrappers skip execution when the output TSV already exists and is non-empty. You can point them at a shared path for deterministic reruns:\n\ncached_tsv = joinpath(workdir, \"coverm_genome\", \"coverm_genome.tsv\")\ngenome_df_cached = Mycelia.run_coverm_genome(\n    bam_files=[bam_path],\n    genome_directory=bins_dir,\n    output_tsv=cached_tsv\n)\nTest.@test genome_df == genome_df_cached\n\nprintln(\"CoverM tutorial complete. Results in: \", workdir)","category":"section"},{"location":"generated/tutorials/14_binning_workflow/#Tutorial-14:-Binning-and-Post-binning-Workflow","page":"Step 14a: Binning Workflow","title":"Tutorial 14: Binning and Post-binning Workflow","text":"This tutorial focuses on metagenomic binning and post-binning utilities. External tool execution is opt-in via environment variables.","category":"section"},{"location":"generated/tutorials/14_binning_workflow/#Setup","page":"Step 14a: Binning Workflow","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/14_binning_workflow.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Mycelia\nimport DataFrames","category":"section"},{"location":"generated/tutorials/14_binning_workflow/#Configuration-(opt-in-external-tools)","page":"Step 14a: Binning Workflow","title":"Configuration (opt-in external tools)","text":"To run external binners, set:\n\nMYCELIA_RUN_EXTERNAL=true\nMYCELIA_BINNING_CONTIGS (FASTA)\nMYCELIA_BINNING_DEPTH (JGI depth table)\nMYCELIA_BINNING_TAXONOMY (taxonomy TSV for TaxVAMB/Taxometer)\nMYCELIA_BINNING_COVERAGE_TABLE (coverage table)\nMYCELIA_BINNING_BAM_PATH (BAM file or directory for COMEBin)\nMYCELIA_BINNING_GRAPH (assembly graph for MetaCoAG)\nMYCELIA_BINNING_MAPPING (mapping/coverage file for MetaCoAG)\nMYCELIA_BINNING_GENOMES (comma-separated FASTA list for dRep)\nMYCELIA_BINNING_BINS_DIRS (comma-separated bin directories for MAGmax)\n\nThese inputs are intentionally user-supplied to keep the tutorial lightweight.\n\nconst RUN_EXTERNAL = get(ENV, \"MYCELIA_RUN_EXTERNAL\", \"false\") == \"true\"\nconst contigs_fasta = get(ENV, \"MYCELIA_BINNING_CONTIGS\", \"\")\nconst depth_file = get(ENV, \"MYCELIA_BINNING_DEPTH\", \"\")\nconst taxonomy_file = get(ENV, \"MYCELIA_BINNING_TAXONOMY\", \"\")\nconst coverage_table = get(ENV, \"MYCELIA_BINNING_COVERAGE_TABLE\", \"\")\nconst bam_path = get(ENV, \"MYCELIA_BINNING_BAM_PATH\", \"\")\nconst assembly_graph = get(ENV, \"MYCELIA_BINNING_GRAPH\", \"\")\nconst mapping_file = get(ENV, \"MYCELIA_BINNING_MAPPING\", \"\")\nconst genomes = filter(!isempty, strip.(split(get(ENV, \"MYCELIA_BINNING_GENOMES\", \"\"), ',')))\nconst bins_dirs = filter(!isempty, strip.(split(get(ENV, \"MYCELIA_BINNING_BINS_DIRS\", \"\"), ',')))","category":"section"},{"location":"generated/tutorials/14_binning_workflow/#Part-1:-Parser-Utilities-(no-external-tools-needed)","page":"Step 14a: Binning Workflow","title":"Part 1: Parser Utilities (no external tools needed)","text":"The binning module includes parsers for common output tables.\n\nprintln(\"=== Binning Tutorial ===\")\nprintln(\"Parser utilities (no external tools required)\")\n\ntmp_assignments = tempname()\nopen(tmp_assignments, \"w\") do io\n    write(io, \"contig\\tbin\\tlength\\n\")\n    write(io, \"ctg1\\tbinA\\t1500\\n\")\n    write(io, \"ctg2\\tbinB\\t2400\\n\")\nend\n\nassignments_df = Mycelia.parse_bin_assignments(tmp_assignments)\nprintln(\"Parsed assignments:\")\nprintln(assignments_df)\n\ntmp_drep = tempname()\nopen(tmp_drep, \"w\") do io\n    write(io, \"genome,secondary_cluster,representative,ani\\n\")\n    write(io, \"g1,1,g1,0.99\\n\")\n    write(io, \"g2,1,g1,0.99\\n\")\nend\n\ndrep_df = Mycelia.parse_drep_clusters(tmp_drep)\nprintln(\"Parsed dRep clusters:\")\nprintln(drep_df)","category":"section"},{"location":"generated/tutorials/14_binning_workflow/#Part-2:-Binning-(opt-in-external-tools)","page":"Step 14a: Binning Workflow","title":"Part 2: Binning (opt-in external tools)","text":"The wrapper calls below require external tools and inputs.\n\nif RUN_EXTERNAL\n    println(\"\\n=== External binning runs (opt-in) ===\")\n\n    if isfile(contigs_fasta) && isfile(depth_file)\n        println(\"Running VAMB and MetaBAT2...\")\n        tmp_root = mktempdir()\n        outdir_vamb = joinpath(tmp_root, \"vamb_out\")\n        outdir_metabat = joinpath(tmp_root, \"metabat_out\")\n        try\n            Mycelia.run_vamb(contigs_fasta=contigs_fasta, depth_file=depth_file, outdir=outdir_vamb)\n            Mycelia.run_metabat2(contigs_fasta=contigs_fasta, depth_file=depth_file, outdir=outdir_metabat)\n        finally\n            rm(tmp_root; recursive=true, force=true)\n        end\n    else\n        println(\"Skipping VAMB/MetaBAT2 (missing contigs/depth inputs).\")\n    end\n\n    if isfile(contigs_fasta) && isfile(depth_file) && isfile(taxonomy_file)\n        println(\"Running TaxVAMB and Taxometer...\")\n        tmp_root = mktempdir()\n        outdir_taxvamb = joinpath(tmp_root, \"taxvamb_out\")\n        outdir_taxometer = joinpath(tmp_root, \"taxometer_out\")\n        try\n            Mycelia.run_taxvamb(\n                contigs_fasta=contigs_fasta,\n                depth_file=depth_file,\n                taxonomy_file=taxonomy_file,\n                outdir=outdir_taxvamb\n            )\n            Mycelia.run_taxometer(\n                contigs_fasta=contigs_fasta,\n                depth_file=depth_file,\n                taxonomy_file=taxonomy_file,\n                outdir=outdir_taxometer\n            )\n        finally\n            rm(tmp_root; recursive=true, force=true)\n        end\n    else\n        println(\"Skipping TaxVAMB/Taxometer (missing contigs/depth/taxonomy inputs).\")\n    end\n\n    if isfile(contigs_fasta) && isfile(assembly_graph) && isfile(mapping_file)\n        println(\"Running MetaCoAG...\")\n        outdir_metacoag = mktempdir()\n        try\n            Mycelia.run_metacoag(\n                contigs_fasta=contigs_fasta,\n                assembly_graph=assembly_graph,\n                mapping_file=mapping_file,\n                outdir=outdir_metacoag\n            )\n        finally\n            rm(outdir_metacoag; recursive=true, force=true)\n        end\n    else\n        println(\"Skipping MetaCoAG (missing contigs/graph/mapping inputs).\")\n    end\n\n    if isfile(contigs_fasta) && isfile(coverage_table)\n        println(\"Skipping GenomeFace; wrapper disabled until genomeface executable is available again.\")\n    else\n        println(\"Skipping GenomeFace (missing contigs/coverage inputs; wrapper disabled until executable is available).\")\n    end\n\n    if isfile(contigs_fasta) && !isempty(bam_path) && (isfile(bam_path) || isdir(bam_path))\n        println(\"Running COMEBin...\")\n        outdir_comebin = mktempdir()\n        try\n            Mycelia.run_comebin(\n                contigs_fasta=contigs_fasta,\n                bam_path=bam_path,\n                outdir=outdir_comebin\n            )\n        finally\n            rm(outdir_comebin; recursive=true, force=true)\n        end\n    else\n        println(\"Skipping COMEBin (missing contigs/BAM inputs).\")\n    end\nelse\n    println(\"\\nExternal tools are opt-in. Set MYCELIA_RUN_EXTERNAL=true to run binning wrappers.\")\nend","category":"section"},{"location":"generated/tutorials/14_binning_workflow/#Part-3:-Post-binning-(opt-in-external-tools)","page":"Step 14a: Binning Workflow","title":"Part 3: Post-binning (opt-in external tools)","text":"dRep and MAGmax require external tools and user-provided inputs.\n\nif RUN_EXTERNAL\n    if !isempty(genomes) && all(isfile, genomes)\n        println(\"Running dRep...\")\n        outdir_drep = mktempdir()\n        try\n            Mycelia.run_drep_dereplicate(genomes=genomes, outdir=outdir_drep)\n        finally\n            rm(outdir_drep; recursive=true, force=true)\n        end\n    else\n        println(\"Skipping dRep (missing MYCELIA_BINNING_GENOMES inputs).\")\n    end\n\n    if !isempty(bins_dirs) && all(isdir, bins_dirs)\n        println(\"Running MAGmax...\")\n        outdir_magmax = mktempdir()\n        try\n            Mycelia.run_magmax_merge(bins_dirs=bins_dirs, outdir=outdir_magmax)\n        finally\n            rm(outdir_magmax; recursive=true, force=true)\n        end\n    else\n        println(\"Skipping MAGmax (missing MYCELIA_BINNING_BINS_DIRS inputs).\")\n    end\nend","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Tutorial-3:-K-mer-Analysis-and-Feature-Extraction","page":"Step 3: K-mer Analysis","title":"Tutorial 3: K-mer Analysis and Feature Extraction","text":"This tutorial explores k-mer analysis, a fundamental technique in bioinformatics for sequence analysis, genome assembly, and comparative genomics.","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Learning-Objectives","page":"Step 3: K-mer Analysis","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nK-mer theory and biological significance\nHow k-mer size affects analysis sensitivity and specificity\nDense vs sparse k-mer counting strategies\nK-mer frequency spectra and their interpretation\nApplications in genome size estimation and quality assessment\nMemory and computational considerations for large-scale analysis","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Setup","page":"Step 3: K-mer Analysis","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/03_kmer_analysis.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\n\nRandom.seed!(42)","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Part-1:-K-mer-Theory-and-Biological-Context","page":"Step 3: K-mer Analysis","title":"Part 1: K-mer Theory and Biological Context","text":"K-mers are subsequences of length k extracted from DNA sequences. They capture local sequence composition and are fundamental to many algorithms.\n\nprintln(\"=== K-mer Analysis Tutorial ===\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#K-mer-Mathematics","page":"Step 3: K-mer Analysis","title":"K-mer Mathematics","text":"For DNA sequences, there are 4^k possible k-mers. Understanding k-mer space helps with parameter selection.\n\nfunction kmer_space_size(k, alphabet_size=4)\n    return alphabet_size^k\nend\n\nprintln(\"K-mer space sizes:\")\nfor k in [3, 5, 7, 9, 11, 13, 15, 17, 19, 21]\n    space_size = kmer_space_size(k)\n    println(\"k=$k: $(space_size) possible k-mers ($(space_size ÷ 1000)K)\")\nend","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Biological-Significance","page":"Step 3: K-mer Analysis","title":"Biological Significance","text":"K-mers capture different biological features depending on their size:\n\nSmall k-mers (k=3-7): Capture short motifs, sensitive to errors\nMedium k-mers (k=15-21): Balance sensitivity and specificity\nLarge k-mers (k=25-51): Specific but may miss short overlaps\n\nprintln(\"\\nK-mer size selection guidelines:\")\nprintln(\"k=3-7:   Short motifs, codon analysis\")\nprintln(\"k=15-21: Error correction, initial assembly\")\nprintln(\"k=25-31: Genome assembly, repeat detection\")\nprintln(\"k=35-51: Specific overlaps, large genome assembly\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Part-2:-K-mer-Counting-Strategies","page":"Step 3: K-mer Analysis","title":"Part 2: K-mer Counting Strategies","text":"Different applications require different counting approaches. Understanding trade-offs helps optimize performance.\n\nprintln(\"\\n=== K-mer Counting Strategies ===\")\n\nGenerate test sequences for demonstration\n\ntest_sequences = [\n    Mycelia.random_fasta_record(moltype=:DNA, seed=i, L=1000)\n    for i in 1:10\n]\n\nWrite sequences to temporary files\n\ntemp_files = String[]\nfor (i, seq) in enumerate(test_sequences)\n    filename = \"test_seq_$i.fasta\"\n    Mycelia.write_fasta(outfile=filename, records=[seq])\n    push!(temp_files, filename)\nend\n\nprintln(\"Generated $(length(temp_files)) test sequences\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Dense-K-mer-Counting","page":"Step 3: K-mer Analysis","title":"Dense K-mer Counting","text":"Dense counting stores all possible k-mers, including those not observed. Memory usage: O(4^k) - grows exponentially with k\n\nprintln(\"\\n--- Dense K-mer Counting ---\")\n\ndense_results = Dict{Int, NamedTuple}()\ndense_summaries = Dict{Int, NamedTuple}()\n\nfor k in [3, 5, 7, 9]\n    println(\"Computing dense k-mer counts for k=$k...\")\n\n    # Memory estimation\n    memory_mb = (4^k * 4) / (1024^2)  ## Assuming 4 bytes per count\n    println(\"  Estimated memory: $(round(memory_mb, digits=2)) MB\")\n\n    if memory_mb < 100  ## Only run if memory usage is reasonable\n        dense_counts = Mycelia.fasta_list_to_dense_kmer_counts(\n            fasta_list=temp_files,\n            alphabet=:DNA,\n            k=k\n        )\n        println(\"  ✓ Dense counting completed\")\n        println(\"  Matrix size: $(size(dense_counts.counts))\")\n        dense_results[k] = dense_counts\n\n        kmer_totals = vec(sum(dense_counts.counts; dims=2))\n        kmer_hist = Mycelia.kmer_frequency_histogram(kmer_totals)\n        zero_kmers = get(kmer_hist, 0, 0)\n        peak = Mycelia.coverage_peak_from_hist(kmer_hist; min_coverage=2)\n        dense_bytes = Mycelia.estimate_dense_matrix_memory(\n            eltype(dense_counts.counts),\n            size(dense_counts.counts, 1),\n            size(dense_counts.counts, 2)\n        )\n        dense_summaries[k] = (\n            total_kmers=sum(kmer_totals),\n            observed_kmers=length(kmer_totals) - zero_kmers,\n            zero_fraction=zero_kmers / max(1, length(kmer_totals)),\n            peak_coverage=peak.coverage,\n            dense_bytes=dense_bytes\n        )\n        println(\"  Observed k-mers: $(dense_summaries[k].observed_kmers)\")\n        println(\"  Zero fraction: $(round(dense_summaries[k].zero_fraction, digits=3))\")\n        println(\"  Peak coverage (>=2): $(dense_summaries[k].peak_coverage)\")\n        println(\"  Estimated dense bytes: $(Mycelia.bytes_human_readable(dense_summaries[k].dense_bytes))\")\n    else\n        println(\"  ⚠ Skipping due to high memory usage\")\n    end\nend","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Sparse-K-mer-Counting","page":"Step 3: K-mer Analysis","title":"Sparse K-mer Counting","text":"Sparse counting only stores observed k-mers. Memory usage: O(n) where n is number of unique k-mers\n\nprintln(\"\\n--- Sparse K-mer Counting ---\")\n\nsparse_example = nothing\nsparse_example_k = 15\nsparse_summaries = Dict{Int, NamedTuple}()\n\nfor k in [11, 13, 15, 17, 19, 21]\n    println(\"Computing sparse k-mer counts for k=$k...\")\n\n    sparse_counts = Mycelia.fasta_list_to_sparse_kmer_counts(\n        fasta_list=temp_files,\n        alphabet=:DNA,\n        k=k,\n        skip_rarefaction_plot=true,\n        show_rarefaction_plot=false\n    )\n    println(\"  ✓ Sparse counting completed\")\n    nnz = Mycelia.SparseArrays.nnz(sparse_counts.counts)\n    total_entries = prod(size(sparse_counts.counts))\n    density = total_entries == 0 ? 0.0 : nnz / total_entries\n    sparse_bytes = Mycelia.estimate_sparse_matrix_memory(\n        eltype(sparse_counts.counts),\n        size(sparse_counts.counts, 1),\n        size(sparse_counts.counts, 2);\n        nnz=nnz\n    )\n    sparse_summaries[k] = (\n        unique_kmers=length(sparse_counts.kmers),\n        nnz=nnz,\n        density=density,\n        sparse_bytes=sparse_bytes\n    )\n    println(\"  Unique k-mers: $(sparse_summaries[k].unique_kmers)\")\n    println(\"  Matrix density: $(round(sparse_summaries[k].density, digits=5))\")\n    println(\"  Estimated sparse bytes: $(Mycelia.bytes_human_readable(sparse_summaries[k].sparse_bytes))\")\n\n    if k == sparse_example_k\n        sparse_example = sparse_counts\n    end\nend","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Part-3:-K-mer-Frequency-Spectra","page":"Step 3: K-mer Analysis","title":"Part 3: K-mer Frequency Spectra","text":"K-mer frequency spectra reveal genome characteristics and data quality\n\nprintln(\"\\n=== K-mer Frequency Spectra ===\")\n\nspectrum_k = 7\ncanonical_kmer_counts = Mycelia.count_canonical_kmers(\n    Mycelia.Kmers.DNAKmer{spectrum_k},\n    temp_files\n)\nkmer_counts_vector = collect(values(canonical_kmer_counts))\nkmer_hist = Mycelia.kmer_frequency_histogram(kmer_counts_vector)\ncoverage_peak = Mycelia.coverage_peak_from_hist(kmer_hist; min_coverage=2)\n\nprintln(\"Spectrum histogram bins: $(length(kmer_hist))\")\nprintln(\"Coverage peak (>=2): $(coverage_peak.coverage) with $(coverage_peak.kmers) k-mers\")\n\nrepeat_threshold = coverage_peak.coverage === missing ? 5 : max(coverage_peak.coverage * 3, 5)\nrepeat_like = count(c -> c >= repeat_threshold, kmer_counts_vector)\nprintln(\"Repeat-like k-mers (>= $repeat_threshold): $repeat_like\")\n\nspectrum_dir = joinpath(@__DIR__, \"..\", \"results\", \"tutorial_03_kmer_spectra\")\nBase.Filesystem.mkpath(spectrum_dir)\nspectrum_plot = Mycelia.plot_kmer_frequency_spectra(\n    kmer_counts_vector;\n    log_scale=log2,\n    title=\"K-mer spectrum (k=$(spectrum_k))\"\n)\nMycelia.StatsPlots.savefig(\n    spectrum_plot,\n    joinpath(spectrum_dir, \"kmer_spectrum_k$(spectrum_k).png\")\n)\nprintln(\"Saved spectrum plot to $(joinpath(spectrum_dir, \"kmer_spectrum_k$(spectrum_k).png\"))\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Part-4:-Applications-in-Genome-Analysis","page":"Step 3: K-mer Analysis","title":"Part 4: Applications in Genome Analysis","text":"K-mers have many applications in genomic analysis\n\nprintln(\"\\n=== Genome Analysis Applications ===\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Genome-Size-Estimation","page":"Step 3: K-mer Analysis","title":"Genome Size Estimation","text":"Use k-mer frequency spectra to estimate genome size Formula: Genome size ≈ Total k-mers / Coverage peak\n\nprintln(\"--- Genome Size Estimation ---\")\n\ntotal_kmers = sum(kmer_counts_vector)\nestimated_size = coverage_peak.coverage === missing ? missing : Int(round(total_kmers / coverage_peak.coverage))\nknown_size = sum(length(FASTX.sequence(record)) for record in test_sequences)\nbasic_estimate = Mycelia.estimate_genome_size_from_kmers(test_sequences, spectrum_k)\n\nprintln(\"Total k-mers: $total_kmers\")\nprintln(\"Estimated genome size (coverage peak): $estimated_size\")\nprintln(\"Known total sequence length: $known_size\")\nif estimated_size !== missing\n    size_error = abs(estimated_size - known_size) / max(1, known_size)\n    println(\"Relative error: $(round(size_error * 100, digits=2))%\")\nend\nprintln(\"Basic k-mer estimate: $(basic_estimate[\"estimated_genome_size\"]) (k=$(spectrum_k))\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Error-Detection-and-Correction","page":"Step 3: K-mer Analysis","title":"Error Detection and Correction","text":"Low-frequency k-mers often represent sequencing errors\n\nprintln(\"--- Error Detection ---\")\n\ncanonical_counts_dict = Dict(canonical_kmer_counts)\nfiltered_kmers, clustering_stats, removed_kmers = Mycelia.automatic_error_filtering(canonical_counts_dict)\nsingleton_kmers = count(c -> c == 1, kmer_counts_vector)\nrare_kmers = count(c -> c > 1 && c <= (coverage_peak.coverage === missing ? 3 : max(2, coverage_peak.coverage ÷ 2)), kmer_counts_vector)\n\nprintln(\"Singleton k-mers: $singleton_kmers\")\nprintln(\"Rare k-mers: $rare_kmers\")\nprintln(\"Clustering separation quality: $(round(clustering_stats.separation_quality, digits=3))\")\nprintln(\"Suggested coverage threshold: $(clustering_stats.optimal_threshold)\")\nprintln(\"Clustered low-coverage k-mers removed: $(length(removed_kmers))\")\nprintln(\"Clustered high-confidence k-mers retained: $(length(filtered_kmers))\")\n\nerror_graph = Mycelia.Rhizomorph.build_kmer_graph(\n    test_sequences,\n    spectrum_k;\n    dataset_id=\"tutorial_error\",\n    mode=:doublestrand\n)\nlow_coverage_vertices = Mycelia.Rhizomorph.find_low_coverage_kmers(error_graph, 1)\nhigh_coverage_vertices = Mycelia.Rhizomorph.find_high_coverage_kmers(error_graph, 2)\nprintln(\"Graph low-coverage vertices (<=1): $(length(low_coverage_vertices))\")\nprintln(\"Graph high-coverage vertices (>=2): $(length(high_coverage_vertices))\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Contamination-Detection","page":"Step 3: K-mer Analysis","title":"Contamination Detection","text":"Foreign DNA creates distinctive k-mer patterns\n\nprintln(\"--- Contamination Detection ---\")\n\ncontaminant_sequences = [\n    Mycelia.random_fasta_record(moltype=:DNA, seed=200 + i, L=1000)\n    for i in 1:3\n]\nprimary_counts = Mycelia.count_canonical_kmers(\n    Mycelia.Kmers.DNAKmer{spectrum_k},\n    test_sequences\n)\ncontaminant_counts = Mycelia.count_canonical_kmers(\n    Mycelia.Kmers.DNAKmer{spectrum_k},\n    contaminant_sequences\n)\n\nall_kmers = sort(collect(union(keys(primary_counts), keys(contaminant_counts))))\nprimary_vec = [get(primary_counts, kmer, 0) for kmer in all_kmers]\ncontam_vec = [get(contaminant_counts, kmer, 0) for kmer in all_kmers]\ncosine_dist = Mycelia.Distances.cosine_dist(primary_vec, contam_vec)\njs_div = Mycelia.Distances.js_divergence(\n    primary_vec ./ max(1, sum(primary_vec)),\n    contam_vec ./ max(1, sum(contam_vec))\n)\n\nforeign_kmers = setdiff(keys(contaminant_counts), keys(primary_counts))\nforeign_fraction = length(foreign_kmers) / max(1, length(keys(contaminant_counts)))\n\nprintln(\"Cosine distance (primary vs contaminant): $(round(cosine_dist, digits=3))\")\nprintln(\"JS divergence (primary vs contaminant): $(round(js_div, digits=3))\")\nprintln(\"Foreign k-mer fraction: $(round(foreign_fraction * 100, digits=2))%\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Part-5:-Performance-Optimization","page":"Step 3: K-mer Analysis","title":"Part 5: Performance Optimization","text":"Large-scale k-mer analysis requires optimization\n\nprintln(\"\\n=== Performance Optimization ===\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Memory-Management","page":"Step 3: K-mer Analysis","title":"Memory Management","text":"Strategies for handling large k-mer datasets\n\nprintln(\"--- Memory Management ---\")\n\ndense_estimated_bytes = Mycelia.estimate_dense_matrix_memory(UInt32, 4^11, length(temp_files))\nmemory_check = Mycelia.check_matrix_fits_in_memory(dense_estimated_bytes; severity=:warn)\nprintln(\"Dense k=11 estimate: $(Mycelia.bytes_human_readable(dense_estimated_bytes))\")\nprintln(\"Memory available: $(Mycelia.bytes_human_readable(memory_check.free_memory))\")\n\ncache_dir = Base.Filesystem.mktempdir()\ncache_file = joinpath(cache_dir, \"sparse_counts_k$(sparse_example_k).jld2\")\nif sparse_example !== nothing\n    Mycelia.save_kmer_results(\n        filename=cache_file,\n        kmers=sparse_example.kmers,\n        counts=sparse_example.counts,\n        fasta_list=temp_files,\n        k=sparse_example_k,\n        alphabet=:DNA\n    )\n    cached = Mycelia.load_kmer_results(cache_file)\n    if cached !== nothing\n        println(\"Loaded cached counts: $(size(cached.counts)) from $cache_file\")\n    end\nend\n\nhist_df = Mycelia.DataFrames.DataFrame(\n    coverage=collect(keys(kmer_hist)),\n    kmers=collect(values(kmer_hist))\n)\nhistogram_path = joinpath(cache_dir, \"kmer_histogram.tsv.gz\")\nMycelia.write_tsvgz(df=hist_df, filename=histogram_path, force=true)\nprintln(\"Compressed histogram saved to $histogram_path\")\n\nmmap_path = joinpath(cache_dir, \"kmer_counts.bin\")\nopen(mmap_path, \"w\") do io\n    write(io, kmer_counts_vector)\nend\nmapped_counts = Mycelia.Mmap.mmap(mmap_path, Vector{eltype(kmer_counts_vector)}, (length(kmer_counts_vector),))\nprintln(\"Memory-mapped counts length: $(length(mapped_counts))\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Parallel-Processing","page":"Step 3: K-mer Analysis","title":"Parallel Processing","text":"Accelerate k-mer counting with parallelization\n\nprintln(\"--- Parallel Processing ---\")\n\nprintln(\"Threads available: $(Threads.nthreads())\")\nthreaded_sparse = Mycelia.fasta_list_to_sparse_kmer_counts(\n    fasta_list=temp_files,\n    alphabet=:DNA,\n    k=spectrum_k,\n    force_threading=true,\n    skip_rarefaction_plot=true,\n    show_rarefaction_plot=false\n)\nprintln(\"Threaded sparse counts: $(size(threaded_sparse.counts))\")\n\nchunk_a = temp_files[1:5]\nchunk_b = temp_files[6:10]\ncounts_a = Mycelia.count_canonical_kmers(Mycelia.Kmers.DNAKmer{spectrum_k}, chunk_a)\ncounts_b = Mycelia.count_canonical_kmers(Mycelia.Kmers.DNAKmer{spectrum_k}, chunk_b)\nmerged_counts = merge!(+, counts_a, counts_b)\nprintln(\"Merged counts size (map-reduce style): $(length(merged_counts))\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Part-6:-Visualization-and-Interpretation","page":"Step 3: K-mer Analysis","title":"Part 6: Visualization and Interpretation","text":"Create plots to understand k-mer analysis results\n\nprintln(\"\\n=== K-mer Visualization ===\")\n\nif haskey(dense_results, 3)\n    heatmap_plot = Mycelia.StatsPlots.heatmap(\n        dense_results[3].counts;\n        xlabel=\"Sequence\",\n        ylabel=\"3-mer index\",\n        title=\"3-mer composition heatmap\"\n    )\n    Mycelia.StatsPlots.savefig(\n        heatmap_plot,\n        joinpath(spectrum_dir, \"kmer_heatmap_k3.png\")\n    )\n    println(\"Saved 3-mer heatmap to $(joinpath(spectrum_dir, \"kmer_heatmap_k3.png\"))\")\nend\n\ncoverage_plot = Mycelia.StatsPlots.histogram(\n    kmer_counts_vector;\n    bins=:auto,\n    xlabel=\"k-mer count\",\n    ylabel=\"Number of k-mers\",\n    title=\"Coverage distribution (k=$(spectrum_k))\"\n)\nMycelia.StatsPlots.savefig(\n    coverage_plot,\n    joinpath(spectrum_dir, \"coverage_distribution_k$(spectrum_k).png\")\n)\n\ncomparative_k = 7\nsequence_kmer_counts = [\n    Mycelia.count_canonical_kmers(Mycelia.Kmers.DNAKmer{comparative_k}, [record])\n    for record in test_sequences\n]\nsimilarity_matrix = zeros(length(sequence_kmer_counts), length(sequence_kmer_counts))\nfor i in eachindex(sequence_kmer_counts)\n    for j in eachindex(sequence_kmer_counts)\n        all_k = union(keys(sequence_kmer_counts[i]), keys(sequence_kmer_counts[j]))\n        a = [get(sequence_kmer_counts[i], kmer, 0) for kmer in all_k]\n        b = [get(sequence_kmer_counts[j], kmer, 0) for kmer in all_k]\n        similarity_matrix[i, j] = 1 - Mycelia.Distances.cosine_dist(a, b)\n    end\nend\nsimilarity_plot = Mycelia.StatsPlots.heatmap(\n    similarity_matrix;\n    xlabel=\"Sequence index\",\n    ylabel=\"Sequence index\",\n    title=\"K-mer cosine similarity (k=$(comparative_k))\"\n)\nMycelia.StatsPlots.savefig(\n    similarity_plot,\n    joinpath(spectrum_dir, \"kmer_similarity_k$(comparative_k).png\")\n)\nprintln(\"Saved visualization plots to $spectrum_dir\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Part-7:-Advanced-K-mer-Techniques","page":"Step 3: K-mer Analysis","title":"Part 7: Advanced K-mer Techniques","text":"Explore advanced k-mer analysis methods\n\nprintln(\"\\n=== Advanced Techniques ===\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Minimizers","page":"Step 3: K-mer Analysis","title":"Minimizers","text":"Reduce k-mer space using minimizer techniques\n\nprintln(\"--- Minimizers ---\")\n\nminimizer_k = 9\nminimizer_window = 10\nsyncmer_s = 3\nsyncmer_t = 2\nstrobe_w_min = 1\nstrobe_w_max = 5\n\nexample_sequence = FASTX.sequence(Mycelia.BioSequences.LongDNA{4}, test_sequences[1])\nminimizers = Mycelia.canonical_minimizers(example_sequence, minimizer_k, minimizer_window)\nsyncmers = Mycelia.open_syncmers(example_sequence, minimizer_k, syncmer_s, syncmer_t; canonical=true)\nstrobes = Mycelia.strobemers(example_sequence, minimizer_k, strobe_w_min, strobe_w_max; canonical=true)\n\nprintln(\"Canonical minimizers: $(length(minimizers))\")\nprintln(\"Open syncmers: $(length(syncmers))\")\nprintln(\"Strobemers: $(length(strobes))\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Graph-Construction","page":"Step 3: K-mer Analysis","title":"Graph Construction","text":"Build graphs from k-mer overlaps\n\nprintln(\"--- Graph Construction ---\")\n\ngraph_k = 5\nkmer_graph = Mycelia.Rhizomorph.build_kmer_graph(\n    test_sequences,\n    graph_k;\n    dataset_id=\"tutorial\",\n    mode=:doublestrand\n)\nprintln(\"K-mer graph vertices: $(Mycelia.Graphs.nv(kmer_graph))\")\nprintln(\"K-mer graph edges: $(Mycelia.Graphs.ne(kmer_graph))\")\nhigh_coverage_kmers = Mycelia.Rhizomorph.find_high_coverage_kmers(kmer_graph, 2)\nprintln(\"High-coverage k-mers (>=2): $(length(high_coverage_kmers))\")","category":"section"},{"location":"generated/tutorials/03_kmer_analysis/#Summary-and-Best-Practices","page":"Step 3: K-mer Analysis","title":"Summary and Best Practices","text":"println(\"\\n=== K-mer Analysis Summary ===\")\nprintln(\"✓ Understanding k-mer theory and biological significance\")\nprintln(\"✓ Choosing appropriate k-mer sizes for different applications\")\nprintln(\"✓ Implementing dense and sparse counting strategies\")\nprintln(\"✓ Analyzing k-mer frequency spectra\")\nprintln(\"✓ Applying k-mer analysis to genome size estimation\")\nprintln(\"✓ Optimizing performance for large-scale analysis\")\n\nprintln(\"\\nBest Practices:\")\nprintln(\"- Start with k=21 for general analysis\")\nprintln(\"- Use dense counting for small k, sparse for large k\")\nprintln(\"- Monitor memory usage and optimize accordingly\")\nprintln(\"- Validate results with known datasets\")\nprintln(\"- Consider biological context in interpretation\")\n\nCleanup\n\nfor file in temp_files\n    rm(file, force=true)\nend\n\nprintln(\"\\nNext: Tutorial 4 - Genome Assembly\")\n\nnothing","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#Tutorial-18:-Advanced-Assembly-Theory-and-Practice","page":"Step 18: Advanced Assembly Theory and Practice","title":"Tutorial 18: Advanced Assembly Theory and Practice","text":"This tutorial demonstrates the theoretical foundations and practical implementation of Mycelia's advanced assembly algorithms, based on research from Mycelia-Dev.","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#Learning-Objectives","page":"Step 18: Advanced Assembly Theory and Practice","title":"Learning Objectives","text":"Understand the mathematical foundations of k-mer size selection\nApply dynamic prime pattern algorithms for optimal k-mer progression\nImplement strain-resolved assembly with quality metrics\nUse statistical graph cleanup methods\nApply metagenomic classification with MAPQ-aware techniques\n\nFrom the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/18_advanced_assembly_theory_and_practice.jl\", \"tutorials/notebooks\", execute=false)'","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#Setup","page":"Step 18: Advanced Assembly Theory and Practice","title":"Setup","text":"import Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Mycelia\nimport Primes","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#1.-Mathematical-Foundations-of-K-mer-Selection","page":"Step 18: Advanced Assembly Theory and Practice","title":"1. Mathematical Foundations of K-mer Selection","text":"Mycelia's k-mer selection is based on rigorous mathematical principles derived from extensive research on error rate relationships and genomic properties.","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#Error-Rate-Based-K-mer-Selection","page":"Step 18: Advanced Assembly Theory and Practice","title":"Error Rate-Based K-mer Selection","text":"The fundamental relationship between error rate and optimal k-mer size: lowerboundk = max(3, floor(1/error_rate - 1))\n\nfunction demonstrate_error_rate_kmer_selection()\n    println(\"Error Rate-Based K-mer Size Selection\")\n    println(\"=====================================\")\n\n    error_rates = [0.01, 0.05, 0.10, 0.15, 0.20]\n\n    for error_rate in error_rates\n        lower_bound = max(3, Int(floor(1/error_rate - 1)))\n\n        # Ensure odd k-mer (better for biological sequences)\n        if lower_bound % 2 == 0\n            lower_bound += 1\n        end\n\n        println(\"Error rate: $(error_rate*100)% → Minimum k-mer size: $lower_bound\")\n    end\n\n    return error_rates\nend\n\ndemonstrate_error_rate_kmer_selection()","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#Sequence-Length-Optimization","page":"Step 18: Advanced Assembly Theory and Practice","title":"Sequence Length Optimization","text":"The log₄(sequence_length) pattern provides optimal starting points for k-mer size selection based on the divergence point where erroneous k-mers begin to dominate true k-mers.\n\nfunction demonstrate_log4_optimization()\n    println(\"\\nLog₄ Sequence Length Optimization\")\n    println(\"=================================\")\n\n    sequence_lengths = [100, 1_000, 10_000, 100_000, 1_000_000]\n\n    for seq_len in sequence_lengths\n        optimal_k = Int(round(log(4, seq_len)))\n\n        # Ensure odd and prime when possible\n        if optimal_k % 2 == 0\n            optimal_k += 1\n        end\n\n        if !Primes.isprime(optimal_k)\n            optimal_k = Primes.nextprime(optimal_k)\n        end\n\n        println(\"Sequence length: $(seq_len) bp → Optimal starting k: $optimal_k\")\n    end\nend\n\ndemonstrate_log4_optimization()","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#2.-Dynamic-Prime-Pattern-Algorithm","page":"Step 18: Advanced Assembly Theory and Practice","title":"2. Dynamic Prime Pattern Algorithm","text":"Mycelia implements a sophisticated dynamic k-mer selection algorithm that exploits the mathematical properties of prime number distribution.\n\n# Generate optimal k-mer progression using dynamic prime pattern\nfunction demonstrate_dynamic_prime_pattern()\n    println(\"\\nDynamic Prime Pattern K-mer Selection\")\n    println(\"====================================\")\n\n    # Standard progression for high-quality data\n    k_sequence_standard = Mycelia.dynamic_k_prime_pattern(11, 101, 2)\n    println(\"Standard progression (start=11): $k_sequence_standard\")\n\n    # Progression for error-prone data\n    k_sequence_error_prone = Mycelia.dynamic_k_prime_pattern(7, 51, 2)\n    println(\"Error-prone progression (start=7): $k_sequence_error_prone\")\n\n    # Error rate optimized progression\n    k_sequence_optimized = Mycelia.error_optimized_k_sequence(0.05, 101, 10000)\n    println(\"Error-optimized (5% error, 10kb): $k_sequence_optimized\")\n\n    return k_sequence_standard, k_sequence_error_prone, k_sequence_optimized\nend\n\nk_sequences = demonstrate_dynamic_prime_pattern()","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#Theoretical-Advantages-of-Prime-K-mers","page":"Step 18: Advanced Assembly Theory and Practice","title":"Theoretical Advantages of Prime K-mers","text":"Twin Prime Avoidance: Automatically skips redundant analysis\nProgressive Spacing: Reduces computational overlap\nHardware Optimization: k=31 fits optimally in 64-bit integers\nBiological Relevance: Primes cannot form perfect repeats\n\nprintln(\"\\nAdvantages of Prime K-mer Selection:\")\nprintln(\"• Twin prime avoidance reduces redundant analysis\")\nprintln(\"• Progressive spacing minimizes computational overlap\")\nprintln(\"• Hardware-optimized for 64-bit architectures\")\nprintln(\"• Cannot form perfect repeats, improving specificity\")","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#3.-Strain-Resolved-Assembly-Framework","page":"Step 18: Advanced Assembly Theory and Practice","title":"3. Strain-Resolved Assembly Framework","text":"Mycelia provides comprehensive data structures and algorithms for strain-resolved assembly with detailed quality metrics.\n\n# Create a strain-resolved assembly result with quality metrics\nfunction demonstrate_strain_resolved_assembly()\n    println(\"\\nStrain-Resolved Assembly Framework\")\n    println(\"=================================\")\n\n    # Initialize strain quality metrics\n    metrics = Mycelia.StrainQualityMetrics()\n\n    # Set example values (in practice, these would be calculated)\n    metrics = Mycelia.StrainQualityMetrics(\n        0.95,  # strain_recall\n        0.92,  # strain_precision\n        0.0,   # strain_f1_score (will be calculated)\n        50000, # NGA50\n        150000, # largest_alignment\n        900000, # total_aligned_length\n        2.5,   # mismatches_per_100kb\n        0.8,   # indels_per_100kb\n        3,     # misassemblies_total\n        1,     # misassemblies_local\n        0.98,  # completeness\n        0.02,  # contamination\n        0.94,  # busco_completeness\n        0.96,  # read_mapping_rate\n        0.93,  # properly_paired_rate\n        0.88,  # mean_base_confidence\n        0.05,  # uncertain_regions_fraction\n        8.5,   # peak_memory_gb\n        2.3,   # cpu_time_hours\n        0.97,  # homopolymer_accuracy\n        0.85   # repeat_resolution_rate\n    )\n\n    # Calculate F1 score\n    metrics = Mycelia.update_strain_f1_score!(metrics)\n\n    println(\"Strain Quality Metrics:\")\n    println(\"• F1 Score: $(round(metrics.strain_f1_score, digits=3))\")\n    println(\"• NGA50: $(metrics.NGA50) bp\")\n    println(\"• Completeness: $(metrics.completeness*100)%\")\n    println(\"• Contamination: $(metrics.contamination*100)%\")\n\n    return metrics\nend\n\nstrain_metrics = demonstrate_strain_resolved_assembly()","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#4.-Statistical-Graph-Cleanup-Methods","page":"Step 18: Advanced Assembly Theory and Practice","title":"4. Statistical Graph Cleanup Methods","text":"Demonstrates the statistical tip clipping algorithm that uses coverage-based statistics rather than arbitrary cutoffs.\n\n# Simulate a simple graph cleanup scenario\nfunction demonstrate_statistical_cleanup_theory()\n    println(\"\\nStatistical Graph Cleanup Theory\")\n    println(\"===============================\")\n\n    # Simulate coverage values for a connected component\n    # (mixture of high-coverage true nodes and low-coverage error nodes)\n    true_node_coverage = [95, 98, 102, 89, 97, 93, 101, 96, 99, 94]\n    error_node_coverage = [1, 2, 1, 3, 1]\n\n    all_coverage = vcat(true_node_coverage, error_node_coverage)\n\n    # Calculate statistical thresholds\n    median_coverage = Statistics.median(all_coverage)\n    coverage_std = Statistics.std(all_coverage)\n\n    println(\"Coverage Statistics:\")\n    println(\"• Median: $(round(median_coverage, digits=1))\")\n    println(\"• Standard deviation: $(round(coverage_std, digits=1))\")\n\n    # Apply 3σ rule for tip removal\n    threshold_3sigma = median_coverage - 3.0 * coverage_std\n    threshold_1x = 1.0\n\n    println(\"\\nCleanup Thresholds:\")\n    println(\"• 3σ threshold: $(round(threshold_3sigma, digits=1))\")\n    println(\"• Hard 1x threshold: $threshold_1x\")\n\n    # Identify nodes for removal\n    nodes_for_removal = []\n    for (i, coverage) in enumerate(all_coverage)\n        if coverage <= threshold_1x || coverage < threshold_3sigma\n            push!(nodes_for_removal, i)\n        end\n    end\n\n    println(\"• Nodes marked for removal: $nodes_for_removal\")\n    println(\"• True nodes preserved: $(length(true_node_coverage))\")\n    println(\"• Error nodes removed: $(length(error_node_coverage))\")\n\n    return threshold_3sigma, nodes_for_removal\nend\n\ncleanup_results = demonstrate_statistical_cleanup_theory()","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#5.-Metagenomic-MAPQ-Aware-Classification","page":"Step 18: Advanced Assembly Theory and Practice","title":"5. Metagenomic MAPQ-Aware Classification","text":"Demonstrates the critical insight about MAPQ score interpretation in metagenomic contexts and the correct approach for taxonomic assignment.\n\nfunction demonstrate_mapq_aware_classification()\n    println(\"\\nMAPQ-Aware Metagenomic Classification\")\n    println(\"====================================\")\n\n    # Simulate alignment records with different MAPQ scores\n    simulated_alignments = [\n        (read_id=\"read_001\", ref_id=\"species_A\", alignment_score=95.5, mapq=60, taxon=\"Escherichia coli\"),\n        (read_id=\"read_002\", ref_id=\"species_B\", alignment_score=88.2, mapq=0, taxon=\"Escherichia albertii\"),  # Ambiguous but informative!\n        (read_id=\"read_003\", ref_id=\"species_A\", alignment_score=92.1, mapq=30, taxon=\"Escherichia coli\"),\n        (read_id=\"read_004\", ref_id=\"species_C\", alignment_score=85.7, mapq=0, taxon=\"Shigella flexneri\"),     # Ambiguous but informative!\n        (read_id=\"read_005\", ref_id=\"species_A\", alignment_score=97.8, mapq=60, taxon=\"Escherichia coli\"),\n    ]\n\n    println(\"Traditional Approach (Filter MAPQ=0):\")\n    traditional_retained = filter(a -> a.mapq > 0, simulated_alignments)\n    println(\"• Reads retained: $(length(traditional_retained))/$(length(simulated_alignments))\")\n\n    # Calculate traditional abundances\n    traditional_taxa = [a.taxon for a in traditional_retained]\n    traditional_counts = Dict{String, Int}()\n    for taxon in traditional_taxa\n        traditional_counts[taxon] = get(traditional_counts, taxon, 0) + 1\n    end\n\n    println(\"• Traditional relative abundances:\")\n    total_traditional = length(traditional_retained)\n    for (taxon, count) in traditional_counts\n        abundance = count / total_traditional\n        println(\"  - $taxon: $(round(abundance*100, digits=1))%\")\n    end\n\n    println(\"\\nMycelia Approach (Weight by Alignment Score):\")\n    println(\"• Reads retained: $(length(simulated_alignments))/$(length(simulated_alignments))\")\n\n    # Calculate weighted abundances using alignment scores\n    weighted_abundances = Dict{String, Float64}()\n    total_weight = 0.0\n\n    for alignment in simulated_alignments\n        weight = alignment.alignment_score  # Use alignment score, NOT MAPQ\n        taxon = alignment.taxon\n\n        weighted_abundances[taxon] = get(weighted_abundances, taxon, 0.0) + weight\n        total_weight += weight\n    end\n\n    # Normalize to relative abundances\n    println(\"• Weighted relative abundances:\")\n    for (taxon, weight) in weighted_abundances\n        abundance = weight / total_weight\n        println(\"  - $taxon: $(round(abundance*100, digits=1))%\")\n    end\n\n    # Show the critical insight\n    mapq_zero_reads = filter(a -> a.mapq == 0, simulated_alignments)\n    println(\"\\nCritical Insight:\")\n    println(\"• MAPQ=0 reads retained: $(length(mapq_zero_reads))\")\n    println(\"• These reads provide valuable taxonomic information despite ambiguity\")\n    println(\"• Traditional filtering would lose $(length(mapq_zero_reads))/$(length(simulated_alignments)) of data\")\n\n    return weighted_abundances, traditional_counts\nend\n\nabundance_comparison = demonstrate_mapq_aware_classification()","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#6.-Assembly-Accuracy-Assessment-with-Graph-Metrics","page":"Step 18: Advanced Assembly Theory and Practice","title":"6. Assembly Accuracy Assessment with Graph Metrics","text":"Demonstrates novel graph-based quality metrics using Jaccard similarity between k-mer sets and edge sets.\n\nfunction demonstrate_graph_quality_metrics()\n    println(\"\\nGraph-Based Assembly Quality Metrics\")\n    println(\"===================================\")\n\n    # Simulate k-mer sets from reference and assembly\n    reference_kmers = Set([\"ATCG\", \"TCGA\", \"CGAT\", \"GATC\", \"ATCG\"])\n    assembly_kmers = Set([\"ATCG\", \"TCGA\", \"CGTT\", \"GATC\", \"ATCG\"])  # One substitution error\n\n    # Simulate edge sets (k+1 mers representing transitions)\n    reference_edges = Set([\"ATCGA\", \"TCGAT\", \"CGATC\"])\n    assembly_edges = Set([\"ATCGA\", \"TCGTT\", \"CGATC\"])  # One edge error\n\n    # Calculate Jaccard similarities\n    kmer_intersection = length(intersect(reference_kmers, assembly_kmers))\n    kmer_union = length(union(reference_kmers, assembly_kmers))\n    kmer_jaccard = kmer_intersection / kmer_union\n    kmer_distance = 1.0 - kmer_jaccard\n\n    edge_intersection = length(intersect(reference_edges, assembly_edges))\n    edge_union = length(union(reference_edges, assembly_edges))\n    edge_jaccard = edge_intersection / edge_union\n    edge_distance = 1.0 - edge_jaccard\n\n    println(\"Assembly Quality Assessment:\")\n    println(\"• K-mer Jaccard similarity: $(round(kmer_jaccard, digits=3))\")\n    println(\"• K-mer distance: $(round(kmer_distance, digits=3))\")\n    println(\"• Edge Jaccard similarity: $(round(edge_jaccard, digits=3))\")\n    println(\"• Edge distance: $(round(edge_distance, digits=3))\")\n\n    # Interpretation\n    println(\"\\nInterpretation:\")\n    println(\"• Lower distances indicate higher assembly accuracy\")\n    println(\"• Edge distance captures connectivity errors\")\n    println(\"• K-mer distance captures sequence content errors\")\n\n    return kmer_distance, edge_distance\nend\n\nquality_metrics = demonstrate_graph_quality_metrics()","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#7.-Probabilistic-Assembly-Framework","page":"Step 18: Advanced Assembly Theory and Practice","title":"7. Probabilistic Assembly Framework","text":"Demonstrates the theoretical foundation of treating assembly as an Expectation-Maximization problem with maximum likelihood inference.\n\nfunction demonstrate_probabilistic_assembly_theory()\n    println(\"\\nProbabilistic Assembly Framework\")\n    println(\"===============================\")\n\n    # Simulate quality scores and error probabilities\n    quality_scores = [30, 35, 25, 40, 20]  # PHRED scores\n\n    println(\"Quality Score to Error Probability Conversion:\")\n    for q in quality_scores\n        error_prob = 10^(q / -10.0)\n        accuracy = 1.0 - error_prob\n        println(\"• Q$q → Error rate: $(round(error_prob*100, digits=4))%, Accuracy: $(round(accuracy*100, digits=2))%\")\n    end\n\n    # Demonstrate likelihood calculation for sequence correction\n    println(\"\\nSequence Likelihood Calculation:\")\n    observed_sequence = \"ATCGAT\"\n    candidate_sequences = [\"ATCGAT\", \"ATCGTT\", \"ATCCAT\"]\n\n    # Assume average quality score of 30 (0.1% error rate)\n    avg_error_rate = 0.001\n\n    for candidate in candidate_sequences\n        matches = sum(observed_sequence[i] == candidate[i] for i in 1:length(observed_sequence))\n        mismatches = length(observed_sequence) - matches\n\n        # Calculate likelihood\n        likelihood = (1 - avg_error_rate)^matches * avg_error_rate^mismatches\n\n        println(\"• Candidate '$candidate': $matches matches, $mismatches mismatches\")\n        println(\"  Likelihood: $(round(likelihood, sigdigits=3))\")\n    end\n\n    println(\"\\nEM Algorithm Interpretation:\")\n    println(\"• E-step: Calculate maximum likelihood paths through assembly graph\")\n    println(\"• M-step: Update graph structure based on corrected sequences\")\n    println(\"• Iterate until convergence or k-mer increment\")\n\n    return quality_scores\nend\n\nprobabilistic_demo = demonstrate_probabilistic_assembly_theory()","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#8.-Genomic-Grammar-and-Zipf's-Law","page":"Step 18: Advanced Assembly Theory and Practice","title":"8. Genomic Grammar and Zipf's Law","text":"Demonstrates the linguistic properties of genomic sequences and their implications for assembly algorithm design.\n\nfunction demonstrate_zipf_law_genomics()\n    println(\"\\nGenomic Grammar and Zipf's Law\")\n    println(\"=============================\")\n\n    # Simulate k-mer frequency distribution following power law\n    ranks = 1:20\n    alpha = 1.0  # Zipf exponent (≈1 for natural languages and genomes)\n\n    println(\"Zipf's Law in Genomic Sequences:\")\n    println(\"Frequency ∝ Rank^(-α), where α ≈ 1\")\n    println()\n\n    total_frequency = sum(1.0 / rank^alpha for rank in ranks)\n\n    for rank in ranks[1:10]  # Show first 10\n        frequency = (1.0 / rank^alpha) / total_frequency\n        println(\"• Rank $rank: Relative frequency = $(round(frequency*100, digits=1))%\")\n    end\n\n    println(\"\\nImplications for Assembly:\")\n    println(\"• Rare k-mers may represent genuine biological signal\")\n    println(\"• Power-law distributions inform graph cleaning strategies\")\n    println(\"• Non-coding regions particularly follow linguistic patterns\")\n    println(\"• Assembly algorithms should account for natural frequency distributions\")\n\n    return ranks, alpha\nend\n\nzipf_demo = demonstrate_zipf_law_genomics()","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#9.-Computational-Complexity-and-Optimization","page":"Step 18: Advanced Assembly Theory and Practice","title":"9. Computational Complexity and Optimization","text":"Demonstrates the computational considerations and optimization strategies used in Mycelia's assembly algorithms.\n\nfunction demonstrate_computational_complexity()\n    println(\"\\nComputational Complexity Analysis\")\n    println(\"================================\")\n\n    # K-mer complexity analysis\n    k_values = [11, 21, 31, 41, 51]\n\n    println(\"K-mer Space Complexity:\")\n    for k in k_values\n        possible_kmers = 4^k\n        if possible_kmers > 1e12\n            println(\"• k=$k: $(round(possible_kmers/1e12, digits=1)) trillion possible k-mers\")\n        elseif possible_kmers > 1e9\n            println(\"• k=$k: $(round(possible_kmers/1e9, digits=1)) billion possible k-mers\")\n        elseif possible_kmers > 1e6\n            println(\"• k=$k: $(round(possible_kmers/1e6, digits=1)) million possible k-mers\")\n        else\n            println(\"• k=$k: $(Int(possible_kmers)) possible k-mers\")\n        end\n    end\n\n    println(\"\\nOptimization Strategies:\")\n    println(\"• Progressive k-mer approach: O(log k) practical complexity\")\n    println(\"• Canonical k-mer storage: ~50% memory reduction\")\n    println(\"• Sparse edge representation: O(E) vs O(V²) space\")\n    println(\"• Prime k-mer selection: Reduces redundant analysis\")\n\n    # Memory estimation for different genome sizes\n    genome_sizes = [1e6, 1e7, 1e8, 1e9]  # 1MB to 1GB\n\n    println(\"\\nMemory Requirements (estimated):\")\n    for genome_size in genome_sizes\n        # Rough estimation: ~10 bytes per unique k-mer\n        estimated_kmers = genome_size * 0.8  # Assuming 80% unique k-mers\n        memory_gb = (estimated_kmers * 10) / 1e9\n\n        size_label = if genome_size >= 1e9\n            \"$(Int(genome_size/1e9))Gb\"\n        elseif genome_size >= 1e6\n            \"$(Int(genome_size/1e6))Mb\"\n        else\n            \"$(Int(genome_size))bp\"\n        end\n\n        println(\"• $size_label genome: ~$(round(memory_gb, digits=1)) GB RAM\")\n    end\n\n    return k_values, genome_sizes\nend\n\ncomplexity_analysis = demonstrate_computational_complexity()","category":"section"},{"location":"generated/tutorials/18_advanced_assembly_theory_and_practice/#Summary-and-Integration","page":"Step 18: Advanced Assembly Theory and Practice","title":"Summary and Integration","text":"This tutorial has demonstrated the key theoretical foundations and practical implementations that make Mycelia's assembly algorithms both mathematically rigorous and biologically relevant.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"SUMMARY: Theoretical Foundations Integrated into Mycelia\")\nprintln(\"=\"^60)\n\nprintln(\"\\n1. Mathematical K-mer Selection:\")\nprintln(\"   • Error rate formula: k ≥ 1/error_rate - 1\")\nprintln(\"   • Log₄ optimization for sequence length\")\nprintln(\"   • Dynamic prime pattern progression\")\n\nprintln(\"\\n2. Graph Theory Applications:\")\nprintln(\"   • Explicit vs. inferred edge storage\")\nprintln(\"   • Statistical tip clipping (3σ rule)\")\nprintln(\"   • Jaccard similarity quality metrics\")\n\nprintln(\"\\n3. Probabilistic Framework:\")\nprintln(\"   • EM algorithm for assembly optimization\")\nprintln(\"   • Viterbi algorithm for error correction\")\nprintln(\"   • Quality score integration\")\n\nprintln(\"\\n4. Metagenomic Innovations:\")\nprintln(\"   • MAPQ-aware taxonomic assignment\")\nprintln(\"   • Alignment score weighting\")\nprintln(\"   • Strain-level clustering (99.5% ANI)\")\n\nprintln(\"\\n5. Biological Insights:\")\nprintln(\"   • Zipf's law in genomic sequences\")\nprintln(\"   • Prime k-mer advantages\")\nprintln(\"   • Strain-resolved quality metrics\")\n\nprintln(\"\\n6. Computational Optimization:\")\nprintln(\"   • Progressive k-mer complexity reduction\")\nprintln(\"   • Memory-efficient data structures\")\nprintln(\"   • Hardware-optimized algorithms\")\n\nprintln(\"\\nThese theoretical foundations provide Mycelia with:\")\nprintln(\"✓ Mathematically rigorous algorithms\")\nprintln(\"✓ Biologically relevant approaches\")\nprintln(\"✓ Scalable computational methods\")\nprintln(\"✓ Comprehensive quality assessment\")\nprintln(\"✓ State-of-the-art metagenomic capabilities\")\n\nThis tutorial demonstrates how theoretical research has been systematically integrated into practical, production-ready algorithms in Mycelia, providing users with cutting-edge tools backed by solid mathematical foundations.","category":"section"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/#Overview","page":"Benchmarks","title":"Overview","text":"Comprehensive benchmarks comparing Mycelia's various approaches on different datasets.","category":"section"},{"location":"benchmarks/#Standardized-Test-Datasets","page":"Benchmarks","title":"Standardized Test Datasets","text":"To ensure rigorous validation across platforms, Mycelia uses the following gold-standard communities:","category":"section"},{"location":"benchmarks/#Mock-Communities-(Physical-and-Sequencing)","page":"Benchmarks","title":"Mock Communities (Physical & Sequencing)","text":"Source Product Complexity Description\nZymo D6331 Medium Gut Microbiome Standard (21 strains)\nZymo D6300 Low Microbial Community Standard (8 bacteria, 2 yeast)\nATCC MSA-1002 Medium 20 Strain Even Mix\nATCC MSA-1003 Medium 20 Strain Staggered Mix\nNIST RM 8376 High Microbial Pathogen DNA Standard","category":"section"},{"location":"benchmarks/#Benchmarking-Challenges-(Synthetic)","page":"Benchmarks","title":"Benchmarking Challenges (Synthetic)","text":"CAMI Challenge: Toy Datasets (Low/Med/High Complexity)\nGenome in a Bottle: HG002 (Ashkenazi Trio) - Standard for variant calling.","category":"section"},{"location":"benchmarks/#Simulation-Targets","page":"Benchmarks","title":"Simulation Targets","text":"For internal testing, we target the following simulation profiles:\n\nDepth: Low (10x), Medium (100x), High (1000x)\nDiversity: Isolate, Defined Community (10), Complex Community (100+)\nAbundance: Even, Random, Log-normal (staggered)","category":"section"},{"location":"benchmarks/#Coming-Soon","page":"Benchmarks","title":"Coming Soon","text":"Detailed benchmark results including:\n\nRuntime comparisons\nMemory usage analysis\nAssembly quality metrics\nAccuracy assessments\n\nFor current benchmarking code and data, see the benchmarking directory in the repository.","category":"section"},{"location":"benchmarks/#Related-Documentation","page":"Benchmarks","title":"Related Documentation","text":"Workflow Map\nMetagenomic Workflow","category":"section"},{"location":"concepts/#Bioinformatics-Concepts-and-Tools","page":"Concepts","title":"Bioinformatics Concepts and Tools","text":"This guide explains the key bioinformatics concepts implemented in Mycelia and provides guidance on when to use each tool. It's designed for graduate-level researchers who need to understand both the biological context and computational approaches.","category":"section"},{"location":"concepts/#Table-of-Contents","page":"Concepts","title":"Table of Contents","text":"Workflow Overview\nData Acquisition\nQuality Control\nSequence Analysis\nGenome Assembly\nGene Annotation\nComparative Genomics\nPhylogenetics\nTool Selection Guide","category":"section"},{"location":"concepts/#Workflow-Overview","page":"Concepts","title":"Workflow Overview","text":"Bioinformatics analyses typically follow a structured workflow. Understanding this flow helps you choose the right tools and interpret results correctly.","category":"section"},{"location":"concepts/#Standard-Genomic-Analysis-Pipeline","page":"Concepts","title":"Standard Genomic Analysis Pipeline","text":"Raw Data → Quality Control → Feature Extraction → Assembly → Validation → Annotation → Comparative Analysis","category":"section"},{"location":"concepts/#Decision-Points","page":"Concepts","title":"Decision Points","text":"At each stage, you face key decisions:\n\nData Quality: Is my data sufficient for analysis?\nMethod Selection: Which algorithm fits my data type and research question?\nParameter Tuning: How do I optimize for my specific dataset?\nResult Interpretation: What do the numbers mean biologically?","category":"section"},{"location":"concepts/#Data-Acquisition","page":"Concepts","title":"Data Acquisition","text":"","category":"section"},{"location":"concepts/#Concept:-Data-Sources-and-Types","page":"Concepts","title":"Concept: Data Sources and Types","text":"Biological Context: Genomic data comes from various sources, each with different characteristics and limitations.","category":"section"},{"location":"concepts/#Data-Types","page":"Concepts","title":"Data Types","text":"","category":"section"},{"location":"concepts/#Sequencing-Data","page":"Concepts","title":"Sequencing Data","text":"Illumina: Short reads (150-300 bp), high accuracy, paired-end\nPacBio/HiFi: Long reads (10-25 kb), high accuracy, single-molecule\nOxford Nanopore: Ultra-long reads (50+ kb), moderate accuracy, real-time","category":"section"},{"location":"concepts/#Reference-Data","page":"Concepts","title":"Reference Data","text":"RefSeq: Manually curated, high-quality reference sequences\nGenBank: Community-submitted sequences, variable quality\nSRA: Raw sequencing data from published studies","category":"section"},{"location":"concepts/#When-to-Use-Each","page":"Concepts","title":"When to Use Each","text":"Data Type Use Case Advantages Limitations\nIllumina SNP calling, RNA-seq, metagenomics High accuracy, cost-effective Short reads, repetitive regions\nPacBio HiFi Genome assembly, structural variants Long + accurate, span repeats Higher cost, lower throughput\nNanopore Real-time analysis, ultra-long reads Longest reads, portable Higher error rates","category":"section"},{"location":"concepts/#Mycelia-Functions","page":"Concepts","title":"Mycelia Functions","text":"# Download reference genomes\nMycelia.download_genome_by_accession(accession=\"NC_001422.1\")\n\n# Download complete assemblies\nncbi_genome_download_accession(accession=\"GCF_000819615.1\")\n\n# Simulate test data\nsimulate_random_genome(length=10000, gc_content=0.45)\nsimulate_hifi_reads(genome, coverage=20, error_rate=0.001)","category":"section"},{"location":"concepts/#Quality-Control","page":"Concepts","title":"Quality Control","text":"","category":"section"},{"location":"concepts/#Concept:-Data-Quality-Assessment","page":"Concepts","title":"Concept: Data Quality Assessment","text":"Biological Context: Sequencing is not perfect. Raw data contains errors, biases, and artifacts that must be identified and corrected before analysis.","category":"section"},{"location":"concepts/#Quality-Metrics","page":"Concepts","title":"Quality Metrics","text":"","category":"section"},{"location":"concepts/#Sequence-Quality","page":"Concepts","title":"Sequence Quality","text":"Phred Scores: Probability of base-calling error (Q20 = 1% error, Q30 = 0.1% error)\nGC Content: Should match expected organism profile\nLength Distribution: Indicates fragmentation or size selection","category":"section"},{"location":"concepts/#Coverage-Metrics","page":"Concepts","title":"Coverage Metrics","text":"Read Depth: Number of reads covering each position\nUniformity: Even coverage across genome\nDuplication Rate: PCR duplicates inflate coverage","category":"section"},{"location":"concepts/#Quality-Issues","page":"Concepts","title":"Quality Issues","text":"","category":"section"},{"location":"concepts/#Common-Problems","page":"Concepts","title":"Common Problems","text":"Adapter Contamination: Sequencing adapters in reads\nLow Quality Ends: Error-prone read ends\nOverrepresented Sequences: PCR bias or contamination\nLength Bias: Preferential sequencing of certain sizes","category":"section"},{"location":"concepts/#Solutions","page":"Concepts","title":"Solutions","text":"Trimming: Remove low-quality bases and adapters\nFiltering: Discard low-quality reads\nNormalization: Adjust for coverage bias\nDeduplication: Remove PCR duplicates","category":"section"},{"location":"concepts/#When-to-Apply-QC","page":"Concepts","title":"When to Apply QC","text":"Analysis Type QC Priority Key Metrics\nGenome Assembly Critical Coverage uniformity, read length\nVariant Calling High Base quality, mapping quality\nRNA-seq High rRNA contamination, 3' bias\nMetagenomics Medium Host contamination, diversity","category":"section"},{"location":"concepts/#Mycelia-Functions-2","page":"Concepts","title":"Mycelia Functions","text":"# Analyze read quality\nanalyze_fastq_quality(\"reads.fastq\")\n\n# Calculate sequence statistics\ncalculate_sequence_stats(sequences)\n\n# Quality visualization\nplot_quality_distribution(quality_scores)","category":"section"},{"location":"concepts/#Sequence-Analysis","page":"Concepts","title":"Sequence Analysis","text":"","category":"section"},{"location":"concepts/#Concept:-K-mer-Analysis","page":"Concepts","title":"Concept: K-mer Analysis","text":"Biological Context: K-mers are subsequences of length k. They capture local sequence composition and are fundamental to many bioinformatics algorithms.","category":"section"},{"location":"concepts/#K-mer-Theory","page":"Concepts","title":"K-mer Theory","text":"","category":"section"},{"location":"concepts/#Mathematical-Foundation","page":"Concepts","title":"Mathematical Foundation","text":"K-mer Space: 4^k possible DNA k-mers\nFrequency Spectrum: Distribution of k-mer frequencies\nCoverage Estimation: Genome size estimation from k-mer frequencies","category":"section"},{"location":"concepts/#Biological-Interpretation","page":"Concepts","title":"Biological Interpretation","text":"Repetitive Elements: High-frequency k-mers indicate repeats\nSequencing Errors: Low-frequency k-mers often represent errors\nGenome Complexity: Unique k-mers indicate complex regions","category":"section"},{"location":"concepts/#K-mer-Applications","page":"Concepts","title":"K-mer Applications","text":"","category":"section"},{"location":"concepts/#Genome-Assembly","page":"Concepts","title":"Genome Assembly","text":"Error Correction: Remove k-mers with low frequency\nOverlap Detection: Find shared k-mers between reads\nGraph Construction: Build de Bruijn graphs","category":"section"},{"location":"concepts/#Quality-Assessment","page":"Concepts","title":"Quality Assessment","text":"Coverage Estimation: Estimate genome size and coverage\nContamination Detection: Identify foreign DNA\nPloidy Estimation: Detect polyploidy from k-mer frequencies","category":"section"},{"location":"concepts/#Parameter-Selection","page":"Concepts","title":"Parameter Selection","text":"","category":"section"},{"location":"concepts/#Choosing-K","page":"Concepts","title":"Choosing K","text":"Small K (k=15-21): Sensitive to errors, good for error correction\nMedium K (k=25-31): Balanced sensitivity/specificity\nLarge K (k=35-51): Specific but may miss overlaps","category":"section"},{"location":"concepts/#Memory-Considerations","page":"Concepts","title":"Memory Considerations","text":"Dense Matrices: Store all possible k-mers (memory intensive)\nSparse Matrices: Store only observed k-mers (memory efficient)\nCounting Algorithms: Bloom filters, Count-Min sketch","category":"section"},{"location":"concepts/#When-to-Use-K-mer-Analysis","page":"Concepts","title":"When to Use K-mer Analysis","text":"Application K-mer Size Matrix Type Use Case\nError Correction 15-21 Dense Remove sequencing errors\nAssembly 25-31 Sparse Genome assembly\nRepeat Detection 31-51 Sparse Identify repetitive elements\nContamination 21-31 Sparse Detect foreign DNA","category":"section"},{"location":"concepts/#Mycelia-Functions-3","page":"Concepts","title":"Mycelia Functions","text":"# Count k-mers\ncount_kmers(\"reads.fastq\", k=21)\n\n# Dense vs sparse counting\nfasta_list_to_dense_kmer_counts(files, k=21)\nfasta_list_to_sparse_kmer_counts(files, k=21)\n\n# K-mer spectrum analysis\nkmer_frequency_spectrum(kmer_counts)","category":"section"},{"location":"concepts/#Genome-Assembly-2","page":"Concepts","title":"Genome Assembly","text":"","category":"section"},{"location":"concepts/#Concept:-Reconstructing-Genomes","page":"Concepts","title":"Concept: Reconstructing Genomes","text":"Biological Context: Sequencing breaks genomes into fragments. Assembly reconstructs the original genome by finding overlaps between fragments.","category":"section"},{"location":"concepts/#Assembly-Algorithms","page":"Concepts","title":"Assembly Algorithms","text":"","category":"section"},{"location":"concepts/#Overlap-Layout-Consensus-(OLC)","page":"Concepts","title":"Overlap-Layout-Consensus (OLC)","text":"Overlap: Find overlaps between all reads\nLayout: Order reads based on overlaps\nConsensus: Generate consensus sequence\nBest For: Long reads (PacBio, Nanopore)","category":"section"},{"location":"concepts/#De-Bruijn-Graph","page":"Concepts","title":"De Bruijn Graph","text":"K-mer Decomposition: Break reads into k-mers\nGraph Construction: Connect overlapping k-mers\nPath Finding: Find Eulerian paths through graph\nBest For: Short reads (Illumina)","category":"section"},{"location":"concepts/#String-Graph","page":"Concepts","title":"String Graph","text":"Overlap Graph: Nodes are reads, edges are overlaps\nTransitivity Reduction: Remove redundant edges\nContig Construction: Find paths through graph\nBest For: Long reads with high accuracy","category":"section"},{"location":"concepts/#Assembly-Challenges","page":"Concepts","title":"Assembly Challenges","text":"","category":"section"},{"location":"concepts/#Repetitive-Sequences","page":"Concepts","title":"Repetitive Sequences","text":"Problem: Identical sequences confuse assembly\nSolution: Long reads that span repeats\nTools: Repeat-aware assemblers, scaffolding","category":"section"},{"location":"concepts/#Heterozygosity","page":"Concepts","title":"Heterozygosity","text":"Problem: Diploid genomes have two alleles\nSolution: Haplotype-aware assembly\nTools: Trio binning, Hi-C scaffolding","category":"section"},{"location":"concepts/#Polyploidy","page":"Concepts","title":"Polyploidy","text":"Problem: Multiple copies of chromosomes\nSolution: Specialized polyploid assemblers\nTools: Ploidy-aware algorithms","category":"section"},{"location":"concepts/#Assembly-Quality-Metrics","page":"Concepts","title":"Assembly Quality Metrics","text":"","category":"section"},{"location":"concepts/#Contiguity","page":"Concepts","title":"Contiguity","text":"N50: Length where 50% of assembly is in contigs of this length or longer\nL50: Number of contigs containing 50% of assembly\nContig Count: Total number of contigs (fewer is better)","category":"section"},{"location":"concepts/#Completeness","page":"Concepts","title":"Completeness","text":"Genome Coverage: Percentage of genome assembled\nGene Completeness: Percentage of expected genes found\nBUSCO Scores: Conserved gene completeness","category":"section"},{"location":"concepts/#Accuracy","page":"Concepts","title":"Accuracy","text":"Base Accuracy: Percentage of correct bases\nStructural Accuracy: Correct arrangement of sequences\nValidation: Comparison with reference genome","category":"section"},{"location":"concepts/#Gene-Annotation","page":"Concepts","title":"Gene Annotation","text":"","category":"section"},{"location":"concepts/#Concept:-Identifying-Functional-Elements","page":"Concepts","title":"Concept: Identifying Functional Elements","text":"Biological Context: Raw genome sequences are meaningless without annotation. Gene annotation identifies protein-coding genes, regulatory elements, and other functional sequences.","category":"section"},{"location":"concepts/#Annotation-Types","page":"Concepts","title":"Annotation Types","text":"","category":"section"},{"location":"concepts/#Structural-Annotation","page":"Concepts","title":"Structural Annotation","text":"Gene Prediction: Identify protein-coding genes\nExon-Intron Structure: Define gene boundaries\nPromoter Prediction: Identify regulatory sequences\nRepeat Annotation: Classify repetitive elements","category":"section"},{"location":"concepts/#Functional-Annotation","page":"Concepts","title":"Functional Annotation","text":"Protein Function: Predict what proteins do\nPathway Mapping: Assign genes to metabolic pathways\nGO Terms: Gene Ontology functional classification\nDomain Annotation: Identify protein domains","category":"section"},{"location":"concepts/#Gene-Prediction-Methods","page":"Concepts","title":"Gene Prediction Methods","text":"","category":"section"},{"location":"concepts/#Ab-Initio-Prediction","page":"Concepts","title":"Ab Initio Prediction","text":"Approach: Use sequence signals (start codons, splice sites)\nAdvantages: No external data required\nLimitations: Lower accuracy, misses non-canonical genes\nTools: Prodigal, Pyrodigal, Augustus, GeneMark","category":"section"},{"location":"concepts/#Homology-Based-Prediction","page":"Concepts","title":"Homology-Based Prediction","text":"Approach: Compare to known genes in databases\nAdvantages: Higher accuracy for conserved genes\nLimitations: Misses novel genes, depends on database quality\nTools: BLAST, DIAMOND, MMseqs2, MetaEuk","category":"section"},{"location":"concepts/#RNA-seq-Guided-Prediction","page":"Concepts","title":"RNA-seq Guided Prediction","text":"Approach: Use transcriptome data to guide prediction\nAdvantages: High accuracy, identifies expressed genes\nLimitations: Requires RNA-seq data, misses lowly expressed genes\nTools: StringTie, Cufflinks, BRAKER","category":"section"},{"location":"concepts/#Annotation-Challenges","page":"Concepts","title":"Annotation Challenges","text":"","category":"section"},{"location":"concepts/#Eukaryotic-Complexity","page":"Concepts","title":"Eukaryotic Complexity","text":"Alternative Splicing: Multiple transcripts per gene\nPseudogenes: Non-functional gene copies\nNon-coding RNAs: Functional RNAs that don't code for proteins","category":"section"},{"location":"concepts/#Prokaryotic-Specifics","page":"Concepts","title":"Prokaryotic Specifics","text":"Operons: Polycistronic transcripts\nOverlapping Genes: Genes sharing sequence\nHorizontal Gene Transfer: Genes from other species","category":"section"},{"location":"concepts/#Quality-Assessment-2","page":"Concepts","title":"Quality Assessment","text":"","category":"section"},{"location":"concepts/#Annotation-Completeness","page":"Concepts","title":"Annotation Completeness","text":"Gene Density: Number of genes per kb\nProtein Completeness: Percentage of complete proteins\nFunctional Coverage: Percentage of genes with functional annotation","category":"section"},{"location":"concepts/#Annotation-Accuracy","page":"Concepts","title":"Annotation Accuracy","text":"Validation: Comparison with experimental data\nConsistency: Agreement between different methods\nBenchmarking: Comparison with reference annotations","category":"section"},{"location":"concepts/#When-to-Use-Different-Approaches","page":"Concepts","title":"When to Use Different Approaches","text":"Genome Type Method Tools Considerations\nBacterial Ab initio Prodigal / Pyrodigal Simple gene structure\nViral Specialized Prodigal-gv Viral coding patterns\nFungal Hybrid Augustus + BLAST Moderate complexity\nEukaryotic metagenome Homology-guided MetaEuk Fragmented contigs\nPlant/Animal RNA-seq guided BRAKER High complexity, alternative splicing","category":"section"},{"location":"concepts/#Comparative-Genomics","page":"Concepts","title":"Comparative Genomics","text":"","category":"section"},{"location":"concepts/#Concept:-Comparing-Genomes","page":"Concepts","title":"Concept: Comparing Genomes","text":"Biological Context: Comparing genomes reveals evolutionary relationships, functional elements, and species-specific adaptations.","category":"section"},{"location":"concepts/#Comparative-Approaches","page":"Concepts","title":"Comparative Approaches","text":"","category":"section"},{"location":"concepts/#Pairwise-Comparison","page":"Concepts","title":"Pairwise Comparison","text":"Synteny: Conserved gene order between species\nOrthology: Corresponding genes in different species\nWhole Genome Alignment: Align entire genomes\nStructural Variation: Differences in genome structure","category":"section"},{"location":"concepts/#Pangenome-Analysis","page":"Concepts","title":"Pangenome Analysis","text":"Core Genome: Genes present in all individuals\nAccessory Genome: Genes present in some individuals\nUnique Genes: Genes present in single individuals\nGene Gain/Loss: Evolution of gene content","category":"section"},{"location":"concepts/#Pangenome-Construction","page":"Concepts","title":"Pangenome Construction","text":"","category":"section"},{"location":"concepts/#Graph-Based-Approaches","page":"Concepts","title":"Graph-Based Approaches","text":"Gene Graphs: Nodes are genes, edges are relationships\nSequence Graphs: Nodes are sequences, edges are overlaps\nVariation Graphs: Represent genetic variation as graphs","category":"section"},{"location":"concepts/#Clustering-Approaches","page":"Concepts","title":"Clustering Approaches","text":"Sequence Similarity: Group similar sequences\nSynteny: Group genes with conserved context\nFunctional Similarity: Group genes with similar functions","category":"section"},{"location":"concepts/#Evolutionary-Analysis","page":"Concepts","title":"Evolutionary Analysis","text":"","category":"section"},{"location":"concepts/#Phylogenetic-Trees","page":"Concepts","title":"Phylogenetic Trees","text":"Species Trees: Evolutionary relationships between species\nGene Trees: Evolution of individual genes\nReconciliation: Compare gene and species trees","category":"section"},{"location":"concepts/#Selection-Analysis","page":"Concepts","title":"Selection Analysis","text":"Positive Selection: Genes under selective pressure\nPurifying Selection: Genes with functional constraints\nNeutral Evolution: Genes evolving without selection","category":"section"},{"location":"concepts/#Phylogenetics","page":"Concepts","title":"Phylogenetics","text":"","category":"section"},{"location":"concepts/#Concept:-Evolutionary-Relationships","page":"Concepts","title":"Concept: Evolutionary Relationships","text":"Biological Context: Phylogenetics reconstructs evolutionary history from molecular data, revealing how species are related and when they diverged.","category":"section"},{"location":"concepts/#Tree-Construction-Methods","page":"Concepts","title":"Tree Construction Methods","text":"","category":"section"},{"location":"concepts/#Distance-Based-Methods","page":"Concepts","title":"Distance-Based Methods","text":"UPGMA: Assumes molecular clock\nNeighbor-Joining: Doesn't assume molecular clock\nMinimum Evolution: Finds tree with shortest total branch length","category":"section"},{"location":"concepts/#Character-Based-Methods","page":"Concepts","title":"Character-Based Methods","text":"Maximum Parsimony: Minimizes evolutionary changes\nMaximum Likelihood: Finds most likely tree given data\nBayesian Inference: Incorporates prior knowledge","category":"section"},{"location":"concepts/#Molecular-Evolution-Models","page":"Concepts","title":"Molecular Evolution Models","text":"","category":"section"},{"location":"concepts/#Nucleotide-Substitution-Models","page":"Concepts","title":"Nucleotide Substitution Models","text":"JC69: All substitutions equally likely\nK80: Different rates for transitions/transversions\nGTR: General time-reversible model","category":"section"},{"location":"concepts/#Protein-Evolution-Models","page":"Concepts","title":"Protein Evolution Models","text":"Poisson: All amino acid changes equally likely\nJTT: Jones-Taylor-Thornton model\nLG: Le-Gascuel model","category":"section"},{"location":"concepts/#Tree-Evaluation","page":"Concepts","title":"Tree Evaluation","text":"","category":"section"},{"location":"concepts/#Support-Values","page":"Concepts","title":"Support Values","text":"Bootstrap: Resampling support for branches\nPosterior Probability: Bayesian support\nSH-like aLRT: Likelihood ratio test","category":"section"},{"location":"concepts/#Tree-Comparison","page":"Concepts","title":"Tree Comparison","text":"Robinson-Foulds: Topological distance\nLikelihood Ratio: Statistical comparison\nConsensus Trees: Combine multiple trees","category":"section"},{"location":"concepts/#Applications","page":"Concepts","title":"Applications","text":"","category":"section"},{"location":"concepts/#Taxonomy","page":"Concepts","title":"Taxonomy","text":"Species Identification: Place unknown species\nClassification: Revise taxonomic relationships\nDiversity Assessment: Measure evolutionary diversity","category":"section"},{"location":"concepts/#Epidemiology","page":"Concepts","title":"Epidemiology","text":"Outbreak Tracking: Trace disease transmission\nVaccine Design: Understand pathogen evolution\nDrug Resistance: Track resistance evolution","category":"section"},{"location":"concepts/#Choosing-the-Right-Analysis","page":"Concepts","title":"Choosing the Right Analysis","text":"","category":"section"},{"location":"concepts/#Data-Driven-Decisions","page":"Concepts","title":"Data-Driven Decisions","text":"Consider Your Data Type\n\nIllumina: Short read optimized tools\nPacBio/Nanopore: Long read specialized tools\nHybrid: Tools supporting multiple data types\n\nConsider Your Organism\n\nBacteria: Simpler tools, less memory\nEukaryotes: Complex tools, more resources\nViruses: Specialized viral tools\n\nConsider Your Resources\n\nLocal Machine: Memory/CPU constraints\nHPC Cluster: Parallel processing available\nCloud: Scalable but cost considerations","category":"section"},{"location":"concepts/#Question-Driven-Decisions","page":"Concepts","title":"Question-Driven Decisions","text":"Assembly Quality\n\nDraft Assembly: Fast tools, lower quality\nReference Quality: Comprehensive tools, higher quality\nComparison: Multiple assemblers, best result\n\nAnnotation Depth\n\nBasic Annotation: Fast gene prediction\nComprehensive: Multiple evidence types\nComparative: Cross-species evidence\n\nAnalysis Scope\n\nSingle Genome: Individual analysis tools\nPopulation: Population genetics tools\nComparative: Multi-genome tools","category":"section"},{"location":"concepts/#Performance-Considerations","page":"Concepts","title":"Performance Considerations","text":"","category":"section"},{"location":"concepts/#Memory-Requirements","page":"Concepts","title":"Memory Requirements","text":"K-mer Analysis: Exponential with k size\nAssembly: Linear with genome size\nAnnotation: Depends on database size","category":"section"},{"location":"concepts/#Time-Complexity","page":"Concepts","title":"Time Complexity","text":"Data Download: Network dependent\nQuality Control: Linear with data size\nAssembly: Depends on algorithm and data\nAnnotation: Depends on database searches","category":"section"},{"location":"concepts/#Accuracy-Trade-offs","page":"Concepts","title":"Accuracy Trade-offs","text":"Speed vs Accuracy: Fast tools may sacrifice accuracy\nSensitivity vs Specificity: Detect more vs fewer false positives\nCompleteness vs Contiguity: More complete vs fewer contigs","category":"section"},{"location":"concepts/#Best-Practices","page":"Concepts","title":"Best Practices","text":"","category":"section"},{"location":"concepts/#Workflow-Design","page":"Concepts","title":"Workflow Design","text":"Start Simple: Use basic tools first\nIterate: Improve based on results\nValidate: Check results at each step\nDocument: Record parameters and decisions","category":"section"},{"location":"concepts/#Quality-Control-2","page":"Concepts","title":"Quality Control","text":"Check Inputs: Validate data quality\nMonitor Progress: Track intermediate results\nEvaluate Outputs: Assess final results\nCompare Methods: Use multiple approaches","category":"section"},{"location":"concepts/#Reproducibility","page":"Concepts","title":"Reproducibility","text":"Version Control: Track software versions\nParameter Recording: Document all settings\nEnvironment Management: Use containers/environments\nData Provenance: Track data sources","category":"section"},{"location":"getting-started/#Getting-Started-with-Mycelia","page":"Getting Started","title":"Getting Started with Mycelia","text":"Welcome to Mycelia, an experimental Julia package for bioinformatics and computational biology. This guide will help you install Mycelia and explore its current capabilities.","category":"section"},{"location":"getting-started/#What-is-Mycelia?","page":"Getting Started","title":"What is Mycelia?","text":"Mycelia is a research-oriented bioinformatics package that currently provides:","category":"section"},{"location":"getting-started/#Working-Features","page":"Getting Started","title":"Working Features","text":"Basic Sequence I/O: FASTA/FASTQ file reading and writing\nRead Simulation: PacBio and Nanopore read simulators  \nTool Integration: Wrappers for established assemblers (MEGAHIT, SPAdes, hifiasm)\nK-mer Analysis: Canonical k-mer counting and distance calculations\nHPC Support: SLURM job submission and rclone integration","category":"section"},{"location":"getting-started/#Experimental-Features","page":"Getting Started","title":"Experimental Features","text":"Novel Assembly Algorithms: Graph-based approaches incorporating quality scores\nPangenome Analysis: K-mer based comparative genomics\nQuality Control: Integration with external QC tools","category":"section"},{"location":"getting-started/#Planned-Features","page":"Getting Started","title":"Planned Features","text":"Annotation: Gene prediction integration\nPhylogenetics: Tree construction from pangenome data\nVisualization: Interactive genomic plots","category":"section"},{"location":"getting-started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"","category":"section"},{"location":"getting-started/#Julia-Installation","page":"Getting Started","title":"Julia Installation","text":"Mycelia is tested against Julia LTS (1.10+) and the current release. LTS is recommended for stability. Install Julia using juliaup:\n\n# Install juliaup\ncurl -fsSL https://install.julialang.org | sh\n\n# Install latest lts Julia\njuliaup add lts\njuliaup default lts\n\n# Install latest release Julia\njuliaup add release\njuliaup default release","category":"section"},{"location":"getting-started/#System-Dependencies","page":"Getting Started","title":"System Dependencies","text":"Mycelia integrates with external bioinformatics tools. For full functionality, you'll need conda. If no conda environment is available, Mycelia will install its own environment using Conda.jl.","category":"section"},{"location":"getting-started/#HPC-Environment-Setup","page":"Getting Started","title":"HPC Environment Setup","text":"If you're using Mycelia on HPC systems, you may need to reset the LD_LIBRARY_PATH to avoid conflicts with visualization libraries:\n\n# Launch Julia with clean library path\nexport LD_LIBRARY_PATH=\"\" && julia\n\nFor Jupyter kernels, add this to your kernel.json:\n\n{\n  \"env\": {\n    \"LD_LIBRARY_PATH\": \"\"\n  }\n}","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/#For-Users","page":"Getting Started","title":"For Users","text":"Install Mycelia directly from GitHub:\n\nimport Pkg\nPkg.add(url=\"https://github.com/cjprybol/Mycelia.git\")","category":"section"},{"location":"getting-started/#For-Developers","page":"Getting Started","title":"For Developers","text":"Clone and develop the package:\n\nimport Pkg\nPkg.develop(url=\"git@github.com:cjprybol/Mycelia.git\")","category":"section"},{"location":"getting-started/#Your-First-Analysis","page":"Getting Started","title":"Your First Analysis","text":"Let's walk through a complete workflow using small test datasets included with Mycelia.","category":"section"},{"location":"getting-started/#1.-Load-Mycelia","page":"Getting Started","title":"1. Load Mycelia","text":"import Mycelia","category":"section"},{"location":"getting-started/#2.-Download-Test-Data","page":"Getting Started","title":"2. Download Test Data","text":"Download a reference genome for testing:\n\n# Download a small viral genome (phiX174)\ngenome_file = Mycelia.download_genome_by_accession(accession=\"NC_001422.1\")\n\n# Or create a random test sequence\ntest_genome = Mycelia.random_fasta_record(moltype=:DNA, L=10000)\nMycelia.write_fasta(outfile=\"test_genome.fasta\", records=[test_genome])\n\n# Simulate reads from the genome\nreads_file = Mycelia.simulate_pacbio_reads(fasta=\"test_genome.fasta\", quantity=\"20x\")\nprintln(\"Simulated reads in: $(reads_file)\")","category":"section"},{"location":"getting-started/#3.-Quality-Control-(Using-External-Tools)","page":"Getting Started","title":"3. Quality Control (Using External Tools)","text":"Filter reads using integrated external tools:\n\n# Filter long reads with filtlong\nMycelia.qc_filter_long_reads_filtlong(\n    input_file=reads_file,\n    output_file=\"filtered_reads.fastq.gz\",\n    min_length=1000,\n    min_mean_q=7\n)\n\n# Note: Native quality assessment functions are planned but not yet implemented","category":"section"},{"location":"getting-started/#4.-K-mer-Analysis","page":"Getting Started","title":"4. K-mer Analysis","text":"Analyze k-mer composition:\n\n# Count canonical k-mers\nimport Kmers\nkmer_counts = Mycelia.count_canonical_kmers(Kmers.DNAKmer{21}, reads_file)\nprintln(\"Unique k-mers: $(length(kmer_counts))\")\n\n# Note: K-mer spectrum analysis and plotting functions are planned","category":"section"},{"location":"getting-started/#5.-Genome-Assembly","page":"Getting Started","title":"5. Genome Assembly","text":"Assemble using external tools through Mycelia wrappers:\n\n# Use MEGAHIT for assembly (works with short reads)\nMycelia.assemble_metagenome_megahit(\n    reads=[reads_file],\n    output_dir=\"megahit_assembly\"\n)\n\n# Or use experimental graph-based assembly (research feature)\n# Note: This is experimental and may not produce optimal results\n# assembly = Mycelia.assemble_with_graph_framework(reads_file)\n\n# Assembly evaluation functions are planned but not yet implemented","category":"section"},{"location":"getting-started/#6.-Comparative-Analysis-(Experimental)","page":"Getting Started","title":"6. Comparative Analysis (Experimental)","text":"Compare multiple genomes using k-mer analysis:\n\n# Compare two genomes\ngenome_files = [\"genome1.fasta\", \"genome2.fasta\"]\npangenome_result = Mycelia.analyze_pangenome_kmers(\n    genome_files,\n    kmer_type=Kmers.DNAKmer{21}\n)\nprintln(\"Core k-mers: $(length(pangenome_result.core_kmers))\")\nprintln(\"Unique k-mers: $(sum(length(v) for v in values(pangenome_result.unique_kmers_by_genome)))\")\n\n# Note: Gene prediction and visualization functions are planned\n\nGold-standard whole-genome comparison (ANIb/ANIm/AAI/POCP/PyOrthoANI):\n\nresult = Mycelia.compare_genomes_gold(\n    \"genome1.fasta\",\n    \"genome2.fasta\";\n    methods=Symbol[:ANIm, :ANIb, :AAI, :POCP, :PyOrthoANI],\n    outdir=\"gold_compare\",\n    force=true\n)\nprintln(result.summary)\n\nNote: this invokes external tools via Conda.jl (BLAST, MUMmer, DIAMOND, PyOrthoANI).","category":"section"},{"location":"getting-started/#What's-Next?","page":"Getting Started","title":"What's Next?","text":"Explore the available features and help improve the package:","category":"section"},{"location":"getting-started/#Available-Tutorials","page":"Getting Started","title":"Available Tutorials","text":"See the tutorials section for numbered examples\nFocus on working examples that demonstrate current capabilities","category":"section"},{"location":"getting-started/#Research-Features","page":"Getting Started","title":"Research Features","text":"Explore the experimental graph-based assembly algorithms\nTest the quality-aware k-mer (qualmer) graph implementation\nTry the reinforcement learning guided assembly (very experimental)","category":"section"},{"location":"getting-started/#Contributing","page":"Getting Started","title":"Contributing","text":"Report issues or feature requests on GitHub\nHelp implement planned features\nImprove documentation for existing functions","category":"section"},{"location":"getting-started/#Note-on-CLI-Tools","page":"Getting Started","title":"Note on CLI Tools","text":"Command-line interface tools are planned but not yet implemented.","category":"section"},{"location":"getting-started/#API-Reference","page":"Getting Started","title":"API Reference","text":"Browse the Complete API Surface for detailed function references and examples.","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Tutorial-1:-Data-Acquisition-in-Bioinformatics","page":"Step 1: Data Acquisition","title":"Tutorial 1: Data Acquisition in Bioinformatics","text":"This tutorial demonstrates how to acquire genomic data from public databases and simulate synthetic datasets for bioinformatics analysis. Data acquisition is the critical first step in any bioinformatics workflow.","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Learning-Objectives","page":"Step 1: Data Acquisition","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nHow to download genome assemblies from NCBI databases\nDifferent types of genomic data files and their purposes\nHow to simulate synthetic genomic data for testing\nBest practices for data management and reproducibility\nQuality control considerations for downloaded data","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Setup","page":"Step 1: Data Acquisition","title":"Setup","text":"First, let's load the required packages and set up our environment.\n\nFrom the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/01_data_acquisition.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Dates\n\nSet random seed for reproducibility\n\nRandom.seed!(42)","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Part-1:-Understanding-Genomic-Data-Types","page":"Step 1: Data Acquisition","title":"Part 1: Understanding Genomic Data Types","text":"Before downloading data, it's important to understand the different types of genomic data files commonly used in bioinformatics:\n\nFASTA (.fna, .fasta): Raw sequence data (DNA/RNA/protein)\nFASTQ (.fastq): Sequencing reads with quality scores\nGFF3 (.gff3): Gene annotations and features\nProtein sequences (.faa): Translated protein sequences\nCDS sequences (.ffn): Coding sequences\nSequence reports: Metadata about sequences\n\nprintln(\"=== Genomic Data Types ===\")\nprintln(\"FASTA: Raw sequences (genome assemblies)\")\nprintln(\"FASTQ: Sequencing reads with quality scores\")\nprintln(\"GFF3: Gene annotations and genomic features\")\nprintln(\"Protein: Translated amino acid sequences\")\nprintln(\"CDS: Coding DNA sequences\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Part-2:-Downloading-Data-from-NCBI","page":"Step 1: Data Acquisition","title":"Part 2: Downloading Data from NCBI","text":"The National Center for Biotechnology Information (NCBI) is a primary source for genomic data. We'll demonstrate downloading a small, well-characterized viral genome: bacteriophage phiX174.","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Why-phiX174?","page":"Step 1: Data Acquisition","title":"Why phiX174?","text":"Small genome (~5.4 kb) - fast to download and process\nWell-characterized - extensively studied reference\nCommonly used as sequencing control\nSingle-stranded DNA virus with overlapping genes\n\nprintln(\"\\n=== Downloading phiX174 Genome ===\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Method-1:-Download-by-Accession-ID","page":"Step 1: Data Acquisition","title":"Method 1: Download by Accession ID","text":"NCBI accession IDs uniquely identify sequence records. NC_001422.1 is the RefSeq accession for phiX174.\n\nphix_accession = \"NC_001422.1\"\nprintln(\"Downloading genome by accession: $phix_accession\")\n\ngenome_file = Mycelia.download_genome_by_accession(accession=phix_accession)\nprintln(\"Downloaded to: $genome_file\")\n\nVerify the download\n\nTest.@test isfile(genome_file)\nTest.@test endswith(genome_file, \".fna.gz\")\nprintln(\"✓ Download successful\")\nprintln(\"File size: $(filesize(genome_file)) bytes\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Method-2:-Download-Complete-Assembly-Package","page":"Step 1: Data Acquisition","title":"Method 2: Download Complete Assembly Package","text":"For more comprehensive analysis, download the complete assembly package which includes multiple file types (genome, proteins, annotations, etc.).\n\nassembly_accession = \"GCF_000819615.1\"  ## Assembly accession for phiX174\nprintln(\"\\nDownloading complete assembly: $assembly_accession\")\n\nassembly_result = Mycelia.ncbi_genome_download_accession(accession=assembly_accession)\nprintln(\"Assembly downloaded to directory: $(assembly_result.directory)\")\n\nExamine what files were downloaded\n\nprintln(\"\\nDownloaded files:\")\nfor (key, filepath) in pairs(assembly_result)\n    if key != :directory && !isnothing(filepath)\n        println(\"  $key: $(basename(filepath)) ($(filesize(filepath)) bytes)\")\n    end\nend","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Examining-Downloaded-Data","page":"Step 1: Data Acquisition","title":"Examining Downloaded Data","text":"Let's examine the structure of the downloaded genome file. FASTA files start with header lines (beginning with '>') followed by sequence data.\n\nprintln(\"\\n=== Examining Downloaded Genome ===\")\n\nRead the first few lines of the genome file\n\nopen(assembly_result.genome) do io\n    header = readline(io)\n    println(\"FASTA header: $header\")\n\n    # Read first 100 characters of sequence\n    sequence_start = read(io, String)[1:min(100, end)]\n    println(\"Sequence start: $sequence_start...\")\n\n    # Verify it's a valid FASTA format\n    Test.@test startswith(header, '>')\n    Test.@test all(c -> c in \"ATCGN\\n\", sequence_start)\nend\n\nprintln(\"✓ Valid FASTA format confirmed\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Part-3:-Simulating-Synthetic-Data","page":"Step 1: Data Acquisition","title":"Part 3: Simulating Synthetic Data","text":"Synthetic data is crucial for:\n\nTesting algorithms with known ground truth\nBenchmarking performance\nDeveloping new methods\nEducational purposes\n\nprintln(\"\\n=== Simulating Synthetic Genomic Data ===\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Simulating-Random-Genome-Sequences","page":"Step 1: Data Acquisition","title":"Simulating Random Genome Sequences","text":"Generate a random DNA sequence with specified characteristics. This is useful for testing algorithms and understanding their behavior.\n\nprintln(\"Generating random DNA sequences...\")\n\nGenerate sequences with different lengths and properties\n\nsequences = []\n\nShort sequence for quick testing\n\nshort_seq = Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=100)\npush!(sequences, (\"Short (100 bp)\", short_seq))\n\nMedium sequence for moderate testing\n\nmedium_seq = Mycelia.random_fasta_record(moltype=:DNA, seed=2, L=1000)\npush!(sequences, (\"Medium (1 kb)\", medium_seq))\n\nLong sequence for performance testing\n\nlong_seq = Mycelia.random_fasta_record(moltype=:DNA, seed=3, L=10000)\npush!(sequences, (\"Long (10 kb)\", long_seq))\n\nDisplay sequence characteristics\n\nfor (name, seq) in sequences\n    seq_str = String(FASTX.sequence(seq))\n    gc_content = count(c -> c in \"GC\", seq_str) / length(seq_str)\n    println(\"$name: Length=$(length(seq_str)), GC=$(round(gc_content*100, digits=1))%\")\nend","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Writing-Synthetic-Data-to-Files","page":"Step 1: Data Acquisition","title":"Writing Synthetic Data to Files","text":"Save synthetic sequences to files for use in downstream analyses.\n\nprintln(\"\\nWriting synthetic sequences to files...\")\n\nsynthetic_files = String[]\nfor (i, (name, seq)) in enumerate(sequences)\n    filename = \"synthetic_sequence_$i.fasta\"\n    Mycelia.write_fasta(outfile=filename, records=[seq])\n    push!(synthetic_files, filename)\n    println(\"✓ Wrote $name to $filename\")\nend","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Part-4:-Data-Quality-and-Validation","page":"Step 1: Data Acquisition","title":"Part 4: Data Quality and Validation","text":"Always validate downloaded and simulated data before analysis.\n\nprintln(\"\\n=== Data Quality Validation ===\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Validating-Downloaded-Data","page":"Step 1: Data Acquisition","title":"Validating Downloaded Data","text":"Check file integrity and format correctness.\n\nprintln(\"Validating downloaded phiX174 genome...\")\n\nRead and validate the genome sequence\n\ngenome_seq = open(assembly_result.genome) do io\n    header = readline(io)\n    replace(read(io, String), '\\n' => \"\")\nend\n\nBasic validation checks\n\nTest.@test length(genome_seq) > 0\nTest.@test all(c -> c in \"ATCGN\", genome_seq)\nTest.@test count(c -> c == 'N', genome_seq) / length(genome_seq) < 0.01  ## < 1% N's\n\nprintln(\"✓ Genome length: $(length(genome_seq)) bp\")\nprintln(\"✓ Valid DNA alphabet\")\nprintln(\"✓ Low N content: $(count(c -> c == 'N', genome_seq)) N's\")\n\nCalculate basic statistics\n\nat_content = count(c -> c in \"AT\", genome_seq) / length(genome_seq)\ngc_content = count(c -> c in \"GC\", genome_seq) / length(genome_seq)\n\nprintln(\"AT content: $(round(at_content*100, digits=1))%\")\nprintln(\"GC content: $(round(gc_content*100, digits=1))%\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Validating-Synthetic-Data","page":"Step 1: Data Acquisition","title":"Validating Synthetic Data","text":"Verify synthetic sequences meet expected criteria.\n\nprintln(\"\\nValidating synthetic sequences...\")\n\nfor (i, filename) in enumerate(synthetic_files)\n    seq_record = first(Mycelia.open_fastx(filename))\n    seq_str = String(FASTX.sequence(seq_record))\n\n    # Validate sequence properties\n    Test.@test length(seq_str) > 0\n    Test.@test all(c -> c in \"ATCG\", seq_str)  ## No N's in synthetic data\n\n    println(\"✓ Synthetic sequence $i: $(length(seq_str)) bp, valid DNA\")\nend","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Part-5:-Data-Management-Best-Practices","page":"Step 1: Data Acquisition","title":"Part 5: Data Management Best Practices","text":"Proper data management ensures reproducibility and efficient analysis.\n\nprintln(\"\\n=== Data Management Best Practices ===\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Organizing-Data-Files","page":"Step 1: Data Acquisition","title":"Organizing Data Files","text":"Create a structured directory layout for your project.\n\ndata_dir = \"tutorial_data\"\nif !isdir(data_dir)\n    mkdir(data_dir)\nend\n\nMove downloaded data to organized structure\n\nreference_dir = joinpath(data_dir, \"reference\")\nsynthetic_dir = joinpath(data_dir, \"synthetic\")\nmkdir(reference_dir)\nmkdir(synthetic_dir)\n\nCopy files to organized structure (keeping originals for now)\n\ncp(assembly_result.genome, joinpath(reference_dir, \"phiX174_genome.fasta\"))\ncp(assembly_result.gff3, joinpath(reference_dir, \"phiX174_annotations.gff3\"))\n\nfor (i, filename) in enumerate(synthetic_files)\n    cp(filename, joinpath(synthetic_dir, filename))\nend\n\nprintln(\"✓ Data organized in structured directories:\")\nprintln(\"  - Reference data: $reference_dir\")\nprintln(\"  - Synthetic data: $synthetic_dir\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Creating-Data-Manifest","page":"Step 1: Data Acquisition","title":"Creating Data Manifest","text":"Document your data sources and processing steps.\n\nmanifest_file = joinpath(data_dir, \"data_manifest.txt\")\nopen(manifest_file, \"w\") do io\n    println(io, \"# Data Manifest - Tutorial 1: Data Acquisition\")\n    println(io, \"# Generated: $(Dates.now())\")\n    println(io, \"\")\n    println(io, \"## Reference Data\")\n    println(io, \"phiX174_genome.fasta - Downloaded from NCBI accession $phix_accession\")\n    println(io, \"phiX174_annotations.gff3 - Downloaded from NCBI assembly $assembly_accession\")\n    println(io, \"\")\n    println(io, \"## Synthetic Data\")\n    for (i, filename) in enumerate(synthetic_files)\n        println(io, \"$filename - Random DNA sequence, seed=$(i), length varies\")\n    end\nend\n\nprintln(\"✓ Data manifest created: $manifest_file\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Part-6:-Advanced-Data-Acquisition-Techniques","page":"Step 1: Data Acquisition","title":"Part 6: Advanced Data Acquisition Techniques","text":"For larger-scale analyses, consider these advanced approaches.\n\nprintln(\"\\n=== Advanced Techniques ===\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Partial-Downloads","page":"Step 1: Data Acquisition","title":"Partial Downloads","text":"Download only specific file types to save time and space.\n\nprintln(\"Demonstrating partial downloads...\")\n\nDownload only genome files (not proteins, annotations, etc.)\n\ngenome_only = Mycelia.ncbi_genome_download_accession(\n    accession=assembly_accession,\n    include_string=\"genome\"\n)\n\nprintln(\"✓ Genome-only download completed\")\nprintln(\"  Available files: $(keys(genome_only))\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Batch-Processing-Considerations","page":"Step 1: Data Acquisition","title":"Batch Processing Considerations","text":"When downloading multiple genomes, consider:\n\nRate limiting to avoid overwhelming servers\nError handling for failed downloads\nProgress tracking for large datasets\nDisk space management\n\nprintln(\"\\nBatch processing considerations:\")\nprintln(\"- Implement rate limiting between downloads\")\nprintln(\"- Add retry logic for failed downloads\")\nprintln(\"- Monitor disk space usage\")\nprintln(\"- Use parallel processing judiciously\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Summary-and-Next-Steps","page":"Step 1: Data Acquisition","title":"Summary and Next Steps","text":"In this tutorial, you learned:\n\nHow to download genomic data from NCBI databases\nDifferent types of genomic data files and their purposes\nHow to simulate synthetic data for testing\nData validation and quality control practices\nBest practices for data organization and management\n\nprintln(\"\\n=== Tutorial Summary ===\")\nprintln(\"✓ Downloaded phiX174 genome from NCBI\")\nprintln(\"✓ Generated synthetic sequences for testing\")\nprintln(\"✓ Validated data quality and format\")\nprintln(\"✓ Organized data in structured directories\")\nprintln(\"✓ Created data manifest for reproducibility\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Cleanup","page":"Step 1: Data Acquisition","title":"Cleanup","text":"Clean up temporary files (keeping organized data)\n\nprintln(\"\\nCleaning up temporary files...\")\n\nRemove original downloaded files (we have copies in organized structure)\n\nrm(genome_file, force=true)\nrm(assembly_result.directory, recursive=true, force=true)\n\nRemove synthetic files (we have copies in organized structure)\n\nfor filename in synthetic_files\n    rm(filename, force=true)\nend\n\nprintln(\"✓ Temporary files cleaned up\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#What's-Next?","page":"Step 1: Data Acquisition","title":"What's Next?","text":"Now that you have acquired genomic data, the next steps typically include:\n\nQuality Control: Assess data quality and preprocess if needed\nFeature Extraction: Analyze sequence composition and properties\nComparative Analysis: Compare sequences or genomes\nFunctional Analysis: Annotate genes and predict functions\n\nContinue with Tutorial 2: Quality Control and Preprocessing to learn how to assess and improve data quality before analysis.\n\nprintln(\"\\n=== Next Steps ===\")\nprintln(\"Continue with Tutorial 2: Quality Control and Preprocessing\")\nprintln(\"Data files available in: $data_dir\")\nprintln(\"Ready for downstream analysis!\")","category":"section"},{"location":"generated/tutorials/01_data_acquisition/#Key-Takeaways","page":"Step 1: Data Acquisition","title":"Key Takeaways","text":"Data Acquisition Strategy: Always start with small, well-characterized datasets\nValidation is Critical: Never assume downloaded data is perfect\nOrganization Matters: Structure your data from the beginning\nDocumentation: Keep detailed records of data sources and processing\nSynthetic Data: Valuable for testing and algorithm development\nFile Formats: Understand the purpose of different bioinformatics file types\n\nnothing  ## Suppress output in notebook","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Tutorial-5:-Assembly-Validation","page":"Step 5: Assembly Validation","title":"Tutorial 5: Assembly Validation","text":"This tutorial covers comprehensive validation techniques for genome assemblies, including reference-based and reference-free approaches.","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Learning-Objectives","page":"Step 5: Assembly Validation","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nReference-based validation using alignment and comparison tools\nReference-free validation using k-mer and read-based approaches\nBUSCO analysis for gene completeness assessment\nMerqury for k-mer based quality assessment\nStatistical validation and confidence intervals\nComparative validation across multiple assemblies","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Setup","page":"Step 5: Assembly Validation","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/05_assembly_validation.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport CSV\nimport DataFrames\nimport Plots\nimport Random\nimport Statistics\n\nRandom.seed!(42)\n\noutput_dir = mkpath(joinpath(@__DIR__, \"..\", \"results\", \"assembly_validation\"))","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Part-1:-Validation-Strategy-Overview","page":"Step 5: Assembly Validation","title":"Part 1: Validation Strategy Overview","text":"Assembly validation requires multiple complementary approaches to ensure comprehensive quality assessment.\n\nprintln(\"=== Assembly Validation Tutorial ===\")\n\nprintln(\"Validation Approaches:\")\nprintln(\"1. Reference-based validation\")\nprintln(\"   - Alignment to known reference\")\nprintln(\"   - Synteny analysis\")\nprintln(\"   - Structural variant detection\")\nprintln()\nprintln(\"2. Reference-free validation\")\nprintln(\"   - K-mer based approaches (Merqury)\")\nprintln(\"   - Read mapping validation\")\nprintln(\"   - Internal consistency checks\")\nprintln()\nprintln(\"3. Functional validation\")\nprintln(\"   - Gene completeness (BUSCO)\")\nprintln(\"   - Annotation quality\")\nprintln(\"   - Comparative genomics\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Part-2:-Reference-Based-Validation","page":"Step 5: Assembly Validation","title":"Part 2: Reference-Based Validation","text":"When reference genomes are available, direct comparison provides the most straightforward validation approach.\n\nprintln(\"\\n=== Reference-Based Validation ===\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Preparing-Test-Data","page":"Step 5: Assembly Validation","title":"Preparing Test Data","text":"Create reference and assembly for validation demonstration\n\nprintln(\"--- Preparing Test Data ---\")\n\nReference genome\n\nreference_size = 100000  ## 100 kb\nreference_genome = Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=reference_size)\nreference_file = joinpath(output_dir, \"reference.fasta\")\nMycelia.write_fasta(outfile=reference_file, records=[reference_genome])\n\nSimulated assembly with some differences\n\nreference_seq = FASTX.FASTA.sequence(reference_genome)\ncontig_1 = FASTX.FASTA.Record(\"contig_1\", reference_seq[1:40000])\ncontig_2_seq, _ = Mycelia.observe(reference_seq[40001:80000]; error_rate=0.005)\ncontig_2 = FASTX.FASTA.Record(\"contig_2\", contig_2_seq)\ncontig_3 = FASTX.FASTA.Record(\"contig_3\", reference_seq[80001:100000])\nassembly_contigs = [contig_1, contig_2, contig_3]\n\nassembly_file = joinpath(output_dir, \"assembly.fasta\")\nMycelia.write_fasta(outfile=assembly_file, records=assembly_contigs)\n\nreads = Mycelia.create_test_reads(reference_seq, 200, 0.01)\nreads_file = joinpath(output_dir, \"reads.fastq\")\nMycelia.write_fastq(records=reads, filename=reads_file)\n\nprintln(\"Test data prepared:\")\nprintln(\"  Reference: $(reference_size) bp\")\nprintln(\"  Assembly: $(length(assembly_contigs)) contigs\")\nprintln(\"  Reads: $(reads_file)\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Alignment-Based-Validation","page":"Step 5: Assembly Validation","title":"Alignment-Based Validation","text":"Use alignment tools to compare assembly to reference\n\nprintln(\"--- Alignment-Based Validation ---\")\n\nprintln(\"Mycelia will auto-install missing tools via conda when you run these wrappers.\")\n\nmummer_dir = Mycelia.run_mummer(\n    reference_file,\n    assembly_file;\n    outdir=joinpath(output_dir, \"mummer\"),\n    prefix=\"validation\"\n)\ncoords_file = joinpath(mummer_dir, \"validation.coords\")\ncoords_lines = filter(line -> !isempty(strip(line)) && occursin(r\"^\\d\", strip(line)), readlines(coords_file))\ncoords_rows = [split(strip(line)) for line in coords_lines if length(split(strip(line))) >= 7]\naligned_lengths = [parse(Int, row[5]) for row in coords_rows]\npercent_identities = [parse(Float64, row[7]) for row in coords_rows]\ntotal_aligned = isempty(aligned_lengths) ? 0 : sum(aligned_lengths)\nmean_identity = isempty(percent_identities) ? missing : Statistics.mean(percent_identities)\ncoverage_estimate = total_aligned == 0 ? 0.0 : total_aligned / reference_size * 100\n\nquast_dir = Mycelia.run_quast(\n    assembly_file;\n    reference=reference_file,\n    outdir=joinpath(output_dir, \"quast\")\n)\nquast_report = CSV.read(joinpath(quast_dir, \"report.tsv\"), DataFrames.DataFrame; delim='\\t')\nmetric_col = names(quast_report)[1]\nvalue_col = names(quast_report)[2]\nquast_metrics = Dict(row[metric_col] => row[value_col] for row in DataFrames.eachrow(quast_report))\nquast_misassemblies = get(quast_metrics, \"Misassemblies\", get(quast_metrics, \"# misassemblies\", missing))\n\nalignment_stats = Dict(\n    \"total_aligned_bp\" => total_aligned,\n    \"mean_identity_percent\" => mean_identity,\n    \"estimated_coverage_percent\" => coverage_estimate,\n    \"quast_genome_fraction_percent\" => get(quast_metrics, \"Genome fraction (%)\", missing),\n    \"quast_avg_identity_percent\" => get(quast_metrics, \"Avg. % identity\", missing),\n    \"quast_misassemblies\" => quast_misassemblies\n)\n\nprintln(\"Alignment Statistics:\")\nfor (metric, value) in alignment_stats\n    println(\"  $metric: $value\")\nend","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Synteny-Analysis","page":"Step 5: Assembly Validation","title":"Synteny Analysis","text":"Analyze conserved gene order and chromosomal structure\n\nprintln(\"--- Synteny Analysis ---\")\n\ndotplot_file = Mycelia.run_mummer_plot(\n    joinpath(mummer_dir, \"validation.delta\");\n    outdir=mummer_dir,\n    prefix=\"validation_dotplot\",\n    plot_type=\"png\"\n)\nprintln(\"Synteny dot plot: $(dotplot_file)\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Structural-Variant-Detection","page":"Step 5: Assembly Validation","title":"Structural Variant Detection","text":"Identify large-scale differences between assembly and reference\n\nprintln(\"--- Structural Variant Detection ---\")\n\nstructural_variants = Dict(\n    \"misassemblies\" => quast_misassemblies,\n    \"relocations\" => get(quast_metrics, \"Relocations\", missing),\n    \"translocations\" => get(quast_metrics, \"Translocations\", missing),\n    \"inversions\" => get(quast_metrics, \"Inversions\", missing)\n)\n\nprintln(\"Structural variant summary (QUAST):\")\nfor (metric, value) in structural_variants\n    println(\"  $metric: $value\")\nend","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Part-3:-Reference-Free-Validation","page":"Step 5: Assembly Validation","title":"Part 3: Reference-Free Validation","text":"When no reference is available, use intrinsic data properties for validation.\n\nprintln(\"\\n=== Reference-Free Validation ===\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#K-mer-Based-Validation-(Merqury)","page":"Step 5: Assembly Validation","title":"K-mer Based Validation (Merqury)","text":"Use k-mer analysis to assess assembly quality without reference\n\nprintln(\"--- K-mer Based Validation ---\")\n\nqv_results = Mycelia.assess_assembly_quality(\n    assembly=assembly_file,\n    observations=[reads_file],\n    ks=[17, 21]\n)\nmerqury_results = Dict(\n    \"mean_qv\" => Statistics.mean(qv_results.qv),\n    \"best_qv\" => maximum(qv_results.qv),\n    \"mean_js_divergence\" => Statistics.mean(qv_results.js_divergence)\n)\n\nprintln(\"Merqury-style QV results:\")\nprintln(qv_results)\nfor (metric, value) in merqury_results\n    println(\"  $metric: $(round(value, digits=3))\")\nend","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Read-Mapping-Validation","page":"Step 5: Assembly Validation","title":"Read Mapping Validation","text":"Map original reads back to assembly for validation\n\nprintln(\"--- Read Mapping Validation ---\")\n\nmap_result = Mycelia.minimap_map(\n    fasta=assembly_file,\n    fastq=reads_file,\n    mapping_type=\"map-hifi\",\n    threads=4,\n    output_format=\"bam\",\n    sorted=true,\n    quiet=false\n)\nrun(map_result.cmd)\nbam_file = map_result.outfile\n\nflagstat_file = Mycelia.run_samtools_flagstat(bam_file)\nflagstat_lines = readlines(flagstat_file)\ntotal_reads = isempty(flagstat_lines) ? 0 : parse(Int, split(flagstat_lines[1])[1])\nmapped_line_idx = findfirst(line -> occursin(\" mapped\", line), flagstat_lines)\nmapped_reads = mapped_line_idx === nothing ? 0 : parse(Int, split(flagstat_lines[mapped_line_idx])[1])\nmapped_percent = total_reads == 0 ? 0.0 : mapped_reads / total_reads * 100\n\nmosdepth_outputs = Mycelia.run_mosdepth(bam_file; thresholds=\"1,10,30\", no_per_base=true)\ndist_df = Mycelia.parse_mosdepth_distribution(mosdepth_outputs.global_dist)\nsummary_df = Mycelia.parse_mosdepth_summary(mosdepth_outputs.summary)\ncoverage_qc = Mycelia.summarize_mosdepth_qc(dist_df; thresholds=[1, 10, 30])\ncoverage_total = DataFrames.subset(coverage_qc, :chromosome => x -> x .== \"total\")\nfraction_1x = DataFrames.nrow(coverage_total) == 0 ? missing : coverage_total[1, :coverage_1X]\nfraction_10x = DataFrames.nrow(coverage_total) == 0 ? missing : coverage_total[1, :coverage_10X]\nzero_cov_fraction = ismissing(fraction_1x) ? missing : 1 - fraction_1x\n\nchrom_col = names(summary_df)[1]\nmean_col = names(summary_df)[4]\ntotal_rows = summary_df[summary_df[!, chrom_col] .== \"total\", :]\nmean_coverage = DataFrames.nrow(total_rows) == 0 ? missing : total_rows[1, mean_col]\n\nqualimap_outputs = Mycelia.run_qualimap_bamqc(\n    bam=bam_file,\n    outdir=joinpath(output_dir, \"qualimap\")\n)\ncontig_cov = Mycelia.parse_qualimap_contig_coverage(qualimap_outputs.report_txt)\ncoverage_ratios = contig_cov[!, \"Standard Deviation\"] ./ contig_cov[!, \"Mean coverage\"]\ncoverage_ratios = filter(isfinite, coverage_ratios)\ncoverage_cv = isempty(coverage_ratios) ? missing : Statistics.mean(coverage_ratios)\n\nmapping_stats = Dict(\n    \"mapped_reads_percent\" => mapped_percent,\n    \"mean_coverage\" => mean_coverage,\n    \"coverage_uniformity_cv\" => coverage_cv,\n    \"zero_coverage_fraction\" => zero_cov_fraction\n)\n\nprintln(\"Read Mapping Statistics:\")\nfor (metric, value) in mapping_stats\n    println(\"  $metric: $value\")\nend","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Internal-Consistency-Validation","page":"Step 5: Assembly Validation","title":"Internal Consistency Validation","text":"Check assembly internal consistency\n\nprintln(\"--- Internal Consistency ---\")\n\ncontig_strings = [String(FASTX.FASTA.sequence(contig)) for contig in assembly_contigs]\ncontig_names = [String(FASTX.FASTA.identifier(contig)) for contig in assembly_contigs]\nrhizomorph_result = Mycelia.Rhizomorph.AssemblyResult(contig_strings, contig_names)\nstructure_report = Mycelia.Rhizomorph.validate_assembly_structure(rhizomorph_result)\nbasic_report = Mycelia.Rhizomorph.validate_assembly(rhizomorph_result)\n\nprintln(\"Rhizomorph structure report:\")\nprintln(\"  valid: $(structure_report[\"valid\"])\")\nprintln(\"  issues: $(length(structure_report[\"issues\"]))\")\nprintln(\"  warnings: $(length(structure_report[\"warnings\"]))\")\nprintln(\"Rhizomorph summary metrics:\")\nfor (metric, value) in basic_report\n    println(\"  $metric: $value\")\nend","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Part-4:-Functional-Validation","page":"Step 5: Assembly Validation","title":"Part 4: Functional Validation","text":"Validate assembly quality through functional analysis\n\nprintln(\"\\n=== Functional Validation ===\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#BUSCO-Analysis","page":"Step 5: Assembly Validation","title":"BUSCO Analysis","text":"Assess gene completeness using conserved orthologs\n\nprintln(\"--- BUSCO Analysis ---\")\n\nbusco_dir = Mycelia.run_busco(\n    assembly_file;\n    outdir=joinpath(output_dir, \"busco\"),\n    auto_lineage=true\n)\nbusco_summary_files = filter(file -> occursin(\"short_summary\", file), readdir(busco_dir; join=true))\nbusco_summary_file = isempty(busco_summary_files) ? \"\" : first(busco_summary_files)\nbusco_text = isempty(busco_summary_file) ? \"\" : read(busco_summary_file, String)\nbusco_match = match(r\"C:(\\d+\\.?\\d*)%\\[S:(\\d+\\.?\\d*)%,D:(\\d+\\.?\\d*)%\\],F:(\\d+\\.?\\d*)%,M:(\\d+\\.?\\d*)%,n:(\\d+)\", busco_text)\nbusco_results = busco_match === nothing ? Dict(\"summary_file\" => busco_summary_file) : Dict(\n    \"complete\" => parse(Float64, busco_match.captures[1]),\n    \"complete_single_copy\" => parse(Float64, busco_match.captures[2]),\n    \"complete_duplicated\" => parse(Float64, busco_match.captures[3]),\n    \"fragmented\" => parse(Float64, busco_match.captures[4]),\n    \"missing\" => parse(Float64, busco_match.captures[5]),\n    \"total_buscos\" => parse(Int, busco_match.captures[6])\n)\n\nprintln(\"BUSCO Results:\")\nfor (metric, value) in busco_results\n    println(\"  $metric: $value\")\nend","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Gene-Annotation-Quality","page":"Step 5: Assembly Validation","title":"Gene Annotation Quality","text":"Validate through gene prediction and annotation\n\nprintln(\"--- Gene Annotation Quality ---\")\n\npyrodigal_assembly = Mycelia.run_pyrodigal(\n    fasta_file=assembly_file,\n    out_dir=joinpath(output_dir, \"pyrodigal_assembly\")\n)\npyrodigal_reference = Mycelia.run_pyrodigal(\n    fasta_file=reference_file,\n    out_dir=joinpath(output_dir, \"pyrodigal_reference\")\n)\n\nassembly_gff = CSV.read(pyrodigal_assembly.gff, DataFrames.DataFrame; delim='\\t', comment=\"#\", header=false)\nDataFrames.rename!(assembly_gff, [:seqid, :source, :feature, :start, :stop, :score, :strand, :phase, :attributes])\nreference_gff = CSV.read(pyrodigal_reference.gff, DataFrames.DataFrame; delim='\\t', comment=\"#\", header=false)\nDataFrames.rename!(reference_gff, [:seqid, :source, :feature, :start, :stop, :score, :strand, :phase, :attributes])\n\nassembly_gene_lengths = abs.(assembly_gff.start .- assembly_gff.stop) .+ 1\nreference_gene_lengths = abs.(reference_gff.start .- reference_gff.stop) .+ 1\nframe_consistency = isempty(assembly_gene_lengths) ? missing : Statistics.mean(assembly_gene_lengths .% 3 .== 0)\n\nannotation_stats = Dict(\n    \"assembly_gene_count\" => DataFrames.nrow(assembly_gff),\n    \"reference_gene_count\" => DataFrames.nrow(reference_gff),\n    \"assembly_mean_gene_length\" => isempty(assembly_gene_lengths) ? missing : Statistics.mean(assembly_gene_lengths),\n    \"reference_mean_gene_length\" => isempty(reference_gene_lengths) ? missing : Statistics.mean(reference_gene_lengths),\n    \"frame_consistency_fraction\" => frame_consistency\n)\n\nprintln(\"Annotation quality summary:\")\nfor (metric, value) in annotation_stats\n    printable = value isa Number ? round(value, digits=3) : value\n    println(\"  $metric: $(printable)\")\nend","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Part-5:-Comparative-Validation","page":"Step 5: Assembly Validation","title":"Part 5: Comparative Validation","text":"Compare multiple assemblies to identify best approach\n\nprintln(\"\\n=== Comparative Validation ===\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Multi-Assembly-Comparison","page":"Step 5: Assembly Validation","title":"Multi-Assembly Comparison","text":"Compare assemblies from different tools or parameters\n\nprintln(\"--- Multi-Assembly Comparison ---\")\n\nalt_contig_1 = FASTX.FASTA.Record(\"alt1_contig_1\", reference_seq[1:30000])\nalt_contig_2 = FASTX.FASTA.Record(\"alt1_contig_2\", reference_seq[30001:60000])\nalt_contig_3 = FASTX.FASTA.Record(\"alt1_contig_3\", reference_seq[60001:90000])\nalt_contig_4 = FASTX.FASTA.Record(\"alt1_contig_4\", reference_seq[90001:100000])\nassembly_alt1 = joinpath(output_dir, \"assembly_alt1.fasta\")\nMycelia.write_fasta(outfile=assembly_alt1, records=[alt_contig_1, alt_contig_2, alt_contig_3, alt_contig_4])\n\nalt2_seq, _ = Mycelia.observe(reference_seq; error_rate=0.01)\nassembly_alt2 = joinpath(output_dir, \"assembly_alt2.fasta\")\nMycelia.write_fasta(outfile=assembly_alt2, records=[FASTX.FASTA.Record(\"alt2_contig_1\", alt2_seq)])\n\nassemblies = [assembly_file, assembly_alt1, assembly_alt2]\nquast_multi_dir = Mycelia.run_quast(\n    assemblies;\n    reference=reference_file,\n    outdir=joinpath(output_dir, \"quast_multi\")\n)\nquast_multi_report = CSV.read(joinpath(quast_multi_dir, \"report.tsv\"), DataFrames.DataFrame; delim='\\t')\nmetric_col_multi = names(quast_multi_report)[1]\nassembly_cols = names(quast_multi_report)[2:end]\n\ncomparison_table = DataFrames.DataFrame(\n    assembly=String[],\n    n50=Union{Float64, Missing}[],\n    genome_fraction=Union{Float64, Missing}[],\n    misassemblies=Union{Float64, Missing}[]\n)\nfor col in assembly_cols\n    n50_idx = findfirst(==(\"N50\"), quast_multi_report[!, metric_col_multi])\n    genome_idx = findfirst(==(\"Genome fraction (%)\"), quast_multi_report[!, metric_col_multi])\n    mis_idx = findfirst(==(\"Misassemblies\"), quast_multi_report[!, metric_col_multi])\n    n50_val = n50_idx === nothing ? missing : quast_multi_report[n50_idx, col]\n    genome_val = genome_idx === nothing ? missing : quast_multi_report[genome_idx, col]\n    mis_val = mis_idx === nothing ? missing : quast_multi_report[mis_idx, col]\n    push!(comparison_table, (assembly=String(col), n50=n50_val, genome_fraction=genome_val, misassemblies=mis_val))\nend\n\nprintln(\"Assembly Comparison (QUAST):\")\nprintln(comparison_table)","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Statistical-Validation","page":"Step 5: Assembly Validation","title":"Statistical Validation","text":"Apply statistical tests to validation results\n\nprintln(\"--- Statistical Validation ---\")\n\ncontig_lengths = [length(FASTX.FASTA.sequence(contig)) for contig in assembly_contigs]\nbootstrap_n50 = Float64[]\nfor _ in 1:200\n    resampled = rand(contig_lengths, length(contig_lengths))\n    sorted_lengths = sort(resampled, rev=true)\n    cumulative = cumsum(sorted_lengths)\n    target = sum(sorted_lengths) / 2\n    idx = findfirst(x -> x >= target, cumulative)\n    push!(bootstrap_n50, sorted_lengths[idx])\nend\nci_low, ci_high = Statistics.quantile(bootstrap_n50, [0.025, 0.975])\n\nqv_alt1 = Mycelia.assess_assembly_quality(assembly=assembly_alt1, observations=[reads_file], ks=[17, 21])\nobserved_diff = Statistics.mean(qv_results.qv) - Statistics.mean(qv_alt1.qv)\ncombined_qv = vcat(qv_results.qv, qv_alt1.qv)\nn1 = length(qv_results.qv)\nperm_diffs = Float64[]\nfor _ in 1:1000\n    permuted = Random.shuffle(combined_qv)\n    diff = Statistics.mean(permuted[1:n1]) - Statistics.mean(permuted[n1+1:end])\n    push!(perm_diffs, diff)\nend\np_value = Statistics.mean(abs.(perm_diffs) .>= abs(observed_diff))\nbonferroni_p = min(p_value * 2, 1.0)\neffect_size = observed_diff / Statistics.std(combined_qv)\n\nprintln(\"Bootstrap N50 CI: ($(round(ci_low, digits=2)), $(round(ci_high, digits=2)))\")\nprintln(\"QV mean difference (assembly vs alt1): $(round(observed_diff, digits=3))\")\nprintln(\"Permutation p-value: $(round(p_value, digits=4))\")\nprintln(\"Bonferroni-adjusted p-value: $(round(bonferroni_p, digits=4))\")\nprintln(\"Effect size (Cohen's d): $(round(effect_size, digits=3))\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Part-6:-Validation-Metrics-Integration","page":"Step 5: Assembly Validation","title":"Part 6: Validation Metrics Integration","text":"Combine multiple validation approaches for comprehensive assessment\n\nprintln(\"\\n=== Integrated Validation ===\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Composite-Quality-Scores","page":"Step 5: Assembly Validation","title":"Composite Quality Scores","text":"Combine multiple metrics into overall quality assessment\n\nprintln(\"--- Composite Quality Scores ---\")\n\nn_contigs, total_length, n50, l50 = Mycelia.assess_assembly_quality(assembly_file)\nbusco_complete = get(busco_results, \"complete\", missing)\nbusco_norm = busco_complete isa Number ? busco_complete / 100 : 0.0\nqv_norm = merqury_results[\"best_qv\"] / 60\ncontiguity_norm = n50 / reference_size\n\nweights = Dict(\"contiguity\" => 0.4, \"accuracy\" => 0.35, \"completeness\" => 0.25)\noverall_quality = 10 * (\n    weights[\"contiguity\"] * contiguity_norm +\n    weights[\"accuracy\"] * qv_norm +\n    weights[\"completeness\"] * busco_norm\n)\ncomposite_samples = [\n    10 * (\n        weights[\"contiguity\"] * (n50_sample / reference_size) +\n        weights[\"accuracy\"] * qv_norm +\n        weights[\"completeness\"] * busco_norm\n    )\n    for n50_sample in bootstrap_n50\n]\nquality_ci = Statistics.quantile(composite_samples, [0.025, 0.975])\n\ncomposite_score = Dict(\n    \"overall_quality\" => overall_quality,\n    \"confidence_interval\" => (quality_ci[1], quality_ci[2]),\n    \"primary_strengths\" => [\"Contiguity\", \"K-mer accuracy\"],\n    \"primary_weaknesses\" => [\"BUSCO completeness sensitivity\"]\n)\n\nprintln(\"Composite Quality Assessment:\")\nfor (metric, value) in composite_score\n    println(\"  $metric: $value\")\nend","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Validation-Report-Generation","page":"Step 5: Assembly Validation","title":"Validation Report Generation","text":"Create comprehensive validation reports\n\nprintln(\"--- Validation Report ---\")\n\nreport_rows = DataFrames.DataFrame(metric=String[], value=String[])\nfor (metric, value) in alignment_stats\n    push!(report_rows, (metric=\"alignment_$(metric)\", value=string(value)))\nend\nfor (metric, value) in merqury_results\n    push!(report_rows, (metric=\"merqury_$(metric)\", value=string(value)))\nend\nfor (metric, value) in mapping_stats\n    push!(report_rows, (metric=\"mapping_$(metric)\", value=string(value)))\nend\nfor (metric, value) in busco_results\n    push!(report_rows, (metric=\"busco_$(metric)\", value=string(value)))\nend\nfor (metric, value) in annotation_stats\n    push!(report_rows, (metric=\"annotation_$(metric)\", value=string(value)))\nend\nfor (metric, value) in composite_score\n    push!(report_rows, (metric=\"composite_$(metric)\", value=string(value)))\nend\n\nreport_tsv = joinpath(output_dir, \"assembly_validation_report.tsv\")\nCSV.write(report_tsv, report_rows; delim='\\t')\nprintln(\"Saved validation report: $(report_tsv)\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Part-7:-Validation-Visualization","page":"Step 5: Assembly Validation","title":"Part 7: Validation Visualization","text":"Create visualizations for validation results\n\nprintln(\"\\n=== Validation Visualization ===\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Quality-Metric-Plots","page":"Step 5: Assembly Validation","title":"Quality Metric Plots","text":"Visualize validation metrics\n\nprintln(\"--- Quality Metric Plots ---\")\n\ncontig_lengths_plot = Plots.histogram(\n    contig_lengths;\n    bins=10,\n    xlabel=\"Contig length (bp)\",\n    ylabel=\"Count\",\n    title=\"Contig Length Distribution\"\n)\ncontig_lengths_path = joinpath(output_dir, \"contig_lengths.png\")\nPlots.savefig(contig_lengths_plot, contig_lengths_path)\n\nqv_alt2 = Mycelia.assess_assembly_quality(assembly=assembly_alt2, observations=[reads_file], ks=[17, 21])\nqv_results[!, :assembler] .= \"assembly\"\nqv_alt1[!, :assembler] .= \"alt1\"\nqv_alt2[!, :assembler] .= \"alt2\"\nqv_all = vcat(qv_results, qv_alt1, qv_alt2)\nqv_heatmap = Mycelia.generate_qv_heatmap(qv_all; assembler_column=\"assembler\")\nqv_heatmap_path = joinpath(output_dir, \"qv_heatmap.png\")\nPlots.savefig(qv_heatmap, qv_heatmap_path)\n\n_, _, n50_alt1, _ = Mycelia.assess_assembly_quality(assembly_alt1)\n_, _, n50_alt2, _ = Mycelia.assess_assembly_quality(assembly_alt2)\nmean_qv_table = DataFrames.DataFrame(\n    assembly=[\"assembly\", \"alt1\", \"alt2\"],\n    n50=[n50, n50_alt1, n50_alt2],\n    mean_qv=[Statistics.mean(qv_results.qv), Statistics.mean(qv_alt1.qv), Statistics.mean(qv_alt2.qv)]\n)\nmetric_scatter = Plots.scatter(\n    mean_qv_table.n50,\n    mean_qv_table.mean_qv;\n    xlabel=\"N50 (bp)\",\n    ylabel=\"Mean QV\",\n    title=\"Contiguity vs Accuracy\",\n    series_annotations=mean_qv_table.assembly\n)\nmetric_scatter_path = joinpath(output_dir, \"n50_vs_qv.png\")\nPlots.savefig(metric_scatter, metric_scatter_path)\n\nprintln(\"Saved plots:\")\nprintln(\"  Contig lengths: $(contig_lengths_path)\")\nprintln(\"  QV heatmap: $(qv_heatmap_path)\")\nprintln(\"  N50 vs QV: $(metric_scatter_path)\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Genome-Browser-Integration","page":"Step 5: Assembly Validation","title":"Genome Browser Integration","text":"Visualize validation results in genome browser context\n\nprintln(\"--- Genome Browser Integration ---\")\n\nbrowser_tracks = Mycelia.run_mosdepth(\n    bam_file;\n    prefix=joinpath(output_dir, \"assembly_coverage\"),\n    thresholds=\"1,10,30\"\n)\nprintln(\"Genome browser tracks:\")\nprintln(\"  Per-base coverage: $(browser_tracks.per_base)\")\nprintln(\"  Thresholds BED: $(browser_tracks.thresholds_file)\")\nprintln(\"  Load these files into IGV or JBrowse for interactive inspection.\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Part-8:-Validation-Best-Practices","page":"Step 5: Assembly Validation","title":"Part 8: Validation Best Practices","text":"Guidelines for effective assembly validation\n\nprintln(\"\\n=== Validation Best Practices ===\")\n\nprintln(\"Validation Strategy:\")\nprintln(\"- Use multiple complementary approaches\")\nprintln(\"- Always validate with original data\")\nprintln(\"- Compare with related genomes when available\")\nprintln(\"- Focus on metrics relevant to your research goals\")\nprintln()\nprintln(\"Quality Thresholds:\")\nprintln(\"- BUSCO completeness: >90% for eukaryotes, >95% for prokaryotes\")\nprintln(\"- Assembly QV: >30 for high-quality assemblies\")\nprintln(\"- Read mapping: >95% of reads should map\")\nprintln(\"- Contig N50: Should be substantial fraction of chromosome size\")\nprintln()\nprintln(\"Common Pitfalls:\")\nprintln(\"- Relying on single validation metric\")\nprintln(\"- Ignoring biological context\")\nprintln(\"- Not validating with original data\")\nprintln(\"- Accepting assemblies without proper validation\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Part-9:-Troubleshooting-Assembly-Issues","page":"Step 5: Assembly Validation","title":"Part 9: Troubleshooting Assembly Issues","text":"Identify and address common assembly problems\n\nprintln(\"\\n=== Troubleshooting Assembly Issues ===\")","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Common-Problems-and-Solutions","page":"Step 5: Assembly Validation","title":"Common Problems and Solutions","text":"Systematic approach to assembly problem diagnosis\n\nprintln(\"--- Common Assembly Problems ---\")\n\nproblems_solutions = Dict(\n    \"Low contiguity\" => [\n        \"Increase read length or coverage\",\n        \"Optimize assembly parameters\",\n        \"Use scaffolding approaches\",\n        \"Check for contamination\"\n    ],\n    \"Poor gene completeness\" => [\n        \"Check assembly coverage\",\n        \"Examine repeat resolution\",\n        \"Validate gene prediction parameters\",\n        \"Consider alternative assemblers\"\n    ],\n    \"High error rate\" => [\n        \"Increase polishing iterations\",\n        \"Check read quality\",\n        \"Validate assembly parameters\",\n        \"Consider consensus approaches\"\n    ],\n    \"Missing sequences\" => [\n        \"Check for contamination filtering\",\n        \"Examine coverage bias\",\n        \"Validate input data quality\",\n        \"Consider hybrid approaches\"\n    ]\n)\n\nfor (problem, solutions) in problems_solutions\n    println(\"$problem:\")\n    for solution in solutions\n        println(\"  - $solution\")\n    end\n    println()\nend","category":"section"},{"location":"generated/tutorials/05_assembly_validation/#Summary","page":"Step 5: Assembly Validation","title":"Summary","text":"println(\"=== Assembly Validation Summary ===\")\nprintln(\"✓ Understanding multiple validation approaches\")\nprintln(\"✓ Implementing reference-based validation techniques\")\nprintln(\"✓ Applying reference-free validation methods\")\nprintln(\"✓ Functional validation through gene completeness\")\nprintln(\"✓ Comparative validation across multiple assemblies\")\nprintln(\"✓ Statistical validation and confidence assessment\")\nprintln(\"✓ Integrated quality scoring and reporting\")\nprintln(\"✓ Troubleshooting common assembly issues\")\n\nprintln(\"Results saved in: $(output_dir)\")\nprintln(\"\\nNext: Tutorial 6 - Gene Annotation\")\n\nnothing","category":"section"},{"location":"generated/tutorials/14_mash_classification/#Tutorial-14:-Mash-Classification-and-Screening","page":"Step 14b: Mash Classification","title":"Tutorial 14: Mash Classification and Screening","text":"This tutorial demonstrates how to use Mash sketches for quick containment and distance screening against reference sketches.","category":"section"},{"location":"generated/tutorials/14_mash_classification/#Learning-Objectives","page":"Step 14b: Mash Classification","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nHow to sketch reference genomes with Mash\nHow to sketch reads with Mash (-r, -m)\nHow to screen reads against a sketch database\nHow to interpret identity and shared-hash outputs","category":"section"},{"location":"generated/tutorials/14_mash_classification/#Setup","page":"Step 14b: Mash Classification","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/14_mash_classification.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Mycelia\nimport FASTX\nimport Random\n\nRandom.seed!(42)\n\nprintln(\"=== Mash Classification Tutorial ===\")","category":"section"},{"location":"generated/tutorials/14_mash_classification/#Part-1:-Sketching-Reference-Genomes","page":"Step 14b: Mash Classification","title":"Part 1: Sketching Reference Genomes","text":"println(\"\\n--- Reference Sketching ---\")\n\nref_records = [\n    Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=800),\n    Mycelia.random_fasta_record(moltype=:DNA, seed=2, L=800),\n    Mycelia.random_fasta_record(moltype=:DNA, seed=3, L=800)\n]\n\nref_files = String[]\nfor (i, record) in enumerate(ref_records)\n    filename = \"mash_reference_$(i).fasta\"\n    Mycelia.write_fasta(outfile=filename, records=[record])\n    push!(ref_files, filename)\nend\n\nif get(ENV, \"MYCELIA_RUN_EXTERNAL\", \"false\") == \"true\"\n    reference_sketches = Mycelia.run_mash_sketch(\n        input_files=ref_files,\n        outdir=joinpath(pwd(), \"mash_sketches\"),\n        k=21,\n        s=1000\n    ).sketches\n\n    reference_db = Mycelia.run_mash_paste(\n        out_file=joinpath(pwd(), \"mash_sketches\", \"reference_db.msh\"),\n        in_files=reference_sketches\n    )\n\n    println(\"Reference sketch database: $(reference_db)\")\nelse\n    println(\"Skipping Mash reference sketching; set MYCELIA_RUN_EXTERNAL=true to run.\")\nend","category":"section"},{"location":"generated/tutorials/14_mash_classification/#Part-2:-Sketching-Reads","page":"Step 14b: Mash Classification","title":"Part 2: Sketching Reads","text":"println(\"\\n--- Read Sketching ---\")\n\nreads = Mycelia.create_test_reads(String(FASTX.sequence(ref_records[1])), 25, 0.01)\nreads_fastq = \"mash_reads.fastq\"\nMycelia.write_fastq(records=reads, filename=reads_fastq)\n\nif get(ENV, \"MYCELIA_RUN_EXTERNAL\", \"false\") == \"true\"\n    read_sketch = Mycelia.run_mash_sketch(\n        input_files=[reads_fastq],\n        outdir=joinpath(pwd(), \"mash_sketches\"),\n        k=21,\n        s=1000,\n        r=true,\n        min_copies=2\n    ).sketches[1]\n    println(\"Read sketch: $(read_sketch)\")\nelse\n    println(\"Skipping Mash execution; set MYCELIA_RUN_EXTERNAL=true to run sketching.\")\nend","category":"section"},{"location":"generated/tutorials/14_mash_classification/#Part-3:-Screening-Reads-Against-the-Reference-Database","page":"Step 14b: Mash Classification","title":"Part 3: Screening Reads Against the Reference Database","text":"println(\"\\n--- Screening ---\")\n\nif get(ENV, \"MYCELIA_RUN_EXTERNAL\", \"false\") == \"true\"\n    reference_db = joinpath(pwd(), \"mash_sketches\", \"reference_db.msh\")\n    screen_result = Mycelia.run_mash_screen(\n        reference=reference_db,\n        query=reads_fastq,\n        outdir=joinpath(pwd(), \"mash_screen\"),\n        winner_takes_all=true\n    )\n\n    screen_table = Mycelia.parse_mash_screen_output(screen_result.results_tsv)\n    println(screen_table)\nelse\n    println(\"Skipping Mash screening; set MYCELIA_RUN_EXTERNAL=true to run screening.\")\nend","category":"section"},{"location":"generated/tutorials/14_mash_classification/#Part-4:-Interpretation-Notes","page":"Step 14b: Mash Classification","title":"Part 4: Interpretation Notes","text":"Identity is the estimated ANI-like similarity (1.0 is identical).\nShared hashes are the number of shared MinHash sketches; more shared hashes generally imply stronger containment.\nCombine Mash screening with sourmash and sylph to triangulate the most supported pangenome contexts before mapping with minimap2.","category":"section"},{"location":"generated/tutorials/13_rhizomorph_assembly/#Tutorial-13:-Rhizomorph-Assembly-(Assembly-in-5-Minutes)","page":"Step 13: Rhizomorph Assembly","title":"Tutorial 13: Rhizomorph Assembly (Assembly in 5 Minutes)","text":"This tutorial is the updated \"assembly in 5 minutes\" workflow using Mycelia's Rhizomorph assembly pipeline. It walks from data acquisition to assembled contigs with a small viral genome example.","category":"section"},{"location":"generated/tutorials/13_rhizomorph_assembly/#Setup","page":"Step 13: Rhizomorph Assembly","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/13_rhizomorph_assembly.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\nimport Kmers\n\nRandom.seed!(42)\n\nprintln(\"=== Rhizomorph Assembly Tutorial ===\")","category":"section"},{"location":"generated/tutorials/13_rhizomorph_assembly/#Step-1:-Installation-(one-time-setup)","page":"Step 13: Rhizomorph Assembly","title":"Step 1: Installation (one-time setup)","text":"Uncomment if Mycelia is not installed yet.\n\nimport Pkg Pkg.add(url=\"https://github.com/cjprybol/Mycelia.git\")","category":"section"},{"location":"generated/tutorials/13_rhizomorph_assembly/#Step-2:-Download-a-small-reference-genome","page":"Step 13: Rhizomorph Assembly","title":"Step 2: Download a small reference genome","text":"We'll assemble phiX174 (5,386 bp) so the tutorial runs quickly.\n\nprintln(\"Downloading reference genome (phiX174)...\")\nreference_file = Mycelia.download_genome_by_accession(accession=\"NC_001422.1\")\nprintln(\"Reference FASTA: $reference_file\")\n\nref_record = first(Mycelia.open_fastx(reference_file))\nref_length = length(FASTX.sequence(ref_record))\nprintln(\"Reference length: $ref_length bp\")","category":"section"},{"location":"generated/tutorials/13_rhizomorph_assembly/#Step-3:-Simulate-sequencing-reads","page":"Step 13: Rhizomorph Assembly","title":"Step 3: Simulate sequencing reads","text":"For real projects, replace this with your own FASTQ.\n\nprintln(\"Simulating PacBio-style reads...\")\nreads_file = Mycelia.simulate_pacbio_reads(\n    fasta=reference_file,\n    quantity=\"20x\"\n)\nprintln(\"Reads FASTQ: $reads_file\")\n\nreads = collect(Mycelia.open_fastx(reads_file))\nmean_read_length = round(Statistics.mean(length(FASTX.sequence(r)) for r in reads))\ntotal_bases = sum(length(FASTX.sequence(r)) for r in reads)\nprintln(\"Reads loaded: $(length(reads))\")\nprintln(\"Mean read length: $mean_read_length bp\")\nprintln(\"Total bases: $total_bases bp\")","category":"section"},{"location":"generated/tutorials/13_rhizomorph_assembly/#Step-4:-Run-Rhizomorph-assembly","page":"Step 13: Rhizomorph Assembly","title":"Step 4: Run Rhizomorph assembly","text":"The unified Rhizomorph assembly API auto-detects read type and builds the appropriate graph (qualmer graph for FASTQ).\n\nprintln(\"Running Rhizomorph assembly...\")\nstart_time = time()\nassembly = Mycelia.Rhizomorph.assemble_genome(\n    reads;\n    k=31,\n    error_rate=0.01,\n    min_coverage=3\n)\nelapsed = round(time() - start_time, digits=1)\nprintln(\"Assembly completed in $elapsed seconds\")","category":"section"},{"location":"generated/tutorials/13_rhizomorph_assembly/#Step-5:-Inspect-results","page":"Step 13: Rhizomorph Assembly","title":"Step 5: Inspect results","text":"contigs = assembly.contigs\ncontig_names = assembly.contig_names\nprintln(\"Contigs assembled: $(length(contigs))\")\n\nif !isempty(contigs)\n    contig_lengths = [length(contig) for contig in contigs]\n    println(\"Total contig length: $(sum(contig_lengths)) bp\")\n    println(\"Longest contig: $(maximum(contig_lengths)) bp\")\nelse\n    println(\"No contigs were produced; try adjusting parameters.\")\nend\n\nif !isempty(contigs)\n\nValidate against the reference (placeholder metrics for now).\n\n    metrics = Mycelia.Rhizomorph.validate_assembly(assembly; reference=FASTX.sequence(ref_record))\n    println(\"Validation metrics:\")\n    for (key, value) in sort(collect(metrics))\n        println(\"  $key: $value\")\n    end\nend","category":"section"},{"location":"generated/tutorials/13_rhizomorph_assembly/#Step-6:-Save-the-assembly","page":"Step 13: Rhizomorph Assembly","title":"Step 6: Save the assembly","text":"Write contigs to FASTA and, when available, FASTQ with quality scores.\n\nif !isempty(contigs)\n    fasta_records = FASTX.FASTA.Record[]\n    for (name, seq) in zip(contig_names, contigs)\n        push!(fasta_records, FASTX.FASTA.Record(name, seq))\n    end\n    output_fasta = Mycelia.write_fasta(records=fasta_records, outfile=\"phiX174_rhizomorph_assembly.fasta\")\n    println(\"Saved contigs: $output_fasta\")\n\n    if Mycelia.Rhizomorph.has_quality_information(assembly)\n        output_fastq = \"phiX174_rhizomorph_assembly.fastq\"\n        Mycelia.Rhizomorph.write_fastq_contigs(assembly, output_fastq)\n        println(\"Saved quality-aware contigs: $output_fastq\")\n    else\n        println(\"No quality-aware contigs available; FASTQ export skipped.\")\n    end\nend","category":"section"},{"location":"generated/tutorials/13_rhizomorph_assembly/#Step-7:-Optional-k-mer-recovery-check","page":"Step 13: Rhizomorph Assembly","title":"Step 7: Optional k-mer recovery check","text":"Compare 21-mer content between reference and assembly.\n\nif !isempty(contigs)\n    output_fasta = \"phiX174_rhizomorph_assembly.fasta\"\n    if isfile(output_fasta)\n        ref_kmers = Mycelia.count_canonical_kmers(Kmers.DNAKmer{21}, reference_file)\n        asm_kmers = Mycelia.count_canonical_kmers(Kmers.DNAKmer{21}, output_fasta)\n        shared_kmers = length(intersect(keys(ref_kmers), keys(asm_kmers)))\n        kmer_recovery = round(100 * shared_kmers / length(ref_kmers), digits=1)\n        println(\"K-mer recovery rate (21-mers): $kmer_recovery%\")\n    else\n        println(\"K-mer recovery skipped; assembly FASTA not found.\")\n    end\nend","category":"section"},{"location":"generated/tutorials/13_rhizomorph_assembly/#Next-steps","page":"Step 13: Rhizomorph Assembly","title":"Next steps","text":"Replace the simulated reads with your own FASTQ inputs.\nTry alternate parameters (k, mincoverage, errorrate).\nExplore Rhizomorph graph building functions for debugging and visualization.","category":"section"},{"location":"generated/tutorials/run_all_tutorials/#Run-All-Mycelia-Tutorials","page":"Run All Tutorials","title":"Run All Mycelia Tutorials","text":"This script executes all Mycelia tutorials in sequence. Use with caution - may take significant time and resources. External tool steps are gated by MYCELIA_RUN_EXTERNAL=true.","category":"section"},{"location":"generated/tutorials/run_all_tutorials/#Usage","page":"Run All Tutorials","title":"Usage","text":"# Run all tutorials\njulia --project=. tutorials/run_all_tutorials.jl\n\n# Run specific tutorial\njulia --project=. tutorials/01_data_acquisition.jl\n\n# Convert to notebooks\njulia --project=. -e 'include(\"tutorials/run_all_tutorials.jl\"); convert_all_to_notebooks()'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Dates\nimport Literate\n\nList of all tutorials in execution order\n\nTUTORIALS = [\n    \"01_data_acquisition.jl\",\n    \"02_quality_control.jl\",\n    \"03_kmer_analysis.jl\",\n    \"04_genome_assembly.jl\",\n    \"04_graph_type_tutorials.jl\",\n    \"05_assembly_validation.jl\",\n    \"06_gene_annotation.jl\",\n    \"07_comparative_genomics.jl\",\n    \"08_tool_integration.jl\",\n    \"09_round_trip_01_string_graphs.jl\",\n    \"09_round_trip_02_ngram_to_string.jl\",\n    \"09_round_trip_03_fasta_sequences.jl\",\n    \"09_round_trip_04_kmer_to_sequence.jl\",\n    \"09_round_trip_05_fastq_graphs.jl\",\n    \"09_round_trip_06_qualmer_graphs.jl\",\n    \"10_viroid_assembly_workflow.jl\",\n    \"11_reduced_amino_acid_alphabets.jl\",\n    \"12_coverm_coverage.jl\",\n    \"13_rhizomorph_assembly.jl\",\n    \"14_binning_workflow.jl\",\n    \"14_mash_classification.jl\",\n    \"15_round_trip_benchmarking.jl\",\n    \"16_un_corpus_ngram_vs_token_graphs.jl\",\n    \"17_viroid_sketch_round_trip.jl\",\n    \"18_advanced_assembly_theory_and_practice.jl\",\n]\n\n\"\"\"\n    run_all_tutorials()\n\nExecute all tutorials in sequence, collecting timing and status information.\n\"\"\"\nfunction run_all_tutorials()\n    println(\"=== Running All Mycelia Tutorials ===\")\n    println(\"Start time: $(Dates.now())\")\n    println()\n\n    results = []\n    total_start = time()\n\n    for tutorial in TUTORIALS\n        if isfile(tutorial)\n            println(\"Running $tutorial...\")\n            start_time = time()\n\n            try\n                # Execute tutorial\n                include(tutorial)\n\n                elapsed = time() - start_time\n                push!(results, (tutorial, :success, elapsed))\n                println(\"✓ $tutorial completed in $(round(elapsed, digits=2))s\")\n\n            catch e\n                elapsed = time() - start_time\n                push!(results, (tutorial, :error, elapsed, e))\n                println(\"✗ $tutorial failed after $(round(elapsed, digits=2))s\")\n                println(\"  Error: $e\")\n            end\n\n            println()\n        else\n            println(\"⚠ $tutorial not found, skipping...\")\n            push!(results, (tutorial, :not_found, 0.0))\n        end\n    end\n\n    total_elapsed = time() - total_start\n\n    # Print summary\n    println(\"=== Tutorial Execution Summary ===\")\n    println(\"Total time: $(round(total_elapsed, digits=2))s\")\n    println()\n\n    successful = 0\n    for (tutorial, status, elapsed, error...) in results\n        if status == :success\n            println(\"✓ $tutorial ($(round(elapsed, digits=2))s)\")\n            successful += 1\n        elseif status == :error\n            println(\"✗ $tutorial ($(round(elapsed, digits=2))s) - $(error[1])\")\n        else\n            println(\"⚠ $tutorial (not found)\")\n        end\n    end\n\n    println()\n    println(\"Successful: $successful/$(length(TUTORIALS))\")\n    println(\"End time: $(Dates.now())\")\n\n    return results\nend\n\n\"\"\"\n    convert_all_to_notebooks()\n\nConvert all tutorials to Jupyter notebooks using Literate.jl.\n\"\"\"\nfunction convert_all_to_notebooks()\n    println(\"=== Converting Tutorials to Notebooks ===\")\n\n    # Create notebooks directory if it doesn't exist\n    notebooks_dir = \"notebooks\"\n    if !isdir(notebooks_dir)\n        mkdir(notebooks_dir)\n    end\n\n    for tutorial in TUTORIALS\n        if isfile(tutorial)\n            println(\"Converting $tutorial to notebook...\")\n\n            try\n                # Convert to notebook\n                Literate.notebook(tutorial, notebooks_dir, execute=false)\n                println(\"✓ Converted $tutorial\")\n\n            catch e\n                println(\"✗ Failed to convert $tutorial: $e\")\n            end\n        else\n            println(\"⚠ $tutorial not found, skipping...\")\n        end\n    end\n\n    println()\n    println(\"Notebooks saved to: $notebooks_dir\")\nend\n\n\"\"\"\n    run_tutorial(tutorial_name)\n\nRun a specific tutorial by name.\n\"\"\"\nfunction run_tutorial(tutorial_name)\n    if !endswith(tutorial_name, \".jl\")\n        tutorial_name *= \".jl\"\n    end\n\n    if isfile(tutorial_name)\n        println(\"Running $tutorial_name...\")\n        start_time = time()\n\n        try\n            include(tutorial_name)\n            elapsed = time() - start_time\n            println(\"✓ $tutorial_name completed in $(round(elapsed, digits=2))s\")\n            return true\n        catch e\n            elapsed = time() - start_time\n            println(\"✗ $tutorial_name failed after $(round(elapsed, digits=2))s\")\n            println(\"  Error: $e\")\n            return false\n        end\n    else\n        println(\"✗ $tutorial_name not found\")\n        return false\n    end\nend\n\nMain execution\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    # Only run if this script is executed directly\n    if length(ARGS) == 0\n        # Run all tutorials\n        results = run_all_tutorials()\n    elseif ARGS[1] == \"convert\"\n        # Convert to notebooks\n        convert_all_to_notebooks()\n    else\n        # Run specific tutorial\n        tutorial_name = ARGS[1]\n        run_tutorial(tutorial_name)\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Round-Trip-Tutorial-2:-String-Data-N-gram-Graphs-String-Graphs-Reconstruction","page":"Round-Trip 02: N-gram to String","title":"Round-Trip Tutorial 2: String Data → N-gram Graphs → String Graphs → Reconstruction","text":"This tutorial demonstrates the hierarchical graph conversion workflow in Mycelia, showing how fixed-length N-gram graphs can be simplified into variable-length String graphs. This represents the fundamental pattern of graph hierarchy used throughout the Mycelia system.","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Learning-Objectives","page":"Round-Trip 02: N-gram to String","title":"Learning Objectives","text":"By the end of this tutorial, you will:\n\nUnderstand the hierarchical relationship between N-gram and String graphs\nLearn to convert fixed-length graphs to variable-length representations\nPerform graph simplification and path collapse operations\nCompare reconstruction quality across graph representations\nAnalyze the trade-offs between graph complexity and assembly accuracy\n\nFrom the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/09_round_trip_02_ngram_to_string.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Mycelia\nimport Statistics\nimport Random","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Understanding-Graph-Hierarchy","page":"Round-Trip 02: N-gram to String","title":"Understanding Graph Hierarchy","text":"The Mycelia system implements a hierarchical graph structure where fixed-length graphs serve as the foundation for variable-length simplified graphs.\n\nprintln(\"=\"^80)\nprintln(\"ROUND-TRIP TUTORIAL 2: N-GRAM TO STRING GRAPH HIERARCHY\")\nprintln(\"=\"^80)\n\nprintln(\"\\n📚 GRAPH HIERARCHY OVERVIEW:\")\nprintln(\"  Fixed-Length Graphs (Foundation):\")\nprintln(\"    • N-gram graphs: Fixed-size text fragments\")\nprintln(\"    • K-mer graphs: Fixed-size biological sequences\")\nprintln(\"    • Qualmer graphs: Quality-aware fixed-size sequences\")\nprintln()\nprintln(\"  Variable-Length Graphs (Simplified Products):\")\nprintln(\"    • String graphs: Variable-length text sequences\")\nprintln(\"    • BioSequence graphs: Variable-length biological sequences\")\nprintln(\"    • Quality BioSequence graphs: Quality-aware variable sequences\")\nprintln()\nprintln(\"  This tutorial: N-gram → String graph conversion\")","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Data-Preparation-with-Hierarchical-Complexity","page":"Round-Trip 02: N-gram to String","title":"Data Preparation with Hierarchical Complexity","text":"Create test data that will demonstrate different aspects of graph simplification.\n\ntest_datasets = [\n    (\n        name = \"Simple Repetitive\",\n        text = \"ABCABCABCABC\",\n        description = \"High repetition, should simplify well\"\n    ),\n    (\n        name = \"Linear Sequence\",\n        text = \"ABCDEFGHIJKLMNOP\",\n        description = \"Linear path, should collapse to single string\"\n    ),\n    (\n        name = \"Branching Pattern\",\n        text = \"ABCXYZABCDEFABCPQR\",\n        description = \"Branching structure, complex simplification\"\n    ),\n    (\n        name = \"Real Text\",\n        text = \"The quick brown fox jumps over the lazy dog\",\n        description = \"Natural language with spaces and complexity\"\n    ),\n    (\n        name = \"DNA-like Sequence\",\n        text = \"ATCGATCGATCGATCGTAGCTAGCTAGCT\",\n        description = \"Biological sequence simulation\"\n    )\n]\n\nprintln(\"\\n1. HIERARCHICAL DATA PREPARATION\")\nprintln(\"-\"^50)\n\nfor (i, dataset) in enumerate(test_datasets)\n    println(\"Dataset $i: $(dataset.name)\")\n    println(\"  Text: \\\"$(dataset.text)\\\"\")\n    println(\"  Description: $(dataset.description)\")\n    println(\"  Length: $(length(dataset.text)) characters\")\n    println()\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Phase-1:-N-gram-Graph-Construction","page":"Round-Trip 02: N-gram to String","title":"Phase 1: N-gram Graph Construction","text":"Build the foundation fixed-length N-gram graphs.\n\nprintln(\"\\n2. PHASE 1: N-GRAM GRAPH CONSTRUCTION\")\nprintln(\"-\"^50)\n\nngram_results = Dict()\n\nfor n in [3, 4, 5]\n    println(\"\\\\nConstructing $(n)-gram graphs:\")\n\n    for (i, dataset) in enumerate(test_datasets)\n        if length(dataset.text) >= n\n            try\n                # Build N-gram graph (Rhizomorph)\n                graph = Mycelia.Rhizomorph.build_ngram_graph([dataset.text], n; dataset_id=\"$(replace(dataset.name, \" \" => \"_\"))_n$(n)\")\n\n                # Extract statistics\n                vertices = collect(Mycelia.MetaGraphsNext.labels(graph))\n                num_vertices = length(vertices)\n                expected_ngrams = length(dataset.text) - n + 1\n\n                # Calculate graph properties\n                compression_ratio = num_vertices / expected_ngrams\n\n                # Store results\n                key = \"$(dataset.name)_$(n)\"\n                ngram_results[key] = (\n                    dataset = dataset,\n                    graph = graph,\n                    n = n,\n                    vertices = vertices,\n                    num_vertices = num_vertices,\n                    expected_ngrams = expected_ngrams,\n                    compression_ratio = compression_ratio\n                )\n\n                println(\"  $(dataset.name): $(num_vertices)/$(expected_ngrams) vertices ($(round(compression_ratio, digits=3)) compression)\")\n\n                # Show example n-grams\n                if num_vertices > 0\n                    example_count = min(3, num_vertices)\n                    println(\"    Examples: $(vertices[1:example_count])\")\n                end\n\n            catch e\n                println(\"  $(dataset.name): Construction failed - $(typeof(e))\")\n            end\n        else\n            println(\"  $(dataset.name): Text too short for $(n)-grams\")\n        end\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Phase-2:-Graph-Analysis-and-Path-Detection","page":"Round-Trip 02: N-gram to String","title":"Phase 2: Graph Analysis and Path Detection","text":"Analyze the N-gram graphs to understand their structure before simplification.\n\nprintln(\"\\n3. PHASE 2: GRAPH ANALYSIS AND PATH DETECTION\")\nprintln(\"-\"^50)\n\nfunction analyze_ngram_graph_structure(graph, description)\n    \"\"\"Analyze structural properties of an N-gram graph.\"\"\"\n\n    vertices = collect(Mycelia.MetaGraphsNext.labels(graph))\n    num_vertices = length(vertices)\n\n    if num_vertices == 0\n        return (vertices=0, linear_paths=0, branch_points=0, complexity=\"empty\")\n    end\n\n    # Basic connectivity analysis\n    # Note: This is a simplified analysis - full graph traversal would require edge information\n\n    # Analyze overlap patterns\n    overlap_count = 0\n    potential_linear = 0\n\n    for i in 1:length(vertices)\n        for j in (i+1):length(vertices)\n            v1, v2 = vertices[i], vertices[j]\n            if length(v1) > 1 && length(v2) > 1\n                # Check for potential overlap (simplified heuristic)\n                if v1[2:end] == v2[1:end-1] || v2[2:end] == v1[1:end-1]\n                    overlap_count += 1\n                end\n            end\n        end\n    end\n\n    # Estimate complexity\n    complexity = if overlap_count == 0\n        \"isolated\"\n    elseif overlap_count <= num_vertices\n        \"linear\"\n    else\n        \"complex\"\n    end\n\n    println(\"  $description:\")\n    println(\"    Vertices: $num_vertices\")\n    println(\"    Potential overlaps: $overlap_count\")\n    println(\"    Estimated complexity: $complexity\")\n\n    return (\n        vertices = num_vertices,\n        overlaps = overlap_count,\n        complexity = complexity\n    )\nend\n\n# Analyze representative graphs\nprintln(\"Analyzing N-gram graph structures:\")\nfor n in [3, 4]\n    for dataset in test_datasets[1:3]  ## Analyze first 3 datasets\n        key = \"$(dataset.name)_$(n)\"\n        if haskey(ngram_results, key)\n            result = ngram_results[key]\n            analyze_ngram_graph_structure(result.graph, \"$(dataset.name) $(n)-gram\")\n        end\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Phase-3:-String-Graph-Conversion-(Rhizomorph)","page":"Round-Trip 02: N-gram to String","title":"Phase 3: String Graph Conversion (Rhizomorph)","text":"Convert N-gram graphs to variable-length String graphs using Rhizomorph contigs.\n\nprintln(\"\\n4. PHASE 3: STRING GRAPH CONVERSION (CONCEPTUAL)\")\nprintln(\"-\"^50)\n\nfunction convert_ngram_to_string_graph(ngram_result)\n    \"\"\"Convert N-gram graph to variable-length String graph using Rhizomorph contigs.\"\"\"\n    contigs = Mycelia.Rhizomorph.find_contigs_next(ngram_result.graph; min_contig_length=1)\n    contig_strings = [string(contig.sequence) for contig in contigs]\n    if isempty(contig_strings)\n        contig_strings = [string(label) for label in ngram_result.vertices]\n    end\n    dataset_label = replace(ngram_result.dataset.name, \" \" => \"_\")\n    min_overlap = max(1, ngram_result.n - 1)\n    string_graph = Mycelia.Rhizomorph.build_string_graph(\n        contig_strings;\n        dataset_id=\"$(dataset_label)_n$(ngram_result.n)\",\n        min_overlap=min_overlap\n    )\n    string_vertices = collect(Mycelia.MetaGraphsNext.labels(string_graph))\n    return (\n        graph = string_graph,\n        vertices = string_vertices,\n        contig_strings = contig_strings,\n        min_overlap = min_overlap\n    )\nend\n\nstring_conversion_results = Dict()\n\nprintln(\"Converting N-gram graphs to String graphs:\")\nfor (key, result) in ngram_results\n    conversion = convert_ngram_to_string_graph(result)\n\n    string_conversion_results[key] = (\n        original_ngram_result = result,\n        string_graph = conversion.graph,\n        string_vertices = conversion.vertices,\n        contig_strings = conversion.contig_strings,\n        conversion_ratio = length(conversion.vertices) / max(1, result.num_vertices)\n    )\n\n    println(\"  $(key):\")\n    println(\"    N-gram vertices: $(result.num_vertices)\")\n    println(\"    String vertices: $(length(conversion.vertices))\")\n    println(\"    Conversion ratio: $(round(length(conversion.vertices) / max(1, result.num_vertices), digits=3))\")\n\n    if !isempty(conversion.vertices)\n        example_count = min(2, length(conversion.vertices))\n        println(\"    Example strings: $(conversion.vertices[1:example_count])\")\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Phase-4:-Reconstruction-and-Round-Trip-Validation","page":"Round-Trip 02: N-gram to String","title":"Phase 4: Reconstruction and Round-Trip Validation","text":"Validate the complete round-trip workflow through both graph representations.\n\nprintln(\"\\n5. PHASE 4: RECONSTRUCTION AND ROUND-TRIP VALIDATION\")\nprintln(\"-\"^50)\n\nfunction validate_round_trip(original_text, ngram_graph, string_graph, n)\n    \"\"\"Validate the round-trip reconstruction quality.\"\"\"\n\n    # Method 1: Direct N-gram assembly\n    try\n        ngram_assembly = String[]\n        paths = Mycelia.Rhizomorph.find_eulerian_paths_next(ngram_graph)\n        for path in paths\n            if !isempty(path)\n                push!(ngram_assembly, string(Mycelia.Rhizomorph.path_to_sequence(path, ngram_graph)))\n            end\n        end\n        if isempty(ngram_assembly)\n            contigs = Mycelia.Rhizomorph.find_contigs_next(ngram_graph; min_contig_length=1)\n            ngram_assembly = [string(contig.sequence) for contig in contigs]\n        end\n        ngram_success = !isempty(ngram_assembly)\n\n        # Find best N-gram reconstruction\n        best_ngram_similarity = 0.0\n        best_ngram_reconstruction = \"\"\n\n        for reconstruction in ngram_assembly\n            similarity = calculate_similarity(original_text, reconstruction)\n            if similarity > best_ngram_similarity\n                best_ngram_similarity = similarity\n                best_ngram_reconstruction = reconstruction\n            end\n        end\n\n    catch e\n        ngram_success = false\n        best_ngram_similarity = 0.0\n        best_ngram_reconstruction = \"\"\n        ngram_assembly = String[]\n    end\n\n    # Method 2: String graph simulation\n    string_contigs = Mycelia.Rhizomorph.find_contigs_next(string_graph; min_contig_length=1)\n    string_reconstructions = [string(contig.sequence) for contig in string_contigs]\n    if isempty(string_reconstructions)\n        string_reconstructions = [string(label) for label in Mycelia.MetaGraphsNext.labels(string_graph)]\n    end\n    string_success = !isempty(string_reconstructions)\n    best_string_similarity = 0.0\n    best_string_reconstruction = \"\"\n    for reconstruction in string_reconstructions\n        similarity = calculate_similarity(original_text, reconstruction)\n        if similarity > best_string_similarity\n            best_string_similarity = similarity\n            best_string_reconstruction = reconstruction\n        end\n    end\n\n    return (\n        ngram_success = ngram_success,\n        ngram_similarity = best_ngram_similarity,\n        ngram_reconstruction = best_ngram_reconstruction,\n        string_success = string_success,\n        string_similarity = best_string_similarity,\n        string_reconstruction = best_string_reconstruction,\n        comparison = best_ngram_similarity > best_string_similarity ? \"N-gram better\" : \"String better\"\n    )\nend\n\nfunction calculate_similarity(original::String, reconstructed::String)\n    \"\"\"Calculate character-level similarity between strings.\"\"\"\n    min_len = min(length(original), length(reconstructed))\n    max_len = max(length(original), length(reconstructed))\n\n    if max_len == 0\n        return 1.0\n    end\n\n    matches = 0\n    for i in 1:min_len\n        if original[i] == reconstructed[i]\n            matches += 1\n        end\n    end\n\n    return matches / max_len\nend\n\nvalidation_results = Dict()\n\nprintln(\"Validating round-trip reconstructions:\")\nfor (key, conversion_result) in string_conversion_results\n    ngram_result = conversion_result.original_ngram_result\n    string_graph = conversion_result.string_graph\n\n    validation = validate_round_trip(\n        ngram_result.dataset.text,\n        ngram_result.graph,\n        string_graph,\n        ngram_result.n\n    )\n\n    validation_results[key] = validation\n\n    println(\"\\\\n  $(key):\")\n    println(\"    Original: \\\"$(ngram_result.dataset.text)\\\"\")\n    println(\"    N-gram reconstruction: $(validation.ngram_success ? \"SUCCESS\" : \"FAILED\")\")\n    if validation.ngram_success\n        println(\"      Similarity: $(round(validation.ngram_similarity, digits=3))\")\n        println(\"      Result: \\\"$(validation.ngram_reconstruction)\\\"\")\n    end\n    println(\"    String reconstruction: $(validation.string_success ? \"SUCCESS\" : \"FAILED\")\")\n    if validation.string_success\n        println(\"      Similarity: $(round(validation.string_similarity, digits=3))\")\n        println(\"      Result: \\\"$(validation.string_reconstruction)\\\"\")\n    end\n    println(\"    Comparison: $(validation.comparison)\")\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Performance-and-Complexity-Analysis","page":"Round-Trip 02: N-gram to String","title":"Performance and Complexity Analysis","text":"Compare the computational characteristics of both graph types.\n\nprintln(\"\\n6. PERFORMANCE AND COMPLEXITY ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_graph_efficiency(ngram_results, string_results)\n    \"\"\"Analyze computational efficiency of both graph types.\"\"\"\n\n    println(\"Graph type comparison:\")\n\n    total_ngram_vertices = 0\n    total_string_vertices = 0\n    total_original_length = 0\n\n    for (key, ngram_result) in ngram_results\n        if haskey(string_results, key)\n            string_result = string_results[key]\n\n            total_ngram_vertices += ngram_result.num_vertices\n            total_string_vertices += length(string_result.string_vertices)\n            total_original_length += length(ngram_result.dataset.text)\n        end\n    end\n\n    avg_ngram_compression = total_ngram_vertices / total_original_length\n    avg_string_compression = total_string_vertices / total_original_length\n    hierarchy_compression = total_string_vertices / total_ngram_vertices\n\n    println(\"  Average N-gram compression: $(round(avg_ngram_compression, digits=3))\")\n    println(\"  Average String compression: $(round(avg_string_compression, digits=3))\")\n    println(\"  Hierarchical compression (String/N-gram): $(round(hierarchy_compression, digits=3))\")\n\n    println(\"\\\\n  Memory efficiency estimation:\")\n    println(\"    N-gram graphs: Higher vertex count, fixed-size vertices\")\n    println(\"    String graphs: Lower vertex count, variable-size vertices\")\n    println(\"    Trade-off: Graph complexity vs. vertex size\")\n\n    return (\n        ngram_compression = avg_ngram_compression,\n        string_compression = avg_string_compression,\n        hierarchy_compression = hierarchy_compression\n    )\nend\n\nefficiency_analysis = analyze_graph_efficiency(ngram_results, string_conversion_results)","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Real-World-Application:-Multi-Scale-Text-Analysis","page":"Round-Trip 02: N-gram to String","title":"Real-World Application: Multi-Scale Text Analysis","text":"Demonstrate the practical value of hierarchical graph representations.\n\nprintln(\"\\n7. REAL-WORLD APPLICATION: MULTI-SCALE TEXT ANALYSIS\")\nprintln(\"-\"^50)\n\nExample: Analyzing text at multiple resolutions\n\ncomplex_text = \"In bioinformatics, sequence analysis involves the process of subjecting DNA, RNA, or protein sequences to any of a wide range of analytical methods to understand their features, function, structure, or evolution\"\n\nprintln(\"Multi-scale analysis of complex text:\")\nprintln(\"Text: \\\"$(complex_text[1:60])...\\\"\")\nprintln(\"Length: $(length(complex_text)) characters\")\n\n# Build graphs at different scales\nscales = [\n    (n=3, description=\"Fine-grained analysis\"),\n    (n=5, description=\"Medium-grained analysis\"),\n    (n=7, description=\"Coarse-grained analysis\")\n]\n\nprintln(\"\\\\nBuilding multi-scale representations:\")\nfor scale in scales\n    if length(complex_text) >= scale.n\n        ngram_graph = Mycelia.Rhizomorph.build_ngram_graph([complex_text], scale.n; dataset_id=\"multiscale_n$(scale.n)\")\n        ngram_vertices = length(Mycelia.MetaGraphsNext.labels(ngram_graph))\n        compression = ngram_vertices / (length(complex_text) - scale.n + 1)\n\n        println(\"  $(scale.description) (n=$(scale.n)):\")\n        println(\"    N-gram vertices: $ngram_vertices\")\n        println(\"    Compression ratio: $(round(compression, digits=3))\")\n\n        # Simulate string graph conversion\n        estimated_string_count = max(1, ngram_vertices ÷ 4)  ## Rough estimate\n        string_compression = estimated_string_count / (length(complex_text) - scale.n + 1)\n\n        println(\"    Estimated string vertices: $estimated_string_count\")\n        println(\"    String compression ratio: $(round(string_compression, digits=3))\")\n    end\nend\n\nprintln(\"\\\\nInsights from multi-scale analysis:\")\nprintln(\"  • Fine-grained: High detail, more vertices, better local patterns\")\nprintln(\"  • Coarse-grained: Lower detail, fewer vertices, global structure\")\nprintln(\"  • Hierarchical conversion: Further compression with controlled information loss\")","category":"section"},{"location":"generated/tutorials/09_round_trip_02_ngram_to_string/#Tutorial-Summary-and-Best-Practices","page":"Round-Trip 02: N-gram to String","title":"Tutorial Summary and Best Practices","text":"Summarize key learnings and provide guidance for application.\n\nprintln(\"\\n\" * \"=\"^80)\nprintln(\"TUTORIAL SUMMARY AND BEST PRACTICES\")\nprintln(\"=\"^80)\n\n# Calculate overall statistics\ntotal_validations = length(validation_results)\nsuccessful_ngram = sum(1 for v in values(validation_results) if v.ngram_success)\nsuccessful_string = sum(1 for v in values(validation_results) if v.string_success)\n\navg_ngram_similarity = Statistics.mean([v.ngram_similarity for v in values(validation_results)])\navg_string_similarity = Statistics.mean([v.string_similarity for v in values(validation_results)])\n\nprintln(\"\\\\n✅ HIERARCHICAL WORKFLOW COMPLETION:\")\nprintln(\"  1. N-gram Graph Construction: ✓ Multiple scales tested\")\nprintln(\"  2. Graph Structure Analysis: ✓ Complexity patterns identified\")\nprintln(\"  3. String Graph Conversion: ✓ Simulation completed\")\nprintln(\"  4. Round-trip Validation: ✓ Quality metrics calculated\")\nprintln(\"  5. Performance Analysis: ✓ Efficiency trade-offs analyzed\")\nprintln(\"  6. Multi-scale Application: ✓ Real-world example demonstrated\")\n\nprintln(\"\\\\n📊 QUANTITATIVE RESULTS:\")\nprintln(\"  Total test cases: $total_validations\")\nprintln(\"  N-gram reconstruction success: $successful_ngram/$total_validations ($(round(successful_ngram/total_validations*100, digits=1))%)\")\nprintln(\"  String reconstruction success: $successful_string/$total_validations ($(round(successful_string/total_validations*100, digits=1))%)\")\nprintln(\"  Average N-gram similarity: $(round(avg_ngram_similarity, digits=3))\")\nprintln(\"  Average String similarity: $(round(avg_string_similarity, digits=3))\")\nprintln(\"  Hierarchical compression: $(round(efficiency_analysis.hierarchy_compression, digits=3))\")\n\nprintln(\"\\\\n🔄 HIERARCHICAL WORKFLOW VALIDATED:\")\nprintln(\"  String Data → N-gram Graphs → String Graphs → Reconstruction\")\nprintln(\"  ✓ Fixed-length foundation graphs constructed successfully\")\nprintln(\"  ✓ Variable-length simplified graphs derived\")\nprintln(\"  ✓ Quality maintained through conversion process\")\nprintln(\"  ✓ Performance trade-offs quantified\")\n\nprintln(\"\\\\n💡 KEY INSIGHTS:\")\nprintln(\"  • Hierarchical graphs provide multi-resolution analysis capabilities\")\nprintln(\"  • Fixed-length graphs offer detailed local structure information\")\nprintln(\"  • Variable-length graphs provide global structure with compression\")\nprintln(\"  • Conversion quality depends on text complexity and repetition patterns\")\nprintln(\"  • Multi-scale analysis reveals different aspects of data structure\")\n\nprintln(\"\\\\n📋 BEST PRACTICES:\")\nprintln(\"  • Use smaller n-grams (3-4) for detailed local analysis\")\nprintln(\"  • Use larger n-grams (5-7) for global structure identification\")\nprintln(\"  • Apply hierarchical conversion when memory efficiency is critical\")\nprintln(\"  • Validate reconstruction quality at each conversion step\")\nprintln(\"  • Consider text complexity when choosing graph representation\")\n\nprintln(\"\\\\n🚀 NEXT STEPS IN GRAPH HIERARCHY:\")\nprintln(\"  • Tutorial 3: FASTA sequences → Sequence graphs → Reconstruction\")\nprintln(\"  • Tutorial 4: FASTA → K-mer graphs → Sequence graphs (biological hierarchy)\")\nprintln(\"  • Tutorial 5: FASTQ → FASTQ graphs (direct quality-aware workflows)\")\nprintln(\"  • Tutorial 6: FASTQ → Qualmer graphs → FASTQ graphs (quality hierarchy)\")\n\nprintln(\"\\\\n🎯 PATTERNS FOR BIOLOGICAL GRAPHS:\")\nprintln(\"  The hierarchical patterns demonstrated here with text apply to:\")\nprintln(\"  • DNA/RNA sequences: Fixed k-mers → Variable-length contigs\")\nprintln(\"  • Quality data: Fixed qualmers → Quality-aware sequences\")\nprintln(\"  • Protein sequences: Fixed amino acid k-mers → Domain sequences\")\n\nprintln(\"\\\\n\" * \"=\"^80)\nprintln(\"Hierarchical graph conversion workflow mastered!\")\nprintln(\"Ready for biological sequence applications in Tutorial 3!\")\nprintln(\"=\"^80)","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Tutorial-7:-Comparative-Genomics-and-Pangenome-Analysis","page":"Step 7: Comparative Genomics","title":"Tutorial 7: Comparative Genomics and Pangenome Analysis","text":"This tutorial covers comparative genomics approaches, including pangenome construction, phylogenetic analysis, and evolutionary genomics.","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Learning-Objectives","page":"Step 7: Comparative Genomics","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nPangenome concepts and construction methods\nCore, accessory, and unique gene identification\nPhylogenetic tree construction and interpretation\nSynteny analysis and chromosomal rearrangements\nPopulation genomics and evolutionary analysis\nGraph-based genome representation","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Setup","page":"Step 7: Comparative Genomics","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/07_comparative_genomics.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\nimport Graphs\nimport Kmers\n\nRandom.seed!(42)","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-1:-Pangenome-Concepts","page":"Step 7: Comparative Genomics","title":"Part 1: Pangenome Concepts","text":"Pangenomes represent the complete set of genes within a species or closely related group of organisms.\n\nprintln(\"=== Comparative Genomics Tutorial ===\")\n\nprintln(\"Pangenome Components:\")\nprintln(\"- Core genome: Genes present in all individuals\")\nprintln(\"- Accessory genome: Genes present in some individuals\")\nprintln(\"- Unique genes: Genes present in single individuals\")\nprintln(\"- Variable genes: Genes with presence/absence variation\")\nprintln()\nprintln(\"Pangenome Types:\")\nprintln(\"- Open pangenome: Continues to expand with new genomes\")\nprintln(\"- Closed pangenome: Reaches saturation quickly\")\nprintln(\"- Mixed pangenome: Shows both open and closed characteristics\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-2:-Data-Preparation-for-Pangenome-Analysis","page":"Step 7: Comparative Genomics","title":"Part 2: Data Preparation for Pangenome Analysis","text":"Prepare multiple genomes for comparative analysis\n\nprintln(\"\\n=== Data Preparation ===\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Simulating-Multiple-Genomes","page":"Step 7: Comparative Genomics","title":"Simulating Multiple Genomes","text":"Create a set of related genomes for pangenome analysis\n\nprintln(\"--- Simulating Related Genomes ---\")\n\nGenerate core genes present in all genomes\n\nn_genomes = 5\ncore_genes = 200\naccessory_genes = 100\nunique_genes = 50\n\nGenerate simulated genomes with different characteristics\n\ngenome_files = String[]\nfor i in 1:n_genomes\n    genome_size = core_genes * 1000 + rand(0:accessory_genes) * 1000 + rand(0:unique_genes) * 1000\n    genome = Mycelia.random_fasta_record(moltype=:DNA, seed=i, L=genome_size)\n    filename = \"genome_$i.fasta\"\n    Mycelia.write_fasta(outfile=filename, records=[genome])\n    push!(genome_files, filename)\nend\n\nprintln(\"Generated $(n_genomes) genomes:\")\nfor (i, file) in enumerate(genome_files)\n    size = filesize(file)\n    println(\"  Genome $i: $file ($(size) bytes)\")\nend","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-2b:-Sketch-Guided-Pangenome-Context-Selection","page":"Step 7: Comparative Genomics","title":"Part 2b: Sketch-Guided Pangenome Context Selection","text":"Use k-mer sketching against references, sequences, and reference paths to identify which pangenome contexts are supported by the sample, then map against the reduced reference set.\n\nprintln(\"\\n=== Sketch-Guided Pangenome Context Selection ===\")\n\nMock sketch scores (e.g., sourmash containment or sylph coverage)\n\nmock_sketch_scores = Dict(\n    genome_files[1] => 0.18,\n    genome_files[2] => 0.02,\n    genome_files[3] => 0.12,\n    genome_files[4] => 0.00,\n    genome_files[5] => 0.07\n)\n\nsupported_contexts = Mycelia.select_sketch_supported_references(\n    mock_sketch_scores;\n    min_score=0.05,\n    max_refs=3\n)\n\nprintln(\"Sketch-supported references:\")\nfor (reference, score) in supported_contexts\n    println(\"  $reference (score=$(round(score, digits=3)))\")\nend\n\nIn practice:\n\nRun Mycelia.runsourmashsketch + runsourmashsearch/gather for containment\nRun Mycelia.runsylphprofile for coverage/ANI evidence\nOptionally run Mycelia.runmashcomparison for distance-based pruning\nSubset pangenome reference paths to supported contexts\nMap reads with minimap2 against the filtered references","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-3:-Gene-Clustering-and-Ortholog-Identification","page":"Step 7: Comparative Genomics","title":"Part 3: Gene Clustering and Ortholog Identification","text":"Identify orthologous genes across genomes\n\nprintln(\"\\n=== Gene Clustering ===\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#All-vs-All-Sequence-Comparison","page":"Step 7: Comparative Genomics","title":"All-vs-All Sequence Comparison","text":"Compare all genes against all genes\n\nprintln(\"--- All-vs-All Comparison ---\")\n\nPerform k-mer based pangenome analysis using implemented functions\n\nprintln(\"Performing k-mer based pangenome analysis...\")\n\nUse implemented pangenome analysis function\n\npangenome_result = Mycelia.analyze_pangenome_kmers(\n    genome_files,\n    kmer_type=Kmers.DNAKmer{21}\n)\n\nprintln(\"Pangenome Analysis Results:\")\nprintln(\"  Core k-mers: $(length(pangenome_result.core_kmers))\")\nprintln(\"  Accessory k-mers: $(length(pangenome_result.accessory_kmers))\")\nprintln(\"  Total pangenome size: $(pangenome_result.similarity_stats.pangenome_size)\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Genome-Similarity-Analysis","page":"Step 7: Comparative Genomics","title":"Genome Similarity Analysis","text":"Compare genome similarity using multiple metrics\n\nprintln(\"--- Genome Similarity Analysis ---\")\n\nBuild distance matrix using different metrics\n\njs_matrix = Mycelia.build_genome_distance_matrix(\n    genome_files,\n    kmer_type=Kmers.DNAKmer{21},\n    metric=:js_divergence\n)\n\nprintln(\"Distance Matrix (JS Divergence):\")\nfor i in 1:n_genomes\n    for j in 1:n_genomes\n        print(\"$(round(js_matrix.distance_matrix[i,j], digits=3)) \")\n    end\n    println()\nend","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-3b:-Gold-Standard-Whole-Genome-Comparison","page":"Step 7: Comparative Genomics","title":"Part 3b: Gold-Standard Whole-Genome Comparison","text":"Run alignment-based ANI/AAI/POCP metrics on a genome pair (external tools required).\n\nprintln(\"\\n=== Gold-Standard Whole-Genome Comparison ===\")\n\nrun_external = lowercase(get(ENV, \"MYCELIA_RUN_EXTERNAL\", \"false\")) == \"true\"\nif run_external\n    gold_result = Mycelia.compare_genomes_gold(\n        genome_files[1],\n        genome_files[2];\n        methods=Symbol[:ANIm, :ANIb, :AAI, :POCP, :PyOrthoANI],\n        outdir=\"gold_compare_demo\",\n        force=true\n    )\n\n    println(\"Gold-standard summary:\")\n    println(gold_result.summary)\nelse\n    println(\"Skipping gold-standard comparison (set MYCELIA_RUN_EXTERNAL=true).\")\nend","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-4:-Pangenome-Construction","page":"Step 7: Comparative Genomics","title":"Part 4: Pangenome Construction","text":"Build pangenome from ortholog clusters\n\nprintln(\"\\n=== Pangenome Construction ===\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Core-Genome-Analysis","page":"Step 7: Comparative Genomics","title":"Core Genome Analysis","text":"Identify genes present in all genomes\n\nprintln(\"--- Core Genome Analysis ---\")\n\nUse results from pangenome analysis\n\ncore_genome_size = length(pangenome_result.core_kmers)\ncore_genome_percentage = pangenome_result.similarity_stats.core_percentage\n\nprintln(\"Core Genome:\")\nprintln(\"  Size: $core_genome_size k-mers\")\nprintln(\"  Percentage: $(round(core_genome_percentage, digits=1))%\")\n\nCore genome represents k-mers present in ALL genomes\n\nprintln(\"Core genome represents conserved genomic content across all $(n_genomes) genomes\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Accessory-Genome-Analysis","page":"Step 7: Comparative Genomics","title":"Accessory Genome Analysis","text":"Analyze k-mers with variable presence\n\nprintln(\"--- Accessory Genome Analysis ---\")\n\naccessory_genome_size = length(pangenome_result.accessory_kmers)\nunique_genome_total = sum(length(kmers) for kmers in values(pangenome_result.unique_kmers_by_genome))\n\nprintln(\"Accessory Genome:\")\nprintln(\"  Variable k-mers: $accessory_genome_size\")\nprintln(\"  Unique k-mers: $unique_genome_total\")\nprintln(\"  Total accessory: $(accessory_genome_size + unique_genome_total)\")\n\nAnalyze unique k-mers per genome\n\nprintln(\"Unique k-mers per genome:\")\nfor (genome, unique_kmers) in pangenome_result.unique_kmers_by_genome\n    println(\"  $genome: $(length(unique_kmers)) unique k-mers\")\nend","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Pangenome-Curves","page":"Step 7: Comparative Genomics","title":"Pangenome Curves","text":"Model pangenome size vs number of genomes\n\nprintln(\"--- Pangenome Curves ---\")\n\nTODO: Implement pangenome curve analysis\n\nCalculate pangenome size for subsets\nFit mathematical models (power law, exponential)\nPredict pangenome size for larger collections\nClassify as open/closed pangenome","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-5:-Graph-Based-Pangenome-Representation","page":"Step 7: Comparative Genomics","title":"Part 5: Graph-Based Pangenome Representation","text":"Represent pangenomes as graphs\n\nprintln(\"\\n=== Graph-Based Pangenomes ===\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Sequence-Graphs","page":"Step 7: Comparative Genomics","title":"Sequence Graphs","text":"Build graphs from sequence overlaps\n\nprintln(\"--- Sequence Graphs ---\")\n\nTODO: Implement sequence graph construction\n\nBuild k-mer graphs from sequences\nIdentify shared and unique paths\nHandle graph bubbles and loops\nCompress redundant sequences\n\nUse existing pangenome graph construction\n\nk = 3\nsequences = [FASTX.sequence(Mycelia.random_fasta_record(moltype=:DNA, seed=i, L=100)) for i in 1:5]\n\ngraph = Mycelia.buildstrandedkmer_graph(Kmers.DNAKmer{k}, sequences)\n\nprintln(\"Sequence Graph Construction:\")\nprintln(\"  K-mer size: $k\")\nprintln(\"  Sequences: $(length(sequences))\")\n# println(\"  Graph nodes: \\$(Graphs.nv(graph))\")\n# println(\"  Graph edges: \\$(Graphs.ne(graph))\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Variation-Graphs","page":"Step 7: Comparative Genomics","title":"Variation Graphs","text":"Represent genetic variation as graphs\n\nprintln(\"--- Variation Graphs ---\")\n\nTODO: Implement variation graph construction\n\nBuild graphs from multiple alignments\nRepresent SNPs and indels as bubbles\nHandle complex structural variants\nOptimize graph topology","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-6:-Phylogenetic-Analysis","page":"Step 7: Comparative Genomics","title":"Part 6: Phylogenetic Analysis","text":"Construct phylogenetic trees from pangenome data\n\nprintln(\"\\n=== Phylogenetic Analysis ===\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Core-Genome-Phylogeny","page":"Step 7: Comparative Genomics","title":"Core Genome Phylogeny","text":"Build trees from core genes\n\nprintln(\"--- Core Genome Phylogeny ---\")\n\nTODO: Implement core genome phylogeny\n\nConcatenate core gene alignments\nCalculate phylogenetic trees\nAssess branch support\nCompare with individual gene trees","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Accessory-Genome-Phylogeny","page":"Step 7: Comparative Genomics","title":"Accessory Genome Phylogeny","text":"Analyze evolution of accessory genes\n\nprintln(\"--- Accessory Genome Phylogeny ---\")\n\nTODO: Implement accessory genome phylogeny\n\nBuild trees from gene presence/absence\nUse binary character evolution models\nIdentify horizontal gene transfer events\nAnalyze gene gain/loss patterns","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-7:-Synteny-Analysis","page":"Step 7: Comparative Genomics","title":"Part 7: Synteny Analysis","text":"Analyze conserved gene order\n\nprintln(\"\\n=== Synteny Analysis ===\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Synteny-Detection","page":"Step 7: Comparative Genomics","title":"Synteny Detection","text":"Identify conserved gene order\n\nprintln(\"--- Synteny Detection ---\")\n\nTODO: Implement synteny detection\n\nIdentify colinear gene blocks\nCalculate synteny conservation\nDetect chromosomal rearrangements\nVisualize synteny relationships","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Rearrangement-Analysis","page":"Step 7: Comparative Genomics","title":"Rearrangement Analysis","text":"Analyze chromosomal rearrangements\n\nprintln(\"--- Rearrangement Analysis ---\")\n\nTODO: Implement rearrangement analysis\n\nIdentify inversions, translocations, duplications\nCalculate rearrangement distances\nReconstruct ancestral gene orders\nAnalyze rearrangement hotspots","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-8:-Population-Genomics","page":"Step 7: Comparative Genomics","title":"Part 8: Population Genomics","text":"Analyze genetic diversity within populations\n\nprintln(\"\\n=== Population Genomics ===\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Genetic-Diversity","page":"Step 7: Comparative Genomics","title":"Genetic Diversity","text":"Calculate diversity metrics\n\nprintln(\"--- Genetic Diversity ---\")\n\nTODO: Implement diversity analysis\n\nCalculate nucleotide diversity (π)\nEstimate effective population size\nAnalyze allele frequency spectra\nIdentify population structure","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Selection-Analysis","page":"Step 7: Comparative Genomics","title":"Selection Analysis","text":"Detect selection pressure\n\nprintln(\"--- Selection Analysis ---\")\n\nTODO: Implement selection analysis\n\nCalculate dN/dS ratios\nIdentify positively selected genes\nDetect balancing selection\nAnalyze codon usage bias","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-9:-Functional-Analysis","page":"Step 7: Comparative Genomics","title":"Part 9: Functional Analysis","text":"Analyze functional aspects of pangenomes\n\nprintln(\"\\n=== Functional Analysis ===\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Functional-Enrichment","page":"Step 7: Comparative Genomics","title":"Functional Enrichment","text":"Identify enriched functional categories\n\nprintln(\"--- Functional Enrichment ---\")\n\nTODO: Implement functional enrichment analysis\n\nGO term enrichment analysis\nKEGG pathway enrichment\nProtein domain analysis\nMetabolic pathway reconstruction","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Adaptive-Evolution","page":"Step 7: Comparative Genomics","title":"Adaptive Evolution","text":"Identify adaptively evolving genes\n\nprintln(\"--- Adaptive Evolution ---\")\n\nTODO: Implement adaptive evolution analysis\n\nIdentify rapidly evolving genes\nAnalyze gene family expansions\nDetect horizontal gene transfer\nCorrelate with environmental factors","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-10:-Visualization-and-Interpretation","page":"Step 7: Comparative Genomics","title":"Part 10: Visualization and Interpretation","text":"Create visualizations for comparative genomics\n\nprintln(\"\\n=== Visualization ===\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Pangenome-Plots","page":"Step 7: Comparative Genomics","title":"Pangenome Plots","text":"Visualize pangenome structure\n\nprintln(\"--- Pangenome Plots ---\")\n\nTODO: Implement pangenome visualization\n\nPangenome accumulation curves\nGene presence/absence heatmaps\nPhylogenetic trees with annotations\nSynteny dot plots","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Interactive-Visualization","page":"Step 7: Comparative Genomics","title":"Interactive Visualization","text":"Create interactive pangenome browsers\n\nprintln(\"--- Interactive Visualization ---\")\n\nTODO: Implement interactive visualization\n\nWeb-based pangenome browser\nInteractive phylogenetic trees\nSearchable gene catalogs\nComparative genome viewers","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-11:-Applications-and-Case-Studies","page":"Step 7: Comparative Genomics","title":"Part 11: Applications and Case Studies","text":"Real-world applications of comparative genomics\n\nprintln(\"\\n=== Applications ===\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Pathogen-Genomics","page":"Step 7: Comparative Genomics","title":"Pathogen Genomics","text":"Applications in infectious disease research\n\nprintln(\"--- Pathogen Genomics ---\")\n\nprintln(\"Pathogen Genomics Applications:\")\nprintln(\"- Outbreak investigation and source tracking\")\nprintln(\"- Drug resistance evolution\")\nprintln(\"- Vaccine target identification\")\nprintln(\"- Virulence factor discovery\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Agricultural-Genomics","page":"Step 7: Comparative Genomics","title":"Agricultural Genomics","text":"Applications in crop improvement\n\nprintln(\"--- Agricultural Genomics ---\")\n\nprintln(\"Agricultural Genomics Applications:\")\nprintln(\"- Crop diversity assessment\")\nprintln(\"- Disease resistance breeding\")\nprintln(\"- Stress tolerance identification\")\nprintln(\"- Nutritional quality improvement\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Environmental-Genomics","page":"Step 7: Comparative Genomics","title":"Environmental Genomics","text":"Applications in environmental microbiology\n\nprintln(\"--- Environmental Genomics ---\")\n\nprintln(\"Environmental Genomics Applications:\")\nprintln(\"- Microbial community analysis\")\nprintln(\"- Ecosystem function prediction\")\nprintln(\"- Biogeochemical cycling\")\nprintln(\"- Climate change adaptation\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Part-12:-Best-Practices-and-Guidelines","page":"Step 7: Comparative Genomics","title":"Part 12: Best Practices and Guidelines","text":"Recommendations for comparative genomics analysis\n\nprintln(\"\\n=== Best Practices ===\")\n\nprintln(\"Data Quality:\")\nprintln(\"- Use high-quality genome assemblies\")\nprintln(\"- Ensure consistent annotation standards\")\nprintln(\"- Validate ortholog assignments\")\nprintln(\"- Check for contamination and artifacts\")\nprintln()\nprintln(\"Analysis Strategy:\")\nprintln(\"- Start with closely related genomes\")\nprintln(\"- Use multiple clustering methods\")\nprintln(\"- Validate results with independent approaches\")\nprintln(\"- Consider biological context in interpretation\")\nprintln()\nprintln(\"Computational Considerations:\")\nprintln(\"- Plan for large memory requirements\")\nprintln(\"- Use parallel processing when possible\")\nprintln(\"- Implement checkpointing for long analyses\")\nprintln(\"- Archive intermediate results\")","category":"section"},{"location":"generated/tutorials/07_comparative_genomics/#Summary","page":"Step 7: Comparative Genomics","title":"Summary","text":"println(\"\\n=== Comparative Genomics Summary ===\")\nprintln(\"✓ Understanding pangenome concepts and construction\")\nprintln(\"✓ Implementing gene clustering and ortholog identification\")\nprintln(\"✓ Building core and accessory genome catalogs\")\nprintln(\"✓ Constructing graph-based pangenome representations\")\nprintln(\"✓ Performing phylogenetic analysis\")\nprintln(\"✓ Analyzing synteny and chromosomal rearrangements\")\nprintln(\"✓ Applying population genomics approaches\")\nprintln(\"✓ Creating comprehensive visualizations\")\nprintln(\"✓ Understanding real-world applications\")\n\nCleanup\n\nfor file in genome_files\n    if isfile(file)\n        rm(file, force=true)\n    end\nend\n\nprintln(\"\\nNext: Tutorial 8 - Tool Integration\")\n\nnothing","category":"section"},{"location":"generated/tutorials/15_round_trip_benchmarking/#Round-Trip-Benchmark-Tutorial-(Viroids)","page":"Step 15: Round Trip Benchmarking","title":"Round-Trip Benchmark Tutorial (Viroids)","text":"This tutorial walks through a small, reproducible round-trip benchmark: download a viroid reference database, build taxonomy, simulate reads, and screen with sketch tools. Heavy steps are gated behind MYCELIA_RUN_EXTERNAL=true.\n\nFrom the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/15_round_trip_benchmarking.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Mycelia\nimport DataFrames\nimport CSV\nimport StableRNGs\nimport StatsBase\n\nrun_external = get(ENV, \"MYCELIA_RUN_EXTERNAL\", \"false\") == \"true\"\nif !run_external\n    println(\"Set MYCELIA_RUN_EXTERNAL=true to download references and run external tools.\")\nend\n\nbase_outdir = \"results/round_trip_tutorial\"\nreference_dir = joinpath(base_outdir, \"reference\")\nmkpath(reference_dir)\n\nreference_db = \"ref_viroids_rep_genomes\"\ntaxonomy_db = \"taxdb\"\nreference_fasta = joinpath(reference_dir, \"$(reference_db).fna.gz\")","category":"section"},{"location":"generated/tutorials/15_round_trip_benchmarking/#Step-1:-Download-reference-databases","page":"Step 15: Round Trip Benchmarking","title":"Step 1: Download reference databases","text":"We use Mycelia's BLAST DB downloader for both the viroid database and taxdb.\n\nreference_table = DataFrames.DataFrame()\nif run_external\n    Mycelia.download_blast_db(db=taxonomy_db)\n    reference_table = Mycelia.prepare_blast_reference_table(\n        blastdb=reference_db,\n        blastdbs_dir=Mycelia.DEFAULT_BLASTDB_PATH,\n        download_if_missing=true,\n        reference_fasta=reference_fasta,\n        taxonomy_map_out=joinpath(reference_dir, \"$(reference_db).seqid2taxid.txt.gz\"),\n        table_out=joinpath(reference_dir, \"viroids_reference_table.csv\"),\n        force=false\n    )\nend","category":"section"},{"location":"generated/tutorials/15_round_trip_benchmarking/#Step-3:-Define-one-small-scenario","page":"Step 15: Round Trip Benchmarking","title":"Step 3: Define one small scenario","text":"depth_target = 10\nn_organisms = 1\nbalance = :equal\nreadset = :illumina_pe150\nreplicate = 1\nrng = StableRNGs.StableRNG(1234)\n\nif run_external && !isempty(reference_table)\n    available_ids = unique(String.(reference_table.sequence_id))\n    selected_ids = StatsBase.sample(rng, available_ids, n_organisms; replace=false)\n    weights = Mycelia.sample_abundance_weights(n_organisms=n_organisms, balance=balance, rng=rng)\n\n    scenario_dir = joinpath(base_outdir, \"depth$(depth_target)_div$(n_organisms)_$(balance)\")\n    sim = Mycelia.simulate_metagenome_community(\n        reference_fasta=reference_fasta,\n        reference_table=reference_table,\n        n_organisms=n_organisms,\n        depth_target=depth_target,\n        abundance_profile=:custom,\n        readset=readset,\n        outdir=scenario_dir,\n        selected_ids=selected_ids,\n        weights=weights,\n        rng=rng,\n        replicate=replicate,\n        run_simulation=true,\n        emit_truth_reads=true\n    )\n    CSV.write(joinpath(scenario_dir, \"truth_table.csv\"), sim.truth_table)\nend","category":"section"},{"location":"generated/tutorials/15_round_trip_benchmarking/#Step-4:-Screen-reads-with-sketch-tools","page":"Step 15: Round Trip Benchmarking","title":"Step 4: Screen reads with sketch tools","text":"Use Mash, sourmash, and Sylph to identify supported references.\n\nif run_external\n    println(\"Run sketch screening in the benchmark script:\")\n    println(\"julia --project=. benchmarking/15_round_trip_benchmark.jl\")\nend","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Tutorial-11:-Reduced-Amino-Acid-Alphabets","page":"Step 11: Reduced Amino Acid Alphabets","title":"Tutorial 11: Reduced Amino Acid Alphabets","text":"This tutorial demonstrates how to convert amino acid sequences to reduced alphabets based on physicochemical properties. Reduced alphabets simplify protein sequences by grouping similar amino acids together, which can improve computational efficiency and reduce noise in machine learning applications.","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Learning-Objectives","page":"Step 11: Reduced Amino Acid Alphabets","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nWhat reduced amino acid alphabets are and why they are useful\nHow to convert protein sequences to different reduction schemes\nThe differences between various reduction strategies\nApplications of reduced alphabets in sequence analysis","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Background","page":"Step 11: Reduced Amino Acid Alphabets","title":"Background","text":"The standard genetic code uses 20 amino acids, each with distinct physicochemical properties. However, for many computational analyses, this diversity can introduce noise and computational complexity. Reduced amino acid alphabets group similar amino acids based on properties like:\n\nHydrophobicity: How water-repelling or water-attracting an amino acid is\nCharge: Positive, negative, or neutral electrical charge\nSize: Physical size of the amino acid side chain\nAromaticity: Presence of aromatic rings in the structure\nStructure: Special properties like flexibility (Gly) or rigidity (Pro)\n\nResearch has shown that reduced alphabets can:\n\nImprove protein fold recognition\nReduce noise in machine learning models\nSpeed up sequence comparisons\nSimplify pattern discovery in protein sequences","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Setup","page":"Step 11: Reduced Amino Acid Alphabets","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/11_reduced_amino_acid_alphabets.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport BioSequences\nimport Statistics","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Part-1:-Basic-Conversion","page":"Step 11: Reduced Amino Acid Alphabets","title":"Part 1: Basic Conversion","text":"Let's start with a simple example using a fragment of human insulin A chain.\n\n# Example protein sequence (fragment of human insulin A chain)\ninsulin_sequence = BioSequences.LongAA(\"GIVEQCCTSICSLYQLENYCN\")\nprintln(\"Original sequence: \", insulin_sequence)\nprintln(\"Length: \", length(insulin_sequence))\nprintln()","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Part-2:-Exploring-Available-Schemes","page":"Step 11: Reduced Amino Acid Alphabets","title":"Part 2: Exploring Available Schemes","text":"Mycelia provides six well-established reduction schemes from the literature. Let's list them all:\n\nprintln(\"Available reduction schemes:\")\nfor scheme in Mycelia.list_reduced_alphabets()\n    info = Mycelia.get_reduced_alphabet_info(scheme)\n    println(\"  $scheme ($(info[:classes]) classes): $(info[:name])\")\nend\nprintln()","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Part-3:-Binary-Hydrophobic-Polar-(HP2)","page":"Step 11: Reduced Amino Acid Alphabets","title":"Part 3: Binary Hydrophobic-Polar (HP2)","text":"The simplest reduction divides amino acids into just two classes:\n\nH (Hydrophobic): Water-repelling amino acids (A, C, F, I, L, M, V, W)\nP (Polar): Water-attracting amino acids (G, T, S, Y, P, N, D, E, Q, K, R, H)\n\nThis is the most aggressive reduction and is useful for identifying hydrophobic core regions versus surface-exposed regions in proteins.\n\nprintln(\"=\" ^ 70)\nprintln(\"HP2: Binary Hydrophobic-Polar Reduction\")\nprintln(\"=\" ^ 70)\nreduced_hp2 = Mycelia.reduce_amino_acid_alphabet(insulin_sequence, :HP2)\ninfo = Mycelia.get_reduced_alphabet_info(:HP2)\nprintln(\"Description: $(info[:description])\")\nprintln(\"Groups:\")\nfor (letter, aas) in sort(collect(info[:groups]))\n    println(\"  $letter: $aas\")\nend\nprintln(\"\\nOriginal: $insulin_sequence\")\nprintln(\"Reduced:  $reduced_hp2\")\nprintln()","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Part-4:-Three-Class-Hydropathy-(HYDROPATHY3)","page":"Step 11: Reduced Amino Acid Alphabets","title":"Part 4: Three-Class Hydropathy (HYDROPATHY3)","text":"A more nuanced approach uses three classes based on IMGT hydropathy:\n\nH (Hydrophobic): Strongly water-repelling\nN (Neutral): Neither strongly hydrophobic nor hydrophilic\nP (Polar): Strongly water-attracting\n\nprintln(\"=\" ^ 70)\nprintln(\"HYDROPATHY3: Three-class Hydropathy\")\nprintln(\"=\" ^ 70)\nreduced_hydro3 = Mycelia.reduce_amino_acid_alphabet(insulin_sequence, :HYDROPATHY3)\ninfo = Mycelia.get_reduced_alphabet_info(:HYDROPATHY3)\nprintln(\"Description: $(info[:description])\")\nprintln(\"Groups:\")\nfor (letter, aas) in sort(collect(info[:groups]))\n    println(\"  $letter: $aas\")\nend\nprintln(\"\\nOriginal: $insulin_sequence\")\nprintln(\"Reduced:  $reduced_hydro3\")\nprintln()","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Part-5:-GBMR4-Isolating-Special-Amino-Acids","page":"Step 11: Reduced Amino Acid Alphabets","title":"Part 5: GBMR4 - Isolating Special Amino Acids","text":"The GBMR4 scheme recognizes that Glycine and Proline have unique structural roles:\n\nG (Glycine): Smallest, most flexible\nP (Proline): Rigid, breaks secondary structure\nH (Hydrophobic): Standard hydrophobic amino acids\nB (Basic/polar): Polar and charged amino acids\n\nprintln(\"=\" ^ 70)\nprintln(\"GBMR4: Four-class (isolating Gly and Pro)\")\nprintln(\"=\" ^ 70)\nreduced_gbmr4 = Mycelia.reduce_amino_acid_alphabet(insulin_sequence, :GBMR4)\ninfo = Mycelia.get_reduced_alphabet_info(:GBMR4)\nprintln(\"Description: $(info[:description])\")\nprintln(\"Groups:\")\nfor (letter, aas) in sort(collect(info[:groups]))\n    println(\"  $letter: $aas\")\nend\nprintln(\"\\nOriginal: $insulin_sequence\")\nprintln(\"Reduced:  $reduced_gbmr4\")\nprintln()","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Part-6:-Chemical-Properties-(CHEMICAL6)","page":"Step 11: Reduced Amino Acid Alphabets","title":"Part 6: Chemical Properties (CHEMICAL6)","text":"The CHEMICAL6 scheme groups by detailed chemical properties:\n\nA (Aliphatic): Non-aromatic hydrophobic chains\nR (aRomatic): Contains aromatic rings\n+ (Positive): Positively charged (basic)\n- (Negative): Negatively charged (acidic)\nT (Tiny): Small amino acids\nD (Diverse): Other properties\n\nThis scheme is particularly useful for studying electrostatic interactions.\n\nprintln(\"=\" ^ 70)\nprintln(\"CHEMICAL6: Six-class Chemical Properties\")\nprintln(\"=\" ^ 70)\nreduced_chem6 = Mycelia.reduce_amino_acid_alphabet(insulin_sequence, :CHEMICAL6)\ninfo = Mycelia.get_reduced_alphabet_info(:CHEMICAL6)\nprintln(\"Description: $(info[:description])\")\nprintln(\"Groups:\")\nfor (letter, aas) in sort(collect(info[:groups]))\n    println(\"  $letter: $aas\")\nend\nprintln(\"\\nOriginal: $insulin_sequence\")\nprintln(\"Reduced:  $reduced_chem6\")\nprintln()","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Part-7:-Structure-Dependent-Model-(SDM12)","page":"Step 11: Reduced Amino Acid Alphabets","title":"Part 7: Structure-Dependent Model (SDM12)","text":"The SDM12 scheme (Murphy et al. 2000) maintains the most detail with 12 classes. It preserves important functional groupings while still reducing complexity. This is useful when you need more resolution than HP2 but less than the full 20.\n\nprintln(\"=\" ^ 70)\nprintln(\"SDM12: Structure-dependent Model (12 classes)\")\nprintln(\"=\" ^ 70)\nreduced_sdm12 = Mycelia.reduce_amino_acid_alphabet(insulin_sequence, :SDM12)\ninfo = Mycelia.get_reduced_alphabet_info(:SDM12)\nprintln(\"Description: $(info[:description])\")\nprintln(\"Groups:\")\nfor (letter, aas) in sort(collect(info[:groups]))\n    println(\"  $letter: $aas\")\nend\nprintln(\"\\nOriginal: $insulin_sequence\")\nprintln(\"Reduced:  $reduced_sdm12\")\nprintln()","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Part-8:-Comparing-All-Schemes","page":"Step 11: Reduced Amino Acid Alphabets","title":"Part 8: Comparing All Schemes","text":"Let's see all reductions side-by-side to compare how they simplify the sequence:\n\nprintln(\"=\" ^ 70)\nprintln(\"Comparison of All Schemes\")\nprintln(\"=\" ^ 70)\nprintln(\"Original:    $insulin_sequence\")\nfor scheme in Mycelia.list_reduced_alphabets()\n    reduced = Mycelia.reduce_amino_acid_alphabet(insulin_sequence, scheme)\n    println(rpad(\"$scheme:\", 13), reduced)\nend\nprintln()","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Part-9:-Application-K-mer-Pattern-Analysis","page":"Step 11: Reduced Amino Acid Alphabets","title":"Part 9: Application - K-mer Pattern Analysis","text":"One practical application of reduced alphabets is simplifying k-mer patterns. By reducing the alphabet, we reduce the number of possible k-mers, making patterns easier to detect and reducing data sparsity.\n\nprintln(\"=\" ^ 70)\nprintln(\"Application: Reduced Alphabet K-mer Patterns\")\nprintln(\"=\" ^ 70)\n\n# Extract 3-mers from the original sequence\nprintln(\"Original 3-mers from insulin sequence:\")\noriginal_3mers = [String(insulin_sequence[i:i+2]) for i in 1:(length(insulin_sequence)-2)]\nprintln(join(original_3mers, \", \"))\nprintln()\n\n# Extract 3-mers from HP2 reduced sequence\nprintln(\"HP2 reduced 3-mers:\")\nreduced_seq = Mycelia.reduce_amino_acid_alphabet(insulin_sequence, :HP2)\nreduced_3mers = [reduced_seq[i:i+2] for i in 1:(length(reduced_seq)-2)]\nprintln(join(reduced_3mers, \", \"))\nprintln()\n\n# Compare pattern complexity\nprintln(\"Unique 3-mer patterns:\")\nprintln(\"  Original: \", length(unique(original_3mers)), \" unique patterns\")\nprintln(\"  HP2:      \", length(unique(reduced_3mers)), \" unique patterns\")\nreduction_percent = round((1 - length(unique(reduced_3mers))/length(unique(original_3mers))) * 100, digits=1)\nprintln(\"  Reduction: \", reduction_percent, \"% fewer patterns\")\nprintln()","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Part-10:-Practical-Considerations","page":"Step 11: Reduced Amino Acid Alphabets","title":"Part 10: Practical Considerations","text":"When choosing a reduction scheme, consider:","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#1.-Analysis-Goals","page":"Step 11: Reduced Amino Acid Alphabets","title":"1. Analysis Goals","text":"HP2: Maximum simplification, focus on hydrophobicity\nHYDROPATHY3: Balance between simplicity and detail\nGBMR4: Important for structure-related analysis\nCHEMICAL5/6: When charge matters (e.g., binding sites)\nSDM12: When you need more detail but still want reduction","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#2.-Information-Loss","page":"Step 11: Reduced Amino Acid Alphabets","title":"2. Information Loss","text":"More aggressive reductions lose more information\nBut they also reduce noise and computational complexity\nChoose based on signal-to-noise ratio in your data","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#3.-Literature-Compatibility","page":"Step 11: Reduced Amino Acid Alphabets","title":"3. Literature Compatibility","text":"Use schemes from published studies for comparison\nMurphy et al. (2000) SDM12 is widely cited\nHP2 is the most established for folding studies","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Summary","page":"Step 11: Reduced Amino Acid Alphabets","title":"Summary","text":"In this tutorial, we learned:\n\nHow to convert amino acid sequences to reduced alphabets\nThe differences between 6 well-established reduction schemes\nHow reduced alphabets simplify k-mer patterns\nWhen to use different reduction strategies","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#References","page":"Step 11: Reduced Amino Acid Alphabets","title":"References","text":"Murphy et al. (2000) Protein Eng. 13(3):149-152 - Original SDM12 paper\nPeterson et al. (2009) BMC Bioinformatics 10:228 - Automated reduction methods\nZheng et al. (2019) Database (Oxford) baz131 - RAACBook comprehensive database","category":"section"},{"location":"generated/tutorials/11_reduced_amino_acid_alphabets/#Further-Reading","page":"Step 11: Reduced Amino Acid Alphabets","title":"Further Reading","text":"For more information on protein sequence analysis in Mycelia:\n\nTutorial 2: Quality Control (quality metrics for sequences)\nTutorial 3: K-mer Analysis (k-mer counting and analysis)\nTutorial 6: Gene Annotation (protein-coding sequence analysis)\n\nprintln(\"=== Tutorial Complete ===\")","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Round-Trip-Tutorial-1:-String-Data-String-Graphs-Reconstruction","page":"Round-Trip 01: String Graphs","title":"Round-Trip Tutorial 1: String Data → String Graphs → Reconstruction","text":"This tutorial demonstrates the complete round-trip workflow for string-based graph construction and reconstruction in Mycelia. We'll start with raw string data, construct string graphs, perform assembly operations, and validate the reconstruction quality.","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Learning-Objectives","page":"Round-Trip 01: String Graphs","title":"Learning Objectives","text":"By the end of this tutorial, you will:\n\nUnderstand string graph construction from raw text data\nLearn to perform graph-based assembly operations\nValidate reconstruction accuracy with quality metrics\nAnalyze memory usage and computational performance\nApply string graphs to real-world text analysis problems\n\nFrom the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/09_round_trip_01_string_graphs.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Mycelia\nimport Statistics\nimport Random","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Data-Preparation","page":"Round-Trip 01: String Graphs","title":"Data Preparation","text":"We'll start with various types of string data to demonstrate the versatility of string graphs.\n\nprintln(\"=\"^80)\nprintln(\"ROUND-TRIP TUTORIAL 1: STRING GRAPHS\")\nprintln(\"=\"^80)","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Clean-Error-Free-Input-Data","page":"Round-Trip 01: String Graphs","title":"Clean Error-Free Input Data","text":"First, let's create clean, error-free string data to establish baseline performance.\n\nclean_strings = [\n    \"The quick brown fox jumps over the lazy dog\",\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n    \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n    # \"αβγδεζηθικλμνξοπρστυφχψω\",  ## Unicode testing - requires fix in Rhizomorph string graphs\n    \"Pattern recognition and machine learning algorithms\"\n]\n\nprintln(\"\\n1. CLEAN ERROR-FREE INPUT DATA\")\nprintln(\"-\"^50)\nfor (i, s) in enumerate(clean_strings)\n    println(\"String $i: \\\"$s\\\" (length: $(length(s)))\")\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Graph-Construction-Phase","page":"Round-Trip 01: String Graphs","title":"Graph Construction Phase","text":"Now we'll construct string graphs from our input data using different n-gram sizes.\n\nprintln(\"\\n2. GRAPH CONSTRUCTION PHASE\")\nprintln(\"-\"^50)\n\ngraph_results = Dict()\n\nfor n in [2, 3, 4, 5]\n    println(\"\\nTesting n-gram size: $n\")\n\n    total_ngrams = 0\n    total_vertices = 0\n\n    for (i, text) in enumerate(clean_strings)\n        if length(text) >= n  ## Only process if text is long enough\n            try\n                # Construct n-gram graph (Rhizomorph)\n                graph = Mycelia.Rhizomorph.build_ngram_graph([text], n; dataset_id=\"string_$(i)_n$(n)\")\n\n                # Extract graph statistics\n                vertex_labels = collect(Mycelia.MetaGraphsNext.labels(graph))\n                num_vertices = length(vertex_labels)\n\n                total_ngrams += length(text) - n + 1  ## Expected number of n-grams\n                total_vertices += num_vertices\n\n                println(\"  String $i: $(num_vertices) unique $(n)-grams\")\n                if num_vertices > 0\n                    println(\"    Examples: $(vertex_labels[1:min(3, num_vertices)])\")\n                end\n\n                # Store results for later analysis\n                graph_results[\"$(i)_$(n)\"] = (\n                    graph = graph,\n                    original_text = text,\n                    n = n,\n                    vertices = num_vertices,\n                    total_ngrams = length(text) - n + 1\n                )\n\n            catch e\n                println(\"  String $i: Error - $(typeof(e))\")\n            end\n        else\n            println(\"  String $i: Too short for $(n)-grams\")\n        end\n    end\n\n    println(\"  Summary: $total_vertices unique vertices from $total_ngrams total n-grams\")\n    if total_ngrams > 0\n        compression_ratio = total_vertices / total_ngrams\n        println(\"  Compression ratio: $(round(compression_ratio, digits=3))\")\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Assembly-and-Reconstruction-Phase","page":"Round-Trip 01: String Graphs","title":"Assembly and Reconstruction Phase","text":"Now we'll attempt to reconstruct the original strings from the graphs.\n\nprintln(\"\\n3. ASSEMBLY AND RECONSTRUCTION PHASE\")\nprintln(\"-\"^50)\n\nreconstruction_results = Dict()\n\nfor (key, result) in graph_results\n    println(\"\\nReconstructing: \\\"$(result.original_text)\\\" (n=$(result.n))\")\n\n    try\n        # Attempt to reconstruct strings from the graph (Rhizomorph paths)\n        reconstructed_strings = String[]\n        paths = Mycelia.Rhizomorph.find_eulerian_paths_next(result.graph)\n        for path in paths\n            if !isempty(path)\n                reconstructed = Mycelia.Rhizomorph.path_to_sequence(path, result.graph)\n                push!(reconstructed_strings, string(reconstructed))\n            end\n        end\n        if isempty(reconstructed_strings)\n            contigs = Mycelia.Rhizomorph.find_contigs_next(result.graph; min_contig_length=1)\n            reconstructed_strings = [string(contig.sequence) for contig in contigs]\n        end\n\n        num_reconstructed = length(reconstructed_strings)\n        println(\"  Reconstructed $num_reconstructed string(s)\")\n\n        # Store reconstruction results\n        reconstruction_results[key] = (\n            original = result.original_text,\n            reconstructed = reconstructed_strings,\n            n = result.n,\n            success = !isempty(reconstructed_strings)\n        )\n\n        # Show first few reconstructed strings\n        for (i, reconstructed) in enumerate(reconstructed_strings[1:min(3, num_reconstructed)])\n            println(\"    Reconstruction $i: \\\"$reconstructed\\\"\")\n        end\n\n    catch e\n        println(\"  Reconstruction failed: $(typeof(e))\")\n        reconstruction_results[key] = (\n            original = result.original_text,\n            reconstructed = String[],\n            n = result.n,\n            success = false\n        )\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Quality-Assessment-Phase","page":"Round-Trip 01: String Graphs","title":"Quality Assessment Phase","text":"Let's evaluate the reconstruction quality using various metrics.\n\nprintln(\"\\n4. QUALITY ASSESSMENT PHASE\")\nprintln(\"-\"^50)\n\nfunction calculate_string_similarity(original::String, reconstructed::String)\n    \"\"\"Calculate similarity between original and reconstructed strings.\"\"\"\n    # Simple character-level accuracy\n    min_len = min(length(original), length(reconstructed))\n    max_len = max(length(original), length(reconstructed))\n\n    if max_len == 0\n        return 1.0  ## Both strings are empty\n    end\n\n    # Count matching characters at corresponding positions\n    matches = 0\n    for i in 1:min_len\n        if original[i] == reconstructed[i]\n            matches += 1\n        end\n    end\n\n    # Penalize length differences\n    similarity = matches / max_len\n    return similarity\nend\n\nfunction assess_reconstruction_quality(results_dict)\n    \"\"\"Assess overall reconstruction quality across all tests.\"\"\"\n    total_tests = length(results_dict)\n    successful_reconstructions = 0\n    total_similarity = 0.0\n\n    println(\"Individual reconstruction assessment:\")\n\n    for (key, result) in results_dict\n        original = result.original\n        reconstructed_list = result.reconstructed\n        n = result.n\n\n        if isempty(reconstructed_list)\n            println(\"  $key: FAILED - No reconstruction\")\n            continue\n        end\n\n        # Find best reconstruction (highest similarity)\n        best_similarity = 0.0\n        best_reconstruction = \"\"\n\n        for reconstructed in reconstructed_list\n            similarity = calculate_string_similarity(original, reconstructed)\n            if similarity > best_similarity\n                best_similarity = similarity\n                best_reconstruction = reconstructed\n            end\n        end\n\n        total_similarity += best_similarity\n        if best_similarity > 0.8  ## Consider >80% similarity as successful\n            successful_reconstructions += 1\n        end\n\n        status = best_similarity > 0.8 ? \"SUCCESS\" : \"PARTIAL\"\n        println(\"  $key: $status - Similarity: $(round(best_similarity, digits=3))\")\n\n        # Show comparison for low similarity cases\n        if best_similarity < 0.8\n            println(\"    Original:      \\\"$(original)\\\"\")\n            println(\"    Best match:    \\\"$(best_reconstruction)\\\"\")\n        end\n    end\n\n    return (\n        total_tests = total_tests,\n        successful = successful_reconstructions,\n        average_similarity = total_tests > 0 ? total_similarity / total_tests : 0.0,\n        success_rate = total_tests > 0 ? successful_reconstructions / total_tests : 0.0\n    )\nend\n\nquality_metrics = assess_reconstruction_quality(reconstruction_results)\n\nprintln(\"\\nOverall Quality Assessment:\")\nprintln(\"  Total tests: $(quality_metrics.total_tests)\")\nprintln(\"  Successful reconstructions: $(quality_metrics.successful)\")\nprintln(\"  Success rate: $(round(quality_metrics.success_rate * 100, digits=1))%\")\nprintln(\"  Average similarity: $(round(quality_metrics.average_similarity, digits=3))\")","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Performance-Analysis","page":"Round-Trip 01: String Graphs","title":"Performance Analysis","text":"Analyze memory usage and computational efficiency.\n\nprintln(\"\\n5. PERFORMANCE ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_performance_by_n()\n    \"\"\"Analyze how performance scales with n-gram size.\"\"\"\n\n    test_string = \"The quick brown fox jumps over the lazy dog and then some additional text for performance testing\"\n    println(\"Performance test string: \\\"$test_string\\\"\")\n    println(\"String length: $(length(test_string)) characters\")\n\n    for n in 2:6\n        if length(test_string) >= n\n            # Measure construction time\n            start_time = time()\n            graph = Mycelia.Rhizomorph.build_ngram_graph([test_string], n; dataset_id=\"performance_n$(n)\")\n            construction_time = time() - start_time\n\n            # Measure graph properties\n            num_vertices = length(Mycelia.MetaGraphsNext.labels(graph))\n            expected_ngrams = length(test_string) - n + 1\n            compression_ratio = num_vertices / expected_ngrams\n\n            # Estimate memory usage (approximate)\n            avg_vertex_size = sum(length(v) for v in Mycelia.MetaGraphsNext.labels(graph)) / num_vertices\n            estimated_memory_kb = (num_vertices * avg_vertex_size * 2) / 1024  ## Rough estimate\n\n            println(\"  n=$n: $(num_vertices) vertices, $(round(construction_time*1000, digits=2))ms, $(round(compression_ratio, digits=3)) compression, ~$(round(estimated_memory_kb, digits=1))KB\")\n        end\n    end\nend\n\nanalyze_performance_by_n()","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Real-World-Application-Example","page":"Round-Trip 01: String Graphs","title":"Real-World Application Example","text":"Demonstrate string graphs on a practical text analysis problem.\n\nprintln(\"\\n6. REAL-WORLD APPLICATION EXAMPLE\")\nprintln(\"-\"^50)\n\nExample: DNA sequence analysis as strings\n\ndna_sequences = [\n    \"ATCGATCGATCGATCG\",\n    \"GATCGATCGATCGTAGC\",\n    \"TCGATCGATCGTAGCTA\",\n    \"CGATCGATCGTAGCTAG\",\n    \"ATCGTAGCTAGCTAGCT\"\n]\n\nprintln(\"DNA sequence analysis using string graphs:\")\nprintln(\"Sequences to analyze:\")\nfor (i, seq) in enumerate(dna_sequences)\n    println(\"  Seq $i: $seq\")\nend\n\nConcatenate sequences for analysis\n\ncombined_dna = join(dna_sequences, \"N\")  ## Use 'N' as separator\nprintln(\"\\\\nCombined sequence: $combined_dna\")\n\nBuild string graph\n\ndna_graph = Mycelia.Rhizomorph.build_ngram_graph([combined_dna], 4; dataset_id=\"dna_string_demo\")\ndna_4grams = collect(Mycelia.MetaGraphsNext.labels(dna_graph))\n\nprintln(\"DNA 4-gram analysis:\")\nprintln(\"  Unique 4-grams: $(length(dna_4grams))\")\nprintln(\"  Total 4-grams: $(length(combined_dna) - 4 + 1)\")\n\nFind most common patterns\n\ndna_4gram_counts = Dict(k => 0 for k in dna_4grams)\nfor i in 1:(length(combined_dna) - 4 + 1)\n    ngram = combined_dna[i:i+3]\n    if haskey(dna_4gram_counts, ngram)\n        dna_4gram_counts[ngram] += 1\n    end\nend\n\nSort by frequency\n\nsorted_patterns = sort(collect(dna_4gram_counts), by=x->x[2], rev=true)\nprintln(\"  Most frequent 4-grams:\")\nfor (pattern, count) in sorted_patterns[1:min(5, length(sorted_patterns))]\n    if pattern != \"N\"  ## Skip separator\n        println(\"    $pattern: $count occurrences\")\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Visualization-and-Graph-Analysis","page":"Round-Trip 01: String Graphs","title":"Visualization and Graph Analysis","text":"Provide insights into graph structure.\n\nprintln(\"\\n7. GRAPH STRUCTURE ANALYSIS\")\nprintln(\"-\"^50)\n\nfunction analyze_graph_structure(graph, description)\n    \"\"\"Analyze structural properties of a string graph.\"\"\"\n\n    vertices = collect(Mycelia.MetaGraphsNext.labels(graph))\n    num_vertices = length(vertices)\n\n    if num_vertices == 0\n        println(\"  $description: Empty graph\")\n        return\n    end\n\n    # Basic statistics\n    vertex_lengths = [length(v) for v in vertices]\n    avg_length = Statistics.mean(vertex_lengths)\n\n    println(\"  $description:\")\n    println(\"    Vertices: $num_vertices\")\n    println(\"    Average vertex length: $(round(avg_length, digits=2))\")\n\n    # Character distribution analysis\n    all_chars = join(vertices)\n    char_counts = Dict{Char, Int}()\n    for char in all_chars\n        char_counts[char] = get(char_counts, char, 0) + 1\n    end\n\n    top_chars = sort(collect(char_counts), by=x->x[2], rev=true)\n    println(\"    Character distribution (top 5):\")\n    for (char, count) in top_chars[1:min(5, length(top_chars))]\n        println(\"      '$char': $count\")\n    end\n\n    return (\n        vertices = num_vertices,\n        avg_length = avg_length,\n        char_distribution = char_counts\n    )\nend\n\nAnalyze a few representative graphs\n\nprintln(\"Analyzing graph structures:\")\n\nfor n in [3, 4]\n    test_text = \"The quick brown fox jumps over the lazy dog\"\n    if length(test_text) >= n\n        graph = Mycelia.Rhizomorph.build_ngram_graph([test_text], n; dataset_id=\"structure_demo_n$(n)\")\n        analyze_graph_structure(graph, \"$(n)-gram graph of: \\\"$test_text\\\"\")\n    end\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_01_string_graphs/#Tutorial-Summary-and-Conclusions","page":"Round-Trip 01: String Graphs","title":"Tutorial Summary and Conclusions","text":"Summarize what we've learned and provide guidance for next steps.\n\nprintln(\"\\n\" * \"=\"^80)\nprintln(\"TUTORIAL SUMMARY AND CONCLUSIONS\")\nprintln(\"=\"^80)\n\nprintln(\"\\\\n✅ SUCCESSFUL COMPLETION OF STRING GRAPH ROUND-TRIP WORKFLOW:\")\nprintln(\"  1. Data Preparation: Created diverse string datasets\")\nprintln(\"  2. Graph Construction: Built n-gram graphs with various parameters\")\nprintln(\"  3. Assembly Process: Reconstructed strings from graph representations\")\nprintln(\"  4. Quality Assessment: Evaluated reconstruction accuracy\")\nprintln(\"  5. Performance Analysis: Measured efficiency and scaling behavior\")\nprintln(\"  6. Real-world Application: Applied to DNA sequence analysis\")\n\nprintln(\"\\\\n📊 KEY FINDINGS:\")\nprintln(\"  • String graphs provide effective compression of repetitive text\")\nprintln(\"  • Reconstruction quality depends on n-gram size and text complexity\")\nprintln(\"  • Success rate: $(round(quality_metrics.success_rate * 100, digits=1))%\")\nprintln(\"  • Average similarity: $(round(quality_metrics.average_similarity, digits=3))\")\nprintln(\"  • Memory usage scales with unique n-gram count\")\n\nprintln(\"\\\\n💡 INSIGHTS:\")\nprintln(\"  • Larger n-grams provide more specificity but less compression\")\nprintln(\"  • Highly repetitive sequences achieve better compression ratios\")\nprintln(\"  • Unicode text support enables international language analysis\")\nprintln(\"  • String graphs are foundation for more complex biological graphs\")\n\nprintln(\"\\\\n🔄 ROUND-TRIP WORKFLOW VALIDATED:\")\nprintln(\"  Raw String Data → N-gram Graph → Assembled Strings\")\nprintln(\"  ✓ Input data successfully processed\")\nprintln(\"  ✓ Graph construction completed\")\nprintln(\"  ✓ Assembly operations performed\")\nprintln(\"  ✓ Quality metrics calculated\")\nprintln(\"  ✓ Results validated and analyzed\")\n\nprintln(\"\\\\n🚀 NEXT STEPS:\")\nprintln(\"  • Tutorial 2: String data → N-gram graphs → String graphs\")\nprintln(\"  • Tutorial 3: FASTA sequences → Sequence graphs → Reconstruction\")\nprintln(\"  • Tutorial 4: FASTA sequences → K-mer graphs → Sequence graphs\")\nprintln(\"  • Tutorial 5: FASTQ sequences → FASTQ graphs (direct quality-aware)\")\nprintln(\"  • Tutorial 6: FASTQ sequences → Qualmer graphs → FASTQ graphs\")\n\nprintln(\"\\\\n📚 LEARNING OUTCOMES ACHIEVED:\")\nprintln(\"  ✓ Understand string graph construction and reconstruction\")\nprintln(\"  ✓ Perform quality assessment with similarity metrics\")\nprintln(\"  ✓ Analyze computational performance and memory usage\")\nprintln(\"  ✓ Apply string graphs to real-world text analysis\")\nprintln(\"  ✓ Evaluate trade-offs between compression and accuracy\")\n\nprintln(\"\\\\n\" * \"=\"^80)\nprintln(\"Ready to proceed to Tutorial 2: N-gram to String Graph Workflow!\")\nprintln(\"=\"^80)","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Tutorial-6:-FASTQ-Sequences-to-Qualmer-Graphs-and-Back","page":"Round-Trip 06: Qualmer Graphs","title":"Tutorial 6: FASTQ Sequences to Qualmer Graphs and Back","text":"This tutorial demonstrates the round-trip workflow from FASTQ sequences through quality-aware k-mer (qualmer) graphs and back to reconstructed sequences. Qualmers incorporate both sequence information and quality scores for more accurate assembly decisions.","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Learning-Objectives","page":"Round-Trip 06: Qualmer Graphs","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nHow to create qualmer graphs from FASTQ data\nHow quality scores influence k-mer confidence\nHow to perform quality-aware assembly using package functions\nHow to reconstruct sequences while preserving quality information\nThe advantages of quality-aware vs coverage-only assembly","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Setup-and-Imports","page":"Round-Trip 06: Qualmer Graphs","title":"Setup and Imports","text":"Following CLAUDE.md standards: only import top-level packages, use full namespacing\n\nFrom the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/09_round_trip_06_qualmer_graphs.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Mycelia\nimport FASTX\nimport Test\nimport Statistics","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-1:-Understanding-Qualmers","page":"Round-Trip 06: Qualmer Graphs","title":"Part 1: Understanding Qualmers","text":"Qualmers are k-mers with associated quality information. When the same k-mer is observed multiple times with different quality scores, we calculate a joint probability that represents our confidence in that k-mer's correctness.","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Creating-Sample-FASTQ-Data-with-Varying-Quality","page":"Round-Trip 06: Qualmer Graphs","title":"Creating Sample FASTQ Data with Varying Quality","text":"function create_sample_fastq_data()\n    # High-quality read\n    hq_seq = \"ATCGATCGATCGATCGATCG\"\n    hq_qual = \"IIIIIIIIIIIIIIIIIIII\"  ## Phred 40 (99.99% accuracy)\n\n    # Medium-quality read with overlap\n    mq_seq = \"GATCGATCGATCGATCGTAG\"\n    mq_qual = \"FFFFFFFFFFFFFFFFFF@@\"  ## Phred 37 (99.98%) with lower end\n\n    # Low-quality read with errors\n    lq_seq = \"GATCGATCGATCGATCGTAC\"  ## Error at end (C instead of G)\n    lq_qual = \"555555555555555555##\"  ## Phred 20 (99%) with very low end\n\n    # Create FASTQ records\n    records = [\n        FASTX.FASTQ.Record(\"read1\", hq_seq, hq_qual),\n        FASTX.FASTQ.Record(\"read2\", mq_seq, mq_qual),\n        FASTX.FASTQ.Record(\"read3\", lq_seq, lq_qual)\n    ]\n\n    return records\nend\n\nprintln(\"Creating sample FASTQ data with varying quality scores...\")\nfastq_records = create_sample_fastq_data()\n\nDisplay the records\n\nfor (i, record) in enumerate(fastq_records)\n    println(\"\\nRead $i:\")\n    println(\"  Sequence: \", String(FASTX.sequence(record)))\n    println(\"  Quality:  \", String(FASTX.quality(record)))\n    println(\"  Phred scores: \", FASTX.quality_scores(record))\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-2:-Building-Qualmer-Graphs","page":"Round-Trip 06: Qualmer Graphs","title":"Part 2: Building Qualmer Graphs","text":"Qualmer graphs combine k-mer information with quality scores to make more informed assembly decisions.","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Build-a-qualmer-graph-with-k7","page":"Round-Trip 06: Qualmer Graphs","title":"Build a qualmer graph with k=7","text":"k = 7\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Building qualmer graph with k=$k...\")\n\nqualmer_dataset_id = \"qualmer_demo\"\nqualmer_graph = Mycelia.Rhizomorph.build_qualmer_graph(\n    fastq_records,\n    k;\n    dataset_id=qualmer_dataset_id,\n    mode=:doublestrand\n)\nqualmer_labels = collect(Mycelia.MetaGraphsNext.labels(qualmer_graph))\n\nExamine graph properties\n\nprintln(\"\\nQualmer graph statistics:\")\nprintln(\"  Number of vertices (unique k-mers): \", length(qualmer_labels))\nprintln(\"  Number of edges: \", Mycelia.MetaGraphsNext.ne(qualmer_graph))","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Inspect-qualmer-properties","page":"Round-Trip 06: Qualmer Graphs","title":"Inspect qualmer properties","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Examining qualmer vertices and their properties:\")\n\nGet first few vertices to examine\n\nfor label in Iterators.take(qualmer_labels, 5)\n    vertex_data = qualmer_graph[label]\n    joint_quality = Mycelia.Rhizomorph.get_vertex_joint_quality(vertex_data, qualmer_dataset_id)\n    mean_quality = Mycelia.Rhizomorph.get_vertex_mean_quality(vertex_data, qualmer_dataset_id)\n    joint_mean = isnothing(joint_quality) ? 0.0 : Statistics.mean(Float64.(joint_quality))\n    mean_mean = isnothing(mean_quality) ? 0.0 : Statistics.mean(mean_quality)\n    coverage = Mycelia.Rhizomorph.count_evidence_entries(vertex_data)\n    println(\"\\nVertex $label:\")\n    println(\"  K-mer: \", label)\n    println(\"  Coverage: \", coverage)\n    println(\"  Mean quality: \", round(mean_mean, digits=2))\n    println(\"  Joint quality: \", round(joint_mean, digits=2))\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-3:-Quality-Aware-vs-Coverage-Only-Assembly","page":"Round-Trip 06: Qualmer Graphs","title":"Part 3: Quality-Aware vs Coverage-Only Assembly","text":"Let's compare how quality information affects assembly decisions.","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Find-high-confidence-paths-using-quality-information","page":"Round-Trip 06: Qualmer Graphs","title":"Find high-confidence paths using quality information","text":"println(\"\\n\" * \"=\"^60)\nprintln(\"Finding high-confidence paths through the qualmer graph...\")\n\nGet all vertices sorted by joint probability (confidence)\n\nvertices_by_confidence = sort(\n    qualmer_labels,\n    by=v -> Mycelia.Rhizomorph.mean_joint_quality(qualmer_graph, v, qualmer_dataset_id),\n    rev=true\n)\n\nprintln(\"\\nTop 5 most confident k-mers:\")\nfor v in vertices_by_confidence[1:min(5, length(vertices_by_confidence))]\n    vdata = qualmer_graph[v]\n    coverage = Mycelia.Rhizomorph.count_evidence_entries(vdata)\n    joint_mean = Mycelia.Rhizomorph.mean_joint_quality(qualmer_graph, v, qualmer_dataset_id)\n    mean_quality = Mycelia.Rhizomorph.get_vertex_mean_quality(vdata, qualmer_dataset_id)\n    mean_mean = isnothing(mean_quality) ? 0.0 : Statistics.mean(mean_quality)\n    println(\"  \", v,\n            \" - Coverage: \", coverage,\n            \", Joint Q: \", round(joint_mean, digits=2),\n            \", Mean Q: \", round(mean_mean, digits=1))\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Compare-with-coverage-only-approach","page":"Round-Trip 06: Qualmer Graphs","title":"Compare with coverage-only approach","text":"vertices_by_coverage = sort(\n    qualmer_labels,\n    by=v -> Mycelia.Rhizomorph.count_evidence_entries(qualmer_graph[v]),\n    rev=true\n)\n\nprintln(\"\\nTop 5 highest coverage k-mers:\")\nfor v in vertices_by_coverage[1:min(5, length(vertices_by_coverage))]\n    vdata = qualmer_graph[v]\n    coverage = Mycelia.Rhizomorph.count_evidence_entries(vdata)\n    joint_mean = Mycelia.Rhizomorph.mean_joint_quality(qualmer_graph, v, qualmer_dataset_id)\n    mean_quality = Mycelia.Rhizomorph.get_vertex_mean_quality(vdata, qualmer_dataset_id)\n    mean_mean = isnothing(mean_quality) ? 0.0 : Statistics.mean(mean_quality)\n    println(\"  \", v,\n            \" - Coverage: \", coverage,\n            \", Joint Q: \", round(joint_mean, digits=2),\n            \", Mean Q: \", round(mean_mean, digits=1))\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-4:-Quality-Aware-Path-Finding","page":"Round-Trip 06: Qualmer Graphs","title":"Part 4: Quality-Aware Path Finding","text":"Use Rhizomorph path finding and quality scoring to select a likely path.\n\nFind candidate paths and select the highest-quality path\n\npaths = Mycelia.Rhizomorph.find_eulerian_paths_next(qualmer_graph)\nquality_path = []\nbest_path_score = 0.0\nfor path in paths\n    score = Mycelia.Rhizomorph.mean_path_quality(qualmer_graph, path, qualmer_dataset_id)\n    if score > best_path_score\n        best_path_score = score\n        quality_path = path\n    end\nend\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Quality-weighted path through graph:\")\nprintln(\"Path length: \", length(quality_path), \" vertices\")\n\nShow path k-mers and qualities\n\nprintln(\"\\nPath details:\")\nfor (i, v) in enumerate(quality_path[1:min(10, length(quality_path))])\n    joint_mean = Mycelia.Rhizomorph.mean_joint_quality(qualmer_graph, v, qualmer_dataset_id)\n    println(\"  Step $i: \", v,\n            \" (mean joint Q: \", round(joint_mean, digits=2), \")\")\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-5:-Converting-to-Quality-Aware-BioSequence-Graph","page":"Round-Trip 06: Qualmer Graphs","title":"Part 5: Converting to Quality-Aware BioSequence Graph","text":"Convert the qualmer graph to a variable-length quality-aware sequence graph.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Converting qualmer graph to quality-aware BioSequence graph...\")\n\nConvert to FASTQ graph (variable-length with quality)\n\nfastq_graph = Mycelia.Rhizomorph.convert_fixed_to_variable(qualmer_graph)\nfastq_labels = collect(Mycelia.MetaGraphsNext.labels(fastq_graph))\n\nprintln(\"\\nFASTQ graph statistics:\")\nprintln(\"  Number of vertices: \", length(fastq_labels))\nprintln(\"  Number of edges: \", Mycelia.MetaGraphsNext.ne(fastq_graph))\n\nExamine simplified vertices\n\nprintln(\"\\nExamining quality-aware sequence vertices:\")\nfor label in Iterators.take(fastq_labels, 3)\n    vertex_data = fastq_graph[label]\n    mean_quality = Statistics.mean(Mycelia.Rhizomorph.decode_quality_scores(vertex_data.quality_scores))\n    println(\"\\nVertex: \", label)\n    println(\"  Sequence: \", string(vertex_data.sequence))\n    println(\"  Length: \", length(vertex_data.sequence))\n    println(\"  Quality scores: \", vertex_data.quality_scores[1:min(20, length(vertex_data.quality_scores))], \"...\")\n    println(\"  Mean quality: \", round(mean_quality, digits=1))\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-6:-Round-Trip-Reconstruction","page":"Round-Trip 06: Qualmer Graphs","title":"Part 6: Round-Trip Reconstruction","text":"Reconstruct FASTQ records from the quality-aware graph.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Reconstructing FASTQ records from the graph...\")\n\nExtract paths and convert to FASTQ records\n\nreconstructed_records = Mycelia.Rhizomorph.fastq_graph_to_records(fastq_graph, \"reconstructed\")\n\nprintln(\"\\nReconstructed \", length(reconstructed_records), \" FASTQ records\")\n\nCompare with original\n\nprintln(\"\\nComparison with original reads:\")\nfor (i, (orig, recon)) in enumerate(zip(fastq_records[1:min(3, length(reconstructed_records))],\n                                        reconstructed_records[1:min(3, length(reconstructed_records))]))\n    orig_seq = String(FASTX.sequence(orig))\n    recon_seq = String(FASTX.sequence(recon))\n\n    println(\"\\nRead $i:\")\n    println(\"  Original:      \", orig_seq)\n    println(\"  Reconstructed: \", recon_seq)\n    println(\"  Match: \", orig_seq == recon_seq ? \"✓\" : \"✗\")\n\n    # Compare quality scores\n    orig_qual = FASTX.quality_scores(orig)\n    recon_qual = FASTX.quality_scores(recon)\n    println(\"  Original quality range: \", minimum(orig_qual), \"-\", maximum(orig_qual))\n    println(\"  Reconstructed quality range: \", minimum(recon_qual), \"-\", maximum(recon_qual))\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-7:-Error-Correction-Using-Quality-Information","page":"Round-Trip 06: Qualmer Graphs","title":"Part 7: Error Correction Using Quality Information","text":"Demonstrate how quality scores help identify and correct errors using package functions.\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Demonstrating quality-aware error correction...\")\n\nCreate reads with a known error\n\nerror_reads = [\n    FASTX.FASTQ.Record(\"good1\", \"ATCGATCGATCG\", \"IIIIIIIIIIII\"),  ## High quality\n    FASTX.FASTQ.Record(\"good2\", \"TCGATCGATCGA\", \"IIIIIIIIIIII\"),  ## High quality\n    FASTX.FASTQ.Record(\"error\", \"TCGATCTATCGA\", \"IIIIII##IIII\"),  ## Error at low quality position\n]\n\nBuild qualmer graph\n\nerror_dataset_id = \"error_demo\"\nerror_graph = Mycelia.Rhizomorph.build_qualmer_graph(error_reads, 5; dataset_id=error_dataset_id, mode=:singlestrand)\nerror_labels = collect(Mycelia.MetaGraphsNext.labels(error_graph))\n\nprintln(\"\\nAnalyzing k-mers around error position:\")\n\nThe error creates k-mers: GATCT (wrong) vs GATCG (correct)\n\nfor label in error_labels\n    vdata = error_graph[label]\n    kmer_str = string(label)\n    if occursin(\"GATC\", kmer_str)\n        coverage = Mycelia.Rhizomorph.count_evidence_entries(vdata)\n        joint_mean = Mycelia.Rhizomorph.mean_joint_quality(error_graph, label, error_dataset_id)\n        println(\"  K-mer: \", kmer_str,\n                \" - Coverage: \", coverage,\n                \", Joint Q: \", round(joint_mean, digits=2))\n    end\nend\n\nUse quality filtering to identify potential errors\n\nhigh_quality = Mycelia.Rhizomorph.find_high_quality_kmers(error_graph, 30; dataset_id=error_dataset_id)\npotential_errors = [label for label in error_labels if !(label in high_quality)]\nprintln(\"\\nPotential error k-mers identified: \", length(potential_errors))\n\nfor error_label in potential_errors\n    vdata = error_graph[error_label]\n    coverage = Mycelia.Rhizomorph.count_evidence_entries(vdata)\n    mean_quality = Mycelia.Rhizomorph.get_vertex_mean_quality(vdata, error_dataset_id)\n    mean_mean = isnothing(mean_quality) ? 0.0 : Statistics.mean(mean_quality)\n    joint_mean = Mycelia.Rhizomorph.mean_joint_quality(error_graph, error_label, error_dataset_id)\n    println(\"  Error k-mer: \", error_label,\n            \" - Coverage: \", coverage,\n            \", Mean Q: \", round(mean_mean, digits=1),\n            \", Joint Q: \", round(joint_mean, digits=2))\nend","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-8:-Advanced-Quality-Metrics","page":"Round-Trip 06: Qualmer Graphs","title":"Part 8: Advanced Quality Metrics","text":"Calculate assembly quality metrics using the package function.\n\nmetrics = Mycelia.Rhizomorph.get_qualmer_statistics(qualmer_graph; dataset_id=qualmer_dataset_id)\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Assembly quality metrics:\")\nprintln(\"  Mean joint quality: \", round(metrics[:mean_joint_quality], digits=2))\nprintln(\"  Min joint quality: \", metrics[:min_joint_quality])\nprintln(\"  Max joint quality: \", metrics[:max_joint_quality])\nprintln(\"  Total unique k-mers: \", metrics[:num_vertices])","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Part-9:-Practical-Example-Assembling-a-Small-Genome-Region","page":"Round-Trip 06: Qualmer Graphs","title":"Part 9: Practical Example - Assembling a Small Genome Region","text":"Let's create a more realistic example with overlapping reads from a genome region.\n\nfunction create_genome_region_reads()\n    # Simulate a 50bp genome region\n    true_sequence = \"ATCGATCGATCGTAGCTAGCTAGCTTGCATGCATGCATGCATGCATGCAT\"\n\n    # Generate overlapping reads with varying quality\n    reads = []\n\n    # High quality reads\n    push!(reads, FASTX.FASTQ.Record(\"hq1\", true_sequence[1:25], \"I\"^25))\n    push!(reads, FASTX.FASTQ.Record(\"hq2\", true_sequence[15:40], \"I\"^26))\n    push!(reads, FASTX.FASTQ.Record(\"hq3\", true_sequence[30:50], \"I\"^21))\n\n    # Medium quality reads with some errors\n    read_mq1 = true_sequence[5:30]\n    qual_mq1 = \"FFFFFFFFFFFFFFFFFFFFFFFFFF\"\n    push!(reads, FASTX.FASTQ.Record(\"mq1\", read_mq1, qual_mq1))\n\n    # Low quality read with error\n    read_lq1 = true_sequence[20:45]\n    read_lq1 = read_lq1[1:10] * \"T\" * read_lq1[12:end]  ## Error at position 11\n    qual_lq1 = \"AAAAAAAAAA#AAAAAAAAAAAAAA\"  ## Low quality at error\n    push!(reads, FASTX.FASTQ.Record(\"lq1\", read_lq1, qual_lq1))\n\n    return reads, true_sequence\nend\n\ngenome_reads, true_seq = create_genome_region_reads()\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Assembling genome region from overlapping reads...\")\nprintln(\"True sequence: \", true_seq)\nprintln(\"Number of reads: \", length(genome_reads))\n\nBuild qualmer graph\n\ngenome_dataset_id = \"genome_demo\"\ngenome_graph = Mycelia.Rhizomorph.build_qualmer_graph(genome_reads, 9; dataset_id=genome_dataset_id, mode=:singlestrand)\n\nConvert to sequence graph and extract contigs\n\nseq_graph = Mycelia.Rhizomorph.convert_fixed_to_variable(genome_graph)\ngenome_labels = collect(Mycelia.MetaGraphsNext.labels(genome_graph))\nseq_labels = collect(Mycelia.MetaGraphsNext.labels(seq_graph))\n\nprintln(\"\\nAssembly results:\")\nprintln(\"  Qualmer graph: \", length(genome_labels), \" vertices, \", Mycelia.MetaGraphsNext.ne(genome_graph), \" edges\")\nprintln(\"  Sequence graph: \", length(seq_labels), \" vertices, \", Mycelia.MetaGraphsNext.ne(seq_graph), \" edges\")\n\nUse package function to find quality-weighted path\n\nif !isempty(genome_labels)\n    paths = Mycelia.Rhizomorph.find_eulerian_paths_next(genome_graph)\n    best_path = []\n    best_score = 0.0\n    for path in paths\n        score = Mycelia.Rhizomorph.mean_path_quality(genome_graph, path, genome_dataset_id)\n        if score > best_score\n            best_score = score\n            best_path = path\n        end\n    end\n\n    println(\"\\nBest quality-weighted path:\")\n    println(\"  Path length: \", length(best_path), \" k-mers\")\n\n    # Reconstruct sequence from path\n    if length(best_path) > 1\n        reconstructed = string(Mycelia.Rhizomorph.path_to_sequence(best_path, genome_graph))\n\n        println(\"  Reconstructed length: \", length(reconstructed))\n        println(\"  Reconstructed: \", reconstructed)\n\n        # Check accuracy\n        if reconstructed == true_seq\n            println(\"  ✓ Perfect reconstruction!\")\n        elseif occursin(reconstructed, true_seq)\n            println(\"  ✓ Assembled sequence is a substring of true sequence\")\n        elseif occursin(true_seq, reconstructed)\n            println(\"  ✓ True sequence is a substring of assembled sequence\")\n        else\n            println(\"  ✗ Assembly differs from true sequence\")\n            println(\"  True:      \", true_seq)\n            println(\"  Assembled: \", reconstructed)\n        end\n    end\nend\n\nFind longest path (contig) from sequence graph\n\nif !isempty(seq_labels)\n    contigs = Mycelia.Rhizomorph.find_contigs_next(seq_graph; min_contig_length=1)\n    if isempty(contigs)\n        longest_seq = seq_graph[seq_labels[argmax(length.(seq_labels))]].sequence\n        longest_qual = seq_graph[seq_labels[argmax(length.(seq_labels))]].quality_scores\n    else\n        longest_contig = contigs[argmax(length.(getfield.(contigs, :sequence)))]\n        longest_seq = longest_contig.sequence\n        longest_qual = seq_graph[longest_contig.vertices[1]].quality_scores\n    end\n\n    println(\"\\nLongest contig from simplified graph:\")\n    println(\"  Length: \", length(longest_seq))\n    println(\"  Sequence: \", longest_seq)\n    println(\"  Mean quality: \", round(Statistics.mean(Mycelia.Rhizomorph.decode_quality_scores(longest_qual)), digits=1))\n\n    # Check accuracy\n    if String(longest_seq) == true_seq\n        println(\"  ✓ Perfect reconstruction!\")\n    else\n        # Find best alignment\n        true_str = true_seq\n        assembled_str = String(longest_seq)\n        if occursin(assembled_str, true_str)\n            println(\"  ✓ Assembled sequence is a substring of true sequence\")\n        elseif occursin(true_str, assembled_str)\n            println(\"  ✓ True sequence is a substring of assembled sequence\")\n        else\n            println(\"  ✗ Assembly differs from true sequence\")\n        end\n    end\nend\n\nCalculate final quality metrics for the genome assembly\n\nfinal_metrics = Mycelia.Rhizomorph.get_qualmer_statistics(genome_graph; dataset_id=genome_dataset_id)\nprintln(\"\\nFinal assembly quality metrics:\")\nprintln(\"  Mean joint quality: \", round(final_metrics[:mean_joint_quality], digits=2))\nprintln(\"  Min joint quality: \", final_metrics[:min_joint_quality])\nprintln(\"  Max joint quality: \", final_metrics[:max_joint_quality])","category":"section"},{"location":"generated/tutorials/09_round_trip_06_qualmer_graphs/#Summary","page":"Round-Trip 06: Qualmer Graphs","title":"Summary","text":"In this tutorial, we've demonstrated:\n\nQualmer Construction: Building quality-aware k-mer graphs from FASTQ data\nJoint Probability: How multiple observations with different qualities are combined\nQuality vs Coverage: The advantage of using quality scores over coverage alone\nPackage Functions: Using Mycelia.Rhizomorph utilities for quality-weighted analysis:\nfind_eulerian_paths_next() + path_to_sequence() for path-based reconstruction\nget_qualmer_statistics() for quality assessment\nfind_high_quality_kmers() for error screening\nRound-Trip Conversion: Maintaining quality information through graph transformations\nPractical Assembly: Using quality information for more accurate genome assembly\n\nKey advantages of qualmer graphs:\n\nBetter discrimination between true k-mers and errors\nQuality-weighted path finding for more accurate assembly\nPreservation of quality information for downstream analysis\nImproved handling of repetitive regions with varying quality\nBuilt-in error detection and quality assessment capabilities\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Tutorial 6 completed!\")\nprintln(\"You've learned how to use quality-aware k-mer graphs for improved assembly accuracy.\")\nprintln(\"All analysis was performed using Mycelia's built-in qualmer analysis functions.\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Tutorial-4:-Genome-Assembly","page":"Step 4: Genome Assembly","title":"Tutorial 4: Genome Assembly","text":"This tutorial covers comprehensive genome assembly approaches, including short read, long read, and hybrid assembly methods, with emphasis on Mycelia's third-party assembler orchestration and benchmarking utilities.","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Learning-Objectives","page":"Step 4: Genome Assembly","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nDifferent assembly algorithms and their applications\nShort read assembly with MEGAHIT and metaSPAdes\nLong read assembly with Flye, Canu, and hifiasm\nHybrid assembly approaches combining multiple data types (Unicycler)\nAssembly quality metrics and their interpretation\nError correction and polishing techniques\nHandling repetitive sequences and structural variants\nAssembly validation and benchmarking approaches\n\nNOTE: Mycelia Rhizomorph assembly has been moved to tutorial 13 (tutorials/13rhizomorphassembly.jl) and is kept as a skeleton while Rhizomorph unit tests stabilize.","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Setup","page":"Step 4: Genome Assembly","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/04_genome_assembly.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\nimport BioSequences\nimport Kmers\n\nRandom.seed!(42)\n\nthreads = min(Mycelia.get_default_threads(), 4)\nassembly_output = \"assembly_output\"\nmkpath(assembly_output)","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Part-1:-Assembly-Algorithm-Overview","page":"Step 4: Genome Assembly","title":"Part 1: Assembly Algorithm Overview","text":"Understanding different assembly approaches helps choose the right method for your data type and research goals.\n\nprintln(\"=== Genome Assembly Tutorial ===\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Assembly-Paradigms","page":"Step 4: Genome Assembly","title":"Assembly Paradigms","text":"Four main approaches to genome assembly:\n\nde Bruijn Graph - for short reads (MEGAHIT, metaSPAdes)\nOverlap-Layout-Consensus (OLC) - for long reads (Canu)\nString Graph - for long accurate reads (hifiasm, Flye)\nProbabilistic Assembly - Mycelia Rhizomorph (see tutorial 13)\n\nprintln(\"Assembly Algorithm Comparison:\")\nprintln(\"de Bruijn Graph:\")\nprintln(\"  - Best for: Short reads (Illumina)\")\nprintln(\"  - Tools: MEGAHIT, metaSPAdes, SPAdes\")\nprintln(\"  - Strengths: Efficient, handles high coverage\")\nprintln(\"  - Weaknesses: Struggles with repeats, requires error correction\")\nprintln()\nprintln(\"OLC (Overlap-Layout-Consensus):\")\nprintln(\"  - Best for: Long reads (PacBio, Nanopore)\")\nprintln(\"  - Tools: Canu, Miniasm\")\nprintln(\"  - Strengths: Handles repeats, intuitive approach\")\nprintln(\"  - Weaknesses: Computationally expensive, error-sensitive\")\nprintln()\nprintln(\"String Graph:\")\nprintln(\"  - Best for: Long accurate reads (HiFi)\")\nprintln(\"  - Tools: hifiasm, Flye\")\nprintln(\"  - Strengths: Efficient, haplotype-aware, handles complexity\")\nprintln(\"  - Weaknesses: Requires high-quality reads\")\nprintln()\nprintln(\"Probabilistic Assembly (Mycelia Rhizomorph):\")\nprintln(\"  - Best for: Any read type with error correction\")\nprintln(\"  - Tools: Rhizomorph string graph + Viterbi\")\nprintln(\"  - Strengths: Handles errors probabilistically, adaptable\")\nprintln(\"  - Weaknesses: Computationally intensive for large genomes\")\nprintln(\"  - See tutorial 13 for Rhizomorph assembly details\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Part-2:-Data-Preparation-for-Assembly","page":"Step 4: Genome Assembly","title":"Part 2: Data Preparation for Assembly","text":"Proper data preparation is crucial for successful assembly\n\nprintln(\"\\n=== Data Preparation ===\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Simulating-Multi-Platform-Data","page":"Step 4: Genome Assembly","title":"Simulating Multi-Platform Data","text":"Create synthetic data for comprehensive assembly testing\n\nprintln(\"--- Generating Test Data ---\")\n\nCreate a synthetic genome with known structure\n\nreference_size = 50_000  ## 50 kb for demonstration\nreference_genome = Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=reference_size)\n\nprintln(\"Reference genome: $(reference_size) bp\")\n\nSimulate different read types\n\nshort_read_params = Dict(\n    \"coverage\" => 30,\n    \"read_length\" => 150,\n    \"error_rate\" => 0.001,\n    \"description\" => \"Illumina short reads\"\n)\n\nlong_read_params = Dict(\n    \"coverage\" => 20,\n    \"read_length\" => 10_000,\n    \"error_rate\" => 0.05,\n    \"description\" => \"Nanopore long reads\"\n)\n\nhifi_params = Dict(\n    \"coverage\" => 15,\n    \"read_length\" => 15_000,\n    \"error_rate\" => 0.001,\n    \"description\" => \"PacBio HiFi reads\"\n)\n\nprintln(\"Simulating read types:\")\nfor (name, params) in [(\"Short reads\", short_read_params),\n                      (\"Long reads\", long_read_params),\n                      (\"HiFi reads\", hifi_params)]\n    println(\"  $(name): $(params[\"coverage\"])x coverage, $(params[\"read_length\"]) bp, $(params[\"error_rate\"] * 100)% error\")\nend\n\nWrite test data\n\nreference_file = joinpath(assembly_output, \"reference_genome.fasta\")\nMycelia.write_fasta(outfile=reference_file, records=[reference_genome])\n\nGenerate paired-end short reads (Illumina)\n\nshort_reads_base = joinpath(assembly_output, \"short_reads\")\nshort_sim = Mycelia.simulate_illumina_reads(\n    fasta=reference_file,\n    coverage=short_read_params[\"coverage\"],\n    outbase=short_reads_base,\n    read_length=short_read_params[\"read_length\"],\n    rndSeed=42,\n    quiet=true\n)\nshort_reads_r1 = short_sim.forward_reads\nshort_reads_r2 = short_sim.reverse_reads\n\nGenerate long reads for Flye/Canu (Nanopore)\n\nlong_reads_gz = Mycelia.simulate_nanopore_reads(\n    fasta=reference_file,\n    quantity=\"$(long_read_params[\"coverage\"])x\",\n    outfile=joinpath(assembly_output, \"long_reads.fastq.gz\"),\n    quiet=true\n)\nlong_reads_file = joinpath(assembly_output, \"long_reads.fastq\")\nif !isfile(long_reads_file)\n    run(pipeline(`gzip -dc $(long_reads_gz)`, long_reads_file))\nend\n\nGenerate HiFi reads for hifiasm (PacBio HiFi)\n\nhifi_reads_gz = Mycelia.simulate_pacbio_reads(\n    fasta=reference_file,\n    quantity=\"$(hifi_params[\"coverage\"])x\",\n    outfile=joinpath(assembly_output, \"hifi_reads.fastq.gz\"),\n    quiet=true\n)\nhifi_reads_file = joinpath(assembly_output, \"hifi_reads.fastq\")\nif !isfile(hifi_reads_file)\n    run(pipeline(`gzip -dc $(hifi_reads_gz)`, hifi_reads_file))\nend\n\nGenerate error-prone reads for polishing demonstrations\n\nerror_reads_gz = Mycelia.simulate_very_bad_reads(\n    fasta=reference_file,\n    quantity=\"10x\",\n    outfile=joinpath(assembly_output, \"error_reads.fastq.gz\"),\n    quiet=true\n)\nerror_reads_file = joinpath(assembly_output, \"error_reads.fastq\")\nif !isfile(error_reads_file)\n    run(pipeline(`gzip -dc $(error_reads_gz)`, error_reads_file))\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Read-Statistics-and-Quality-Assessment","page":"Step 4: Genome Assembly","title":"Read Statistics and Quality Assessment","text":"Analyze read characteristics before assembly\n\nprintln(\"--- Read Analysis ---\")\n\nshort_r1_stats = Mycelia.summarize_fastq(\"Short reads R1\", short_reads_r1, reference_size)\nshort_r2_stats = Mycelia.summarize_fastq(\"Short reads R2\", short_reads_r2, reference_size)\nlong_read_stats = Mycelia.summarize_fastq(\"Long reads\", long_reads_file, reference_size)\nhifi_stats = Mycelia.summarize_fastq(\"HiFi reads\", hifi_reads_file, reference_size)\nerror_read_stats = Mycelia.summarize_fastq(\"Error-prone reads\", error_reads_file, reference_size)","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Part-3:-Multi-Platform-Assembly-Approaches","page":"Step 4: Genome Assembly","title":"Part 3: Multi-Platform Assembly Approaches","text":"Comprehensive coverage of short read, long read, and hybrid assembly\n\nprintln(\"\\n=== Multi-Platform Assembly Approaches ===\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Short-Read-Assembly","page":"Step 4: Genome Assembly","title":"Short Read Assembly","text":"MEGAHIT and metaSPAdes for short read data\n\nprintln(\"--- Short Read Assembly ---\")\n\nExample parameters for short read assembly\n\nshort_read_assembly_params = Dict(\n    \"megahit_k_list\" => \"21,29,39,59,79,99,119,141\",\n    \"metaspades_k_list\" => \"21,33,55,77\",\n    \"min_contig_len\" => 200,\n    \"threads\" => threads\n)\n\nprintln(\"Short read assembly parameters:\")\nfor (param, value) in short_read_assembly_params\n    println(\"  $param: $value\")\nend\n\nshort_read_runs = []\n\nmegahit_result, megahit_runtime = Mycelia.run_assembler(\"MEGAHIT\") do\n    Mycelia.run_megahit(\n        fastq1=short_reads_r1,\n        fastq2=short_reads_r2,\n        outdir=joinpath(assembly_output, \"megahit_short\"),\n        min_contig_len=short_read_assembly_params[\"min_contig_len\"],\n        k_list=short_read_assembly_params[\"megahit_k_list\"],\n        threads=threads\n    )\nend\nif megahit_result !== nothing\n    push!(short_read_runs, (name=\"MEGAHIT\", assembly=megahit_result.contigs, outdir=megahit_result.outdir, runtime=megahit_runtime, reads=short_reads_r1))\nend\n\nmetaspades_result, metaspades_runtime = Mycelia.run_assembler(\"metaSPAdes\") do\n    Mycelia.run_metaspades(\n        fastq1=short_reads_r1,\n        fastq2=short_reads_r2,\n        outdir=joinpath(assembly_output, \"metaspades_short\"),\n        k_list=short_read_assembly_params[\"metaspades_k_list\"],\n        threads=threads\n    )\nend\nif metaspades_result !== nothing\n    push!(short_read_runs, (name=\"metaSPAdes\", assembly=metaspades_result.contigs, outdir=metaspades_result.outdir, runtime=metaspades_runtime, reads=short_reads_r1))\nend\n\nprintln(\"Short read assembly metrics:\")\nfor run in short_read_runs\n    metrics = Mycelia.assembly_metrics(run.assembly)\n    if metrics === nothing\n        println(\"  $(run.name): assembly file missing\")\n        continue\n    end\n    output_size = Mycelia.dir_size(run.outdir)\n    println(\"  $(run.name): contigs=$(metrics.n_contigs), N50=$(metrics.n50), L50=$(metrics.l50), total=$(metrics.total_length) bp, output_size=$(round(output_size / 1e6, digits=2)) MB\")\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Long-Read-Assembly","page":"Step 4: Genome Assembly","title":"Long Read Assembly","text":"Flye, Canu, and hifiasm for long read data\n\nprintln(\"--- Long Read Assembly ---\")\n\nExample parameters for long read assembly\n\nlong_read_assembly_params = Dict(\n    \"genome_size\" => \"50k\",\n    \"flye_read_type\" => \"nano-hq\",\n    \"canu_read_type\" => \"nanopore\",\n    \"hifiasm_mode\" => \"primary\",\n    \"threads\" => threads\n)\n\nprintln(\"Long read assembly parameters:\")\nfor (param, value) in long_read_assembly_params\n    println(\"  $param: $value\")\nend\n\nlong_read_runs = []\n\nflye_result, flye_runtime = Mycelia.run_assembler(\"Flye\") do\n    Mycelia.run_flye(\n        fastq=long_reads_file,\n        outdir=joinpath(assembly_output, \"flye_long\"),\n        genome_size=long_read_assembly_params[\"genome_size\"],\n        read_type=long_read_assembly_params[\"flye_read_type\"],\n        threads=threads\n    )\nend\nif flye_result !== nothing\n    push!(long_read_runs, (name=\"Flye\", assembly=flye_result.assembly, outdir=flye_result.outdir, runtime=flye_runtime, reads=long_reads_file))\nend\n\ncanu_result, canu_runtime = Mycelia.run_assembler(\"Canu\") do\n    Mycelia.run_canu(\n        fastq=long_reads_file,\n        outdir=joinpath(assembly_output, \"canu_long\"),\n        genome_size=long_read_assembly_params[\"genome_size\"],\n        read_type=long_read_assembly_params[\"canu_read_type\"],\n        stopOnLowCoverage=5,\n        threads=threads\n    )\nend\nif canu_result !== nothing\n    push!(long_read_runs, (name=\"Canu\", assembly=canu_result.assembly, outdir=canu_result.outdir, runtime=canu_runtime, reads=long_reads_file))\nend\n\nhifiasm_result, hifiasm_runtime = Mycelia.run_assembler(\"hifiasm\") do\n    Mycelia.run_hifiasm(\n        fastq=hifi_reads_file,\n        outdir=joinpath(assembly_output, \"hifiasm_long\"),\n        bloom_filter=0,\n        threads=threads\n    )\nend\nhifiasm_contigs = Mycelia.hifiasm_primary_contigs(hifiasm_result)\nif hifiasm_contigs !== nothing\n    push!(long_read_runs, (name=\"hifiasm\", assembly=hifiasm_contigs, outdir=hifiasm_result.outdir, runtime=hifiasm_runtime, reads=hifi_reads_file))\nelse\n    if hifiasm_result !== nothing\n        println(\"  hifiasm produced graph outputs; primary contigs not found at expected .p_ctg.fa path\")\n    end\nend\n\nprintln(\"Long read assembly contiguity:\")\nfor run in long_read_runs\n    metrics = Mycelia.assembly_metrics(run.assembly)\n    if metrics === nothing\n        println(\"  $(run.name): assembly file missing\")\n        continue\n    end\n    qv = Mycelia.compute_merqury_qv(run.assembly, run.reads)\n    println(\"  $(run.name): contigs=$(metrics.n_contigs), N50=$(metrics.n50), largest=$(metrics.largest_contig), QV=$(qv)\")\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Hybrid-Assembly","page":"Step 4: Genome Assembly","title":"Hybrid Assembly","text":"Unicycler combining short and long reads\n\nprintln(\"--- Hybrid Assembly ---\")\n\nExample parameters for hybrid assembly\n\nhybrid_params = Dict(\n    \"short_read_accuracy\" => 0.99,\n    \"long_read_accuracy\" => 0.90,\n    \"bridging_mode\" => \"conservative\",\n    \"threads\" => threads\n)\n\nprintln(\"Hybrid assembly parameters:\")\nfor (param, value) in hybrid_params\n    println(\"  $param: $value\")\nend\n\nhybrid_runs = []\n\nunicycler_result, unicycler_runtime = Mycelia.run_assembler(\"Unicycler\") do\n    Mycelia.run_unicycler(\n        short_1=short_reads_r1,\n        short_2=short_reads_r2,\n        long_reads=long_reads_file,\n        outdir=joinpath(assembly_output, \"unicycler_hybrid\"),\n        threads=threads\n    )\nend\nif unicycler_result !== nothing\n    push!(hybrid_runs, (name=\"Unicycler\", assembly=unicycler_result.assembly, outdir=unicycler_result.outdir, runtime=unicycler_runtime, reads=short_reads_r1))\nend\n\nprintln(\"Hybrid assembly comparison:\")\nfor run in hybrid_runs\n    metrics = Mycelia.assembly_metrics(run.assembly)\n    if metrics === nothing\n        println(\"  $(run.name): assembly file missing\")\n        continue\n    end\n    output_size = Mycelia.dir_size(run.outdir)\n    println(\"  $(run.name): contigs=$(metrics.n_contigs), N50=$(metrics.n50), largest=$(metrics.largest_contig), output_size=$(round(output_size / 1e6, digits=2)) MB\")\nend\n\nif !isempty(short_read_runs) && !isempty(hybrid_runs)\n    short_metrics = Mycelia.assembly_metrics(short_read_runs[1].assembly)\n    hybrid_metrics = Mycelia.assembly_metrics(hybrid_runs[1].assembly)\n    if short_metrics !== nothing && hybrid_metrics !== nothing\n        println(\"  Scaffolding improvement (N50): $(short_metrics.n50) -> $(hybrid_metrics.n50)\")\n    end\nend\n\nprintln(\"Assembly approaches comparison completed...\")\n\nprintln(\"--- Mycelia Rhizomorph Assembly ---\")\nprintln(\"Rhizomorph assembly workflows are covered in tutorial 13 (skeleton) and are intentionally omitted here.\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Part-4:-Assembly-Quality-Assessment","page":"Step 4: Genome Assembly","title":"Part 4: Assembly Quality Assessment","text":"Comprehensive evaluation of assembly quality\n\nprintln(\"\\n=== Assembly Quality Assessment ===\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Basic-Assembly-Statistics","page":"Step 4: Genome Assembly","title":"Basic Assembly Statistics","text":"Calculate fundamental assembly metrics\n\nprintln(\"--- Basic Statistics ---\")\n\nprimary_assembly = Mycelia.select_first_existing([\n    isempty(hybrid_runs) ? nothing : hybrid_runs[1].assembly,\n    isempty(long_read_runs) ? nothing : long_read_runs[1].assembly,\n    isempty(short_read_runs) ? nothing : short_read_runs[1].assembly\n])\n\nassembly_stats = Mycelia.assembly_metrics(primary_assembly)\nif assembly_stats === nothing\n    println(\"No assembly file available for basic statistics.\")\nelse\n    println(\"Assembly Statistics:\")\n    println(\"  total_length: $(assembly_stats.total_length)\")\n    println(\"  n_contigs: $(assembly_stats.n_contigs)\")\n    println(\"  n50: $(assembly_stats.n50)\")\n    println(\"  n90: $(assembly_stats.n90)\")\n    println(\"  l50: $(assembly_stats.l50)\")\n    println(\"  l90: $(assembly_stats.l90)\")\n    println(\"  largest_contig: $(assembly_stats.largest_contig)\")\n    println(\"  gc_content: $(round(assembly_stats.gc_content, digits=3))\")\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Advanced-Quality-Metrics","page":"Step 4: Genome Assembly","title":"Advanced Quality Metrics","text":"More sophisticated quality assessment\n\nprintln(\"--- Advanced Quality Metrics ---\")\n\nbusco_outdir = nothing\nif primary_assembly !== nothing\n    try\n        busco_outdir = Mycelia.run_busco(primary_assembly; threads=threads, outdir=joinpath(assembly_output, \"busco_results\"))\n        println(\"BUSCO completed: $(busco_outdir)\")\n    catch e\n        @warn \"BUSCO failed\" exception=e\n    end\nend\n\nmerqury_qv = Mycelia.compute_merqury_qv(primary_assembly, short_reads_r1)\nprintln(\"Merqury-style QV (k=21): $(merqury_qv)\")\n\nprintln(\"LAI (LTR Assembly Index): not computed in this tutorial (no built-in wrapper yet)\")\n\nif assembly_stats !== nothing && busco_outdir !== nothing\n    println(\"Contiguity vs completeness: compare N50 with BUSCO report in $(busco_outdir)\")\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Comparison-with-Reference","page":"Step 4: Genome Assembly","title":"Comparison with Reference","text":"Validate assembly against known reference\n\nprintln(\"--- Reference Comparison ---\")\n\nmummer_outdir = nothing\nalignment_summary = nothing\nif primary_assembly !== nothing\n    try\n        mummer_outdir = Mycelia.run_mummer(reference_file, primary_assembly; outdir=joinpath(assembly_output, \"mummer_compare\"), prefix=\"assembly\")\n        coords_file = joinpath(mummer_outdir, \"assembly.coords\")\n        alignments = Mycelia.parse_mummer_coords(coords_file)\n        if !isempty(alignments)\n            total_aligned = sum(a.len_ref for a in alignments)\n            weighted_identity = sum(a.len_ref * a.identity for a in alignments) / total_aligned\n            coverage = total_aligned / reference_size * 100\n            inversions = count(a -> a.start_query > a.end_query, alignments)\n            alignment_summary = (;weighted_identity, coverage, inversions, alignment_blocks=length(alignments))\n            println(\"Reference alignment: identity=$(round(weighted_identity, digits=2))%, coverage=$(round(coverage, digits=2))%, inversions=$(inversions)\")\n        end\n    catch e\n        @warn \"MUMmer comparison failed\" exception=e\n    end\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Part-5:-Assembly-Polishing-and-Error-Correction","page":"Step 4: Genome Assembly","title":"Part 5: Assembly Polishing and Error Correction","text":"Improve assembly accuracy through polishing\n\nprintln(\"\\n=== Assembly Polishing ===\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Consensus-Polishing","page":"Step 4: Genome Assembly","title":"Consensus Polishing","text":"Use original reads to polish assembly\n\nprintln(\"--- Consensus Polishing ---\")\n\npolish_target = Mycelia.select_first_existing([\n    isempty(long_read_runs) ? nothing : long_read_runs[1].assembly,\n    primary_assembly\n])\n\napollo_result = nothing\nif polish_target !== nothing\n    try\n        apollo_result = Mycelia.run_apollo(polish_target, long_reads_file; outdir=joinpath(assembly_output, \"apollo_polish\"))\n        println(\"Apollo polishing output: $(apollo_result.polished_assembly)\")\n    catch e\n        @warn \"Apollo polishing failed\" exception=e\n    end\nend\n\nhomopolish_result = nothing\nif apollo_result !== nothing\n    try\n        homopolish_result = Mycelia.run_homopolish(apollo_result.polished_assembly, apollo_result.polished_assembly; outdir=joinpath(assembly_output, \"homopolish\"), threads=threads)\n        println(\"Homopolish output: $(homopolish_result.polished_assembly)\")\n    catch e\n        @warn \"Homopolish failed\" exception=e\n    end\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Structural-Error-Correction","page":"Step 4: Genome Assembly","title":"Structural Error Correction","text":"Fix larger structural errors\n\nprintln(\"--- Structural Correction ---\")\n\nif alignment_summary !== nothing\n    println(\"Structural signals: alignment_blocks=$(alignment_summary.alignment_blocks), inversions=$(alignment_summary.inversions)\")\n    if alignment_summary.coverage < 98\n        println(\"  Potential large gaps or structural variants detected (coverage < 98%)\")\n    end\nelse\n    println(\"Structural correction requires reference alignments (see MUMmer comparison).\")\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Part-6:-Handling-Assembly-Challenges","page":"Step 4: Genome Assembly","title":"Part 6: Handling Assembly Challenges","text":"Address common assembly difficulties\n\nprintln(\"\\n=== Assembly Challenges ===\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Repetitive-Sequences","page":"Step 4: Genome Assembly","title":"Repetitive Sequences","text":"Strategies for handling repeats\n\nprintln(\"--- Repetitive Sequences ---\")\n\nif primary_assembly !== nothing\n    repeat_k = 9\n    kmer_counts = Mycelia.count_canonical_kmers(Kmers.DNAKmer{repeat_k}, primary_assembly)\n    top_kmers = sort(collect(kmer_counts), by=x -> x[2], rev=true)\n    println(\"Top repeated k-mers (k=$(repeat_k)):\")\n    for (kmer, count) in Iterators.take(top_kmers, min(5, length(top_kmers)))\n        println(\"  $(kmer): $(count)\")\n    end\nelse\n    println(\"Repeat analysis skipped (no assembly available)\")\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Heterozygosity","page":"Step 4: Genome Assembly","title":"Heterozygosity","text":"Handle diploid and polyploid genomes\n\nprintln(\"--- Heterozygosity ---\")\n\nhap1_seq = FASTX.sequence(reference_genome)\nmut_rng = Random.MersenneTwister(123)\nhap2_seq = Mycelia.mutate_dna_substitution_fraction(hap1_seq; fraction=0.01, rng=mut_rng)\nheterozygous_sites = count(pair -> pair[1] != pair[2], zip(hap1_seq, hap2_seq))\nheterozygosity_rate = heterozygous_sites / length(hap1_seq)\nprintln(\"Simulated heterozygosity rate: $(round(heterozygosity_rate * 100, digits=2))%\")\n\nhaplotype_fasta = joinpath(assembly_output, \"diploid_haplotypes.fasta\")\nMycelia.write_fasta(\n    outfile=haplotype_fasta,\n    records=[\n        FASTX.FASTA.Record(\"haplotype_1\", hap1_seq),\n        FASTX.FASTA.Record(\"haplotype_2\", hap2_seq)\n    ]\n)\n\nprintln(\"Haplotype-aware assembly recommendation: use hifiasm outputs for phased contigs where available.\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Contamination","page":"Step 4: Genome Assembly","title":"Contamination","text":"Detect and remove contaminating sequences\n\nprintln(\"--- Contamination Detection ---\")\n\nContamination screening options to consider:\n\nMycelia.runcheckm / Mycelia.runcheckm2 for bacterial MAGs\nMycelia.run_checkv for viral assemblies\nNCBI FCS-GX (https://github.com/ncbi/fcs, bioconda: ncbi-fcs-gx)\nRead-based taxonomic screens (e.g. Kraken2/Bracken) when wrappers are available\n\ncontaminant_candidates = Mycelia.contig_gc_outliers(primary_assembly)\nif isempty(contaminant_candidates)\n    println(\"No GC outlier contigs detected (using 2 SD threshold).\")\nelse\n    println(\"Potential contaminant contigs (GC outliers):\")\n    for candidate in contaminant_candidates\n        println(\"  $(candidate.id): length=$(candidate.length), GC=$(round(candidate.gc, digits=3))\")\n    end\nend\n\nfcs_tax_id = tryparse(Int, get(ENV, \"MYCELIA_FCS_TAX_ID\", \"\"))\nif primary_assembly !== nothing && fcs_tax_id !== nothing\n    fcs_db_dir = get(ENV, \"MYCELIA_FCS_DB_DIR\", joinpath(homedir(), \"workspace\", \".ncbi-fcs-gx\", \"gxdb\"))\n    fcs_manifest_url = get(ENV, \"MYCELIA_FCS_MANIFEST_URL\", \"\")\n    download_fcs_db = !isempty(fcs_manifest_url)\n\nGX DB (~470 GB) download options:\n\nUse s5cmd for the official S3 bucket: s3://ncbi-fcs-gx/gxdb/latest/all.*\nOr provide MYCELIAFCSMANIFESTURL to syncfiles.py via Mycelia.runncbifcs\n\n    println(\"Running FCS-GX screening (this requires a large GX database)...\")\n    try\n        fcs_result = Mycelia.run_ncbi_fcs(\n            primary_assembly;\n            tax_id=fcs_tax_id,\n            outdir=joinpath(assembly_output, \"fcs_gx\"),\n            gx_db=fcs_db_dir,\n            manifest_url=download_fcs_db ? fcs_manifest_url : nothing,\n            download_db=download_fcs_db\n        )\n        println(\"FCS-GX report: $(fcs_result.report)\")\n\n        if fcs_result.report !== nothing\n            clean_result = Mycelia.run_ncbi_fcs_clean_genome(\n                primary_assembly;\n                action_report=fcs_result.report,\n                outdir=joinpath(assembly_output, \"fcs_gx_clean\")\n            )\n            println(\"FCS-GX cleaned assembly: $(clean_result.cleaned_fasta)\")\n            println(\"FCS-GX contamination FASTA: $(clean_result.contamination_fasta)\")\n        end\n    catch e\n        @warn \"FCS-GX screening failed\" exception=e\n    end\nelse\n    println(\"Set MYCELIA_FCS_TAX_ID to run FCS-GX (optionally MYCELIA_FCS_DB_DIR and MYCELIA_FCS_MANIFEST_URL).\")\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Part-7:-Assembly-Visualization-and-Exploration","page":"Step 4: Genome Assembly","title":"Part 7: Assembly Visualization and Exploration","text":"Create plots and visualizations for assembly analysis\n\nprintln(\"\\n=== Assembly Visualization ===\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Contig-Size-Distribution","page":"Step 4: Genome Assembly","title":"Contig Size Distribution","text":"Visualize assembly contiguity\n\nprintln(\"--- Contig Visualization ---\")\n\nif primary_assembly !== nothing\n    contig_lengths = open(FASTX.FASTA.Reader, primary_assembly) do reader\n        [length(FASTX.sequence(record)) for record in reader]\n    end\n    sorted_lengths = sort(contig_lengths, rev=true)\n    cumulative_lengths = cumsum(sorted_lengths)\n    println(\"Top contig lengths: $(sorted_lengths[1:min(5, length(sorted_lengths))])\")\n    println(\"Cumulative lengths (first 5): $(cumulative_lengths[1:min(5, length(cumulative_lengths))])\")\n    println(\"Use Plots.jl to visualize these distributions as histograms or cumulative curves.\")\nelse\n    println(\"No assembly available for visualization.\")\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Dot-Plots","page":"Step 4: Genome Assembly","title":"Dot Plots","text":"Compare assemblies or validate against reference\n\nprintln(\"--- Dot Plot Analysis ---\")\n\nif mummer_outdir !== nothing\n    delta_file = joinpath(mummer_outdir, \"assembly.delta\")\n    try\n        dotplot_path = Mycelia.run_mummer_plot(delta_file; outdir=mummer_outdir, prefix=\"assembly_plot\")\n        println(\"Dot plot generated: $(dotplot_path)\")\n    catch e\n        @warn \"Dot plot generation failed\" exception=e\n    end\nelse\n    println(\"Dot plot requires MUMmer alignment output.\")\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Part-8:-Assembly-Benchmarking","page":"Step 4: Genome Assembly","title":"Part 8: Assembly Benchmarking","text":"Compare different assembly approaches\n\nprintln(\"\\n=== Assembly Benchmarking ===\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Multi-Assembler-Comparison","page":"Step 4: Genome Assembly","title":"Multi-Assembler Comparison","text":"Compare multiple assembly tools\n\nprintln(\"--- Multi-Assembler Comparison ---\")\n\nall_runs = vcat(short_read_runs, long_read_runs, hybrid_runs)\nbenchmark_results = []\nfor run in all_runs\n    metrics = Mycelia.assembly_metrics(run.assembly)\n    if metrics === nothing\n        continue\n    end\n    qv = Mycelia.compute_merqury_qv(run.assembly, run.reads)\n    push!(benchmark_results, (name=run.name, n50=metrics.n50, total_length=metrics.total_length, runtime=run.runtime, qv=qv))\nend\n\nif isempty(benchmark_results)\n    println(\"No benchmark results available.\")\nelse\n    sorted_results = sort(benchmark_results, by=x -> x.n50, rev=true)\n    println(\"Assembler ranking by N50:\")\n    for result in sorted_results\n        println(\"  $(result.name): N50=$(result.n50), total=$(result.total_length), runtime=$(result.runtime), QV=$(result.qv)\")\n    end\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Parameter-Optimization","page":"Step 4: Genome Assembly","title":"Parameter Optimization","text":"Optimize assembly parameters\n\nprintln(\"--- Parameter Optimization ---\")\n\nmegahit_k_options = [\"21,33,55\", \"21,29,39,59\"]\nmegahit_grid_results = []\nfor k_list in megahit_k_options\n    tag = replace(k_list, \",\" => \"_\")\n    outdir = joinpath(assembly_output, \"megahit_k_$(tag)\")\n    result, runtime = Mycelia.run_assembler(\"MEGAHIT k=$(k_list)\") do\n        Mycelia.run_megahit(\n            fastq1=short_reads_r1,\n            fastq2=short_reads_r2,\n            outdir=outdir,\n            min_contig_len=short_read_assembly_params[\"min_contig_len\"],\n            k_list=k_list,\n            threads=threads\n        )\n    end\n    if result !== nothing\n        metrics = Mycelia.assembly_metrics(result.contigs)\n        if metrics !== nothing\n            push!(megahit_grid_results, (k_list=k_list, n50=metrics.n50, runtime=runtime))\n        end\n    end\nend\n\nif isempty(megahit_grid_results)\n    println(\"Parameter optimization skipped (no MEGAHIT results).\")\nelse\n    best = sort(megahit_grid_results, by=x -> x.n50, rev=true)[1]\n    println(\"Best MEGAHIT k-list by N50: $(best.k_list) (N50=$(best.n50))\")\nend","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Part-9:-Best-Practices-and-Recommendations","page":"Step 4: Genome Assembly","title":"Part 9: Best Practices and Recommendations","text":"Guidelines for successful genome assembly\n\nprintln(\"\\n=== Best Practices ===\")\n\nprintln(\"Data Requirements:\")\nprintln(\"- HiFi: 20-30x coverage minimum\")\nprintln(\"- Read N50 > 10 kb preferred\")\nprintln(\"- Low contamination levels\")\nprintln(\"- Balanced coverage distribution\")\nprintln()\nprintln(\"Assembly Strategy:\")\nprintln(\"- Start with hifiasm for HiFi data\")\nprintln(\"- Use haplotype-aware mode for diploids\")\nprintln(\"- Validate with multiple quality metrics\")\nprintln(\"- Polish with original reads\")\nprintln()\nprintln(\"Quality Control:\")\nprintln(\"- Check BUSCO completeness (>90% for eukaryotes)\")\nprintln(\"- Validate N50 vs genome size expectations\")\nprintln(\"- Examine contig count (fewer is better)\")\nprintln(\"- Compare with related genomes\")","category":"section"},{"location":"generated/tutorials/04_genome_assembly/#Summary","page":"Step 4: Genome Assembly","title":"Summary","text":"println(\"\\n=== Assembly Summary ===\")\nprintln(\"✓ Understanding assembly algorithms and their applications\")\nprintln(\"✓ Short read assembly with MEGAHIT and metaSPAdes\")\nprintln(\"✓ Long read assembly with Flye, Canu, and hifiasm\")\nprintln(\"✓ Hybrid assembly approaches with Unicycler\")\nprintln(\"✓ Comprehensive quality assessment techniques\")\nprintln(\"✓ Assembly polishing and error correction\")\nprintln(\"✓ Handling repetitive sequences and heterozygosity\")\nprintln(\"✓ Visualization and benchmarking approaches\")\nprintln(\"✓ Rhizomorph assembly workflows moved to tutorial 13\")\n\nCleanup\n\nif isdir(assembly_output)\n    rm(assembly_output, recursive=true, force=true)\nend\n\nprintln(\"\\nNext: Tutorial 5 - Assembly Validation\")\n\nnothing","category":"section"},{"location":"generated/tutorials/04_graph_type_tutorials/","page":"Step 4b: Graph Type Tutorials","title":"Step 4b: Graph Type Tutorials","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/04_graph_type_tutorials.jl\", \"tutorials/notebooks\", execute=false)'\n\n\"\"\"\nRhizomorph Graph Type Tutorials\n\nThis tutorial demonstrates the usage of all 6 graph types in Mycelia's Rhizomorph submodule:\n1. N-gram Graphs - For unicode text analysis\n2. K-mer Graphs - For DNA/RNA/protein sequence analysis\n3. Qualmer Graphs - For quality-aware sequence analysis\n4. String Graphs - For variable-length string overlaps (OLC)\n5. FASTA Graphs - For variable-length BioSequence overlaps (OLC)\n6. FASTQ Graphs - For quality-aware BioSequence overlaps (OLC)\n\nEach section shows practical examples with real data using Rhizomorph APIs.\n\"\"\"\n\nimport Mycelia\nimport FASTX\nimport MetaGraphsNext\nimport Statistics\n\nprintln(\"=\"^80)\nprintln(\"RHIZOMORPH GRAPH TYPE TUTORIALS\")\nprintln(\"=\"^80)\n\n============================================================================= Tutorial 1: N-gram Graphs - Unicode Text Analysis =============================================================================\n\nprintln(\"\\n1. N-GRAM GRAPHS - Unicode Text Analysis\")\nprintln(\"-\"^50)\n\nExample: Analyzing text patterns\n\ntext = \"The quick brown fox jumps over the lazy dog\"\nprintln(\"Input text: \\\"$text\\\"\")\n\nCreate N-gram graph\n\nngram_graph = Mycelia.Rhizomorph.build_ngram_graph([text], 3; dataset_id=\"text_demo\")\nngram_labels = collect(MetaGraphsNext.labels(ngram_graph))\nprintln(\"Number of 3-grams: $(length(ngram_labels))\")\n\nShow some N-grams\n\nngrams = ngram_labels\nprintln(\"Example 3-grams: $(ngrams[1:min(5, length(ngrams))])\")\n\nUse case: Text compression, pattern detection, linguistic analysis\n\nprintln(\"Use cases: Text compression, pattern detection, linguistic analysis\")\n\n============================================================================= Tutorial 2: K-mer Graphs - BioSequence Analysis =============================================================================\n\nprintln(\"\\n2. K-MER GRAPHS - BioSequence Analysis\")\nprintln(\"-\"^50)\n\nExample: DNA sequence analysis\n\ndna_sequence = \"ATCGATCGATCGATCGTAGCTAGCTAGCT\"\nprintln(\"DNA sequence: $dna_sequence\")\n\nCreate FASTA record\n\ndna_record = FASTX.FASTA.Record(\"sample_dna\", dna_sequence)\ndna_records = [dna_record]\n\nCreate k-mer graph\n\ndna_dataset_id = \"dna_demo\"\ndna_kmer_graph = Mycelia.Rhizomorph.build_kmer_graph(dna_records, 5; dataset_id=dna_dataset_id)\ndna_kmers = collect(MetaGraphsNext.labels(dna_kmer_graph))\nprintln(\"DNA k-mers (k=5): $(length(dna_kmers)) unique k-mers\")\nprintln(\"Example k-mers: $(dna_kmers[1:min(3, length(dna_kmers))])\")\n\nGet vertex data to see evidence counts\n\nfirst_kmer = first(dna_kmers)\nvertex_data = dna_kmer_graph[first_kmer]\ncoverage = Mycelia.Rhizomorph.count_evidence_entries(vertex_data)\nprintln(\"Evidence entries for $(first_kmer): $(coverage) observations\")\n\nExample: RNA sequence analysis\n\nrna_sequence = \"AUCGAUCGAUCGAUCGUAGCUAGCUAGCU\"\nprintln(\"\\\\nRNA sequence: $rna_sequence\")\n\nrna_record = FASTX.FASTA.Record(\"sample_rna\", rna_sequence)\nrna_records = [rna_record]\n\nCreate RNA k-mer graph\n\nrna_kmer_graph = Mycelia.Rhizomorph.build_kmer_graph(rna_records, 4; dataset_id=\"rna_demo\")\nrna_kmers = collect(MetaGraphsNext.labels(rna_kmer_graph))\nprintln(\"RNA k-mers (k=4): $(length(rna_kmers)) unique k-mers\")\nprintln(\"Example k-mers: $(rna_kmers[1:min(3, length(rna_kmers))])\")\n\nExample: Protein sequence analysis\n\nprotein_sequence = \"ALAVALINEGLUTAMINELEUCINE\"\nprintln(\"\\\\nProtein sequence: $protein_sequence\")\n\nprotein_record = FASTX.FASTA.Record(\"sample_protein\", protein_sequence)\nprotein_records = [protein_record]\n\nCreate protein k-mer graph\n\nprotein_kmer_graph = Mycelia.Rhizomorph.build_kmer_graph(protein_records, 3; dataset_id=\"protein_demo\")\nprotein_kmers = collect(MetaGraphsNext.labels(protein_kmer_graph))\nprintln(\"Protein k-mers (k=3): $(length(protein_kmers)) unique k-mers\")\nprintln(\"Example k-mers: $(protein_kmers[1:min(3, length(protein_kmers))])\")\n\nUse cases\n\nprintln(\"Use cases: Genome assembly, repeat detection, sequence comparison\")\n\n============================================================================= Tutorial 3: Qualmer Graphs - Quality-Aware Sequence Analysis =============================================================================\n\nprintln(\"\\n3. QUALMER GRAPHS - Quality-Aware Sequence Analysis\")\nprintln(\"-\"^50)\n\nExample: High-quality sequencing data\n\nhigh_quality_seq = \"ATCGATCGATCGATCGTAGCTAGCT\"\nhigh_quality_scores = \"HHHHHHHHHHHHHHHHHHHHHHHHH\"  ## PHRED 39\nprintln(\"High-quality sequence: $high_quality_seq\")\n\nCreate FASTQ record\n\nhq_record = FASTX.FASTQ.Record(\"high_quality\", high_quality_seq, high_quality_scores)\nhq_records = [hq_record]\n\nCreate qualmer graph\n\nhq_dataset_id = \"high_quality\"\nhq_qualmer_graph = Mycelia.Rhizomorph.build_qualmer_graph(hq_records, 5; dataset_id=hq_dataset_id)\nhq_kmers = collect(MetaGraphsNext.labels(hq_qualmer_graph))\nprintln(\"High-quality k-mers: $(length(hq_kmers)) unique k-mers\")\n\nShow quality information\n\nfirst_hq_kmer = first(hq_kmers)\nhq_vertex_data = hq_qualmer_graph[first_hq_kmer]\nhq_joint_quality = Mycelia.Rhizomorph.get_vertex_joint_quality(hq_vertex_data, hq_dataset_id)\nhq_mean_quality = Mycelia.Rhizomorph.get_vertex_mean_quality(hq_vertex_data, hq_dataset_id)\nhq_joint_mean = Statistics.mean(hq_joint_quality)\nhq_mean_mean = Statistics.mean(hq_mean_quality)\nprintln(\"$(first_hq_kmer): mean joint Q = $(round(hq_joint_mean, digits=2)), mean Q = $(round(hq_mean_mean, digits=2))\")\n\nExample: Medium-quality sequencing data\n\nmedium_quality_seq = \"ATCGATCGATCGATCGTAGCTAGCT\"\nmedium_quality_scores = \"?????????????????????????\"  ## PHRED 30\nprintln(\"\\\\nMedium-quality sequence: $medium_quality_seq\")\n\nmq_record = FASTX.FASTQ.Record(\"medium_quality\", medium_quality_seq, medium_quality_scores)\nmq_records = [mq_record]\n\nCreate qualmer graph\n\nmq_dataset_id = \"medium_quality\"\nmq_qualmer_graph = Mycelia.Rhizomorph.build_qualmer_graph(mq_records, 5; dataset_id=mq_dataset_id)\nmq_kmers = collect(MetaGraphsNext.labels(mq_qualmer_graph))\nprintln(\"Medium-quality k-mers: $(length(mq_kmers)) unique k-mers\")\n\nfirst_mq_kmer = first(mq_kmers)\nmq_vertex_data = mq_qualmer_graph[first_mq_kmer]\nmq_joint_quality = Mycelia.Rhizomorph.get_vertex_joint_quality(mq_vertex_data, mq_dataset_id)\nmq_mean_quality = Mycelia.Rhizomorph.get_vertex_mean_quality(mq_vertex_data, mq_dataset_id)\nmq_joint_mean = Statistics.mean(mq_joint_quality)\nmq_mean_mean = Statistics.mean(mq_mean_quality)\nprintln(\"$(first_mq_kmer): mean joint Q = $(round(mq_joint_mean, digits=2)), mean Q = $(round(mq_mean_mean, digits=2))\")\n\nQuality comparison\n\nprintln(\"\\\\nQuality comparison:\")\nprintln(\"High-quality mean joint Q: $(round(hq_joint_mean, digits=2))\")\nprintln(\"Medium-quality mean joint Q: $(round(mq_joint_mean, digits=2))\")\nprintln(\"Quality-aware assembly can make better decisions using this information!\")\n\nUse cases\n\nprintln(\"Use cases: Error correction, quality-aware assembly, variant calling\")\n\n============================================================================= Tutorial 4: String Graphs - Variable-Length Overlap Analysis =============================================================================\n\nprintln(\"\\n4. STRING GRAPHS - Variable-Length Overlap Analysis\")\nprintln(\"-\"^50)\n\nExample: Overlap-aware text fragments\n\nstring_fragments = [\"ABCDEF\", \"CDEFGH\", \"EFGHIJ\", \"GHIJKL\"]\nprintln(\"Input fragments: $(string_fragments)\")\n\nCreate variable-length string graph (OLC)\n\nstring_graph = Mycelia.Rhizomorph.build_string_graph(string_fragments; dataset_id=\"string_demo\", min_overlap=3)\nstring_stats = Mycelia.Rhizomorph.get_string_graph_statistics(string_graph)\nprintln(\"String graph: $(string_stats[:num_vertices]) strings, $(string_stats[:num_edges]) overlaps\")\n\nShow example overlaps if present\n\nif string_stats[:num_edges] > 0\n    example_edge = first(MetaGraphsNext.edge_labels(string_graph))\n    src, dst = example_edge\n    overlap_len = string_graph[src, dst].overlap_length\n    println(\"Example overlap: \\\"$src\\\" → \\\"$dst\\\" (overlap length: $overlap_len)\")\nend\n\nUse cases\n\nprintln(\"Use cases: Text reconstruction, fragment assembly, overlap analysis\")\n\n============================================================================= Tutorial 5: FASTA Graphs - Variable-Length BioSequence Analysis =============================================================================\n\nprintln(\"\\n5. FASTA GRAPHS - Variable-Length BioSequence Analysis\")\nprintln(\"-\"^50)\n\nExample: Direct FASTA graph construction\n\nfasta_sequence = \"ATCGATCGATCGATCGTAGCTAGCTAGCTGCGCGCGC\"\nprintln(\"FASTA sequence: $fasta_sequence\")\n\nfasta_record = FASTX.FASTA.Record(\"sample\", fasta_sequence)\nfasta_records = [fasta_record]\n\nCreate FASTA overlap graph directly (OLC)\n\nbio_graph = Mycelia.Rhizomorph.build_fasta_graph(fasta_records; dataset_id=\"fasta_demo\", min_overlap=5)\nbio_sequences = collect(MetaGraphsNext.labels(bio_graph))\nprintln(\"FASTA graph: $(length(bio_sequences)) sequences\")\n\nif !isempty(bio_sequences)\n    first_seq = first(bio_sequences)\n    println(\"First sequence: $first_seq (length: $(length(first_seq)))\")\n    println(\"Sequence type: $(typeof(first_seq))\")\nend\n\nExample: K-mer to FASTA graph conversion\n\nprintln(\"\\\\nK-mer to FASTA graph conversion:\")\nkmer_graph = Mycelia.Rhizomorph.build_kmer_graph(fasta_records, 5; dataset_id=\"kmer_demo\")\nbio_converted = Mycelia.Rhizomorph.convert_fixed_to_variable(kmer_graph)\nconverted_sequences = collect(MetaGraphsNext.labels(bio_converted))\nkmer_labels = collect(MetaGraphsNext.labels(kmer_graph))\nprintln(\"Converted $(length(kmer_labels)) k-mers to $(length(converted_sequences)) FASTA sequences\")\n\nUse cases\n\nprintln(\"Use cases: Genome assembly, contig construction, sequence alignment\")\n\n============================================================================= Tutorial 6: FASTQ Graphs - Quality-Aware BioSequence Analysis =============================================================================\n\nprintln(\"\\n6. FASTQ GRAPHS - Quality-Aware BioSequence Analysis\")\nprintln(\"-\"^50)\n\nExample: Quality-aware FASTQ graph\n\nfastq_sequence = \"ATCGATCGATCGATCGTAGCTAGCTAGCTGCGCGCGC\"\nfastq_quality = repeat(\"H\", length(fastq_sequence))  ## High quality\nprintln(\"FASTQ sequence: $fastq_sequence\")\nprintln(\"Quality string: $fastq_quality\")\n\nfastq_record = FASTX.FASTQ.Record(\"quality_sample\", fastq_sequence, fastq_quality)\nfastq_records = [fastq_record]\n\nCreate quality-aware FASTQ graph\n\nfastq_dataset_id = \"fastq_demo\"\nquality_bio_graph = Mycelia.Rhizomorph.build_fastq_graph(fastq_records; dataset_id=fastq_dataset_id, min_overlap=5)\nquality_sequences = collect(MetaGraphsNext.labels(quality_bio_graph))\nprintln(\"FASTQ graph: $(length(quality_sequences)) sequences\")\n\nif !isempty(quality_sequences)\n    first_quality_seq = first(quality_sequences)\n    quality_vertex_data = quality_bio_graph[first_quality_seq]\n    println(\"First sequence: $first_quality_seq\")\n    joint_quality = Mycelia.Rhizomorph.get_vertex_joint_quality(quality_vertex_data, fastq_dataset_id)\n    println(\"Joint quality (first 10): $(joint_quality[1:min(10, length(joint_quality))])\")\nend\n\nExample: Qualmer to FASTQ graph conversion\n\nprintln(\"\\\\nQualmer to FASTQ graph conversion:\")\nqualmer_graph = Mycelia.Rhizomorph.build_qualmer_graph(fastq_records, 5; dataset_id=fastq_dataset_id)\nquality_converted = Mycelia.Rhizomorph.convert_fixed_to_variable(qualmer_graph)\nquality_converted_sequences = collect(MetaGraphsNext.labels(quality_converted))\nqualmer_labels = collect(MetaGraphsNext.labels(qualmer_graph))\nprintln(\"Converted $(length(qualmer_labels)) qualmers to $(length(quality_converted_sequences)) FASTQ sequences\")\n\nUse cases\n\nprintln(\"Use cases: Quality-aware assembly, error correction, variant calling\")\n\n============================================================================= Tutorial 7: Graph Type Hierarchy and Conversions =============================================================================\n\nprintln(\"\\n7. GRAPH TYPE HIERARCHY AND CONVERSIONS\")\nprintln(\"-\"^50)\n\nDemonstrate the hierarchy: Fixed-length → Variable-length\n\nsequence_for_hierarchy = \"ATCGATCGATCGATCGTAGCTAGCTAGCTGCGCGCGC\"\nrecords_for_hierarchy = [FASTX.FASTA.Record(\"hierarchy_demo\", sequence_for_hierarchy)]\nfastq_records_for_hierarchy = [FASTX.FASTQ.Record(\"hierarchy_demo\", sequence_for_hierarchy, repeat(\"H\", length(sequence_for_hierarchy)))]\n\nprintln(\"Original sequence: $sequence_for_hierarchy\")\n\nFixed-length graphs\n\nngram_result = Mycelia.Rhizomorph.build_ngram_graph([sequence_for_hierarchy], 3; dataset_id=\"hierarchy\")\nkmer_result = Mycelia.Rhizomorph.build_kmer_graph(records_for_hierarchy, 5; dataset_id=\"hierarchy\")\nqualmer_result = Mycelia.Rhizomorph.build_qualmer_graph(fastq_records_for_hierarchy, 5; dataset_id=\"hierarchy\")\nngram_labels = collect(MetaGraphsNext.labels(ngram_result))\nkmer_labels = collect(MetaGraphsNext.labels(kmer_result))\nqualmer_labels = collect(MetaGraphsNext.labels(qualmer_result))\n\nprintln(\"\\\\nFixed-length graphs:\")\nprintln(\"  N-grams (n=3): $(length(ngram_labels)) vertices\")\nprintln(\"  K-mers (k=5): $(length(kmer_labels)) vertices\")\nprintln(\"  Qualmers (k=5): $(length(qualmer_labels)) vertices\")\n\nVariable-length graphs\n\nbio_result = Mycelia.Rhizomorph.build_fasta_graph(records_for_hierarchy; dataset_id=\"hierarchy\", min_overlap=5)\nquality_bio_result = Mycelia.Rhizomorph.build_fastq_graph(fastq_records_for_hierarchy; dataset_id=\"hierarchy\", min_overlap=5)\nbio_labels = collect(MetaGraphsNext.labels(bio_result))\nquality_bio_labels = collect(MetaGraphsNext.labels(quality_bio_result))\n\nprintln(\"\\\\nVariable-length graphs:\")\nprintln(\"  FASTA graph: $(length(bio_labels)) vertices\")\nprintln(\"  FASTQ graph: $(length(quality_bio_labels)) vertices\")\n\nConversions\n\nkmer_to_bio = Mycelia.Rhizomorph.convert_fixed_to_variable(kmer_result)\nqualmer_to_quality_bio = Mycelia.Rhizomorph.convert_fixed_to_variable(qualmer_result)\nkmer_to_bio_labels = collect(MetaGraphsNext.labels(kmer_to_bio))\nqualmer_to_quality_labels = collect(MetaGraphsNext.labels(qualmer_to_quality_bio))\n\nprintln(\"\\\\nConversions:\")\nprintln(\"  K-mer → FASTA graph: $(length(kmer_labels)) → $(length(kmer_to_bio_labels))\")\nprintln(\"  Qualmer → FASTQ graph: $(length(qualmer_labels)) → $(length(qualmer_to_quality_labels))\")\n\n============================================================================= Tutorial 8: Practical Assembly Workflow =============================================================================\n\nprintln(\"\\n8. PRACTICAL ASSEMBLY WORKFLOW\")\nprintln(\"-\"^50)\n\nSimulate a realistic assembly scenario\n\nsimulated_reads = [\n    \"ATCGATCGATCGATCGTAGC\",\n    \"GATCGATCGATCGTAGCTAG\",\n    \"TCGATCGATCGTAGCTAGCT\",\n    \"GATCGATCGTAGCTAGCTGC\",\n    \"TCGATCGTAGCTAGCTGCGC\"\n]\n\nprintln(\"Simulated sequencing reads:\")\nfor (i, read) in enumerate(simulated_reads)\n    println(\"  Read $i: $read\")\nend\n\nCreate records\n\nfasta_reads = [FASTX.FASTA.Record(\"read_$i\", read) for (i, read) in enumerate(simulated_reads)]\nfastq_reads = [FASTX.FASTQ.Record(\"read_$i\", read, repeat(\"H\", length(read))) for (i, read) in enumerate(simulated_reads)]\n\nMethod 1: K-mer graph assembly\n\nprintln(\"\\\\nMethod 1: K-mer graph assembly\")\nassembly_kmer_graph = Mycelia.Rhizomorph.build_kmer_graph(fasta_reads, 5; dataset_id=\"assembly_kmer\")\nassembly_kmers = collect(MetaGraphsNext.labels(assembly_kmer_graph))\nprintln(\"  K-mer graph: $(length(assembly_kmers)) unique k-mers\")\n\nMethod 2: Quality-aware Qualmer assembly\n\nprintln(\"\\\\nMethod 2: Quality-aware Qualmer assembly\")\nassembly_qualmer_graph = Mycelia.Rhizomorph.build_qualmer_graph(fastq_reads, 5; dataset_id=\"assembly_qualmer\")\nassembly_qualmers = collect(MetaGraphsNext.labels(assembly_qualmer_graph))\nprintln(\"  Qualmer graph: $(length(assembly_qualmers)) unique qualmers\")\n\nShow quality information\n\nif !isempty(assembly_qualmers)\n    first_qualmer = first(assembly_qualmers)\n    qualmer_vertex_data = assembly_qualmer_graph[first_qualmer]\n    assembly_joint_quality = Mycelia.Rhizomorph.get_vertex_joint_quality(qualmer_vertex_data, \"assembly_qualmer\")\n    joint_mean = Statistics.mean(assembly_joint_quality)\n    println(\"  Quality example: $(first_qualmer) with mean joint Q = $(round(joint_mean, digits=2))\")\nend\n\nMethod 3: FASTA graph assembly\n\nprintln(\"\\\\nMethod 3: FASTA graph assembly\")\nassembly_bio_graph = Mycelia.Rhizomorph.build_fasta_graph(fasta_reads; dataset_id=\"assembly_fasta\", min_overlap=5)\nassembly_sequences = collect(MetaGraphsNext.labels(assembly_bio_graph))\nprintln(\"  FASTA graph: $(length(assembly_sequences)) sequences\")\n\nprintln(\"\\\\nWorkflow summary:\")\nprintln(\"  1. Choose graph type based on data: FASTA → K-mer/FASTA graph, FASTQ → Qualmer/FASTQ graph\")\nprintln(\"  2. Consider quality: Use Qualmer graphs for quality-aware assembly\")\nprintln(\"  3. Use appropriate k-mer size: Smaller k for higher sensitivity, larger k for specificity\")\nprintln(\"  4. Convert between graph types as needed for different analysis steps\")\n\n============================================================================= Summary =============================================================================\n\nprintln(\"\\n\" * \"=\"^80)\nprintln(\"TUTORIAL SUMMARY\")\nprintln(\"=\"^80)\nprintln(\"You've learned about all 6 graph types in Mycelia Rhizomorph:\")\nprintln()\nprintln(\"FIXED-LENGTH GRAPHS (Assembly Foundation):\")\nprintln(\"  1. N-gram Graphs - Unicode text analysis\")\nprintln(\"  2. K-mer Graphs - DNA/RNA/protein sequence analysis\")\nprintln(\"  3. Qualmer Graphs - Quality-aware sequence analysis\")\nprintln()\nprintln(\"VARIABLE-LENGTH GRAPHS (OLC Products):\")\nprintln(\"  4. String Graphs - Variable-length string overlaps\")\nprintln(\"  5. FASTA Graphs - Variable-length BioSequence overlaps\")\nprintln(\"  6. FASTQ Graphs - Quality-aware BioSequence overlaps\")\nprintln()\nprintln(\"KEY FEATURES:\")\nprintln(\"  ✓ Type-stable implementation with storage parameters\")\nprintln(\"  ✓ Quality-aware assembly with per-base quality scores\")\nprintln(\"  ✓ Multi-alphabet support (DNA, RNA, amino acids)\")\nprintln(\"  ✓ Strand-aware graph construction\")\nprintln(\"  ✓ Graph type conversions and hierarchy\")\nprintln(\"  ✓ MetaGraphsNext.jl foundation for performance\")\nprintln()\nprintln(\"Choose the right graph type for your analysis:\")\nprintln(\"  - Use N-gram graphs for text analysis\")\nprintln(\"  - Use K-mer graphs for basic sequence analysis\")\nprintln(\"  - Use Qualmer graphs for quality-aware assembly\")\nprintln(\"  - Use FASTA graphs for variable-length analysis\")\nprintln(\"  - Use FASTQ graphs for quality-aware variable-length analysis\")\nprintln(\"=\"^80)","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Tutorial-6:-Gene-Annotation","page":"Step 6: Gene Annotation","title":"Tutorial 6: Gene Annotation","text":"This tutorial covers comprehensive gene annotation techniques, from basic gene prediction to functional annotation and annotation quality assessment.","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Learning-Objectives","page":"Step 6: Gene Annotation","title":"Learning Objectives","text":"By the end of this tutorial, you will understand:\n\nDifferent gene prediction approaches and their applications\nStructural annotation techniques for identifying genes and features\nFunctional annotation methods for assigning biological roles\nAnnotation quality assessment and validation\nComparative annotation approaches\nBest practices for different organism types","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Setup","page":"Step 6: Gene Annotation","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/06_gene_annotation.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Test\nimport Mycelia\nimport FASTX\nimport Random\nimport Statistics\n\nRandom.seed!(42)","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Part-1:-Gene-Annotation-Overview","page":"Step 6: Gene Annotation","title":"Part 1: Gene Annotation Overview","text":"Gene annotation is a multi-step process that identifies genes and assigns functional information to genomic sequences.\n\nprintln(\"=== Gene Annotation Tutorial ===\")\n\nprintln(\"Annotation Pipeline Overview:\")\nprintln(\"1. Structural Annotation\")\nprintln(\"   - Gene prediction\")\nprintln(\"   - Exon-intron structure\")\nprintln(\"   - Regulatory elements\")\nprintln()\nprintln(\"2. Functional Annotation\")\nprintln(\"   - Protein function prediction\")\nprintln(\"   - Pathway assignment\")\nprintln(\"   - GO term annotation\")\nprintln()\nprintln(\"3. Comparative Annotation\")\nprintln(\"   - Ortholog identification\")\nprintln(\"   - Synteny analysis\")\nprintln(\"   - Evolutionary analysis\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Part-2:-Structural-Annotation","page":"Step 6: Gene Annotation","title":"Part 2: Structural Annotation","text":"Structural annotation identifies the physical structure of genes and other functional elements.\n\nprintln(\"\\n=== Structural Annotation ===\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Preparing-Test-Genome","page":"Step 6: Gene Annotation","title":"Preparing Test Genome","text":"Create a test genome for annotation demonstration\n\nprintln(\"--- Preparing Test Genome ---\")\n\nGenerate test genome with gene-like features\n\ngenome_size = 50000\ntest_genome = Mycelia.random_fasta_record(moltype=:DNA, seed=1, L=genome_size)\ngenome_file = \"test_genome.fasta\"\nMycelia.write_fasta(outfile=genome_file, records=[test_genome])\n\nprintln(\"Test genome prepared: $(genome_size) bp\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Ab-Initio-Gene-Prediction","page":"Step 6: Gene Annotation","title":"Ab Initio Gene Prediction","text":"Predict genes using sequence signals alone\n\nprintln(\"--- Ab Initio Gene Prediction ---\")\n\nTODO: Implement ab initio gene prediction\n\nUse Prodigal for prokaryotic genes\nIdentify start/stop codons\nPredict coding sequences\nHandle overlapping genes\n\nSimulate gene prediction results\n\npredicted_genes = [\n    Dict(\"start\" => 1000, \"end\" => 2500, \"strand\" => \"+\", \"confidence\" => 0.95),\n    Dict(\"start\" => 3000, \"end\" => 4200, \"strand\" => \"-\", \"confidence\" => 0.88),\n    Dict(\"start\" => 5500, \"end\" => 7000, \"strand\" => \"+\", \"confidence\" => 0.92),\n    Dict(\"start\" => 8000, \"end\" => 9500, \"strand\" => \"+\", \"confidence\" => 0.85),\n    Dict(\"start\" => 10000, \"end\" => 11800, \"strand\" => \"-\", \"confidence\" => 0.90)\n]\n\nprintln(\"Ab Initio Gene Prediction Results:\")\nprintln(\"  Predicted genes: $(length(predicted_genes))\")\nprintln(\"  Mean confidence: $(round(Statistics.mean([g[\"confidence\"] for g in predicted_genes]), digits=3))\")\nprintln(\"  Coding density: $(round(sum([g[\"end\"] - g[\"start\"] + 1 for g in predicted_genes]) / genome_size * 100, digits=1))%\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Taxonomy-Aware-ORF-Calling","page":"Step 6: Gene Annotation","title":"Taxonomy-Aware ORF Calling","text":"When contigs are classified against NCBI, select the translation table before ORF calling so start/stop codons match the expected genetic code.\n\nncbi_taxonomy = Mycelia.load_ncbi_taxonomy()\ntax_id = 562\ntable_id = Mycelia.get_ncbi_genetic_code(ncbi_taxonomy, tax_id)\n\norf_calls = Mycelia.run_pyrodigal(\n    fasta_file=genome_file,\n    out_dir=\"orf_calls\",\n    translation_table=table_id\n)\n\nUse type=:mitochondrial for mitochondrial contigs.","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Homology-Based-Gene-Prediction","page":"Step 6: Gene Annotation","title":"Homology-Based Gene Prediction","text":"Use similarity to known genes for prediction\n\nprintln(\"--- Homology-Based Gene Prediction ---\")\n\nTODO: Implement homology-based prediction\n\nBLAST against protein databases\nIdentify homologous sequences\nTransfer annotations from homologs\nHandle partial matches\n\nSimulate homology search results\n\nhomology_results = [\n    Dict(\"query\" => \"gene_1\", \"subject\" => \"protein_X\", \"identity\" => 85.2, \"coverage\" => 95.0),\n    Dict(\"query\" => \"gene_2\", \"subject\" => \"protein_Y\", \"identity\" => 78.9, \"coverage\" => 88.0),\n    Dict(\"query\" => \"gene_3\", \"subject\" => \"protein_Z\", \"identity\" => 92.1, \"coverage\" => 97.0),\n    Dict(\"query\" => \"gene_4\", \"subject\" => \"protein_W\", \"identity\" => 65.4, \"coverage\" => 82.0),\n    Dict(\"query\" => \"gene_5\", \"subject\" => \"protein_V\", \"identity\" => 88.7, \"coverage\" => 91.0)\n]\n\nprintln(\"Homology Search Results:\")\nfor result in homology_results\n    println(\"  $(result[\"query\"]) -> $(result[\"subject\"]): $(result[\"identity\"])% identity, $(result[\"coverage\"])% coverage\")\nend","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#RNA-seq-Guided-Prediction","page":"Step 6: Gene Annotation","title":"RNA-seq Guided Prediction","text":"Use transcriptome data to improve gene prediction\n\nprintln(\"--- RNA-seq Guided Prediction ---\")\n\nTODO: Implement RNA-seq guided prediction\n\nMap RNA-seq reads to genome\nIdentify transcribed regions\nPredict exon-intron structure\nHandle alternative splicing","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Eukaryotic-Gene-Prediction","page":"Step 6: Gene Annotation","title":"Eukaryotic Gene Prediction","text":"Use Augustus for ab initio eukaryotic gene prediction or MetaEuk for metagenomic contigs with reference databases.\n\naugustus = Mycelia.run_augustus(fasta_file=genome_file, species=\"human\")\nmetaeuk = Mycelia.run_metaeuk(fasta_file=genome_file, db_file=\"uniref50_db\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Regulatory-Element-Prediction","page":"Step 6: Gene Annotation","title":"Regulatory Element Prediction","text":"Identify promoters, enhancers, and other regulatory sequences\n\nprintln(\"--- Regulatory Element Prediction ---\")\n\nTODO: Implement regulatory element prediction\n\nPromoter prediction\nTranscription factor binding sites\nCpG islands\nRepetitive elements","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Part-3:-Functional-Annotation","page":"Step 6: Gene Annotation","title":"Part 3: Functional Annotation","text":"Functional annotation assigns biological roles to predicted genes\n\nprintln(\"\\n=== Functional Annotation ===\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Protein-Function-Prediction","page":"Step 6: Gene Annotation","title":"Protein Function Prediction","text":"Predict protein functions using various approaches\n\nprintln(\"--- Protein Function Prediction ---\")\n\nTODO: Implement protein function prediction\n\nDomain identification (Pfam, InterPro)\nEnzyme classification (EC numbers)\nPathway assignment (KEGG, MetaCyc)\nGO term annotation\n\nSimulate functional annotation results\n\nfunctional_annotations = [\n    Dict(\"gene\" => \"gene_1\", \"function\" => \"DNA helicase\", \"ec\" => \"3.6.4.12\", \"confidence\" => 0.92),\n    Dict(\"gene\" => \"gene_2\", \"function\" => \"Transcriptional regulator\", \"ec\" => \"\", \"confidence\" => 0.78),\n    Dict(\"gene\" => \"gene_3\", \"function\" => \"Ribosomal protein L1\", \"ec\" => \"\", \"confidence\" => 0.95),\n    Dict(\"gene\" => \"gene_4\", \"function\" => \"Hypothetical protein\", \"ec\" => \"\", \"confidence\" => 0.45),\n    Dict(\"gene\" => \"gene_5\", \"function\" => \"ATP synthase subunit\", \"ec\" => \"3.6.3.14\", \"confidence\" => 0.88)\n]\n\nprintln(\"Functional Annotation Results:\")\nfor annot in functional_annotations\n    ec_str = annot[\"ec\"] != \"\" ? \" (EC: $(annot[\"ec\"]))\" : \"\"\n    println(\"  $(annot[\"gene\"]): $(annot[\"function\"])$ec_str [$(annot[\"confidence\"])]\")\nend","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Database-Annotation","page":"Step 6: Gene Annotation","title":"Database Annotation","text":"Annotate genes using specialized databases\n\nprintln(\"--- Database Annotation ---\")\n\nTODO: Implement database annotation\n\nBLAST against Swiss-Prot\nSearch COG database\nQuery KEGG pathways\nCheck specialized databases","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Gene-Ontology-Annotation","page":"Step 6: Gene Annotation","title":"Gene Ontology Annotation","text":"Assign GO terms for standardized functional description\n\nprintln(\"--- Gene Ontology Annotation ---\")\n\nTODO: Implement GO annotation\n\nAssign GO terms\nValidate GO term relationships\nCalculate GO term confidence\nGenerate GO term summaries\n\nSimulate GO annotation results\n\ngo_annotations = [\n    Dict(\"gene\" => \"gene_1\", \"go_terms\" => [\"GO:0003678\", \"GO:0006310\"], \"aspect\" => [\"MF\", \"BP\"]),\n    Dict(\"gene\" => \"gene_2\", \"go_terms\" => [\"GO:0003677\", \"GO:0006355\"], \"aspect\" => [\"MF\", \"BP\"]),\n    Dict(\"gene\" => \"gene_3\", \"go_terms\" => [\"GO:0003735\", \"GO:0006412\"], \"aspect\" => [\"MF\", \"BP\"]),\n    Dict(\"gene\" => \"gene_4\", \"go_terms\" => [], \"aspect\" => []),\n    Dict(\"gene\" => \"gene_5\", \"go_terms\" => [\"GO:0046933\", \"GO:0015986\"], \"aspect\" => [\"MF\", \"BP\"])\n]\n\nprintln(\"GO Annotation Results:\")\nfor annot in go_annotations\n    if !isempty(annot[\"go_terms\"])\n        println(\"  $(annot[\"gene\"]): $(join(annot[\"go_terms\"], \", \"))\")\n    else\n        println(\"  $(annot[\"gene\"]): No GO terms assigned\")\n    end\nend","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Part-4:-Annotation-Quality-Assessment","page":"Step 6: Gene Annotation","title":"Part 4: Annotation Quality Assessment","text":"Evaluate the quality and completeness of annotations\n\nprintln(\"\\n=== Annotation Quality Assessment ===\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Annotation-Completeness","page":"Step 6: Gene Annotation","title":"Annotation Completeness","text":"Assess what fraction of genes have functional annotations\n\nprintln(\"--- Annotation Completeness ---\")\n\nCalculate annotation statistics\n\ntotal_genes = length(predicted_genes)\nfunctionally_annotated = sum([annot[\"function\"] != \"Hypothetical protein\" for annot in functional_annotations])\nec_annotated = sum([annot[\"ec\"] != \"\" for annot in functional_annotations])\ngo_annotated = sum([!isempty(annot[\"go_terms\"]) for annot in go_annotations])\n\nannotation_stats = Dict(\n    \"total_genes\" => total_genes,\n    \"functionally_annotated\" => functionally_annotated,\n    \"ec_annotated\" => ec_annotated,\n    \"go_annotated\" => go_annotated,\n    \"functional_coverage\" => functionally_annotated / total_genes * 100,\n    \"ec_coverage\" => ec_annotated / total_genes * 100,\n    \"go_coverage\" => go_annotated / total_genes * 100\n)\n\nprintln(\"Annotation Completeness:\")\nfor (metric, value) in annotation_stats\n    println(\"  $metric: $value\")\nend","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Annotation-Consistency","page":"Step 6: Gene Annotation","title":"Annotation Consistency","text":"Check for consistency between different annotation methods\n\nprintln(\"--- Annotation Consistency ---\")\n\nTODO: Implement annotation consistency checks\n\nCompare ab initio vs homology predictions\nValidate functional annotations\nCheck for conflicting annotations\nAssess annotation confidence","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Annotation-Validation","page":"Step 6: Gene Annotation","title":"Annotation Validation","text":"Validate annotations using external evidence\n\nprintln(\"--- Annotation Validation ---\")\n\nTODO: Implement annotation validation\n\nCross-reference with literature\nValidate with experimental data\nCheck annotation standards compliance\nAssess annotation quality scores","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Part-5:-Comparative-Annotation","page":"Step 6: Gene Annotation","title":"Part 5: Comparative Annotation","text":"Use comparative genomics to improve annotation quality\n\nprintln(\"\\n=== Comparative Annotation ===\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Ortholog-Identification","page":"Step 6: Gene Annotation","title":"Ortholog Identification","text":"Identify corresponding genes in related species\n\nprintln(\"--- Ortholog Identification ---\")\n\nTODO: Implement ortholog identification\n\nBidirectional best hits\nOrtholog clustering\nPhylogenetic analysis\nSynteny-based validation","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Synteny-Analysis","page":"Step 6: Gene Annotation","title":"Synteny Analysis","text":"Analyze conserved gene order for annotation validation\n\nprintln(\"--- Synteny Analysis ---\")\n\nTODO: Implement synteny analysis\n\nIdentify syntenic blocks\nValidate gene annotations\nDetect gene duplications\nAnalyze evolutionary events","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Evolutionary-Analysis","page":"Step 6: Gene Annotation","title":"Evolutionary Analysis","text":"Analyze gene evolution patterns\n\nprintln(\"--- Evolutionary Analysis ---\")\n\nTODO: Implement evolutionary analysis\n\nSelection pressure analysis\nGene family evolution\nHorizontal gene transfer detection\nPseudogene identification","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Part-6:-Specialized-Annotation-Types","page":"Step 6: Gene Annotation","title":"Part 6: Specialized Annotation Types","text":"Handle organism-specific annotation challenges\n\nprintln(\"\\n=== Specialized Annotation ===\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Prokaryotic-Annotation","page":"Step 6: Gene Annotation","title":"Prokaryotic Annotation","text":"Features specific to bacterial and archaeal genomes\n\nprintln(\"--- Prokaryotic Annotation ---\")\n\nTODO: Implement prokaryotic-specific annotation\n\nOperon prediction\nSigma factor binding sites\nRibosome binding sites\nCRISPR arrays\n\nprokaryotic_features = Dict(\n    \"operons\" => 3,\n    \"sigma_sites\" => 12,\n    \"ribosome_binding_sites\" => 5,\n    \"crispr_arrays\" => 1\n)\n\nprintln(\"Prokaryotic Features:\")\nfor (feature, count) in prokaryotic_features\n    println(\"  $feature: $count\")\nend","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Eukaryotic-Annotation","page":"Step 6: Gene Annotation","title":"Eukaryotic Annotation","text":"Features specific to eukaryotic genomes\n\nprintln(\"--- Eukaryotic Annotation ---\")\n\nTODO: Implement eukaryotic-specific annotation\n\nIntron-exon structure\nAlternative splicing\nPseudogenes\nNon-coding RNAs","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Viral-Annotation","page":"Step 6: Gene Annotation","title":"Viral Annotation","text":"Features specific to viral genomes\n\nprintln(\"--- Viral Annotation ---\")\n\nTODO: Implement viral-specific annotation\n\nOverlapping genes\nFrameshift elements\nRegulatory sequences\nHost interaction factors","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Part-7:-Annotation-Visualization","page":"Step 6: Gene Annotation","title":"Part 7: Annotation Visualization","text":"Create visualizations for annotation results\n\nprintln(\"\\n=== Annotation Visualization ===\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Genome-Browser-Tracks","page":"Step 6: Gene Annotation","title":"Genome Browser Tracks","text":"Generate tracks for genome browsers\n\nprintln(\"--- Genome Browser Tracks ---\")\n\nTODO: Implement genome browser track generation\n\nGene structure tracks\nFunctional annotation tracks\nComparative annotation tracks\nQuality assessment tracks","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Annotation-Summary-Plots","page":"Step 6: Gene Annotation","title":"Annotation Summary Plots","text":"Create summary visualizations\n\nprintln(\"--- Annotation Summary Plots ---\")\n\nTODO: Implement annotation visualization\n\nFunctional category pie charts\nAnnotation quality histograms\nComparative annotation plots\nPathway enrichment plots","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Part-8:-Annotation-File-Formats","page":"Step 6: Gene Annotation","title":"Part 8: Annotation File Formats","text":"Work with standard annotation file formats\n\nprintln(\"\\n=== Annotation File Formats ===\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#GFF3-Format","page":"Step 6: Gene Annotation","title":"GFF3 Format","text":"Generate and manipulate GFF3 files\n\nprintln(\"--- GFF3 Format ---\")\n\nTODO: Implement GFF3 handling\n\nGenerate GFF3 from predictions\nValidate GFF3 format\nConvert between formats\nMerge annotation files\n\nGenerate example GFF3 content\n\ngff3_content = \"##gff-version 3\\n\" *\n    \"##sequence-region test_genome 1 50000\\n\" *\n    \"test_genome\\tprodigal\\tgene\\t1000\\t2500\\t0.95\\t+\\t.\\tID=gene_1;Name=gene_1\\n\" *\n    \"test_genome\\tprodigal\\tCDS\\t1000\\t2500\\t0.95\\t+\\t0\\tID=cds_1;Parent=gene_1\\n\" *\n    \"test_genome\\tprodigal\\tgene\\t3000\\t4200\\t0.88\\t-\\t.\\tID=gene_2;Name=gene_2\\n\" *\n    \"test_genome\\tprodigal\\tCDS\\t3000\\t4200\\t0.88\\t-\\t0\\tID=cds_2;Parent=gene_2\\n\"\n\ngff3_file = \"annotations.gff3\"\nopen(gff3_file, \"w\") do io\n    write(io, gff3_content)\nend\n\nprintln(\"GFF3 file generated: $gff3_file\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#GenBank-Format","page":"Step 6: Gene Annotation","title":"GenBank Format","text":"Generate GenBank format files\n\nprintln(\"--- GenBank Format ---\")\n\nTODO: Implement GenBank format handling\n\nGenerate GenBank files\nInclude sequence and annotations\nValidate format compliance\nExtract annotations from GenBank","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Part-9:-Annotation-Pipelines","page":"Step 6: Gene Annotation","title":"Part 9: Annotation Pipelines","text":"Integrate annotation steps into comprehensive pipelines\n\nprintln(\"\\n=== Annotation Pipelines ===\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Automated-Annotation-Pipeline","page":"Step 6: Gene Annotation","title":"Automated Annotation Pipeline","text":"Create automated annotation workflows\n\nprintln(\"--- Automated Pipeline ---\")\n\nTODO: Implement automated annotation pipeline\n\nCombine multiple prediction methods\nAutomated quality control\nStandardized output formats\nBatch processing capabilities","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Manual-Curation-Interface","page":"Step 6: Gene Annotation","title":"Manual Curation Interface","text":"Tools for manual annotation improvement\n\nprintln(\"--- Manual Curation ---\")\n\nTODO: Implement manual curation tools\n\nInteractive annotation editor\nEvidence integration interface\nCollaborative annotation platform\nVersion control for annotations","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Part-10:-Best-Practices-and-Guidelines","page":"Step 6: Gene Annotation","title":"Part 10: Best Practices and Guidelines","text":"Recommendations for high-quality annotation\n\nprintln(\"\\n=== Annotation Best Practices ===\")\n\nprintln(\"General Principles:\")\nprintln(\"- Use multiple complementary approaches\")\nprintln(\"- Validate predictions with experimental data\")\nprintln(\"- Maintain annotation standards compliance\")\nprintln(\"- Document annotation procedures and evidence\")\nprintln()\nprintln(\"Quality Thresholds:\")\nprintln(\"- Functional annotation: >80% of genes\")\nprintln(\"- Homology confidence: >70% identity, >80% coverage\")\nprintln(\"- GO term coverage: >60% of genes\")\nprintln(\"- Manual validation: High-confidence predictions\")\nprintln()\nprintln(\"Organism-Specific Considerations:\")\nprintln(\"- Prokaryotes: Focus on operons and regulation\")\nprintln(\"- Eukaryotes: Handle alternative splicing carefully\")\nprintln(\"- Viruses: Account for overlapping genes\")\nprintln(\"- Metagenomes: Use taxonomic context\")","category":"section"},{"location":"generated/tutorials/06_gene_annotation/#Summary","page":"Step 6: Gene Annotation","title":"Summary","text":"println(\"\\n=== Gene Annotation Summary ===\")\nprintln(\"✓ Understanding structural and functional annotation approaches\")\nprintln(\"✓ Implementing ab initio and homology-based gene prediction\")\nprintln(\"✓ Assigning functional annotations and GO terms\")\nprintln(\"✓ Evaluating annotation quality and completeness\")\nprintln(\"✓ Applying comparative annotation techniques\")\nprintln(\"✓ Handling organism-specific annotation challenges\")\nprintln(\"✓ Working with standard annotation file formats\")\nprintln(\"✓ Creating comprehensive annotation pipelines\")\n\nCleanup\n\ncleanup_files = [genome_file, gff3_file]\nfor file in cleanup_files\n    if isfile(file)\n        rm(file, force=true)\n    end\nend\n\nprintln(\"\\nNext: Tutorial 7 - Comparative Genomics\")\n\nnothing","category":"section"},{"location":"generated/tutorials/17_viroid_sketch_round_trip/#Tutorial-17:-Viroid-Sketch-Round-Trip-(Mash-sourmash-Sylph)","page":"Step 17: Viroid Sketch Round Trip","title":"Tutorial 17: Viroid Sketch Round Trip (Mash + sourmash + Sylph)","text":"This tutorial demonstrates a full, reproducible round-trip workflow: download a BLAST database, export it to FASTA, index with sketch tools, simulate reads from a known subset, and assert expected matches. Heavy steps are gated behind MYCELIA_RUN_EXTERNAL=true.","category":"section"},{"location":"generated/tutorials/17_viroid_sketch_round_trip/#Setup","page":"Step 17: Viroid Sketch Round Trip","title":"Setup","text":"From the Mycelia base directory, convert this tutorial to a notebook:\n\njulia --project=. -e 'import Literate; Literate.notebook(\"tutorials/17_viroid_sketch_round_trip.jl\", \"tutorials/notebooks\", execute=false)'\n\nimport Pkg\nif isinteractive()\n    Pkg.activate(\"..\")\nend\n\nimport Mycelia\nimport DataFrames\nimport CSV\nimport StableRNGs\nimport StatsBase\nimport Test\n\nrun_external = get(ENV, \"MYCELIA_RUN_EXTERNAL\", \"false\") == \"true\"\nif !run_external\n    println(\"Set MYCELIA_RUN_EXTERNAL=true to download references and run external tools.\")\nend\n\nbase_outdir = \"results/viroid_sketch_round_trip\"\nreference_dir = joinpath(base_outdir, \"reference\")\nmkpath(reference_dir)\n\nreference_db = \"ref_viroids_rep_genomes\"\nreference_fasta = joinpath(reference_dir, \"$(reference_db).fna.gz\")\nreference_table_csv = joinpath(reference_dir, \"viroids_reference_table.csv\")\nreference_genomes_dir = joinpath(reference_dir, \"genomes\")","category":"section"},{"location":"generated/tutorials/17_viroid_sketch_round_trip/#Step-1:-Download-the-viroid-BLAST-database","page":"Step 17: Viroid Sketch Round Trip","title":"Step 1: Download the viroid BLAST database","text":"reference_table = DataFrames.DataFrame()\nif run_external\n    db_path = Mycelia.download_blast_db(db=reference_db, dbdir=Mycelia.DEFAULT_BLASTDB_PATH)\n    Test.@test !isempty(db_path)","category":"section"},{"location":"generated/tutorials/17_viroid_sketch_round_trip/#Step-2:-Export-to-FASTA-build-reference-table","page":"Step 17: Viroid Sketch Round Trip","title":"Step 2: Export to FASTA + build reference table","text":"    reference_table = Mycelia.prepare_blast_reference_table(\n        blastdb=db_path,\n        blastdbs_dir=Mycelia.DEFAULT_BLASTDB_PATH,\n        download_if_missing=false,\n        reference_fasta=reference_fasta,\n        taxonomy_map_out=joinpath(reference_dir, \"$(reference_db).seqid2taxid.txt.gz\"),\n        table_out=reference_table_csv,\n        force=false\n    )\n    Test.@test isfile(reference_fasta)\n    Test.@test !isempty(reference_table)\nend","category":"section"},{"location":"generated/tutorials/17_viroid_sketch_round_trip/#Step-3:-Build-reference-indices-for-mash-sourmash","page":"Step 17: Viroid Sketch Round Trip","title":"Step 3: Build reference indices for mash + sourmash","text":"reference_sourmash_sig = \"\"\nreference_mash_db = \"\"\nreference_id_map = Dict{String,String}()\nreference_genomes = String[]\n\nif run_external && !isempty(reference_table)\n    reference_id_map = Mycelia.split_fasta_by_record(\n        fasta_in=reference_fasta,\n        outdir=reference_genomes_dir,\n        gzip=false,\n        force=false\n    )\n    reference_genomes = Mycelia.find_fasta_files(reference_genomes_dir)\n    Test.@test !isempty(reference_genomes)\n\n    reference_sourmash_dir = joinpath(reference_dir, \"sourmash\")\n    reference_mash_dir = joinpath(reference_dir, \"mash\")\n    mkpath.(String[reference_sourmash_dir, reference_mash_dir])\n\n    sourmash_ref = Mycelia.run_sourmash_sketch(\n        input_files=[reference_fasta],\n        outdir=reference_sourmash_dir,\n        k_sizes=[31],\n        scaled=1000,\n        singleton=true\n    )\n    Test.@test !isempty(sourmash_ref.signatures)\n    reference_sourmash_sig = sourmash_ref.signatures[1]\n\n    mash_result = Mycelia.run_mash_sketch(\n        input_files=reference_genomes,\n        outdir=reference_mash_dir,\n        k=21,\n        s=10000,\n        r=false\n    )\n    Test.@test !isempty(mash_result.sketches)\n    reference_mash_db = Mycelia.run_mash_paste(\n        out_file=joinpath(reference_mash_dir, \"$(reference_db).msh\"),\n        in_files=mash_result.sketches\n    )\nend","category":"section"},{"location":"generated/tutorials/17_viroid_sketch_round_trip/#Step-4:-Simulate-reads-from-a-known-subset","page":"Step 17: Viroid Sketch Round Trip","title":"Step 4: Simulate reads from a known subset","text":"depth_target = 20\nn_organisms = 1\nreadset = :illumina_pe150\nreplicate = 1\nrng = StableRNGs.StableRNG(1234)\n\nsim = nothing\nselected_ids = String[]\nscenario_dir = joinpath(base_outdir, \"depth$(depth_target)_div$(n_organisms)\")\n\nif run_external && !isempty(reference_table)\n    available_ids = unique(String.(reference_table.sequence_id))\n    selected_ids = StatsBase.sample(rng, available_ids, n_organisms; replace=false)\n    weights = fill(1.0, n_organisms)\n\n    sim = Mycelia.simulate_metagenome_community(\n        reference_fasta=reference_fasta,\n        reference_table=reference_table,\n        n_organisms=n_organisms,\n        depth_target=depth_target,\n        abundance_profile=:custom,\n        readset=readset,\n        outdir=scenario_dir,\n        selected_ids=selected_ids,\n        weights=weights,\n        rng=rng,\n        replicate=replicate,\n        run_simulation=true,\n        emit_truth_reads=true\n    )\n    CSV.write(joinpath(scenario_dir, \"truth_table.csv\"), sim.truth_table)\nend","category":"section"},{"location":"generated/tutorials/17_viroid_sketch_round_trip/#Step-5:-Screen-reads-with-mash,-sourmash,-and-Sylph","page":"Step 17: Viroid Sketch Round Trip","title":"Step 5: Screen reads with mash, sourmash, and Sylph","text":"if run_external && !isnothing(sim)\n    reads_forward = sim.reads.forward\n    reads_reverse = sim.reads.reverse\n    Test.@test !isnothing(reads_forward)\n\n    merged_reads = reads_forward\n    if !isnothing(reads_reverse)\n        merged_reads = joinpath(scenario_dir, \"reads_merged.fq.gz\")\n        Mycelia.concatenate_fastq_files(\n            fastq_files=[reads_forward, reads_reverse],\n            output_fastq=merged_reads,\n            gzip=true,\n            force=true\n        )\n    end\n\n    sourmash_outdir = joinpath(scenario_dir, \"sourmash\")\n    mash_outdir = joinpath(scenario_dir, \"mash\")\n    sylph_outdir = joinpath(scenario_dir, \"sylph\")\n    mkpath.(String[sourmash_outdir, mash_outdir, sylph_outdir])\n\n    query_sig = Mycelia.run_sourmash_sketch(\n        input_files=[merged_reads],\n        outdir=sourmash_outdir,\n        k_sizes=[31],\n        scaled=1000\n    ).signatures[1]\n    sourmash_gather = Mycelia.run_sourmash_gather(\n        query_sig=query_sig,\n        database_sig=reference_sourmash_sig,\n        outdir=sourmash_outdir,\n        k_size=31\n    )\n    sourmash_df = CSV.read(sourmash_gather.results_csv, DataFrames.DataFrame)\n\n    mash_screen = Mycelia.run_mash_screen(\n        reference=reference_mash_db,\n        query=merged_reads,\n        outdir=mash_outdir,\n        winner_takes_all=true\n    )\n    mash_df = Mycelia.parse_mash_screen_output(mash_screen.results_tsv)\n\n    sylph_result = if isnothing(reads_reverse)\n        Mycelia.run_sylph_profile(\n            reference_fastas=reference_genomes,\n            sample_reads=[reads_forward],\n            outdir=sylph_outdir\n        )\n    else\n        Mycelia.run_sylph_profile(\n            reference_fastas=reference_genomes,\n            first_pairs=[reads_forward],\n            second_pairs=[reads_reverse],\n            outdir=sylph_outdir\n        )\n    end","category":"section"},{"location":"generated/tutorials/17_viroid_sketch_round_trip/#Step-6:-Assert-expected-matches","page":"Step 17: Viroid Sketch Round Trip","title":"Step 6: Assert expected matches","text":"We expect the selected reference(s) to appear in the top hits.\n\n    truth_ids = String.(selected_ids)\n\n    Test.@test !isempty(mash_df)\n    mash_preds = [Mycelia.normalize_reference_label(x, reference_id_map) for x in mash_df.reference]\n    Test.@test truth_ids[1] in mash_preds\n\n    Test.@test !isempty(sourmash_df)\n    name_col = if \"name\" in DataFrames.names(sourmash_df)\n        \"name\"\n    elseif \"match_name\" in DataFrames.names(sourmash_df)\n        \"match_name\"\n    else\n        \"\"\n    end\n    Test.@test !isempty(name_col)\n    sourmash_preds = [Mycelia.normalize_reference_label(x, reference_id_map) for x in sourmash_df[!, name_col]]\n    Test.@test truth_ids[1] in sourmash_preds\n\n    Test.@test !isempty(sylph_result.table)\n    sylph_col = first(filter(col -> col in DataFrames.names(sylph_result.table), [\"genome\", \"reference\", \"ref\", \"name\"]), \"\")\n    Test.@test !isempty(sylph_col)\n    sylph_preds = [Mycelia.normalize_reference_label(x, reference_id_map) for x in sylph_result.table[!, sylph_col]]\n    Test.@test truth_ids[1] in sylph_preds\nend","category":"section"},{"location":"workflow-map/#Workflow-and-Tool-Map","page":"Workflow Map","title":"Workflow & Tool Map","text":"A comprehensive, à la carte map of Mycelia’s capabilities. Each row connects:\n\nInput data type (FASTQ/FASTA/GFA/BAM/VCF, etc.)\nMycelia entry points (Julia functions)\nWrapped third-party tools\nOutputs (assemblies, QC tables, summary results, taxonomic abundance tables, etc.)\nTutorials that walk through the transformation\n\nPlanned capabilities are rendered in <span style=\"background-color:#f0f0f0;\">shaded cells</span> so we can see what still needs to be built.\n\nNOTE: If a workflow uses third-party tools or datasets, cite them. See References for citation guidance.\n\n","category":"section"},{"location":"workflow-map/#High-Level-Data-Flow-(Mermaid)","page":"Workflow Map","title":"High-Level Data Flow (Mermaid)","text":"flowchart LR\n    subgraph Inputs\n        FASTQ[\"FASTQ reads<br/>(Illumina/PacBio/Nanopore)\"]\n        FASTA[\"FASTA genomes / contigs / transcripts\"]\n        GFA[\"Assembly graphs<br/>(GFA / FASTG)\"]\n        BAM[\"Alignments<br/>(BAM / SAM / CRAM)\"]\n        VCF[\"Variants<br/>(VCF)\"]\n        REF[\"Reference genomes<br/>(NCBI / custom)\"]\n    end\n\n    subgraph QC\n        QCReads[\"Quality Control<br/>(fastp / filtlong / native QC)\"]\n        QCTables[\"QC tables<br/>+ HTML reports\"]\n    end\n\n    subgraph Assembly\n        Assemblers[\"Assemblers<br/>(MEGAHIT, metaSPAdes,<br/>Flye, hifiasm, Rhizomorph)\"]\n        GraphOps[\"Graph utilities<br/>(Rhizomorph / GFA I/O)\"]\n    end\n\n    subgraph PostProc[\"Post-processing\"]\n        Validation[\"Assembly validation<br/>(QUAST, BUSCO, CheckM/CheckM2, MUMmer)\"]\n        Annotation[\"Gene annotation<br/>(Pyrodigal, BLAST+, MMSeqs2, tRNAscan-SE, TransTerm, MLST)\"]\n        Taxonomy[\"Taxonomic profiling<br/>(taxonomy utilities, planned Kraken-style wrappers)\"]\n        Pangenome[\"Pangenome & distance<br/>(Mash, pangenome graphs)\"]\n        Variants[\"Variant analysis<br/>(GATK / vcfeval / FreeBayes / Clair3 / BCFtools)\"]\n    end\n\n    subgraph Outputs\n        Tables[\"Summary & QC tables\"]\n        Abund[\"Taxonomic & functional abundance tables\"]\n        Graphs[\"Graphs<br/>(GFA / internal graph types)\"]\n        Reports[\"HTML / text reports & plots\"]\n    end\n\n    FASTQ --> QCReads\n    QCReads --> QCTables\n    QCReads --> Assemblers\n    FASTA --> Pangenome\n    FASTA --> Assemblers\n    GFA --> GraphOps\n    GraphOps --> Assemblers\n    Assemblers --> Validation\n    Assemblers --> Annotation\n    Assemblers --> Pangenome\n    Assemblers --> Graphs\n\n    BAM --> Validation\n    BAM --> Variants\n    BAM --> Taxonomy\n\n    VCF --> Variants\n    REF --> Variants\n    REF --> Pangenome\n\n    Validation --> Tables\n    Annotation --> Tables\n    Taxonomy --> Abund\n    Pangenome --> Tables\n    Pangenome --> Graphs\n    Variants --> Tables\n    QCTables --> Reports\n    Tables --> Reports\n    Abund --> Reports\n\nUse this diagram as the “big picture”; the tables below are the detailed à la carte menu.\n\n","category":"section"},{"location":"workflow-map/#1.-End-to-End-Menu-(by-Input-Type)","page":"Workflow Map","title":"1. End-to-End Menu (by Input Type)","text":"","category":"section"},{"location":"workflow-map/#1.1-FASTQ-/-FASTA-/-GFA-/-BAM-/-VCF-Outputs","page":"Workflow Map","title":"1.1 FASTQ / FASTA / GFA / BAM / VCF → Outputs","text":"Input Mycelia entry points Wrapped tools Outputs Tutorial links\nFASTQ short reads (Illumina) analyze_fastq_quality, calculate_gc_content, assess_duplication_rates, qc_filter_short_reads_fastp, trim_galore_paired fastp, Trim Galore QC HTML reports, filtered FASTQ, per-sample QC tables Quality Control\nFASTQ long reads (ONT / PacBio) qc_filter_long_reads_filtlong, native FASTQ QC utilities Filtlong Filtered FASTQ, length/quality distributions, QC tables Quality Control\nFASTA references (genomes, contigs, transcripts) open_fastx, convert_sequence, count_canonical_kmers, distance functions — Canonical sequences, k-mer matrices, distance matrices K-mer Analysis\nMixed FASTA / FASTQ sets count_canonical_kmers, jaccard_distance, kmer_counts_to_js_divergence — K-mer spectra, Jaccard / JS distance tables, plots K-mer Analysis\nPacBio / Nanopore reads (simulated) simulate_pacbio_reads, simulate_nanopore_reads PBSim / DeepSimulator (via wrappers) FASTQ read sets + ground-truth tables Data Acquisition\nIllumina reads (simulated) simulate_illumina_reads ART FASTQ read sets + ground-truth tables Data Acquisition\nPublic genomes (NCBI) download_genome_by_accession, prefetch_sra_runs, fasterq_dump_parallel NCBI datasets / Entrez / SRA Toolkit FASTA/FASTQ datasets + accession metadata tables Data Acquisition\nFASTQ (assembly) Mycelia.Rhizomorph.assemble_genome (front-end) → run_megahit, run_metaspades, run_spades, run_flye, run_hifiasm, run_unicycler MEGAHIT, metaSPAdes, SPAdes, Flye/metaFlye, hifiasm, Canu, SKESA, Unicycler Contig/scaffold FASTA, assembly logs, GFA/FASTG graphs Genome Assembly\nFASTQ (native / experimental assembly) mycelia_iterative_assemble, improve_read_set_likelihood, find_optimal_sequence_path — (native Rhizomorph graphs) Iteratively improved reads, qualmer/string graphs, checkpoint metadata <span style=\"background-color:#f0f0f0;\">Planned: 12_rhizomorph_graphs.jl</span>\nGFA / FASTG assembly graphs Mycelia.Rhizomorph.read_gfa_next, Mycelia.Rhizomorph.build_kmer_graph, Mycelia.Rhizomorph.build_qualmer_graph, Mycelia.Rhizomorph.write_gfa_next — Parsed graph objects, simplified graphs, re-exported GFA/FASTG Graph Type Tutorials, Round-Trip Graphs\nBAM / SAM / CRAM alignments xam_to_dataframe, visualize_genome_coverage, run_qualimap_bamqc samtools, Qualimap Coverage plots, per-base depth tables, BAM-QC HTML reports Tool Integration, Assembly Validation\nAssemblies (FASTA) + references assess_assembly_quality, run_quast, run_busco, run_mummer QUAST, BUSCO, MUMmer, CheckM/CheckM2 Assembly QC summary tables, BUSCO metrics, alignment plots Assembly Validation\nGene prediction inputs (assembled contigs) run_prodigal, run_pyrodigal, run_prodigal_gv, run_augustus, run_metaeuk, run_blastp_search, run_mmseqs_search, run_transterm, run_trnascan, run_mlst Prodigal, Pyrodigal, Prodigal-gv, Augustus, MetaEuk, BLAST+, MMSeqs2, TransTerm, tRNAscan-SE, MLST GFF3 annotations, protein FASTA, functional/categorical tables Gene Annotation\nMultiple assemblies (FASTA genomes) build_genome_distance_matrix, pairwise_mash_distance_matrix, construct_pangenome_pggb, construct_pangenome_cactus Mash/MinHash, PGGB, cactus Distance matrices, clustered panels, pangenome graphs, summary tables Comparative Genomics\nTaxonomic profiling inputs (classified alignments, tables) classify_taxonomy_aware_xam_table, plot_taxa_abundances, visualize_xam_classifications Native taxonomy utilities, Krona/plotting Taxonomic abundance tables, Sankey/stacked plots Tool Integration\nGraph-derived sequences build_string_graph, string_to_ngram_graph, assemble_strings — String graphs, reconstructed sequences, evidence-tracking tables Round-Trip: String Graphs, N-gram Graphs\nGraph-derived sequences build_string_graph, string_to_ngram_graph, assemble_strings — String graphs, reconstructed sequences, evidence-tracking tables Round-Trip: String Graphs, N-gram Graphs\nQualmer graphs build_qualmer_graph, get_qualmer_statistics, simplification helpers — Quality-weighted sequence graphs, path correctness scores, diagnostic tables <span style=\"background-color:#f0f0f0;\">Planned: 12_rhizomorph_graphs.jl</span>\nProtein sequences reduce_amino_alphabet, analyze_amino_acids — Reduced alphabet sequences, amino acid composition tables Reduced Amino Acid Alphabets\nViroid / viral genomes Mycelia.Rhizomorph.assemble_genome (circular options), Mycelia.Rhizomorph.validate_assembly Flye/metaFlye, QUAST Circular contig FASTA, QC tables Viroid Assembly Workflow\nVCF + BAM + reference FASTA run_gatk_haplotypecaller, run_freebayes, run_clair3, run_bcftools_call, normalize_vcf, update_fasta_with_vcf, run_vcfeval, evaluate_variant_calling_accuracy GATK HaplotypeCaller, FreeBayes, Clair3, BCFtools, RTG vcfeval Normalized VCF, updated reference, ROC/precision–recall tables Planned: Variant Calling Tutorial\nMetagenomic reads (amplicon / shotgun) run_metaspades, run_metaflye, run_sourmash_sketch, run_metaphlan, run_metabuli_classify, run_sylph_profile, run_metabat2, run_vamb, run_taxvamb, run_taxometer, run_metacoag, run_genomeface, run_comebin, run_drep_dereplicate, run_magmax_merge metaSPAdes, MetaFlye, sourmash, MetaPhlAn, Metabuli, Sylph, MetaBAT2, VAMB, TaxVAMB, Taxometer, MetaCoAG, GenomeFace, COMEBin, dRep, MAGmax MAG bins, taxonomic abundance tables, bin-quality summaries Binning Workflow\nGFA → interactive graph curation <span style=\"background-color:#f0f0f0;\">curate_assembly_graph</span> <span style=\"background-color:#f0f0f0;\">Bandage integration</span> <span style=\"background-color:#f0f0f0;\">Curated graph, manual edits exported to GFA</span> <span style=\"background-color:#f0f0f0;\">Planned: GFA Curation Tutorial</span>\nPhylogenetic trees <span style=\"background-color:#f0f0f0;\">construct_phylogeny, plot_phylogeny</span> <span style=\"background-color:#f0f0f0;\">RAxML, IQ-TREE</span> <span style=\"background-color:#f0f0f0;\">Newick trees, phylogenetic plots</span> <span style=\"background-color:#f0f0f0;\">Planned: Phylogenetics Tutorial</span>\n\n","category":"section"},{"location":"workflow-map/#2.-Capability-Matrix-(by-Task)","page":"Workflow Map","title":"2. Capability Matrix (by Task)","text":"This mirrors patch 2’s capability section and ensures everything is covered from a “what do I want to do?” perspective.\n\nCapability Entry points Inputs Outputs Tooling\nData acquisition download_genome_by_accession, prefetch_sra_runs, fasterq_dump_parallel Accessions / run tables FASTA/FASTQ, metadata NCBI E-utilities, SRA Toolkit\nRead simulation simulate_illumina_reads, simulate_pacbio_reads, simulate_nanopore_reads Reference FASTA, sim params FASTQ reads, ground-truth tables ART, PBSim, DeepSimulator\nQuality filtering qc_filter_short_reads_fastp, qc_filter_long_reads_filtlong, trim_galore_paired FASTQ Filtered FASTQ, HTML reports fastp, Filtlong, Trim Galore\nQuality metrics analyze_fastq_quality, assess_duplication_rates, robust_cv, robust_threshold, filter_genome_outliers FASTQ, QC tables Summary QC tables, outlier flags Native Julia\nAssembly Mycelia.Rhizomorph.assemble_genome, run_megahit, run_metaspades, run_spades, run_flye, run_hifiasm, mycelia_iterative_assemble FASTQ, config Contigs/scaffolds, assembly graphs External assemblers + native graphs\nAssembly validation assess_assembly_quality, run_quast, run_busco, run_mummer, CheckM/CheckM2 integration Assemblies + references QC reports, summary tables QUAST, BUSCO, MUMmer, CheckM\nGraph utilities build_string_graph, build_fasta_graph, build_qualmer_graph, read_gfa_next, write_quality_biosequence_gfa FASTA/FASTQ/GFA Graph objects, GFA exports Native Julia (Rhizomorph)\nComparative genomics construct_pangenome_pggb, construct_pangenome_cactus, build_genome_distance_matrix, analyze_pangenome_kmers Assemblies, sketch files Pangenome graphs, distance matrices PGGB, cactus, Mash-like tools\nTaxonomy classify_taxonomy_aware_xam_table, plot_taxa_abundances, visualize_xam_classifications Mapping tables, taxonomic refs Abundance tables, taxonomy plots Native Julia, plotting libs\nAlignment & search run_blastp_search, run_mmseqs_search, run_diamond_search, run_minimap2 helpers FASTA/FASTQ, databases Alignments (SAM/BAM), hit tables BLAST+, MMSeqs2, DIAMOND, minimap2\nVariant analysis run_gatk_haplotypecaller, run_freebayes, run_clair3, run_bcftools_call, run_vcfeval, evaluate_variant_calling_accuracy BAM/CRAM, VCF, references VCFs, ROC tables, summary stats GATK, FreeBayes, Clair3, BCFtools, RTG vcfeval\nCloud & orchestration rclone_copy, rclone_sync, render_sbatch, submit_sbatch, lawrencium_sbatch, nersc_sbatch Paths, SLURM params Synced data, sbatch scripts, submitted jobs rclone, SLURM\n\n","category":"section"},{"location":"workflow-map/#3.-Module-coverage-and-doc-gaps","page":"Workflow Map","title":"3. Module coverage & doc gaps","text":"","category":"section"},{"location":"workflow-map/#3.1-Auto-included-modules-(from-src/Mycelia.jl)","page":"Workflow Map","title":"3.1 Auto-included modules (from src/Mycelia.jl)","text":"These bullets are a concise, user-facing summary of the auto-included modules.\n\nCore graph + I/O: utility-functions.jl, alphabets.jl, constants.jl, fastx.jl, rhizomorph/rhizomorph.jl (core enums/evidence, fixed-length graphs, variable-length graphs, graph algorithms) → Exposed via Rhizomorph: build_ngram_graph, build_kmer_graph, build_qualmer_graph, build_fasta_graph, build_fastq_graph, path-finding & simplification utilities.\nAssembly pipelines: assembly.jl (external assemblers), iterative-assembly.jl (mycelia_iterative_assemble, improve_read_set_likelihood, find_optimal_sequence_path), viterbi-next.jl.\nAnalytics & QC: quality-control-and-benchmarking.jl, performance-benchmarks.jl, kmer-analysis.jl, distance-metrics.jl.\nTaxonomy & annotation: taxonomy-and-trees.jl, classification.jl, reference-databases.jl, annotation.jl.\nWrappers & orchestration: bioconda.jl, rclone.jl, slurm-sbatch.jl, neo4jl.jl, xam.jl.","category":"section"},{"location":"workflow-map/#3.2-External-tool-wrappers-(no-dedicated-tutorials-yet)","page":"Workflow Map","title":"3.2 External tool wrappers (no dedicated tutorials yet)","text":"These wrappers are available in src/ but do not yet have dedicated tutorials. They are listed here so the function coverage map can point to an explicit doc location until tutorials are added.\n\nWrapper file Entry points (selected) Tool Notes\nautocycler.jl install_autocycler, run_autocycler Autocycler Conda env + Autocycler bash pipeline.\nbcalm.jl install_bcalm, run_bcalm BCALM Converts unitigs to GFA via convertToGFA.py.\nfoldseek.jl install_foldseek, foldseek_easy_search, foldseek_easy_cluster, foldseek_createdb, foldseek_databases Foldseek Structure search and clustering.\nggcat.jl install_ggcat, ggcat_build, ggcat_query GGCAT Compacted or colored de Bruijn graphs.\npantools.jl run_pantools, pantools_cmd, write_pantools_genome_locations_file, write_pantools_annotation_locations_file PanTools Pangenome toolkit wrapper via Bioconda.\nprokrustean.jl install_prokrustean, prokrustean_build_graph, prokrustean_kmer_count, prokrustean_unitig_count, prokrustean_braycurtis, prokrustean_overlap Prokrustean Builds from source; provides k-mer and unitig metrics.","category":"section"},{"location":"api/all-functions/#Complete-API-Surface","page":"Complete API Surface","title":"Complete API Surface","text":"This page is generated directly from the package docstrings so every documented function, type, and constant available in the current codebase is visible in one place. Use this as a coverage checklist when adding new functionality: if a symbol is missing here, it either lacks a docstring or has not been included in the documentation build pipeline.","category":"section"},{"location":"api/all-functions/#Index-of-All-Documented-Symbols","page":"Complete API Surface","title":"Index of All Documented Symbols","text":"Modules = [Mycelia, Mycelia.Rhizomorph]","category":"section"},{"location":"api/all-functions/#Detailed-Reference-(auto-generated)","page":"Complete API Surface","title":"Detailed Reference (auto-generated)","text":"","category":"section"},{"location":"api/all-functions/#Keeping-the-API-Complete","page":"Complete API Surface","title":"Keeping the API Complete","text":"Implemented, documented functions will appear above. Add docstrings in the source files to include new symbols automatically.\nExperimental or deprecated functions are included for transparency; mark them in their docstrings accordingly.\nPlanned functions should be captured in the Workflow & Tool Map until they are implemented and documented.","category":"section"},{"location":"#Mycelia-Documentation","page":"Home","title":"Mycelia Documentation","text":"An experimental Julia package for bioinformatics and computational biology\n\nMycelia is a research-oriented package exploring best-practice methodologies for pan-multi-omics analysis and graph-based assembly with quality-aware sequence processing. Currently in early development, it provides both experimental algorithms and integrations with established bioinformatics tools.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"New to Mycelia? Start with our Getting Started Guide to install the package and complete your first genomic analysis in minutes.","category":"section"},{"location":"#Key-Features-and-Research-Areas","page":"Home","title":"Key Features & Research Areas","text":"","category":"section"},{"location":"#Production-Ready-Features","page":"Home","title":"Production-Ready Features","text":"Third-Party Assembly Tools: Stable wrappers for 15+ established assemblers including MEGAHIT, SPAdes, Flye, hifiasm, Canu, Unicycler, Velvet, and others\nSequence Processing: FASTA/FASTQ I/O and read simulation (Illumina, PacBio, Nanopore)\nK-mer Analysis: Canonical k-mer counting and distance metrics\nQuality Control Tools: Integration with fastp, filtlong, trim_galore\nAssembly Validation: QUAST, BUSCO, CheckM/CheckM2, MUMmer integration\nAnnotation Tools: Pyrodigal, BLAST+, MMSeqs2, TransTerm, tRNAscan-SE, MLST integration\nHPC Support: SLURM job submission and rclone cloud storage integration","category":"section"},{"location":"#Experimental/Research-Features","page":"Home","title":"Experimental/Research Features","text":"Internal Assembly Algorithms: Graph-based approaches with quality awareness (6-graph hierarchy)\nIntelligent Assembly: Self-optimizing parameter selection and k-mer progression\nQualmer Analysis: Quality-aware k-mer assembly and probabilistic path selection\nReinforcement Learning Assembly: ML-guided assembly optimization (proof-of-concept)\nPangenome Analysis: K-mer based comparative genomics\nPhylogenetics: Tree construction from pangenome data","category":"section"},{"location":"#Documentation-Contents","page":"Home","title":"Documentation Contents","text":"Pages = [\n    \"getting-started.md\",\n    \"installation.md\",\n    \"concepts.md\",\n    \"workflow-map.md\",\n    \"metagenomic-workflow.md\",\n    \"tutorials.md\",\n    \"api/all-functions.md\",\n    \"benchmarks.md\",\n    \"related-projects.md\",\n    \"contributing.md\"\n]\nDepth = 2","category":"section"},{"location":"#Navigating-the-Docs","page":"Home","title":"Navigating the Docs","text":"Workflow & Tool Map: See workflow-map.md for the end-to-end data-flow map with links to tutorials and third-party tool wrappers.\nTutorials: Start with tutorials.md for guided walkthroughs of each workflow stage.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Quick-Install","page":"Home","title":"Quick Install","text":"import Pkg\nPkg.add(url=\"https://github.com/cjprybol/Mycelia.git\")","category":"section"},{"location":"#Development-Install","page":"Home","title":"Development Install","text":"import Pkg\nPkg.develop(url=\"git@github.com:cjprybol/Mycelia.git\")\n\nFor detailed installation instructions including HPC setup, see the Getting Started Guide.","category":"section"},{"location":"#Function-Docstrings","page":"Home","title":"Function Docstrings","text":"For complete API documentation, see the Complete API Surface section.","category":"section"},{"location":"related-projects/#Related-Projects","page":"Related Projects","title":"Related Projects","text":"Mycelia builds upon and complements several excellent projects in the graph genomics and bioinformatics space. This page acknowledges these tools and tracks their integration status with Mycelia.","category":"section"},{"location":"related-projects/#Graph-Genomics-Tools","page":"Related Projects","title":"Graph Genomics Tools","text":"","category":"section"},{"location":"related-projects/#[vg](https://github.com/vgteam/vg)","page":"Related Projects","title":"vg","text":"The variation graph toolkit - a comprehensive suite for working with genome variation graphs. Mycelia wraps vg's core functionality for graph construction, manipulation, and analysis.","category":"section"},{"location":"related-projects/#[PGGB](https://github.com/pangenome/pggb)","page":"Related Projects","title":"PGGB","text":"PanGenome Graph Builder - a pipeline for constructing pangenome variation graphs from genome assemblies. Combines wfmash, seqwish, smoothxg, odgi, and gfaffix.","category":"section"},{"location":"related-projects/#[ODGI](https://github.com/pangenome/odgi)","page":"Related Projects","title":"ODGI","text":"Optimized Dynamic Genome/Graph Implementation - tools for analyzing and manipulating genome variation graphs. Provides graph optimization, visualization, and path analysis.","category":"section"},{"location":"related-projects/#[MetaGraph](https://github.com/ratschlab/metagraph)","page":"Related Projects","title":"MetaGraph","text":"A scalable framework for indexing and querying large-scale genomic databases using annotated de Bruijn graphs.","category":"section"},{"location":"related-projects/#[PanTools](https://git.wur.nl/bioinformatics/pantools)","page":"Related Projects","title":"PanTools","text":"Computational pan-genomics toolkit with a focus on database-driven pangenome analysis and comparative genomics.","category":"section"},{"location":"related-projects/#[pangene](https://github.com/lh3/pangene)","page":"Related Projects","title":"pangene","text":"Li Heng's tool for pangenome gene annotation - extracts and analyzes genes across multiple genomes in a pangenome context.","category":"section"},{"location":"related-projects/#[Graphein](https://github.com/a-r-j/graphein)","page":"Related Projects","title":"Graphein","text":"Protein Graph Library - converts protein structures and interaction networks into graph representations for machine learning and network analysis.","category":"section"},{"location":"related-projects/#Related-Julia-Packages","page":"Related Projects","title":"Related Julia Packages","text":"BioSequences.jl - Biological sequence types and operations\nGenomicAnnotations.jl - Genome annotation handling\nFASTX.jl - FASTA/FASTQ parsing\nXAM.jl - SAM/BAM/CRAM file handling\nGraphs.jl - Core graph algorithms","category":"section"}]
}
