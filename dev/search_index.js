var documenterSearchIndex = {"docs":
[{"location":"#Mycelia-Documentation","page":"Home","title":"Mycelia Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the Mycelia documentation.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install Julia (if not already installed)","category":"page"},{"location":"","page":"Home","title":"Home","text":"I have had trouble getting the visualization libraries Plots.jl and Makie.jl (and associated packages) to load correctly on HPC due to the complexities of the default LDLIBRARYPATH","category":"page"},{"location":"","page":"Home","title":"Home","text":"I imagine other research supercomputer users may have similar issues, although I don't have these issues on cloud vendors like GCP or AWS","category":"page"},{"location":"","page":"Home","title":"Home","text":"To enable Julia to install all of it's own necessary dependencies independent of the system, I reset the LDLIBRARYPATH variable prior to launching Julia !!","category":"page"},{"location":"","page":"Home","title":"Home","text":"This can be done easily when launching Julia from the command line by","category":"page"},{"location":"","page":"Home","title":"Home","text":"export LD_LIBRARY_PATH=\"\" && julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"And can be done for Julia jupyter kernels by setting the env key => value pair in the appropriate kernel.json file","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clone the repo as a Julia package","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\n# for production usage\nPkg.add(url=\"https://github.com/cjprybol/Mycelia.git\")\n# for development\nPkg.develop(url=\"git@github.com:cjprybol/Mycelia.git\")","category":"page"},{"location":"#Function-Docstrings","page":"Home","title":"Function Docstrings","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Mycelia]","category":"page"},{"location":"#Mycelia._detect_sequence_extension-Tuple{Symbol}","page":"Home","title":"Mycelia._detect_sequence_extension","text":"_detect_sequence_extension(sequence_type::Symbol) -> String\n\n\nInternal helper function to convert sequence type to file extension.\n\nArguments\n\nsequence_type: Symbol representing sequence type (:DNA, :RNA, or :AA)\n\nReturns\n\nString: Appropriate file extensions\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.add_bioconda_env-Tuple{Any}","page":"Home","title":"Mycelia.add_bioconda_env","text":"add_bioconda_env(pkg; force) -> Union{Nothing, Base.Process}\n\n\nCreate a new Conda environment with a specified Bioconda package.\n\nArguments\n\npkg::String: Package name to install. Can include channel specification using  the format \"channel::package\"\n\nKeywords\n\nforce::Bool=false: If true, recreates the environment even if it already exists\n\nDetails\n\nThe function creates a new Conda environment named after the package and installs the package into it. It uses channel priority: conda-forge > bioconda > defaults. If CONDA_RUNNER is set to 'mamba', it will ensure mamba is installed first.\n\nExamples\n\n# Install basic package\nadd_bioconda_env(\"blast\")\n\n# Install from specific channel\nadd_bioconda_env(\"bioconda::blast\")\n\n# Force reinstallation\nadd_bioconda_env(\"blast\", force=true)\n\nNotes\n\nRequires Conda.jl to be installed and configured\nUses CONDA_RUNNER global variable to determine whether to use conda or mamba\nCleans conda cache after installation\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.add_edgemer_to_graph!-NTuple{4, Any}","page":"Home","title":"Mycelia.add_edgemer_to_graph!","text":"add_edgemer_to_graph!(\n    graph,\n    record_identifier,\n    index,\n    observed_edgemer\n) -> Any\n\n\nAdd an observed edgemer to a graph with its associated metadata.\n\nArguments\n\ngraph::MetaGraph: The graph to modify\nrecord_identifier: Identifier for the source record\nindex: Position where edgemer was observed\nobserved_edgemer: The biological sequence representing the edgemer\n\nDetails\n\nProcesses the edgemer by:\n\nSplitting it into source and destination kmers\nConverting kmers to their canonical forms\nCreating or updating an edge with orientation metadata\nStoring observation details (record, position, orientation)\n\nReturns\n\nModified graph with the new edge and metadata\n\nNote\n\nIf the edge already exists, the observation is added to the existing metadata.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.add_fastx_records_to_graph!-Tuple{Any, Any}","page":"Home","title":"Mycelia.add_fastx_records_to_graph!","text":"add_fastx_records_to_graph!(graph, fastxs) -> Any\n\n\nAdd FASTX records from multiple files as a graph property.\n\nArguments\n\ngraph: A MetaGraph that will store the FASTX records\nfastxs: Collection of FASTA/FASTQ file paths to process\n\nDetails\n\nCreates a dictionary mapping sequence descriptions to their corresponding FASTX records, then stores this dictionary as a graph property under the key :records. Multiple input files are merged, with later files overwriting records with duplicate descriptions.\n\nReturns\n\nThe modified graph with added records property.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.add_record_edgemers_to_graph!-Tuple{Any}","page":"Home","title":"Mycelia.add_record_edgemers_to_graph!","text":"add_record_edgemers_to_graph!(graph) -> Any\n\n\nProcesses DNA sequence records stored in the graph and adds their edgemers (k+1 length subsequences)  to build the graph structure.\n\nArguments\n\ngraph: A Mycelia graph object containing DNA sequence records and graph properties\n\nDetails\n\nUses the k-mer size specified in graph.gprops[:k] to generate k+1 length edgemers\nIterates through each record in graph.gprops[:records]\nFor each record, generates all possible overlapping edgemers\nAdds each edgemer to the graph with its position and record information\n\nReturns\n\nThe modified graph object with added edgemer information\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.amino_acids_to_codons-Tuple{}","page":"Home","title":"Mycelia.amino_acids_to_codons","text":"amino_acids_to_codons(\n\n) -> Dict{BioSymbols.AminoAcid, DataType}\n\n\nCreates a mapping from amino acids to representative DNA codons using the standard genetic code.\n\nReturns\n\nDictionary mapping each amino acid (including stop codon AA_Term) to a valid DNA codon that encodes it\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.annotate_aa_fasta-Tuple{}","page":"Home","title":"Mycelia.annotate_aa_fasta","text":"annotate_aa_fasta(\n;\n    fasta,\n    identifier,\n    basedir,\n    mmseqsdb,\n    threads\n)\n\n\nAnnotate amino acid sequences in a FASTA file using MMseqs2 search against UniRef50 database.\n\nArguments\n\nfasta: Path to input FASTA file containing amino acid sequences\nidentifier: Name for the output directory (defaults to FASTA filename without extension)\nbasedir: Base directory for output (defaults to current directory)\nmmseqsdb: Path to MMseqs2 formatted UniRef50 database (defaults to ~/workspace/mmseqs/UniRef50)\nthreads: Number of CPU threads to use (defaults to system thread count)\n\nReturns\n\nPath to the output directory containing MMseqs2 search results\n\nThe function creates a new directory named by identifier under basedir, copies the input FASTA file, and runs MMseqs2 easy-search against the specified database. If the output directory already exists, the function skips processing and returns the directory path.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.annotate_fasta-Tuple{}","page":"Home","title":"Mycelia.annotate_fasta","text":"annotate_fasta(\n;\n    fasta,\n    identifier,\n    basedir,\n    mmseqsdb,\n    threads\n)\n\n\nPerform comprehensive annotation of a FASTA file including gene prediction, protein homology search, and terminator prediction.\n\nArguments\n\nfasta::String: Path to input FASTA file\nidentifier::String: Unique identifier for output directory (default: FASTA filename without extension)\nbasedir::String: Base directory for output (default: current working directory)\nmmseqsdb::String: Path to MMseqs2 UniRef50 database (default: \"~/workspace/mmseqs/UniRef50\")\nthreads::Int: Number of CPU threads to use (default: all available)\n\nProcessing Steps\n\nCreates output directory and copies input FASTA\nRuns Prodigal for gene prediction (nucleotide, amino acid, and GFF output)\nPerforms MMseqs2 homology search against UniRef50\nPredicts terminators using TransTerm\nCombines annotations into a unified GFF file\nGenerates GenBank format output\n\nReturns\n\nString: Path to the output directory containing all generated files\n\nFiles Generated\n\n.prodigal.fna: Predicted genes (nucleotide)\n.prodigal.faa: Predicted proteins\n.prodigal.gff: Prodigal GFF annotations\n.gff: Combined annotations\n.gff.genbank: Final GenBank format\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_alignment-Tuple{Any, Any}","page":"Home","title":"Mycelia.assess_alignment","text":"assess_alignment(\n    a,\n    b\n) -> @NamedTuple{total_matches::Int64, total_edits::Int64}\n\n\nAligns two sequences using the Levenshtein distance and returns the total number of matches and edits.\n\nArguments\n\na::AbstractString: The first sequence to be aligned.\nb::AbstractString: The second sequence to be aligned.\n\nReturns\n\nNamedTuple{(:total_matches, :total_edits), Tuple{Int, Int}}: A named tuple containing:\ntotal_matches::Int: The total number of matching bases in the alignment.\ntotal_edits::Int: The total number of edits (insertions, deletions, substitutions) in the alignment.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_alignment_accuracy-Tuple{Any}","page":"Home","title":"Mycelia.assess_alignment_accuracy","text":"assess_alignment_accuracy(alignment_result) -> Any\n\n\nReturn proportion of matched bases in alignment to total matches + edits.\n\nCalculate the accuracy of a sequence alignment by computing the ratio of matched bases  to total alignment operations (matches + edits).\n\nArguments\n\nalignment_result: Alignment result object containing total_matches and total_edits fields\n\nReturns\n\nFloat64 between 0.0 and 1.0 representing alignment accuracy, where:\n\n1.0 indicates perfect alignment (all matches)\n0.0 indicates no matches\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_assembly_quality-Tuple{}","page":"Home","title":"Mycelia.assess_assembly_quality","text":"assess_assembly_quality(; assembly, observations, ks)\n\n\nEvaluate genome assembly quality by comparing k-mer distributions between assembled sequences and raw observations.\n\nArguments\n\nassembly: Input assembled sequences to evaluate\nobservations: Raw sequencing data for comparison\nks::Vector{Int}: Vector of k-mer sizes to analyze (default: k=17 to 23)\n\nReturns\n\nDataFrame containing quality metrics for each k-mer size:\n\nk: K-mer length used\ncosine_distance: Cosine similarity between k-mer distributions\njs_divergence: Jensen-Shannon divergence between distributions  \nqv: MerQury-style quality value score\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_dnamer_saturation-Tuple{AbstractString}","page":"Home","title":"Mycelia.assess_dnamer_saturation","text":"assess_dnamer_saturation(\n    fastx::AbstractString;\n    power,\n    outdir,\n    min_k,\n    max_k,\n    threshold,\n    kmers_to_assess\n)\n\n\nAnalyzes k-mer saturation in a FASTA/FASTQ file to determine optimal k-mer size.\n\nArguments\n\nfastx::AbstractString: Path to input FASTA/FASTQ file\npower::Int=10: Exponent for downsampling k-mers (2^power)\noutdir::String=\"\": Output directory for results. Uses current directory if empty\nmin_k::Int=3: Minimum k-mer size to evaluate\nmax_k::Int=17: Maximum k-mer size to evaluate\nthreshold::Float64=0.1: Saturation threshold for k-mer assessment\nkmers_to_assess::Int=10_000_000: Maximum number of k-mers to sample\n\nReturns\n\nDict{Int,Float64}: Dictionary mapping k-mer sizes to their saturation scores\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_dnamer_saturation-Tuple{AbstractVector{<:AbstractString}, Any}","page":"Home","title":"Mycelia.assess_dnamer_saturation","text":"assess_dnamer_saturation(\n    fastxs::AbstractVector{<:AbstractString},\n    kmer_type;\n    kmers_to_assess,\n    power,\n    min_count\n) -> Union{@NamedTuple{sampling_points::Vector{Int64}, unique_kmer_counts::Vector{Int64}}, NamedTuple{(:sampling_points, :unique_kmer_counts, :eof), <:Tuple{Vector, Vector{Int64}, Bool}}}\n\n\nAssess k-mer saturation in DNA sequences from FASTX files.\n\nArguments\n\nfastxs::AbstractVector{<:AbstractString}: Vector of paths to FASTA/FASTQ files\nkmer_type: Type of k-mer to analyze (e.g., DNAKmer{21})\nkmers_to_assess=Inf: Maximum number of k-mers to process\npower=10: Base for exponential sampling intervals\nmin_count=1: Minimum count threshold for considering a k-mer\n\nReturns\n\nNamed tuple containing:\n\nsampling_points::Vector{Int}: K-mer counts at which samples were taken\nunique_kmer_counts::Vector{Int}: Number of unique canonical k-mers at each sampling point\neof::Bool: Whether the entire input was processed\n\nDetails\n\nAnalyzes k-mer saturation by counting unique canonical k-mers at exponentially spaced  intervals (powers of power). Useful for assessing sequence complexity and coverage. Returns early if all possible k-mers are observed.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_dnamer_saturation-Tuple{AbstractVector{<:AbstractString}}","page":"Home","title":"Mycelia.assess_dnamer_saturation","text":"assess_dnamer_saturation(\n    fastxs::AbstractVector{<:AbstractString};\n    power,\n    outdir,\n    min_k,\n    max_k,\n    threshold,\n    kmers_to_assess,\n    plot\n)\n\n\nAnalyze k-mer saturation in DNA sequences to determine optimal k value.\n\nArguments\n\nfastxs: Vector of paths to FASTA/FASTQ files to analyze\npower: Base of logarithmic sampling points (default: 10)\noutdir: Optional output directory for plots and results\nmin_k: Minimum k-mer size to test (default: 7)\nmax_k: Maximum k-mer size to test (default: 17)\nthreshold: Saturation threshold to determine optimal k (default: 0.1)\nkmers_to_assess: Maximum number of k-mers to sample (default: 10M)\nplot: Whether to generate saturation curves (default: true)\n\nReturns\n\nInteger representing the first k value that achieves saturation below threshold. If no k value meets the threshold, returns the k with minimum saturation.\n\nDetails\n\nTests only prime k values between mink and maxk\nGenerates saturation curves using logarithmic sampling\nFits curves to estimate maximum unique k-mers\nIf outdir is provided, saves plots as SVG and chosen k value to text file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.assess_optimal_kmer_alignment-Tuple{Any, Any}","page":"Home","title":"Mycelia.assess_optimal_kmer_alignment","text":"assess_optimal_kmer_alignment(\n    kmer,\n    observed_kmer\n) -> Tuple{@NamedTuple{total_matches::Int64, total_edits::Int64}, Union{Missing, Bool}}\n\n\nUsed to determine which orientation provides an optimal alignment for initiating path likelihood analyses in viterbi analysis\n\nCompare alignment scores between a query k-mer and an observed k-mer in both forward and reverse complement orientations to determine optimal alignment.\n\nArguments\n\nkmer: Query k-mer sequence to align\nobserved_kmer: Target k-mer sequence to align against\n\nReturns\n\nA tuple containing:\n\nalignment_result: The alignment result object for the optimal orientation\norientation: Boolean indicating orientation (true = forward, false = reverse complement, missing = tied scores)\n\nDetails\n\nPerforms pairwise alignment in both orientations using assess_alignment()\nCalculates accuracy scores using assess_alignment_accuracy()\nFor tied alignment scores, randomly selects one orientation\nUses BioSequences.reverse_complement for reverse orientation comparison\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.bam_to_fastq-Tuple{}","page":"Home","title":"Mycelia.bam_to_fastq","text":"bam_to_fastq(; bam, fastq)\n\n\nConvert a BAM file to FASTQ format with gzip compression.\n\nArguments\n\nbam: Path to input BAM file\nfastq: Optional output path. Defaults to input path with \".fq.gz\" extension\n\nReturns\n\nPath to the generated FASTQ file\n\nDetails\n\nUses samtools through conda environment\nAutomatically skips if output file exists\nOutput is gzip compressed\nRequires samtools to be available via conda\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.bandage_visualize-Tuple{}","page":"Home","title":"Mycelia.bandage_visualize","text":"bandage_visualize(; gfa, img)\n\n\nGenerate a visualization of a genome assembly graph using Bandage.\n\nArguments\n\ngfa: Path to input GFA (Graphical Fragment Assembly) file\nimg: Optional output image path. Defaults to GFA filename with .png extension\n\nReturns\n\nPath to the generated image file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.biosequences_to_counts_table-Tuple{}","page":"Home","title":"Mycelia.biosequences_to_counts_table","text":"biosequences_to_counts_table(; biosequences, k)\n\n\nConvert a collection of biological sequences into a k-mer count matrix.\n\nArguments\n\nbiosequences: Vector of biological sequences (DNA, RNA, or Amino Acids)\nk: Length of k-mers to count\n\nReturns\n\nNamed tuple with:\n\nsorted_kmers: Vector of all unique k-mers found, lexicographically sorted\nkmer_counts_matrix: Sparse matrix where rows are k-mers and columns are sequences\n\nDetails\n\nFor DNA sequences, counts canonical k-mers (both strands)\nUses parallel processing with Thread-safe progress tracking\nMemory efficient sparse matrix representation\nSupports DNA, RNA and Amino Acid sequences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.biosequences_to_dense_counts_table-Tuple{}","page":"Home","title":"Mycelia.biosequences_to_dense_counts_table","text":"biosequences_to_dense_counts_table(; biosequences, k)\n\n\nConvert a collection of biological sequences into a dense k-mer count matrix.\n\nArguments\n\nbiosequences: Collection of DNA, RNA, or amino acid sequences (BioSequence types)\nk::Integer: Length of k-mers to count (must be ≤ 13)\n\nReturns\n\nNamed tuple containing:\n\nsorted_kmers: Vector of all possible k-mers in sorted order\nkmer_counts_matrix: Dense matrix where rows are k-mers and columns are sequences\n\nDetails\n\nFor DNA sequences, counts canonical k-mers (both strands)\nFor RNA and protein sequences, counts exact k-mers\nUses parallel processing with threads\nFor k > 13, use fasta_list_to_sparse_counts_table instead\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.blastdb2table-Tuple{}","page":"Home","title":"Mycelia.blastdb2table","text":"blastdb2table(; blastdb, outfile, force)\n\n\nConvert a BLAST database to a tabular format with sequence and taxonomy information.\n\nArguments\n\nblastdb::String: Path to the BLAST database\noutfile::String=\"\": Output file path. If empty, generates name based on input database\nforce::Bool=false: Whether to overwrite existing output file\n\nReturns\n\nString: Path to the generated output file (.tsv.gz)\n\nOutput Format\n\nTab-separated file containing columns:\n\nsequence SHA256\nsequence\naccession\ngi\nordinal id\nsequence id\nsequence title\nsequence length\nsequence hash\ntaxid\nleaf-node taxids\nmembership integer\ncommon taxonomic name\ncommon taxonomic names for leaf-node taxids\nscientific name\nscientific names for leaf-node taxids\nBLAST name\ntaxonomic super kingdom\nPIG\n\nDependencies\n\nRequires NCBI BLAST+ and perl-doc packages. May need sudo privileges for installation.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.blastdb_to_fasta-Tuple{}","page":"Home","title":"Mycelia.blastdb_to_fasta","text":"blastdb_to_fasta(; db, dbdir, compressed, outfile)\n\n\nConvert a BLAST database to FASTA format.\n\nArguments\n\ndb::String: Name of the BLAST database to convert (e.g. \"nr\", \"nt\")\ndbdir::String: Directory containing the BLAST database files\ncompressed::Bool: Whether to gzip compress the output file\noutfile::String: Path for the output FASTA file\n\nReturns\n\nPath to the generated FASTA file as String\n\nNotes\n\nFor \"nr\" database, output extension will be .faa.gz (protein)\nFor \"nt\" database, output extension will be .fna.gz (nucleotide)\nRequires ncbi-blast+ and perl-doc packages to be installed\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.build_directed_kmer_graph-Tuple{}","page":"Home","title":"Mycelia.build_directed_kmer_graph","text":"build_directed_kmer_graph(; fastq, k, plot)\n\n\nConstructs a directed graph representation of k-mer transitions from FASTQ sequencing data.\n\nArguments\n\nfastq: Path to input FASTQ file\nk: K-mer size (default: 1). Must be odd and prime. If k=1, optimal size is auto-determined\nplot: Boolean to display quality distribution plot (default: false)\n\nReturns\n\nMetaDiGraph with properties:\n\nassembly_k: k-mer size used\nkmer_counts: frequency of each k-mer\ntransition_likelihoods: edge weights between k-mers\nkmermeanquality, kmertotalquality: quality metrics\nbranchingnodes, unbranchingnodes: topological classification\nlikelyvalidkmer_indices: k-mers above mean quality threshold\nlikelysequencingartifact_indices: potential erroneous k-mers\n\nNote\n\nFor DNA assembly, quality scores are normalized across both strands.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.build_stranded_kmer_graph-Tuple{Any, AbstractVector{<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}}","page":"Home","title":"Mycelia.build_stranded_kmer_graph","text":"build_stranded_kmer_graph(\n    kmer_type,\n    observations::AbstractVector{<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}\n) -> MetaGraphs.MetaDiGraph{T, Float64} where T<:Integer\n\n\nCreate a weighted, strand-specific kmer (de bruijn) graph from a set of kmers and a series of sequence observations in FASTA format.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.canonicalize_kmer_counts!-Tuple{Any}","page":"Home","title":"Mycelia.canonicalize_kmer_counts!","text":"canonicalize_kmer_counts!(kmer_counts) -> Any\n\n\nCanonicalizes the k-mer counts in the given dictionary.\n\nThis function iterates over the provided dictionary kmer_counts, which maps k-mers to their respective counts. For each k-mer that is not in its canonical form, it converts the k-mer to its canonical form and updates the count in the dictionary accordingly. If the canonical form of the k-mer already exists in the dictionary, their counts are summed. The original non-canonical k-mer is then removed from the dictionary.\n\nArguments\n\nkmer_counts::Dict{BioSequences.Kmer, Int}: A dictionary where keys are k-mers and values are their counts.\n\nReturns\n\nThe input dictionary kmer_counts with all k-mers in their canonical form, sorted by k-mers.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.canonicalize_kmer_counts-Tuple{Any}","page":"Home","title":"Mycelia.canonicalize_kmer_counts","text":"canonicalize_kmer_counts(kmer_counts) -> Any\n\n\nNormalize k-mer counts into a canonical form by creating a non-mutating copy.\n\nArguments\n\nkmer_counts: Dictionary or collection of k-mer count data\n\nReturns\n\nA new normalized k-mer count collection\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.chromosome_coverage_table_to_plot-Tuple{Any}","page":"Home","title":"Mycelia.chromosome_coverage_table_to_plot","text":"chromosome_coverage_table_to_plot(cdf) -> Plots.Plot\n\n\nCreates a visualization of chromosome coverage data with statistical thresholds.\n\nArguments\n\ncdf::DataFrame: Coverage data frame containing columns:\nindex: Chromosome position indices\ndepth: Coverage depth values\nchromosome: Chromosome identifier\nmean_coverage: Mean coverage value\nstd_coverage: Standard deviation of coverage\n3σ: Boolean vector indicating +3 sigma regions\n-3σ: Boolean vector indicating -3 sigma regions\n\nReturns\n\nA StatsPlots plot object showing:\nRaw coverage data (black line)\nMean coverage and ±1,2,3σ thresholds (rainbow colors)\nHighlighted regions exceeding ±3σ thresholds (red vertical lines)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.codon_optimize-Tuple{}","page":"Home","title":"Mycelia.codon_optimize","text":"codon_optimize(\n;\n    normalized_codon_frequencies,\n    protein_sequence,\n    n_iterations\n)\n\n\nOptimizes the DNA sequence encoding for a given protein sequence using codon usage frequencies.\n\nArguments\n\nnormalized_codon_frequencies: Dictionary mapping amino acids to their codon frequencies\nprotein_sequence::BioSequences.LongAA: Target protein sequence to optimize\nn_iterations::Integer: Number of optimization iterations to perform\n\nAlgorithm\n\nCreates initial DNA sequence through reverse translation\nIteratively generates new sequences by sampling codons based on their frequencies\nKeeps track of the sequence with highest codon usage likelihood\n\nReturns\n\nBioSequences.LongDNA{2}: Optimized DNA sequence encoding the input protein\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.codons_to_amino_acids-Tuple{}","page":"Home","title":"Mycelia.codons_to_amino_acids","text":"codons_to_amino_acids(\n\n) -> Union{Dict{_A, BioSequences.LongAA} where _A, Dict{_A, V} where {_A, V<:(Kmers.Kmer{BioSequences.AminoAcidAlphabet, _A, _B} where {_B, _A})}}\n\n\nCreates a mapping between DNA codons and their corresponding amino acids using the standard genetic code.\n\nReturns a dictionary where:\n\nKeys are 3-letter DNA codons (e.g., \"ATG\")\nValues are the corresponding amino acids from BioSequences.jl\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.concatenate_files-Tuple{}","page":"Home","title":"Mycelia.concatenate_files","text":"concatenate_files(; files, file)\n\n\nJoin fasta files without any regard to record uniqueness.\n\nA cross-platform version of cat *.fasta > joint.fasta\n\nSee mergefastafiles\n\nConcatenate multiple FASTA files into a single output file by simple appending.\n\nArguments\n\nfiles: Vector of paths to input FASTA files\nfile: Path where the concatenated output will be written\n\nReturns\n\nPath to the output concatenated file\n\nDetails\n\nPlatform-independent implementation of cat *.fasta > combined.fasta. Files are processed sequentially with a progress indicator.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.contig_is_circular-Tuple{String, String}","page":"Home","title":"Mycelia.contig_is_circular","text":"contig_is_circular(\n    graph_file::String,\n    contig_name::String\n) -> Any\n\n\nReturns bool indicating whether the contig is a circle\n\ngraphfile = path to assembly graph.gfa file contigname = name of the contig\n\nDetermine if a contig represents a circular structure in the assembly graph.\n\nA circular contig is one where the sequence forms a complete loop in the assembly graph, typically representing structures like plasmids, circular chromosomes, or other circular DNA elements.\n\nArguments\n\ngraph_file::String: Path to the assembly graph in GFA format\ncontig_name::String: Name/identifier of the contig to check\n\nReturns\n\nBool: true if the contig forms a circular structure, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.contig_is_cleanly_assembled-Tuple{String, String}","page":"Home","title":"Mycelia.contig_is_cleanly_assembled","text":"contig_is_cleanly_assembled(\n    graph_file::String,\n    contig_name::String\n) -> Bool\n\n\nReturns bool indicating whether the contig is cleanly assembled.\n\nBy cleanly assembled we mean that the contig does not have other contigs attached in the same connected component.\n\ngraphfile = path to assembly graph.gfa file contigname = name of the contig\n\nCheck if a contig exists in isolation within its connected component in an assembly graph.\n\nArguments\n\ngraph_file::String: Path to the assembly graph file in GFA format\ncontig_name::String: Name/identifier of the contig to check\n\nReturns\n\nBool: true if the contig exists alone in its connected component, false otherwise\n\nDetails\n\nA contig is considered \"cleanly assembled\" if it appears as a single entry in the  assembly graph's connected components. This function parses the GFA file and checks the contig's isolation status using the graph structure.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.convert-Tuple{Any}","page":"Home","title":"Mycelia.convert","text":"convert(args)\n\n\nConvert between different graph file formats.\n\nArguments\n\nargs: Dictionary with required keys:\n\"in\": Input filepath (supported: .jld2, .gfa, .neo4j)\n\"out\": Output filepath (supported: .jld2, .gfa, .neo4j)\n\nDetails\n\nPerforms format conversion based on file extensions. For non-JLD2 to non-JLD2 conversions, uses JLD2 as an intermediate format.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.convert_sequence-Tuple{AbstractString}","page":"Home","title":"Mycelia.convert_sequence","text":"convert_sequence(seq::AbstractString) -> Any\n\n\nConverts the given sequence (output from FASTX.sequence) into the appropriate BioSequence type:\n\nDNA sequences are converted using BioSequences.LongDNA\nRNA sequences are converted using BioSequences.LongRNA\nAA sequences are converted using BioSequences.LongAA\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.copy_to_tempdir-Tuple{String}","page":"Home","title":"Mycelia.copy_to_tempdir","text":"copy_to_tempdir(file_path::String) -> String\n\n\nCreate a copy of a file in a temporary directory while preserving the original filename.\n\nArguments\n\nfile_path::String: Path to the source file to be copied\n\nReturns\n\nString: Path to the newly created temporary file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.copy_with_unique_identifier-Tuple{Any, Any, Any}","page":"Home","title":"Mycelia.copy_with_unique_identifier","text":"copy_with_unique_identifier(\n    infile,\n    out_directory,\n    unique_identifier;\n    force\n) -> Any\n\n\nCopy a file to a new location with a unique identifier prepended to the filename.\n\nArguments\n\ninfile::AbstractString: Path to the source file to copy\nout_directory::AbstractString: Destination directory for the copied file\nunique_identifier::AbstractString: String to prepend to the filename\nforce::Bool=true: If true, overwrite existing files\n\nReturns\n\nString: Path to the newly created file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_canonical_kmers-Union{Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, Any}} where KMER_TYPE","page":"Home","title":"Mycelia.count_canonical_kmers","text":"count_canonical_kmers(_::Type{KMER_TYPE}, sequences) -> Any\n\n\nCount canonical k-mers in biological sequences. A canonical k-mer is the lexicographically  smaller of a DNA sequence and its reverse complement, ensuring strand-independent counting.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer size and structure\nsequences: Iterator of biological sequences to analyze\n\nReturns\n\nDict{KMER_TYPE,Int}: Dictionary mapping canonical k-mers to their counts\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, AbstractString}} where KMER_TYPE","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    fastx_file::AbstractString\n) -> Any\n\n\nCount k-mers in a FASTA/FASTQ file and return their frequencies.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer type (e.g., DNAKmer{K})\nfastx_file: Path to input FASTA/FASTQ file\n\nReturns\n\nDict{KMER_TYPE, Int}: Dictionary mapping each k-mer to its frequency\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{K}, Tuple{A}, Tuple{Type{Kmers.Mer{K, A}}, BioSequences.LongSequence}} where {A<:BioSequences.AminoAcidAlphabet, K}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.AminoAcidAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> OrderedCollections.OrderedDict{K, Int64} where K<:(Kmers.Kmer{BioSequences.AminoAcidAlphabet, _A, _B} where {_B, _A})\n\n\nCount the frequency of amino acid k-mers in a biological sequence.\n\nArguments\n\nKmers.Kmer{A,K}: Type parameter specifying amino acid alphabet (A) and k-mer length (K)\nsequence: Input biological sequence to analyze\n\nReturns\n\nA sorted dictionary mapping each k-mer to its frequency count in the sequence.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{K}, Tuple{A}, Tuple{Type{Kmers.Mer{K, A}}, BioSequences.LongSequence}} where {A<:BioSequences.DNAAlphabet, K}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.DNAAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> Any\n\n\nCount the frequency of each k-mer in a DNA sequence.\n\nArguments\n\n::Type{Kmers.Kmer{A,K}}: K-mer type with alphabet A and length K\nsequence::BioSequences.LongSequence: Input DNA sequence to analyze\n\nReturns\n\nA sorted dictionary mapping each k-mer to its frequency count in the sequence.\n\nType Parameters\n\nA <: BioSequences.DNAAlphabet: DNA alphabet type\nK: Length of k-mers\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{K}, Tuple{A}, Tuple{Type{Kmers.Mer{K, A}}, BioSequences.LongSequence}} where {A<:BioSequences.RNAAlphabet, K}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{Kmers.Kmer{A<:BioSequences.RNAAlphabet, K}},\n    sequence::BioSequences.LongSequence\n) -> Any\n\n\nCount the frequency of each k-mer in an RNA sequence.\n\nArguments\n\nKmer: Type parameter specifying the k-mer length K and RNA alphabet\nsequence: Input RNA sequence to analyze\n\nReturns\n\nDict{Kmers.Kmer, Int}: Sorted dictionary mapping each k-mer to its frequency count\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{R}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, R}} where {KMER_TYPE, R<:Union{FASTX.FASTA.Reader, FASTX.FASTQ.Reader}}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    sequences::Union{FASTX.FASTA.Reader, FASTX.FASTQ.Reader}\n) -> Any\n\n\nCounts k-mer occurrences in biological sequences from a FASTA/FASTQ reader.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer length and encoding (e.g., DNAKmer{4} for 4-mers)\nsequences: A FASTA or FASTQ reader containing the biological sequences to analyze\n\nReturns\n\nA dictionary mapping k-mers to their counts in the input sequences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{R}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, R}} where {KMER_TYPE, R<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    record::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}\n) -> Any\n\n\nCount the frequency of amino acid k-mers in a biological sequence.\n\nArguments\n\nKmers.Kmer{A,K}: Type parameter specifying amino acid alphabet (A) and k-mer length (K)\nsequence: Input biological sequence to analyze\n\nReturns\n\nA sorted dictionary mapping each k-mer to its frequency count in the sequence.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{T}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, AbstractVector{T}}} where {KMER_TYPE, T<:AbstractString}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    fastx_files::AbstractArray{T<:AbstractString, 1}\n) -> Any\n\n\nCount k-mers across multiple FASTA/FASTQ files and merge the results.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer length (e.g., DNAKmer{4} for 4-mers)\nfastx_files: Vector of paths to FASTA/FASTQ files\n\nReturns\n\nDict{KMER_TYPE, Int}: Dictionary mapping k-mers to their total counts across all files\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_kmers-Union{Tuple{T}, Tuple{KMER_TYPE}, Tuple{Type{KMER_TYPE}, AbstractVector{T}}} where {KMER_TYPE, T<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.count_kmers","text":"count_kmers(\n    _::Type{KMER_TYPE},\n    records::AbstractArray{T<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}, 1}\n) -> Any\n\n\nCount k-mers across multiple sequence records and return a sorted frequency table.\n\nArguments\n\nKMER_TYPE: Type parameter specifying the k-mer length (e.g., DNAKmer{3} for 3-mers)\nrecords: Vector of FASTA/FASTQ records to analyze\n\nReturns\n\nDict{KMER_TYPE, Int}: Sorted dictionary mapping k-mers to their frequencies\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_matrix_to_probability_matrix-Tuple{Any}","page":"Home","title":"Mycelia.count_matrix_to_probability_matrix","text":"count_matrix_to_probability_matrix(counts_matrix) -> Any\n\n\nConvert a matrix of counts into a probability matrix by normalizing each column to sum to 1.0.\n\nArguments\n\ncounts_matrix::Matrix{<:Number}: Input matrix where each column represents counts/frequencies\n\nReturns\n\nMatrix{Float64}: Probability matrix where each column sums to 1.0\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.count_records-Tuple{Any}","page":"Home","title":"Mycelia.count_records","text":"count_records(fastx) -> Int64\n\n\nCounts the total number of records in a FASTA/FASTQ file.\n\nArguments\n\nfastx: Path to a FASTA or FASTQ file (can be gzipped)\n\nReturns\n\nNumber of records (sequences) in the file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.countmap_columns-Tuple{Any}","page":"Home","title":"Mycelia.countmap_columns","text":"countmap_columns(table)\n\n\nGenerate and display frequency counts for all columns in a DataFrame.\n\nArguments\n\ntable::DataFrame: Input DataFrame to analyze\n\nDetails\n\nIterates through each column in the DataFrame and displays:\n\nThe column name\nA Dict mapping unique values to their frequencies using StatsBase.countmap\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_database-Tuple{}","page":"Home","title":"Mycelia.create_database","text":"create_database(; database, address, username, password)\n\n\nCreates a new Neo4j database instance if it doesn't already exist.\n\nArguments\n\ndatabase::String: Name of the database to create\naddress::String: Neo4j server address (e.g. \"neo4j://localhost:7687\")\nusername::String: Neo4j authentication username (defaults to \"neo4j\")\npassword::String: Neo4j authentication password\n\nNotes\n\nRequires system database privileges to execute\nSilently returns if database already exists\nTemporarily switches to system database to perform creation\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_node_constraints-Tuple{Any}","page":"Home","title":"Mycelia.create_node_constraints","text":"create_node_constraints(\n    graph;\n    address,\n    username,\n    password,\n    database\n)\n\n\nCreates unique identifier constraints for each node type in a Neo4j database.\n\nArguments\n\ngraph: A MetaGraph containing nodes with TYPE properties\naddress: Neo4j server address\nusername: Neo4j username (default: \"neo4j\")\npassword: Neo4j password\ndatabase: Neo4j database name (default: \"neo4j\")\n\nDetails\n\nExtracts unique node types from the graph and creates Neo4j constraints ensuring each node of a given type has a unique identifier property.\n\nFailed constraint creation attempts are silently skipped.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.create_tarchive-Tuple{}","page":"Home","title":"Mycelia.create_tarchive","text":"create_tarchive(; directory, tarchive)\n\n\nCreates a gzipped tar archive of the specified directory along with verification files.\n\nArguments\n\ndirectory: Source directory path to archive\ntarchive: Optional output archive path (defaults to directory name with .tar.gz extension)\n\nGenerated Files\n\n{tarchive}: The compressed tar archive\n{tarchive}.log: Contents listing of the archive\n{tarchive}.hashdeep.dfxml: Cryptographic hashes (MD5, SHA1, SHA256) of the archive\n\nReturns\n\nPath to the created tar archive file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.cypher-Tuple{Any}","page":"Home","title":"Mycelia.cypher","text":"cypher(\n    cmd;\n    address,\n    username,\n    password,\n    format,\n    database\n) -> Cmd\n\n\nConstructs a command to execute Neo4j Cypher queries via cypher-shell.\n\nArguments\n\ncmd: The Cypher query command to execute\naddress::String=\"neo4j://localhost:7687\": Neo4j server address\nusername::String=\"neo4j\": Neo4j authentication username\npassword::String=\"password\": Neo4j authentication password \nformat::String=\"auto\": Output format (auto, verbose, or plain)\ndatabase::String=\"neo4j\": Target Neo4j database name\n\nReturns\n\nCmd: A command object ready for execution\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.deduplicate_fasta_file-Tuple{Any, Any}","page":"Home","title":"Mycelia.deduplicate_fasta_file","text":"deduplicate_fasta_file(in_fasta, out_fasta) -> Any\n\n\nRemove duplicate sequences from a FASTA file while preserving headers.\n\nArguments\n\nin_fasta: Path to input FASTA file\nout_fasta: Path where deduplicated FASTA will be written\n\nReturns\n\nPath to the output FASTA file (same as out_fasta parameter)\n\nDetails\n\nSequences are considered identical if they match exactly (case-sensitive)\nFor duplicate sequences, keeps the first header encountered\nInput sequences are sorted by identifier before deduplication\nPreserves the original sequence formatting\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.detect_alphabet-Tuple{AbstractString}","page":"Home","title":"Mycelia.detect_alphabet","text":"detect_alphabet(seq::AbstractString) -> Symbol\n\n\nDetermines the alphabet of a sequence. The function scans through seq only once:\n\nIf a 'T' or 't' is found (and no 'U/u'), the sequence is classified as DNA.\nIf a 'U' or 'u' is found (and no 'T/t'), it is classified as RNA.\nIf both T and U occur, an error is thrown.\nIf a character outside the canonical nucleotide and ambiguity codes is encountered, the sequence is assumed to be protein.\nIf neither T nor U are found, the sequence is assumed to be DNA.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.detect_sequence_extension-Tuple{Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}}","page":"Home","title":"Mycelia.detect_sequence_extension","text":"detect_sequence_extension(\n    record::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}\n) -> String\n\n\nDetect sequence type from input and suggest appropriate file extension.\n\nArguments\n\nrecord: A FASTA/FASTQ record\nsequence: A string or BioSequence containing sequence data\n\nReturns\n\nString: Suggested file extension:\n\".fna\" for DNA\n\".frn\" for RNA\n\".faa\" for protein\n\".fa\" for unrecognized sequences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_fasta_coverage-Tuple{Any}","page":"Home","title":"Mycelia.determine_fasta_coverage","text":"determine_fasta_coverage(bam) -> Any\n\n\nCalculate per-base genomic coverage from a BAM file using bedtools.\n\nArguments\n\nbam::String: Path to input BAM file\n\nReturns\n\nString: Path to the generated coverage file (.coverage.txt)\n\nDetails\n\nUses bedtools genomecov to compute per-base coverage. Creates a coverage file  with the format: <chromosome> <position> <coverage_depth>.  If the coverage file already exists, returns the existing file path.\n\nDependencies\n\nRequires bedtools (automatically installed in conda environment)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_max_canonical_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.determine_max_canonical_kmers","text":"determine_max_canonical_kmers(k, ALPHABET) -> Any\n\n\nCalculate the maximum number of possible canonical k-mers for a given alphabet.\n\nArguments\n\nk::Integer: Length of k-mer\nALPHABET::Vector{Char}: Character set (nucleotides or amino acids)\n\nReturns\n\nInt: Maximum number of possible canonical k-mers\n\nDetails\n\nFor amino acids (AA_ALPHABET): returns total possible k-mers\nFor nucleotides: returns half of total possible k-mers (canonical form)\nRequires odd k-mer length for nucleotide alphabets\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_max_possible_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.determine_max_possible_kmers","text":"determine_max_possible_kmers(k, ALPHABET) -> Any\n\n\nCalculate the total number of possible unique k-mers that can be generated from a given alphabet.\n\nArguments\n\nk: Length of k-mers to consider\nALPHABET: Vector containing the allowed characters/symbols\n\nReturns\n\nInteger representing the maximum number of possible unique k-mers (|Σ|ᵏ)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_primary_contig-Tuple{Any}","page":"Home","title":"Mycelia.determine_primary_contig","text":"determine_primary_contig(qualimap_results) -> Any\n\n\nDetermines the contig with the greatest number of total bases mapping to it\n\nIdentify the primary contig based on mapping coverage from Qualimap results.\n\nArguments\n\nqualimap_results::DataFrame: DataFrame containing Qualimap alignment statistics with  columns \"Contig\" and \"Mapped bases\"\n\nReturns\n\nString: Name of the contig with the highest number of mapped bases\n\nDescription\n\nTakes Qualimap alignment results and determines which contig has the most total bases  mapped to it, which often indicates the main chromosomal assembly.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.determine_read_lengths-Tuple{Any}","page":"Home","title":"Mycelia.determine_read_lengths","text":"determine_read_lengths(\n    fastq_file;\n    total_reads\n) -> Vector{Int64}\n\n\nCalculate sequence lengths for reads in a FASTQ file.\n\nArguments\n\nfastq_file::String: Path to input FASTQ file\ntotal_reads::Integer=Inf: Number of reads to process (defaults to all reads)\n\nReturns\n\nVector{Int}: Array containing the length of each sequence read\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.distance_matrix_to_newick-Tuple{}","page":"Home","title":"Mycelia.distance_matrix_to_newick","text":"distance_matrix_to_newick(\n;\n    distance_matrix,\n    labels,\n    outfile\n)\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\nConvert a distance matrix into a Newick tree format using UPGMA hierarchical clustering.\n\nArguments\n\ndistance_matrix: Square matrix of pairwise distances between entities\nlabels: Vector of labels corresponding to the entities in the distance matrix\noutfile: Path where the Newick tree file will be written\n\nReturns\n\nPath to the generated Newick tree file\n\nDetails\n\nPerforms hierarchical clustering using the UPGMA (average linkage) method and  converts the resulting dendrogram into Newick tree format. The branch lengths  in the tree represent the heights from the clustering.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.document_frequency-Tuple{Any}","page":"Home","title":"Mycelia.document_frequency","text":"document_frequency(documents) -> Dict{_A, Int64} where _A\n\n\nCalculate the document frequency of tokens across a collection of documents.\n\nArguments\n\ndocuments: Collection of text documents where each document is a string\n\nReturns\n\nDictionary mapping each unique token to the number of documents it appears in\n\nDescription\n\nComputes how many documents contain each unique token. Each document is tokenized  by splitting on whitespace. Tokens are counted only once per document, regardless  of how many times they appear within that document.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_and_filter_sra_reads-Tuple{}","page":"Home","title":"Mycelia.download_and_filter_sra_reads","text":"download_and_filter_sra_reads(\n;\n    outdir,\n    srr_identifier\n) -> Union{Nothing, Bool}\n\n\nDownloads and quality filters paired-end reads from the Sequence Read Archive (SRA).\n\nArguments\n\noutdir::String: Output directory path for downloaded and processed files\nsrr_identifier::String: SRA run accession number (e.g., \"SRR12345678\")\n\nDetails\n\nDownloads paired-end FASTQ files using fasterq-dump\nPerforms quality trimming using trim_galore\nRemoves intermediate compressed FASTQ files after processing\n\nReturns\n\nNothing, but creates the following files in outdir:\n\ntrim_galore/[srr_identifier]_1_val_1.fq.gz: Trimmed forward reads\ntrim_galore/[srr_identifier]_2_val_2.fq.gz: Trimmed reverse reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_bandage","page":"Home","title":"Mycelia.download_bandage","text":"download_bandage() -> String\ndownload_bandage(outdir) -> Any\n\n\nDownloads and installs Bandage, a bioinformatics visualization tool for genome assembly graphs.\n\nArguments\n\noutdir=\"/usr/local/bin\": Target installation directory for the Bandage executable\n\nReturns\n\nPath to the installed Bandage executable\n\nDetails\n\nDownloads Bandage v0.8.1 for Ubuntu\nInstalls required system dependencies (libxcb-glx0, libx11-xcb-dev, libfontconfig, libgl1-mesa-glx)\nAttempts installation with sudo, falls back to root if sudo fails\nSkips download if Bandage is already installed at target location\n\nDependencies\n\nRequires system commands: wget, unzip, apt\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.download_blast_db-Tuple{}","page":"Home","title":"Mycelia.download_blast_db","text":"download_blast_db(; db, dbdir, source, wait)\n\n\nSmart downloading of blast dbs depending on interactive, non interactive context\n\nFor a list of all available databases, run: Mycelia.list_blastdbs()\n\nDownloads and sets up BLAST databases from various sources.\n\nArguments\n\ndb: Name of the BLAST database to download\ndbdir: Directory to store the downloaded database (default: \"~/workspace/blastdb\")\nsource: Download source - one of [\"\", \"aws\", \"gcp\", \"ncbi\"]. Empty string auto-detects fastest source\nwait: Whether to wait for download completion (default: true)\n\nReturns\n\nString path to the downloaded database directory\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_genome_by_accession-Tuple{}","page":"Home","title":"Mycelia.download_genome_by_accession","text":"download_genome_by_accession(\n;\n    accession,\n    outdir,\n    compressed\n)\n\n\nDownloads a genomic sequence from NCBI's nucleotide database by its accession number.\n\nArguments\n\naccession::String: NCBI nucleotide accession number (e.g. \"NC_045512\")\noutdir::String: Output directory path. Defaults to current directory\ncompressed::Bool: If true, compresses output file with gzip. Defaults to true\n\nReturns\n\nString: Path to the downloaded file (.fna or .fna.gz)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_genome_by_ftp-Tuple{}","page":"Home","title":"Mycelia.download_genome_by_ftp","text":"download_genome_by_ftp(; ftp, outdir)\n\n\nDownloads a genome file from NCBI FTP server to the specified directory.\n\nArguments\n\nftp::String: NCBI FTP path for the genome (e.g. \"ftp://ftp.ncbi.nlm.nih.gov/.../\")\noutdir::String: Output directory path. Defaults to current working directory.\n\nReturns\n\nString: Path to the downloaded file\n\nNotes\n\nIf the target file already exists, returns the existing file path without re-downloading\nDownloads the genomic.fna.gz version of the genome\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.download_mmseqs_db-Tuple{}","page":"Home","title":"Mycelia.download_mmseqs_db","text":"download_mmseqs_db(; db, dbdir, force, wait)\n\n\nDownloads and sets up MMseqs2 reference databases for sequence searching and analysis.\n\nArguments\n\ndb::String: Name of database to download (see table below)\ndbdir::String: Directory to store the downloaded database (default: \"~/workspace/mmseqs\")\nforce::Bool: If true, force re-download even if database exists (default: false)\nwait::Bool: If true, wait for download to complete (default: true)\n\nReturns\n\nPath to the downloaded database as a String\n\nAvailable Databases\n\nDatabase Type Taxonomy Description\nUniRef100 Aminoacid Yes UniProt Reference Clusters - 100% identity\nUniRef90 Aminoacid Yes UniProt Reference Clusters - 90% identity\nUniRef50 Aminoacid Yes UniProt Reference Clusters - 50% identity\nUniProtKB Aminoacid Yes Universal Protein Knowledge Base\nNR Aminoacid Yes NCBI Non-redundant proteins\nNT Nucleotide No NCBI Nucleotide collection\nGTDB Aminoacid Yes Genome Taxonomy Database\nPDB Aminoacid No Protein Data Bank structures\nPfam-A.full Profile No Protein family alignments\nSILVA Nucleotide Yes Ribosomal RNA database\n\n  Name                  Type            Taxonomy        Url                                                           \n- UniRef100             Aminoacid            yes        https://www.uniprot.org/help/uniref\n- UniRef90              Aminoacid            yes        https://www.uniprot.org/help/uniref\n- UniRef50              Aminoacid            yes        https://www.uniprot.org/help/uniref\n- UniProtKB             Aminoacid            yes        https://www.uniprot.org/help/uniprotkb\n- UniProtKB/TrEMBL      Aminoacid            yes        https://www.uniprot.org/help/uniprotkb\n- UniProtKB/Swiss-Prot  Aminoacid            yes        https://uniprot.org\n- NR                    Aminoacid            yes        https://ftp.ncbi.nlm.nih.gov/blast/db/FASTA\n- NT                    Nucleotide             -        https://ftp.ncbi.nlm.nih.gov/blast/db/FASTA\n- GTDB                  Aminoacid            yes        https://gtdb.ecogenomic.org\n- PDB                   Aminoacid              -        https://www.rcsb.org\n- PDB70                 Profile                -        https://github.com/soedinglab/hh-suite\n- Pfam-A.full           Profile                -        https://pfam.xfam.org\n- Pfam-A.seed           Profile                -        https://pfam.xfam.org\n- Pfam-B                Profile                -        https://xfam.wordpress.com/2020/06/30/a-new-pfam-b-is-released\n- CDD                   Profile                -        https://www.ncbi.nlm.nih.gov/Structure/cdd/cdd.shtml\n- eggNOG                Profile                -        http://eggnog5.embl.de\n- VOGDB                 Profile                -        https://vogdb.org\n- dbCAN2                Profile                -        http://bcb.unl.edu/dbCAN2\n- SILVA                 Nucleotide           yes        https://www.arb-silva.de\n- Resfinder             Nucleotide             -        https://cge.cbs.dtu.dk/services/ResFinder\n- Kalamari              Nucleotide           yes        https://github.com/lskatz/Kalamari\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.draw_dendrogram_tree-Tuple{MetaGraphs.MetaDiGraph}","page":"Home","title":"Mycelia.draw_dendrogram_tree","text":"draw_dendrogram_tree(\n    mg::MetaGraphs.MetaDiGraph;\n    width,\n    height,\n    fontsize,\n    margins,\n    mergenodesize,\n    lineweight,\n    filename\n) -> Luxor.Drawing\n\n\nDraw a dendrogram visualization of hierarchical clustering results stored in a MetaDiGraph.\n\nArguments\n\nmg::MetaGraphs.MetaDiGraph: Graph containing hierarchical clustering results. Must have :hcl in graph properties with clustering data and vertex properties containing :x, :y coordinates.\n\nKeywords\n\nwidth::Integer=500: Width of output image in pixels\nheight::Integer=500: Height of output image in pixels \nfontsize::Integer=12: Font size for node labels in points\nmargins::Float64: Margin size in pixels, defaults to min(width,height)/20\nmergenodesize::Float64=1: Size of circular nodes at merge points\nlineweight::Float64=1: Thickness of dendrogram lines\nfilename::String: Output filename, defaults to timestamp with .dendrogram.png extension\n\nReturns\n\nNothing, but saves dendrogram image to disk and displays preview.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.draw_radial_tree-Tuple{MetaGraphs.MetaDiGraph}","page":"Home","title":"Mycelia.draw_radial_tree","text":"draw_radial_tree(\n    mg::MetaGraphs.MetaDiGraph;\n    width,\n    height,\n    fontsize,\n    margins,\n    mergenodesize,\n    lineweight,\n    filename\n) -> Luxor.Drawing\n\n\nDraw a radial hierarchical clustering tree visualization and save it as an image file.\n\nArguments\n\nmg::MetaGraphs.MetaDiGraph: A meta directed graph containing hierarchical clustering data with required graph properties :hcl containing clustering information.\n\nKeywords\n\nwidth::Int=500: Width of the output image in pixels\nheight::Int=500: Height of the output image in pixels\nfontsize::Int=12: Font size for node labels\nmargins::Float64: Margin size (automatically calculated as min(width,height)/20)\nmergenodesize::Float64=1: Size of the merge point nodes\nlineweight::Float64=1: Thickness of the connecting lines\nfilename::String: Output filename (defaults to timestamp with \".radial.png\" suffix)\n\nDetails\n\nThe function creates a radial visualization of hierarchical clustering results where:\n\nLeaf nodes are arranged in a circle with labels\nInternal nodes represent merge points\nConnections show the hierarchical structure through arcs and lines\n\nThe visualization is saved as a PNG file and automatically previewed.\n\nRequired Graph Properties\n\nThe input graph must have:\n\nmg.gprops[:hcl].labels: Vector of leaf node labels\nmg.gprops[:hcl].order: Vector of ordered leaf nodes\nmg.gprops[:hcl].merges: Matrix of merge operations\nmg.vprops[v][:x]: X coordinate for each vertex\nmg.vprops[v][:y]: Y coordinate for each vertex\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.drop_empty_columns!-Tuple{DataFrames.AbstractDataFrame}","page":"Home","title":"Mycelia.drop_empty_columns!","text":"drop_empty_columns!(\n    df::DataFrames.AbstractDataFrame\n) -> DataFrames.AbstractDataFrame\n\n\nIdentify all columns that have only missing or empty values, and remove those columns from the dataframe in-place.\n\nReturns a modified version of the original dataframe. \n\nSee also: dropemptycolumns\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.drop_empty_columns-Tuple{DataFrames.AbstractDataFrame}","page":"Home","title":"Mycelia.drop_empty_columns","text":"drop_empty_columns(df::DataFrames.AbstractDataFrame) -> Any\n\n\nIdentify all columns that have only missing or empty values, and remove those columns from the dataframe.\n\nReturns a modified copy of the dataframe.\n\nSee also: dropemptycolumns!\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.edge_path_to_sequence-Tuple{Any, Any}","page":"Home","title":"Mycelia.edge_path_to_sequence","text":"edge_path_to_sequence(kmer_graph, edge_path) -> Any\n\n\nConverts a path of edges in a kmer graph into a DNA sequence by concatenating overlapping kmers.\n\nArguments\n\nkmer_graph: A directed graph where vertices represent kmers and edges represent overlaps\nedge_path: Vector of edges representing a path through the graph\n\nReturns\n\nA BioSequences.LongDNASeq containing the merged sequence represented by the path\n\nDetails\n\nThe function:\n\nTakes the first kmer from the source vertex of first edge\nFor each edge, handles orientation (forward/reverse complement)\nVerifies overlaps between consecutive kmers\nConcatenates unique bases to build final sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.edge_probability-Tuple{Any, Any}","page":"Home","title":"Mycelia.edge_probability","text":"edge_probability(stranded_kmer_graph, edge) -> Any\n\n\nCalculate the probability of traversing a specific edge in a stranded k-mer graph.\n\nThe probability is computed as the ratio of this edge's coverage weight to the sum of all outgoing edge weights from the source vertex.\n\nedge_probability(stranded_kmer_graph, edge) -> Any\n\n\nArguments\n\nstranded_kmer_graph: A directed graph where edges represent k-mer connections\nedge: The edge for which to calculate the probability\n\nReturns\n\nFloat64: Probability in range [0,1] representing likelihood of traversing this edge Returns 0.0 if sum of all outgoing edge weights is zero\n\nNote\n\nProbability is based on the :coverage property of edges, using their length as weights\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.edgemer_to_vertex_kmers-Tuple{Any}","page":"Home","title":"Mycelia.edgemer_to_vertex_kmers","text":"edgemer_to_vertex_kmers(\n    edgemer\n) -> Tuple{Kmers.Kmer{BioSequences.DNAAlphabet{2}}, Kmers.Kmer{BioSequences.DNAAlphabet{2}}}\n\n\nConvert an edgemer to two vertex kmers.\n\nThis function takes an edgemer (a sequence of DNA nucleotides) and converts it into two vertex kmers.  A kmer is a substring of length k from a DNA sequence. The first kmer is created from the first  n-1 elements of the edgemer, and the second kmer is created from the last n-1 elements of the edgemer.\n\nArguments\n\nedgemer::AbstractVector{T}: A vector of DNA nucleotides where T is a subtype of BioSequences.DNAAlphabet{2}.\n\nReturns\n\nTuple{Kmers.Kmer{BioSequences.DNAAlphabet{2}}, Kmers.Kmer{BioSequences.DNAAlphabet{2}}}: A tuple containing two kmers.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.equally_spaced_samples-Tuple{Any, Any}","page":"Home","title":"Mycelia.equally_spaced_samples","text":"equally_spaced_samples(vector, n) -> Any\n\n\nSample n equally spaced elements from vector.\n\nArguments\n\nvector: Input vector to sample from\nn: Number of samples to return (must be positive)\n\nReturns\n\nA vector containing n equally spaced elements from the input vector.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.equivalent_fasta_sequences-Tuple{Any, Any}","page":"Home","title":"Mycelia.equivalent_fasta_sequences","text":"equivalent_fasta_sequences(fasta_1, fasta_2) -> Bool\n\n\nCompare two FASTA files to determine if they contain the same set of sequences, regardless of sequence order.\n\nArguments\n\nfasta_1::String: Path to first FASTA file\nfasta_2::String: Path to second FASTA file\n\nReturns\n\nBool: true if both files contain exactly the same sequences, false otherwise\n\nDetails\n\nPerforms a set-based comparison of DNA sequences by hashing each sequence. Sequence order differences between files do not affect the result.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.error_rate_to_q_value-Tuple{Any}","page":"Home","title":"Mycelia.error_rate_to_q_value","text":"error_rate_to_q_value(error_rate) -> Any\n\n\nConvert a sequencing error probability to a Phred quality score (Q-value).\n\nThe calculation uses the standard Phred formula: Q = -10 * log₁₀(error_rate)\n\nArguments\n\nerror_rate::Float64: Probability of error (between 0 and 1)\n\nReturns\n\nq_value::Float64: Phred quality score\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.export_blast_db-Tuple{}","page":"Home","title":"Mycelia.export_blast_db","text":"export_blast_db(; path_to_db, fasta)\n\n\nExport sequences from a BLAST database to a gzipped FASTA file.\n\nArguments\n\npath_to_db: Path to the BLAST database\nfasta: Output path for the gzipped FASTA file (default: path_to_db * \".fna.gz\")\n\nDetails\n\nUses conda's BLAST environment to extract sequences using blastdbcmd. The output is automatically compressed using pigz. If the output file already exists, the function will skip extraction.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.export_blast_db_taxonomy_table-Tuple{}","page":"Home","title":"Mycelia.export_blast_db_taxonomy_table","text":"export_blast_db_taxonomy_table(; path_to_db, outfile)\n\n\nExports a taxonomy mapping table from a BLAST database in seqid2taxid format.\n\nArguments\n\npath_to_db::String: Path to the BLAST database\noutfile::String: Output file path (defaults to input path + \".seqid2taxid.txt.gz\")\n\nReturns\n\nString: Path to the created output file\n\nDetails\n\nCreates a compressed tab-delimited file mapping sequence IDs to taxonomy IDs. Uses blastdbcmd without GI identifiers for better cross-referencing compatibility. If the output file already exists, returns the path without regenerating.\n\nDependencies\n\nRequires BLAST+ tools installed via Bioconda.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.extract_pacbiosample_information-Tuple{Any}","page":"Home","title":"Mycelia.extract_pacbiosample_information","text":"extract_pacbiosample_information(\n    xml\n) -> DataFrames.DataFrame\n\n\nExtract biosample and barcode information from a PacBio XML metadata file.\n\nArguments\n\nxml: Path to PacBio XML metadata file\n\nReturns\n\nDataFrame with two columns:\n\nBioSampleName: Name of the biological sample\nBarcodeName: Associated DNA barcode identifier\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta2normalized_table-Tuple{Any}","page":"Home","title":"Mycelia.fasta2normalized_table","text":"fasta2normalized_table(\n    fasta_file;\n    normalize_name,\n    outfile,\n    force\n) -> Any\n\n\nConvert a FASTA file into a normalized tab-separated table format with standardized sequence identifiers.\n\nArguments\n\nfasta_file::String: Path to input FASTA file\noutfile::String: Path to output compressed TSV file (defaults to input filename + \".tsv.gz\")\nforce::Bool=false: If true, overwrites existing output file\n\nReturns\n\nString: Path to the created output file\n\nOutput Format\n\nCreates a gzipped TSV file with the following columns:\n\nfasta_identifier: Original FASTA filename\nsequence_sha256: SHA256 hash of the sequence\nsequence_identifier: Original sequence ID from FASTA\nsequence_description: Full sequence description from FASTA\nsequence: The actual sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_and_gff_to_genbank-Tuple{}","page":"Home","title":"Mycelia.fasta_and_gff_to_genbank","text":"fasta_and_gff_to_genbank(; fasta, gff, genbank)\n\n\nConvert FASTA sequence and GFF annotation files to GenBank format using EMBOSS seqret.\n\nArguments\n\nfasta::String: Path to input FASTA file containing sequence data\ngff::String: Path to input GFF file containing genomic features\ngenbank::String: Path for output GenBank file\n\nDetails\n\nRequires EMBOSS toolkit (installed via Bioconda). The function will:\n\nCreate necessary output directories\nRun seqret to combine sequence and features\nGenerate a GenBank format file at the specified location\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_genome_size-Tuple{Any}","page":"Home","title":"Mycelia.fasta_genome_size","text":"fasta_genome_size(fasta_file) -> Any\n\n\nCalculate the total size (in bases) of all sequences in a FASTA file.\n\nArguments\n\nfasta_file::AbstractString: Path to the FASTA file\n\nReturns\n\nInt: Sum of lengths of all sequences in the FASTA file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_list_to_dense_counts_table-Tuple{}","page":"Home","title":"Mycelia.fasta_list_to_dense_counts_table","text":"fasta_list_to_dense_counts_table(; fasta_list, k, alphabet)\n\n\nCreate a dense kmer counts table (canonical for DNA, stranded for RNA & AA) for each fasta provided in a list. Scales very well for large numbers of organisms/fasta files, but not for k. Recommended for k <= 13, although 17 may still be possible\n\nGenerate a dense k-mer frequency matrix from multiple FASTA files.\n\nArguments\n\nfasta_list: Vector of paths to FASTA files\nk: Length of k-mers to count (recommended k ≤ 13)\nalphabet: Symbol specifying sequence type (:DNA, :RNA, or :AA)\n\nReturns\n\nNamed tuple containing:\n\nsorted_kmers: Vector of sorted k-mers\nkmer_counts_matrix: Dense matrix where rows are k-mers and columns are sequences\n\nDetails\n\nFor DNA: Uses canonical k-mers (strand-neutral)\nFor RNA/AA: Uses stranded k-mers\nParallelized using Julia's multi-threading\n\nPerformance\n\nEfficient for large numbers of sequences\nMemory usage grows exponentially with k\nFor k > 13, use fasta_list_to_sparse_counts_table instead\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_table_to_fasta-Tuple{Any}","page":"Home","title":"Mycelia.fasta_table_to_fasta","text":"fasta_table_to_fasta(fasta_df) -> Any\n\n\nConvert a DataFrame containing FASTA sequence information into a vector of FASTA records.\n\nArguments\n\nfasta_df::DataFrame: DataFrame with columns \"identifier\", \"description\", and \"sequence\"\n\nReturns\n\nVector{FASTX.FASTA.Record}: Vector of FASTA records\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_to_reference_kmer_counts-Tuple{}","page":"Home","title":"Mycelia.fasta_to_reference_kmer_counts","text":"fasta_to_reference_kmer_counts(; kmer_type, fasta)\n\n\nCounts k-mer occurrences in a FASTA file, considering both forward and reverse complement sequences.\n\nArguments\n\nkmer_type: Type specification for k-mers (e.g., DNAKmer{21})\nfasta: Path to FASTA file containing reference sequences\n\nReturns\n\nDict{kmer_type, Int}: Dictionary mapping each k-mer to its total count across all sequences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_to_table-Tuple{Any}","page":"Home","title":"Mycelia.fasta_to_table","text":"fasta_to_table(fasta) -> DataFrames.DataFrame\n\n\nConvert a FASTA file/record iterator to a DataFrame.\n\nArguments\n\nfasta: FASTA record iterator from FASTX.jl\n\nReturns\n\nDataFrame with columns:\nidentifier: Sequence identifiers\ndescription: Full sequence descriptions \nsequence: Biological sequences as strings\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasta_xam_mapping_stats-Tuple{}","page":"Home","title":"Mycelia.fasta_xam_mapping_stats","text":"fasta_xam_mapping_stats(; fasta, xam)\n\n\nCalculate mapping statistics by comparing sequence alignments (BAM/SAM) to a reference FASTA.\n\nArguments\n\nfasta::String: Path to reference FASTA file\nxam::String: Path to alignment file (BAM or SAM format)\n\nReturns\n\nDataFrame with columns:\n\ncontig: Reference sequence name\ncontig_length: Length of reference sequence\ntotal_aligned_bases: Total number of bases aligned to reference\nmean_depth: Average depth of coverage (totalalignedbases/contig_length)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastani_list-Tuple{}","page":"Home","title":"Mycelia.fastani_list","text":"fastani_list(\n;\n    query_list,\n    reference_list,\n    outfile,\n    threads,\n    force\n) -> Union{Nothing, Base.Process}\n\n\nRun fastani with a query and reference list\n\nCalculate Average Nucleotide Identity (ANI) between genome sequences using FastANI.\n\nArguments\n\nquery_list::String: Path to file containing list of query genome paths (one per line)\nreference_list::String: Path to file containing list of reference genome paths (one per line)\noutfile::String: Path to output file that will contain ANI results\nthreads::Int=Sys.CPU_THREADS: Number of parallel threads to use\nforce::Bool=false: If true, rerun analysis even if output file exists\n\nOutput\n\nGenerates a tab-delimited file with columns:\n\nQuery genome\nReference genome  \nANI value (%)\nCount of bidirectional fragment mappings\nTotal query fragments\n\nNotes\n\nRequires FastANI to be available via Bioconda\nAutomatically sets up required conda environment\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fasterq_dump-Tuple{}","page":"Home","title":"Mycelia.fasterq_dump","text":"fasterq_dump(\n;\n    outdir,\n    srr_identifier\n) -> Union{Nothing, Base.Process}\n\n\nDownload and compress paired-end sequencing reads from the SRA database using fasterq-dump.\n\nArguments\n\noutdir::String=\"\": Output directory for the FASTQ files. Defaults to current directory.\nsrr_identifier::String=\"\": SRA run accession number (e.g., \"SRR12345678\")\n\nOutputs\n\nCreates two gzipped FASTQ files in the output directory:\n\n{srr_identifier}_1.fastq.gz: Forward reads\n{srr_identifier}_2.fastq.gz: Reverse reads\n\nDependencies\n\nRequires fasterq-dump from the SRA Toolkit and pigz for compression.\n\nNotes\n\nSkips download if output files already exist\nUses up to 4 threads or system maximum, whichever is lower\nAllocates 1GB memory for processing\nSkips technical reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastq_record-Tuple{}","page":"Home","title":"Mycelia.fastq_record","text":"fastq_record(; identifier, sequence, quality_scores)\n\n\nConstruct a FASTX FASTQ record from its components.\n\nArguments\n\nidentifier::String: The sequence identifier without the '@' prefix\nsequence::String: The nucleotide sequence\nquality_scores::Vector{Int}: Quality scores (0-93) as raw integers\n\nReturns\n\nFASTX.FASTQRecord: A parsed FASTQ record\n\nNotes\n\nQuality scores are automatically capped at 93 to ensure FASTQ compatibility\nQuality scores are converted to ASCII by adding 33 (Phred+33 encoding)\nThe record is constructed in standard FASTQ format with four lines:\nHeader line (@ + identifier)\nSequence\nPlus line\nQuality scores (ASCII encoded)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_stats-Tuple{Any}","page":"Home","title":"Mycelia.fastx_stats","text":"fastx_stats(fastq) -> Base.Process\n\n\nCalculate basic statistics for FASTQ/FASTA sequence files using seqkit.\n\nArguments\n\nfastq::String: Path to input FASTQ/FASTA file\n\nDetails\n\nAutomatically installs and uses seqkit from Bioconda to compute sequence statistics including number of sequences, total bases, GC content, average length, etc.\n\nDependencies\n\nRequires Conda and Bioconda channel\nInstalls seqkit package if not present\n\nReturns\n\nPrints statistics to standard output in tabular format\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_to_contig_lengths-Tuple{Any}","page":"Home","title":"Mycelia.fastx_to_contig_lengths","text":"fastx_to_contig_lengths(\n    fastx\n) -> OrderedCollections.OrderedDict\n\n\nGenerate detailed mapping statistics for each reference sequence/contig in a XAM (SAM/BAM/CRAM) file.\n\nArguments\n\nxam: Path to XAM file or XAM object\n\nReturns\n\nA DataFrame with per-contig statistics including:\n\nn_aligned_reads: Number of aligned reads\ntotal_aligned_bases: Sum of alignment lengths\ntotal_alignment_score: Sum of alignment scores\nMapping quality statistics (mean, std, median)\nAlignment length statistics (mean, std, median)\nAlignment score statistics (mean, std, median)\nPercent mismatches statistics (mean, std, median)\n\nNote: Only primary alignments (isprimary=true) and mapped reads (ismapped=true) are considered.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_to_kmer_graph-Tuple{Any, AbstractString}","page":"Home","title":"Mycelia.fastx_to_kmer_graph","text":"fastx_to_kmer_graph(\n    KMER_TYPE,\n    fastx::AbstractString\n) -> MetaGraphs.MetaGraph\n\n\nConstructs a k-mer graph from a single FASTX format string.\n\nArguments\n\nKMER_TYPE: The k-mer type specification (e.g., DNAKmer{K} where K is k-mer length)\nfastx::AbstractString: Input sequence in FASTX format (FASTA or FASTQ)\n\nReturns\n\nKmerGraph: A directed graph where vertices are k-mers and edges represent overlaps\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fastx_to_kmer_graph-Tuple{Any, AbstractVector{<:AbstractString}}","page":"Home","title":"Mycelia.fastx_to_kmer_graph","text":"fastx_to_kmer_graph(\n    KMER_TYPE,\n    fastxs::AbstractVector{<:AbstractString}\n) -> MetaGraphs.MetaGraph\n\n\nCreate an in-memory kmer-graph that records:\n\nall kmers\ncounts\nall observed edges between kmers\nedge orientations\nedge counts\n\nConstruct a kmer-graph from one or more FASTX files (FASTA/FASTQ).\n\nArguments\n\nKMER_TYPE: Type for kmer representation (e.g., DNAKmer{K})\nfastxs: Vector of paths to FASTX files\n\nReturns\n\nA MetaGraph where:\n\nVertices represent unique kmers with properties:\n:kmer => The kmer sequence\n:count => Number of occurrences\nEdges represent observed kmer adjacencies with properties:\n:orientation => Relative orientation of connected kmers\n:count => Number of observed transitions\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fibonacci_numbers_less_than-Tuple{Int64}","page":"Home","title":"Mycelia.fibonacci_numbers_less_than","text":"fibonacci_numbers_less_than(\n    n::Int64\n) -> Union{Vector{Any}, Vector{Int64}}\n\n\nGenerate a sequence of Fibonacci numbers strictly less than the input value.\n\nArguments\n\nn::Int: Upper bound (exclusive) for the Fibonacci sequence\n\nReturns\n\nVector{Int}: Array containing Fibonacci numbers less than n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.filesize_human_readable-Tuple{Any}","page":"Home","title":"Mycelia.filesize_human_readable","text":"filesize_human_readable(f) -> Any\n\n\nGets the size of a file and returns it in a human-readable format.\n\nArguments\n\nf: The path to the file, either as a String or an AbstractString.\n\nReturns\n\nA string representing the file size in a human-readable format (e.g., \"3.40 MB\").\n\nDetails\n\nThis function internally uses filesize(f) to get the file size in bytes, then leverages Base.format_bytes to convert it into a human-readable format with appropriate units (KB, MB, GB, etc.).\n\nExamples\n\njulia> filesize_human_readable(\"my_image.jpg\")\n\"2.15 MB\"\n\nSee Also\n\nfilesize: Gets the size of a file in bytes.\nBase.format_bytes: Converts a byte count into a human-readable string. \n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_matching_prefix-Tuple{String, String}","page":"Home","title":"Mycelia.find_matching_prefix","text":"find_matching_prefix(\n    filename1::String,\n    filename2::String;\n    strip_trailing_delimiters\n) -> String\n\n\nFind the longest common prefix between two filenames.\n\nArguments\n\nfilename1::String: First filename to compare\nfilename2::String: Second filename to compare\n\nKeywords\n\nstrip_trailing_delimiters::Bool=true: If true, removes trailing dots, hyphens, and underscores from the result\n\nReturns\n\nString: The longest common prefix found between the filenames\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_nonempty_columns-Tuple{Any}","page":"Home","title":"Mycelia.find_nonempty_columns","text":"find_nonempty_columns(df) -> Any\n\n\nIdentify all columns that have only missing or empty values\n\nReturns as a bit array\n\nSee also: dropemptycolumns, dropemptycolumns!\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_resampling_stretches-Tuple{}","page":"Home","title":"Mycelia.find_resampling_stretches","text":"find_resampling_stretches(\n;\n    record_kmer_solidity,\n    solid_branching_kmer_indices\n)\n\n\nIdentifies sequence regions that require resampling based on kmer solidity patterns.\n\nArguments\n\nrecord_kmer_solidity::BitVector: Boolean array where true indicates solid kmers\nsolid_branching_kmer_indices::Vector{Int}: Indices of solid branching kmers\n\nReturns\n\nVector{UnitRange{Int64}}: Array of ranges (start:stop) indicating stretches that need resampling\n\nDetails\n\nFinds continuous stretches of non-solid kmers and extends them to the nearest solid branching kmers on either side. These stretches represent regions that need resampling.\n\nIf a stretch doesn't have solid branching kmers on both sides, it is excluded from the result. Duplicate ranges are removed from the final output.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.find_true_ranges-Tuple{AbstractVector{Bool}}","page":"Home","title":"Mycelia.find_true_ranges","text":"find_true_ranges(\n    bool_vec::AbstractVector{Bool};\n    min_length\n) -> Vector\n\n\nFinds contiguous ranges of true values in a boolean vector.\n\nArguments\n\nbool_vec::AbstractVector{Bool}: Input boolean vector to analyze\nmin_length=1: Minimum length requirement for a range to be included\n\nReturns\n\nVector of tuples (start, end) where each tuple represents the indices of a contiguous range of true values meeting the minimum length requirement.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.first_of_each_group-Tuple{DataFrames.GroupedDataFrame{DataFrames.DataFrame}}","page":"Home","title":"Mycelia.first_of_each_group","text":"first_of_each_group(\n    gdf::DataFrames.GroupedDataFrame{DataFrames.DataFrame}\n) -> Any\n\n\nReturn a DataFrame containing the first row from each group in a GroupedDataFrame.\n\nArguments\n\ngdf::GroupedDataFrame: A grouped DataFrame created using groupby\n\nReturns\n\nDataFrame: A new DataFrame containing first row from each group\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.fit_optimal_number_of_clusters","page":"Home","title":"Mycelia.fit_optimal_number_of_clusters","text":"fit_optimal_number_of_clusters(\n    distance_matrix\n) -> @NamedTuple{optimal_number_of_clusters::Int64, ks_assessed::Vector{Int64}, within_cluster_sum_of_squares::Vector{Float64}, silhouette_scores::Vector{Float64}}\nfit_optimal_number_of_clusters(\n    distance_matrix,\n    ks_to_try\n) -> NamedTuple{(:optimal_number_of_clusters, :ks_assessed, :within_cluster_sum_of_squares, :silhouette_scores), <:Tuple{Any, Any, Vector{Float64}, Vector{Float64}}}\n\n\nDetermines the optimal number of clusters for k-means clustering by maximizing the silhouette score.\n\nAlgorithm\n\nStarts by evaluating the first 5 k values\nContinues evaluation if optimal k is at the edge of evaluated range\nRefines search by evaluating midpoints between k values around the current optimum\nIterates until convergence (optimal k remains stable)\n\nArguments\n\ndistance_matrix::Matrix: Square matrix of pairwise distances between points\nks_to_try::Vector{Int}: Vector of k values to evaluate. Defaults to [1, 2, ...] up to matrix size\n\nReturns\n\nNamed tuple containing:\n\noptimal_number_of_clusters::Int: The k value giving highest silhouette score\nks_assessed::Vector{Int}: All k values that were evaluated\nwithin_cluster_sum_of_squares::Vector{Float64}: WCSS for each k assessed\nsilhouette_scores::Vector{Float64}: Silhouette scores for each k assessed\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.fit_optimal_number_of_clusters_hclust","page":"Home","title":"Mycelia.fit_optimal_number_of_clusters_hclust","text":"fit_optimal_number_of_clusters_hclust(\n    distance_matrix\n) -> NamedTuple{(:optimal_number_of_clusters, :ks_assessed, :silhouette_scores, :hclust_result), <:Tuple{Int64, Vector{Int64}, Vector{Float64}, Clustering.Hclust}}\nfit_optimal_number_of_clusters_hclust(\n    distance_matrix,\n    ks_to_try\n) -> NamedTuple{(:optimal_number_of_clusters, :ks_assessed, :silhouette_scores, :hclust_result), <:Tuple{Any, Any, Vector{Float64}, Clustering.Hclust}}\n\n\nDetermine the optimal number of clusters using hierarchical clustering with iterative refinement.\n\nArguments\n\ndistance_matrix::Matrix: Square matrix of pairwise distances between observations\nks_to_try::Vector{Int}: Vector of cluster counts to evaluate (default: 1, 2, and sequence from Mycelia.ks())\n\nReturns\n\nNamed tuple containing:\n\noptimal_number_of_clusters::Int: Best number of clusters found\nks_assessed::Vector{Int}: All cluster counts that were evaluated\nsilhouette_scores::Vector{Float64}: Silhouette scores for each k assessed\nhclust_result: Hierarchical clustering result object\n\nDetails\n\nUses Ward's linkage method and silhouette scores to evaluate cluster quality.  Implements an adaptive search that focuses on promising regions between initially tested k values. For k=1, silhouette score is set to 0 as a special case.\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.frequency_matrix_to_cosine_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.frequency_matrix_to_cosine_distance_matrix","text":"frequency_matrix_to_cosine_distance_matrix(\n    probability_matrix\n) -> Any\n\n\nCreate cosine distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to cosine similarity (relative frequency)\n\nCompute pairwise cosine distances between entities based on their feature distributions.\n\nArguments\n\nprobability_matrix: Column-major matrix where rows represent features and columns represent entities. Each column should contain frequency/probability values for one entity.\n\nReturns\n\nSymmetric matrix of size (nentities × nentities) containing pairwise cosine distances. Distance values range from 0 (identical distributions) to 1 (orthogonal distributions).\n\nDetails\n\nComputes upper triangle and mirrors to lower triangle for efficiency\nUses Distances.cosine_dist for the core computation\nTime complexity is O(n²) where n is the number of entities\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.frequency_matrix_to_euclidean_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.frequency_matrix_to_euclidean_distance_matrix","text":"frequency_matrix_to_euclidean_distance_matrix(\n    counts_table\n) -> Any\n\n\nCreate a Euclidean distance matrix from a column-major counts matrix (features as rows and entities as columns), where distance is proportional to total feature count magnitude (size).\n\nCompute pairwise Euclidean distances between entity profiles in a counts matrix.\n\nArguments\n\ncounts_table: A matrix where rows represent features and columns represent entities (column-major format). Each column contains the feature counts/frequencies for one entity.\n\nReturns\n\nA symmetric N×N matrix of Euclidean distances between each pair of entities, where N is the number of entities.\n\nDetails\n\nParallelized computation using multi-threading\nProgress tracking via ProgressMeter\nMemory efficient: only upper triangle is computed, then mirrored\nDistance between entities increases with total feature magnitude differences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.genbank_to_codon_frequencies-Tuple{Any}","page":"Home","title":"Mycelia.genbank_to_codon_frequencies","text":"genbank_to_codon_frequencies(\n    genbank;\n    allow_all\n) -> Dict{BioSymbols.AminoAcid, Dict{Kmers.Kmer{BioSequences.DNAAlphabet{2}, 3, 1}, Int64}}\n\n\nAnalyze codon usage frequencies from genes in a GenBank file.\n\nArguments\n\ngenbank: Path to GenBank format file containing genomic sequences and annotations\nallow_all: If true, initializes frequencies for all possible codons with count=1 (default: true)\n\nReturns\n\nNested dictionary mapping amino acids to their corresponding codon usage counts:\n\nOuter key: AminoAcid (including stop codon)\nInner key: DNACodon\nValue: Count of codon occurrences\n\nDetails\n\nOnly processes genes marked as ':misc_feature' in the GenBank file\nAnalyzes both forward and reverse complement sequences\nDetermines coding strand based on presence of stop codons and start codons\nSkips ambiguous sequences that cannot be confidently oriented\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.genbank_to_fasta-Tuple{}","page":"Home","title":"Mycelia.genbank_to_fasta","text":"genbank_to_fasta(; genbank, fasta, force)\n\n\nConvert a GenBank format file to FASTA format using EMBOSS seqret.\n\nArguments\n\ngenbank: Path to input GenBank format file\nfasta: Optional output FASTA file path (defaults to input path with .fna extension)\nforce: If true, overwrites existing output file (defaults to false)\n\nReturns\n\nPath to the output FASTA file\n\nNotes\n\nRequires EMBOSS suite (installed automatically via Conda)\nWill not regenerate output if it already exists unless force=true\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_all_possible_canonical_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.generate_all_possible_canonical_kmers","text":"generate_all_possible_canonical_kmers(k, alphabet) -> Any\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\nGenerate all possible canonical k-mers of length k from the given alphabet.\n\nFor DNA/RNA sequences, returns unique canonical k-mers where each k-mer is represented by the lexicographically smaller of itself and its reverse complement. For amino acid sequences, returns all possible k-mers without canonicalization.\n\nArguments\n\nk: Length of k-mers to generate\nalphabet: Vector of BioSymbols (DNA, RNA or AminoAcid)\n\nReturns\n\nVector of k-mers, canonicalized for DNA/RNA alphabets\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_all_possible_kmers-Tuple{Any, Any}","page":"Home","title":"Mycelia.generate_all_possible_kmers","text":"generate_all_possible_kmers(k, alphabet) -> Any\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\nGenerate a sorted list of all possible k-mers for a given alphabet.\n\nArguments\n\nk::Integer: Length of k-mers to generate\nalphabet: Collection of symbols (DNA, RNA, or amino acids) from BioSymbols\n\nReturns\n\nSorted Vector of Kmers of the appropriate type (DNA, RNA, or amino acid)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_transterm_coordinates_from_fasta-Tuple{Any}","page":"Home","title":"Mycelia.generate_transterm_coordinates_from_fasta","text":"generate_transterm_coordinates_from_fasta(fasta) -> Any\n\n\nGenerate minimal coordinate files required for TransTermHP analysis from FASTA sequences.\n\nCreates artificial gene annotations at sequence boundaries to enable TransTermHP to run without real gene annotations. For each sequence in the FASTA file, generates two single-base-pair \"genes\" at positions 1-2 and (L-1)-L, where L is sequence length.\n\nArguments\n\nfasta: Path to input FASTA file containing sequences to analyze\n\nReturns\n\nPath to generated coordinate file (original path with \".coords\" extension)\n\nFormat\n\nGenerated coordinate file follows TransTermHP format: gene_id start stop chromosome\n\nwhere chromosome matches FASTA sequence identifiers.\n\nSee also: run_transterm\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.generate_transterm_coordinates_from_gff-Tuple{Any}","page":"Home","title":"Mycelia.generate_transterm_coordinates_from_gff","text":"generate_transterm_coordinates_from_gff(gff_file) -> Any\n\n\nConvert a GFF file to a coordinates file compatible with TransTermHP format.\n\nArguments\n\ngff_file::String: Path to input GFF file\n\nProcessing\n\nConverts 1-based to 0-based coordinates\nExtracts gene IDs from the attributes field\nRetains columns: gene_id, start, end, seqid\n\nReturns\n\nPath to the generated coordinates file (original filename with '.coords' suffix)\n\nOutput Format\n\nSpace-delimited file with columns: gene_id, start, end, seqid\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_base_extension-Tuple{String}","page":"Home","title":"Mycelia.get_base_extension","text":"get_base_extension(filename::String) -> String\n\n\nExtract the base file extension from a filename, handling compressed files.\n\nFor regular files, returns the last extension. For gzipped files, returns the extension before .gz.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_correct_quality-Tuple{Symbol, Int64, Int64}","page":"Home","title":"Mycelia.get_correct_quality","text":"get_correct_quality(tech::Symbol, pos::Int, read_length::Int) -> Int\n\nSimulates a Phred quality score (using the Sanger convention) for a correctly observed base. For Illumina, the quality score is modeled to decay linearly from ~40 at the start to ~20 at the end of the read. For other technologies, the score is sampled from a normal distribution with parameters typical for that platform.\n\nReturns an integer quality score.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_error_quality-Tuple{Symbol}","page":"Home","title":"Mycelia.get_error_quality","text":"get_error_quality(tech::Symbol) -> Int\n\nSimulates a Phred quality score (using the Sanger convention) for a base observed with an error. Error bases are assigned lower quality scores than correctly observed bases. For Illumina, scores typically range between 5 and 15; for nanopore and pacbio, slightly lower values are used; and for ultima, a modest quality score is assigned.\n\nReturns an integer quality score.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_genbank-Tuple{}","page":"Home","title":"Mycelia.get_genbank","text":"get_genbank(\n;\n    db,\n    accession,\n    ftp\n) -> Union{Nothing, GenomicAnnotations.GenBank.Reader}\n\n\nGet dna (db = \"nuccore\") or protein (db = \"protein\") sequences from NCBI or get fasta directly from FTP site\n\nRetrieve GenBank records from NCBI or directly from an FTP site.\n\nArguments\n\ndb::String: NCBI database to query (\"nuccore\" for nucleotide or \"protein\" for protein sequences)\naccession::String: NCBI accession number for the sequence\nftp::String: Direct FTP URL to a GenBank file (gzipped)\n\nReturns\n\nGenomicAnnotations.GenBank.Reader: A reader object containing the GenBank record\n\nDetails\n\nWhen using NCBI queries (db and accession), the function implements rate limiting  (0.5s sleep) to comply with NCBI's API restrictions of max 2 requests per second.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_gff-Tuple{}","page":"Home","title":"Mycelia.get_gff","text":"get_gff(; db, accession, ftp) -> Any\n\n\nGet dna (db = \"nuccore\") or protein (db = \"protein\") sequences from NCBI or get fasta directly from FTP site\n\nRetrieve GFF3 formatted genomic feature data from NCBI or direct FTP source.\n\nArguments\n\ndb::String: NCBI database to query (\"nuccore\" for DNA or \"protein\" for protein sequences)\naccession::String: NCBI accession number\nftp::String: Direct FTP URL to GFF3 file (typically gzipped)\n\nReturns\n\nIO: IOBuffer containing uncompressed GFF3 data\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_kmer_index-Tuple{Any, Any}","page":"Home","title":"Mycelia.get_kmer_index","text":"get_kmer_index(kmers, kmer) -> Any\n\n\nReturns the index position of a given k-mer in a sorted list of k-mers.\n\nArguments\n\nkmers: A sorted vector of k-mers to search within\nkmer: The k-mer sequence to find\n\nReturns\n\nInteger index position where kmer is found in kmers\n\nThrows\n\nAssertionError: If the k-mer is not found in the list\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.get_sequence-Tuple{}","page":"Home","title":"Mycelia.get_sequence","text":"get_sequence(\n;\n    db,\n    accession,\n    ftp\n) -> Union{Nothing, FASTX.FASTA.Reader}\n\n\nGet dna (db = \"nuccore\") or protein (db = \"protein\") sequences from NCBI or get fasta directly from FTP site\n\nRetrieve FASTA format sequences from NCBI databases or direct FTP URLs.\n\nArguments\n\ndb::String: NCBI database type (\"nuccore\" for DNA or \"protein\" for protein sequences)\naccession::String: NCBI sequence accession number\nftp::String: Direct FTP URL to a FASTA file (alternative to db/accession pair)\n\nReturns\n\nFASTX.FASTA.Reader: Reader object containing the requested sequence(s)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.gfa_to_fasta-Tuple{}","page":"Home","title":"Mycelia.gfa_to_fasta","text":"gfa_to_fasta(; gfa, fasta)\n\n\nConvert a GFA (Graphical Fragment Assembly) file to FASTA format.\n\nArguments\n\ngfa::String: Path to input GFA file\nfasta::String=gfa * \".fna\": Path for output FASTA file. Defaults to input filename with \".fna\" extension\n\nReturns\n\nString: Path to the generated FASTA file\n\nDetails\n\nUses gfatools (via Conda) to perform the conversion. The function will:\n\nEnsure gfatools is available in the Conda environment\nExecute the conversion using gfatools gfa2fa\nWrite sequences to the specified FASTA file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.gfa_to_structure_table-Tuple{Any}","page":"Home","title":"Mycelia.gfa_to_structure_table","text":"gfa_to_structure_table(\n    gfa\n) -> NamedTuple{(:contig_table, :records), <:Tuple{DataFrames.DataFrame, Any}}\n\n\nConvert a GFA (Graphical Fragment Assembly) file into a structured representation.\n\nArguments\n\ngfa: Path to GFA file or GFA content as string\n\nReturns\n\nNamed tuple containing:\n\ncontig_table: DataFrame with columns:\nconnected_component: Integer ID for each component\ncontigs: Comma-separated list of contig IDs\nis_circular: Boolean indicating if component forms a cycle\nis_closed: Boolean indicating if single contig forms a cycle\nlengths: Comma-separated list of contig lengths\nrecords: FASTA records from the GFA\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.githash-Tuple{}","page":"Home","title":"Mycelia.githash","text":"githash(; short) -> SubString{String}\n\n\nReturns the current git commit hash of the repository.\n\nArguments\n\nshort::Bool=false: If true, returns abbreviated 8-character hash\n\nReturns\n\nA string containing the git commit hash (full 40 characters by default)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.graph_to_gfa-Tuple{}","page":"Home","title":"Mycelia.graph_to_gfa","text":"graph_to_gfa(; graph, outfile)\n\n\nConvert a Mycelia graph to GFA (Graphical Fragment Assembly) format.\n\nWrites a graph to GFA format, including:\n\nHeader (H) line with GFA version\nSegment (S) lines for each vertex with sequence and depth\nLink (L) lines for edges with overlap size and orientations\n\nArguments\n\ngraph: MetaGraph containing sequence vertices and their relationships\noutfile: Path where the GFA file should be written\n\nReturns\n\nPath to the written GFA file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.hclust_to_metagraph-Tuple{Clustering.Hclust}","page":"Home","title":"Mycelia.hclust_to_metagraph","text":"hclust_to_metagraph(\n    hcl::Clustering.Hclust\n) -> MetaGraphs.MetaDiGraph{Int64, Float64}\n\n\nConvert a hierarchical clustering tree into a directed metagraph representation.\n\nArguments\n\nhcl::Clustering.Hclust: Hierarchical clustering result object\n\nReturns\n\nMetaGraphs.MetaDiGraph: Directed graph with metadata representing the clustering hierarchy\n\nGraph Properties\n\nThe resulting graph contains the following vertex properties:\n\n:hclust_id: String identifier for each node\n:height: Height/distance at each merge point (0.0 for leaves)\n:x: Horizontal position for visualization (0-1 range)\n:y: Vertical position based on normalized height\n:hcl: Original clustering object (stored as graph property)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.heirarchically_cluster_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.heirarchically_cluster_distance_matrix","text":"heirarchically_cluster_distance_matrix(\n    distance_matrix\n) -> Clustering.Hclust\n\n\nPerforms hierarchical clustering on a distance matrix using Ward's linkage method.\n\nArguments\n\ndistance_matrix::Matrix{<:Real}: A symmetric distance/dissimilarity matrix\n\nReturns\n\nHierarchicalCluster: A hierarchical clustering object from Clustering.jl\n\nDetails\n\nUses Ward's method (minimum variance) for clustering, which:\n\nMinimizes total within-cluster variance\nProduces compact, spherical clusters\nWorks well for visualization in radial layouts\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.identify_optimal_number_of_clusters-Tuple{Any}","page":"Home","title":"Mycelia.identify_optimal_number_of_clusters","text":"identify_optimal_number_of_clusters(\n    distance_matrix\n) -> Tuple{Clustering.Hclust, Int64}\n\n\nDetermine the optimal number of clusters for a dataset using hierarchical clustering and silhouette score analysis.\n\nArguments\n\ndistance_matrix: A symmetric matrix of pairwise distances between data points\n\nReturns\n\nA tuple containing:\n\nhcl: The fitted hierarchical clustering object\noptimal_number_of_clusters: Integer indicating the optimal number of clusters\n\nDetails\n\nThe function:\n\nPerforms hierarchical clustering on the distance matrix\nTests cluster counts from 2 to √n (where n is dataset size)\nEvaluates each clustering using silhouette scores\nGenerates a diagnostic plot showing silhouette scores vs cluster counts\nSelects the number of clusters that minimizes the silhouette score\n\nThe diagnostic plot is displayed automatically during execution.\n\nSee Also\n\nheirarchically_cluster_distance_matrix\nClustering.silhouettes\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.install_hashdeep-Tuple{}","page":"Home","title":"Mycelia.install_hashdeep","text":"install_hashdeep() -> Union{Nothing, Base.Process}\n\n\nEnsures the hashdeep utility is installed on the system.\n\nChecks if hashdeep is available in PATH and attempts to install it via apt package manager if not found. Will try with sudo privileges first, then without sudo if that fails.\n\nDetails\n\nChecks PATH for existing hashdeep executable\nAttempts installation using apt package manager\nRequires a Debian-based Linux distribution\n\nReturns\n\nNothing, but prints status messages during execution\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.is_equivalent-Tuple{Any, Any}","page":"Home","title":"Mycelia.is_equivalent","text":"is_equivalent(a, b) -> Any\n\n\nCheck if two biological sequences are equivalent, considering both direct and reverse complement matches.\n\nArguments\n\na: First biological sequence (BioSequence or compatible type)\nb: Second biological sequence (BioSequence or compatible type)\n\nReturns\n\nBool: true if sequences are identical or if one is the reverse complement of the other, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.isolate_normalized_primary_contig-Tuple{Any, Any, Any, Any, Int64}","page":"Home","title":"Mycelia.isolate_normalized_primary_contig","text":"isolate_normalized_primary_contig(\n    assembled_fasta,\n    assembled_gfa,\n    qualimap_report_txt,\n    identifier,\n    k::Int64;\n    primary_contig_fasta\n) -> String\n\n\nPrimary contig is defined as the contig with the most bases mapped to it\n\nIn the context of picking out phage from metagenomic assemblies the longest contig is often bacteria whereas the highest coverage contigs are often primer-dimers or other PCR amplification artifacts.\n\nTaking the contig that has the most bases mapped to it as a product of length * depth is cherry picked as our phage\n\nIsolates and exports the primary contig from an assembly based on coverage depth × length.\n\nThe primary contig is defined as the contig with the highest total mapped bases  (coverage depth × length). This method helps identify potential phage contigs in  metagenomic assemblies, avoiding both long bacterial contigs and short high-coverage  PCR artifacts.\n\nArguments\n\nassembled_fasta: Path to the assembled contigs in FASTA format\nassembled_gfa: Path to the assembly graph in GFA format\nqualimap_report_txt: Path to Qualimap coverage report\nidentifier: String identifier for the output file\nk: Integer representing k-mer size used in assembly\nprimary_contig_fasta: Optional output filepath (default: \"{identifier}.primary_contig.fna\")\n\nReturns\n\nPath to the output FASTA file containing the primary contig\n\nNotes\n\nFor circular contigs, removes the k-mer closure scar if detected\nTrims k bases from the end if they match the first k bases\nUses coverage × length to avoid both long bacterial contigs and short PCR artifacts\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.iterative_polishing","page":"Home","title":"Mycelia.iterative_polishing","text":"iterative_polishing(\n    fastq\n) -> Vector{T} where T<:(NamedTuple{(:fastq, :k), <:Tuple{Any, Any}})\niterative_polishing(\n    fastq,\n    max_k\n) -> Vector{T} where T<:(NamedTuple{(:fastq, :k), <:Tuple{Any, Any}})\niterative_polishing(\n    fastq,\n    max_k,\n    plot\n) -> Vector{T} where T<:(NamedTuple{(:fastq, :k), <:Tuple{Any, Any}})\n\n\nPerforms iterative error correction on FASTQ sequences using progressively larger k-mer sizes.\n\nStarting with the default k-mer size, this function repeatedly applies polishing steps, incrementing the k-mer size until either reaching max_k or encountering instability.\n\nArguments\n\nfastq: Path to input FASTQ file or FastqRecord object\nmax_k: Maximum k-mer size to attempt (default: 89)\nplot: Whether to generate diagnostic plots (default: false)\n\nReturns\n\nVector of polishing results, where each element contains:\n\nk: k-mer size used\nfastq: resulting polished sequences\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.jaccard_distance-Tuple{Any, Any}","page":"Home","title":"Mycelia.jaccard_distance","text":"jaccard_distance(set1, set2) -> Any\n\n\nCalculate the Jaccard distance between two sets, which is the complement of the Jaccard similarity.\n\nThe Jaccard distance is defined as: J_d(AB) = 1 - J_s(AB) = 1 - fracA  BA  B\n\nArguments\n\nset1: First set to compare\nset2: Second set to compare\n\nReturns\n\nFloat64: A value in [0,1] where 0 indicates identical sets and 1 indicates disjoint sets\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.jaccard_similarity-Tuple{Any, Any}","page":"Home","title":"Mycelia.jaccard_similarity","text":"jaccard_similarity(set1, set2) -> Any\n\n\nCompute the Jaccard similarity coefficient between two sets.\n\nThe Jaccard similarity is defined as the size of the intersection divided by the size of the union of two sets:\n\nJ(A,B) = |A ∩ B| / |A ∪ B|\n\nArguments\n\nset1: First set for comparison\nset2: Second set for comparison\n\nReturns\n\nFloat64: A value between 0.0 and 1.0, where:\n1.0 indicates identical sets\n0.0 indicates completely disjoint sets\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.jellyfish_count-Tuple{}","page":"Home","title":"Mycelia.jellyfish_count","text":"jellyfish_count(\n;\n    fastx,\n    k,\n    threads,\n    max_mem,\n    canonical,\n    outfile,\n    conda_check\n)\n\n\nCount k-mers in a FASTA/FASTQ file using Jellyfish.\n\nArguments\n\nfastx::String: Path to input FASTA/FASTQ file (can be gzipped)\nk::Integer: k-mer length\nthreads::Integer=Sys.CPU_THREADS: Number of threads to use\nmax_mem::Integer=Int(Sys.free_memory()): Maximum memory in bytes (defaults to system free memory)\ncanonical::Bool=false: Whether to count canonical k-mers (both strands combined)\noutfile::String=auto: Output filename (auto-generated based on input and parameters)\nconda_check::Bool=true: Whether to verify Jellyfish conda installation\n\nReturns\n\nString: Path to gzipped TSV file containing k-mer counts\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.jellyfish_counts_to_kmer_frequency_histogram","page":"Home","title":"Mycelia.jellyfish_counts_to_kmer_frequency_histogram","text":"jellyfish_counts_to_kmer_frequency_histogram(\n    jellyfish_counts_file\n) -> Any\njellyfish_counts_to_kmer_frequency_histogram(\n    jellyfish_counts_file,\n    outfile\n) -> Any\n\n\nConvert a Jellyfish k-mer count file into a frequency histogram.\n\nArguments\n\njellyfish_counts_file::String: Path to the gzipped TSV file containing Jellyfish k-mer counts\noutfile::String=replace(jellyfish_counts_file, r\"\\.tsv\\.gz$\" => \".count_histogram.tsv\"): Optional output file path\n\nReturns\n\nString: Path to the generated histogram file\n\nDescription\n\nProcesses a Jellyfish k-mer count file to create a frequency histogram where:\n\nColumn 1: Number of k-mers that share the same count\nColumn 2: The count they share\n\nUses system sorting with LC_ALL=C for optimal performance on large files.\n\nNotes\n\nRequires gzip, sort, uniq, and sed command line tools\nUses intermediate disk storage for sorting large files\nSkips processing if output file already exists\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.jitter-Tuple{Any, Any}","page":"Home","title":"Mycelia.jitter","text":"jitter(x, n) -> Any\n\n\nAdd random noise to create a vector of jittered values.\n\nGenerates n values by adding random noise to the input value x.  The noise is uniformly distributed between -1/3 and 1/3.\n\nArguments\n\nx: Base value to add jitter to\nn: Number of jittered values to generate\n\nReturns\n\nVector of length n containing jittered values around x\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_dict_to_vector-Tuple{Any, Any}","page":"Home","title":"Mycelia.kmer_counts_dict_to_vector","text":"kmer_counts_dict_to_vector(\n    kmer_to_index_map,\n    kmer_counts\n) -> Any\n\n\nConvert a dictionary of k-mer counts to a fixed-length numeric vector based on a predefined mapping.\n\nArguments\n\nkmer_to_index_map: Dictionary mapping k-mer sequences to their corresponding vector indices\nkmer_counts: Dictionary containing k-mer sequences and their occurrence counts\n\nReturns\n\nA vector where each position corresponds to a k-mer count, with zeros for absent k-mers\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_to_cosine_similarity-Tuple{Any, Any}","page":"Home","title":"Mycelia.kmer_counts_to_cosine_similarity","text":"kmer_counts_to_cosine_similarity(\n    kmer_counts_1,\n    kmer_counts_2\n) -> Any\n\n\nCalculate the cosine similarity between two k-mer count dictionaries.\n\nArguments\n\nkmer_counts_1::Dict{String,Int}: First dictionary mapping k-mer sequences to their counts\nkmer_counts_2::Dict{String,Int}: Second dictionary mapping k-mer sequences to their counts\n\nReturns\n\nFloat64: Cosine distance between the two k-mer count vectors, in range [0,1] where 0 indicates identical distributions and 1 indicates maximum dissimilarity\n\nDetails\n\nConverts k-mer count dictionaries into vectors using a unified set of keys, then computes cosine distance. Missing k-mers are treated as count 0. Result is invariant to input order and total counts (normalized internally).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_to_js_divergence-Tuple{Any, Any}","page":"Home","title":"Mycelia.kmer_counts_to_js_divergence","text":"kmer_counts_to_js_divergence(\n    kmer_counts_1,\n    kmer_counts_2\n) -> Any\n\n\nCalculate the Jensen-Shannon divergence between two k-mer frequency distributions.\n\nArguments\n\nkmer_counts_1: Dictionary mapping k-mers to their counts in first sequence\nkmer_counts_2: Dictionary mapping k-mers to their counts in second sequence\n\nReturns\n\nNormalized Jensen-Shannon divergence score between 0 and 1, where:\n0 indicates identical distributions\n1 indicates maximally different distributions\n\nNotes\n\nThe measure is symmetric: JS(P||Q) = JS(Q||P)\nCounts are automatically normalized to probability distributions\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_counts_to_merqury_qv-Union{Tuple{}, Tuple{N}, Tuple{k}} where {k, N}","page":"Home","title":"Mycelia.kmer_counts_to_merqury_qv","text":"kmer_counts_to_merqury_qv(\n;\n    raw_data_counts,\n    assembly_counts\n)\n\n\nCalculate assembly Quality Value (QV) score using the Merqury method.\n\nEstimates base-level accuracy by comparing k-mer distributions between raw sequencing data and assembly. Higher QV scores indicate better assembly quality.\n\nArguments\n\nraw_data_counts::AbstractDict{Kmers.DNAKmer{k,N}, Int}: K-mer counts from raw sequencing data\nassembly_counts::AbstractDict{Kmers.DNAKmer{k,N}, Int}: K-mer counts from assembly\n\nReturns\n\nFloat64: Quality Value score in Phred scale (-10log₁₀(error rate))\n\nMethod\n\nQV is calculated using:\n\nKtotal = number of unique kmers in assembly\nKshared = number of kmers shared between raw data and assembly\nP = (Kshared/Ktotal)^(1/k) = estimated base-level accuracy\nQV = -10log₁₀(1-P)\n\nReference\n\nRhie et al. \"Merqury: reference-free quality, completeness, and phasing assessment for genome assemblies\" Genome Biology (2020)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.kmer_path_to_sequence-Tuple{Any}","page":"Home","title":"Mycelia.kmer_path_to_sequence","text":"kmer_path_to_sequence(kmer_path) -> Any\n\n\nConvert a path of overlapping k-mers into a single DNA sequence.\n\nArguments\n\nkmer_path: Vector of k-mers (DNA sequences) where each consecutive pair overlaps by k-1 bases\n\nReturns\n\nBioSequences.LongDNA{2}: Assembled DNA sequence from the k-mer path\n\nDescription\n\nReconstructs the original DNA sequence by joining k-mers, validating that consecutive k-mers  overlap correctly. The first k-mer is used in full, then each subsequent k-mer contributes  its last base.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ks-Tuple{}","page":"Home","title":"Mycelia.ks","text":"ks(; min, max) -> Vector{Int64}\n\n\nGenerates a specialized sequence of prime numbers combining:\n\nOdd primes up to 23 (flip_point)\nPrimes nearest to Fibonacci numbers above 23 up to max\n\nArguments\n\nmin::Int=0: Lower bound for the sequence\nmax::Int=10_000: Upper bound for the sequence\n\nReturns\n\nVector of Int containing the specialized prime sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.lawrencium_sbatch-Tuple{}","page":"Home","title":"Mycelia.lawrencium_sbatch","text":"lawrencium_sbatch(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    partition,\n    qos,\n    account,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd\n)\n\n\nSubmit a job to SLURM scheduler on Lawrence Berkeley Lab's Lawrencium cluster.\n\nArguments\n\njob_name: Name identifier for the SLURM job\nmail_user: Email address for job notifications\nmail_type: Notification type (\"ALL\", \"BEGIN\", \"END\", \"FAIL\", or \"NONE\")\nlogdir: Directory for SLURM output and error logs\npartition: Lawrencium compute partition\nqos: Quality of Service level\naccount: Project account for billing\nnodes: Number of nodes to allocate\nntasks: Number of tasks to spawn\ntime: Wall time limit in format \"days-hours:minutes:seconds\"\ncpus_per_task: CPU cores per task\nmem_gb: Memory per node in GB\ncmd: Shell command to execute\n\nReturns\n\ntrue if submission was successful\n\nNote\n\nFunction includes 5-second delays before and after submission for queue stability.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_blastdbs-Tuple{}","page":"Home","title":"Mycelia.list_blastdbs","text":"list_blastdbs(; source) -> Vector{String}\n\n\nLists available BLAST databases from the specified source.\n\nArguments\n\nsource::String=\"ncbi\": Source of BLAST databases, defaults to \"ncbi\"\n\nReturns\n\nVector{String}: Array of available BLAST database names\n\nNotes\n\nRequires sudo/root privileges to install BLAST+ tools if not already present\nInternet connection required to fetch database listings\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_classes-Tuple{}","page":"Home","title":"Mycelia.list_classes","text":"list_classes() -> DataFrames.DataFrame\n\n\nReturns an array of all taxonomic classes in the database.\n\nClasses represent a major taxonomic rank between phylum and order in biological classification.\n\nReturns\n\nVector{String}: Array of class names sorted alphabetically\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_databases-Tuple{}","page":"Home","title":"Mycelia.list_databases","text":"list_databases(; address, username, password)\n\n\nLists all available Neo4j databases on the specified server.\n\nArguments\n\naddress::String: Neo4j server address (e.g. \"neo4j://localhost:7687\")\nusername::String=\"neo4j\": Neo4j authentication username\npassword::String: Neo4j authentication password\n\nReturns\n\nDataFrame: Contains database information with columns typically including:\nname: Database name\naddress: Database address\nrole: Database role (e.g., primary, secondary)\nstatus: Current status (e.g., online, offline)\ndefault: Boolean indicating if it's the default database\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_families-Tuple{}","page":"Home","title":"Mycelia.list_families","text":"list_families() -> DataFrames.DataFrame\n\n\nReturns a sorted vector of all family names present in the database.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_full_taxonomy-Tuple{}","page":"Home","title":"Mycelia.list_full_taxonomy","text":"list_full_taxonomy() -> DataFrames.DataFrame\n\n\nRetrieves and formats the complete NCBI taxonomy hierarchy into a structured DataFrame.\n\nDetails\n\nAutomatically sets up taxonkit environment and downloads taxonomy database if needed\nStarts from root taxid (1) and includes all descendant taxa\nReformats lineage information into separate columns for each taxonomic rank\n\nReturns\n\nDataFrame with columns:\n\ntaxid: Taxonomy identifier\nlineage: Full taxonomic lineage string\ntaxid_lineage: Lineage with taxonomy IDs\nIndividual rank columns:\nsuperkingdom, kingdom, phylum, class, order, family, genus, species\ncorresponding taxid columns (e.g., superkingdom_taxid)\n\nDependencies\n\nRequires taxonkit (installed automatically via Bioconda)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_genera-Tuple{}","page":"Home","title":"Mycelia.list_genera","text":"list_genera() -> DataFrames.DataFrame\n\n\nReturns a sorted vector of all genera names present in the database.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_kingdoms-Tuple{}","page":"Home","title":"Mycelia.list_kingdoms","text":"list_kingdoms() -> DataFrames.DataFrame\n\n\nLists all taxonomic kingdoms in the database.\n\nReturns a vector of kingdom names as strings. Kingdoms represent the highest major taxonomic rank in biological classification.\n\nReturns\n\nVector{String}: Array of kingdom names\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_orders-Tuple{}","page":"Home","title":"Mycelia.list_orders","text":"list_orders() -> DataFrames.DataFrame\n\n\nLists all orders in the taxonomic database.\n\nReturns a vector of strings containing valid order names according to current mycological taxonomy. Uses the underlying list_rank() function with rank=\"order\".\n\nReturns\n\nVector{String}: Alphabetically sorted list of order names\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_phylums-Tuple{}","page":"Home","title":"Mycelia.list_phylums","text":"list_phylums() -> DataFrames.DataFrame\n\n\nReturns a sorted list of all unique phyla in the database.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_rank-Tuple{Any}","page":"Home","title":"Mycelia.list_rank","text":"list_rank(rank) -> DataFrames.DataFrame\n\n\nList all taxonomic entries at the specified rank level.\n\nArguments\n\nrank::String: Taxonomic rank to query. Must be one of:\n\"top\" (top level)\n\"superkingdom\"/\"domain\"  \n\"kingdom\"\n\"phylum\" \n\"class\"\n\"order\"\n\"family\"\n\"genus\"\n\"species\"\n\nReturns\n\nDataFrame with columns:\n\ntaxid: NCBI taxonomy ID\nname: Scientific name at the specified rank\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_ranks-Tuple{}","page":"Home","title":"Mycelia.list_ranks","text":"list_ranks(; synonyms) -> Vector{String}\n\n\nReturn an ordered list of taxonomic ranks from highest (top) to lowest (species).\n\nArguments\n\nsynonyms::Bool=false: If true, includes alternative names for certain ranks (e.g. \"domain\" for \"superkingdom\")\n\nReturns\n\nVector{String}: An array of taxonomic rank names in hierarchical order\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_species-Tuple{}","page":"Home","title":"Mycelia.list_species","text":"list_species() -> DataFrames.DataFrame\n\n\nReturns a sorted vector of all species names present in the database.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_subtaxa-Tuple{Any}","page":"Home","title":"Mycelia.list_subtaxa","text":"list_subtaxa(taxid) -> Vector{Int64}\n\n\nReturns an array of Integer taxon IDs representing all sub-taxa under the specified taxonomic ID.\n\nArguments\n\ntaxid: NCBI taxonomy identifier for the parent taxon\n\nReturns\n\nVector{Int} containing all descendant taxon IDs\n\nDetails\n\nRequires taxonkit to be installed via Bioconda\nAutomatically sets up taxonkit database if not present\nUses local taxonomy database in ~/.taxonkit/\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_superkingdoms-Tuple{}","page":"Home","title":"Mycelia.list_superkingdoms","text":"list_superkingdoms() -> DataFrames.DataFrame\n\n\nReturns an array of all taxonomic superkingdoms (e.g., Bacteria, Archaea, Eukaryota).\n\nReturns\n\nVector{String}: Array containing names of all superkingdoms in the taxonomy database\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.list_toplevel-Tuple{}","page":"Home","title":"Mycelia.list_toplevel","text":"list_toplevel() -> DataFrames.DataFrame\n\n\nReturns a DataFrame containing the top-level taxonomic nodes.\n\nThe DataFrame has two fixed rows representing the most basic taxonomic classifications:\n\ntaxid=0: \"unclassified\"\ntaxid=1: \"root\"\n\nReturns\n\nDataFrame     Columns:     - taxid::Int : Taxonomic identifier     - name::String : Node name\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_blast_db_taxonomy_table-Tuple{Any}","page":"Home","title":"Mycelia.load_blast_db_taxonomy_table","text":"load_blast_db_taxonomy_table(\n    compressed_blast_db_taxonomy_table_file\n) -> DataFrames.DataFrame\n\n\nLoads a BLAST database taxonomy mapping table from a gzipped file into a DataFrame.\n\nArguments\n\ncompressed_blast_db_taxonomy_table_file::String: Path to a gzipped file containing BLAST taxonomy mappings\n\nReturns\n\nDataFrame: A DataFrame with columns :sequence_id and :taxid containing the sequence-to-taxonomy mappings\n\nFormat\n\nInput file should be a space-delimited text file (gzipped) with two columns:\n\nsequence identifier\ntaxonomy identifier (taxid)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_genbank_metadata-Tuple{}","page":"Home","title":"Mycelia.load_genbank_metadata","text":"load_genbank_metadata() -> DataFrames.DataFrame\n\n\nLoad metadata for GenBank sequences into a DataFrame.\n\nThis is a convenience wrapper around load_ncbi_metadata(\"genbank\") that specifically loads metadata from the GenBank database.\n\nReturns\n\nDataFrame: Contains metadata fields like accession numbers, taxonomy,\n\nand sequence information from GenBank.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_graph-Tuple{Any}","page":"Home","title":"Mycelia.load_graph","text":"load_graph(file) -> Any\n\n\nLoad a graph structure from a serialized file.\n\nArguments\n\nfile::AbstractString: Path to the file containing the serialized graph data\n\nReturns\n\nThe deserialized graph object\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_graph-Tuple{String}","page":"Home","title":"Mycelia.load_graph","text":"load_graph(file::String) -> Any\n\n\nLoads a graph object from a serialized file.\n\nArguments\n\nfile::String: Path to the file containing the serialized graph data. The file should have been created using save_graph.\n\nReturns\n\nThe deserialized graph object stored under the \"graph\" key.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_jellyfish_counts-Tuple{Any}","page":"Home","title":"Mycelia.load_jellyfish_counts","text":"load_jellyfish_counts(\n    jellyfish_counts\n) -> DataFrames.DataFrame\n\n\nLoad k-mer counts from a Jellyfish output file into a DataFrame.\n\nArguments\n\njellyfish_counts::String: Path to a gzipped TSV file (*.jf.tsv.gz) containing Jellyfish k-mer counts\n\nReturns\n\nDataFrame: Table with columns:\nkmer: Biologically encoded k-mers as DNAKmer{k} objects\ncount: Integer count of each k-mer's occurrences\n\nNotes\n\nInput file must be a gzipped TSV with exactly two columns (k-mer sequences and counts)\nK-mer length is automatically detected from the first entry\nFilename must end with '.jf.tsv.gz'\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_jld2-Tuple{Any}","page":"Home","title":"Mycelia.load_jld2","text":"load_jld2(filename) -> Any\n\n\nLoad data stored in a JLD2 file format.\n\nArguments\n\nfilename::String: Path to the JLD2 file to load\n\nReturns\n\nDict: Dictionary containing the loaded data structures\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_matrix_jld2-Tuple{Any}","page":"Home","title":"Mycelia.load_matrix_jld2","text":"load_matrix_jld2(filename) -> Any\n\n\nLoads a matrix from a JLD2 file.\n\nArguments\n\nfilename::String: Path to the JLD2 file containing the matrix under the key \"matrix\"\n\nReturns\n\nMatrix: The loaded matrix data\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_ncbi_metadata-Tuple{Any}","page":"Home","title":"Mycelia.load_ncbi_metadata","text":"load_ncbi_metadata(db) -> DataFrames.DataFrame\n\n\nLoad and parse the assembly summary metadata from NCBI's FTP server for either GenBank or RefSeq databases.\n\nArguments\n\ndb::String: Database source, must be either \"genbank\" or \"refseq\"\n\nReturns\n\nDataFrame: Parsed metadata table with properly typed columns including:\nInteger columns: taxid, species_taxid, genome metrics, and gene counts\nFloat columns: gc_percent\nDate columns: seqreldate, annotation_date\nString columns: all other fields\n\nDetails\n\nDownloads the assembly summary file from NCBI's FTP server and processes it by:\n\nParsing the tab-delimited file with commented headers\nConverting numeric strings to proper Integer/Float types\nParsing date strings to Date objects\nHandling missing values throughout\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_ncbi_taxonomy-Tuple{}","page":"Home","title":"Mycelia.load_ncbi_taxonomy","text":"load_ncbi_taxonomy(\n;\n    path_to_taxdump\n) -> MetaGraphs.MetaDiGraph{T, Float64} where T<:Integer\n\n\nDownloads and constructs a MetaDiGraph representation of the NCBI taxonomy database.\n\nArguments\n\npath_to_taxdump: Directory path where taxonomy files will be downloaded and extracted\n\nReturns\n\nMetaDiGraph: A directed graph where:\nVertices represent taxa with properties:\n:tax_id: NCBI taxonomy identifier\n:scientific_name, :common_name, etc.: Name properties\n:rank: Taxonomic rank\n:division_id, :division_cde, :division_name: Division information\nEdges represent parent-child relationships in the taxonomy\n\nDependencies\n\nRequires internet connection for initial download. Uses DataFrames, MetaGraphs, and ProgressMeter.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.load_refseq_metadata-Tuple{}","page":"Home","title":"Mycelia.load_refseq_metadata","text":"load_refseq_metadata() -> DataFrames.DataFrame\n\n\nLoads NCBI RefSeq metadata into a DataFrame. RefSeq is NCBI's curated collection  of genomic, transcript and protein sequences.\n\nReturns\n\nDataFrame: Contains metadata columns including accession numbers, taxonomic information,\n\nand sequence details from RefSeq.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.local_blast_database_info-Tuple{}","page":"Home","title":"Mycelia.local_blast_database_info","text":"local_blast_database_info(; blastdbs_dir) -> Any\n\n\nQuery information about local BLAST databases and return a formatted summary.\n\nArguments\n\nblastdbs_dir::String: Directory containing BLAST databases (default: \"~/workspace/blastdb\")\n\nReturns\n\nDataFrame with columns:\nBLAST database path\nBLAST database molecule type\nBLAST database title\ndate of last update\nnumber of bases/residues\nnumber of sequences\nnumber of bytes\nBLAST database format version\nhuman readable size\n\nDependencies\n\nRequires NCBI BLAST+ tools. Will attempt to install via apt-get if not present.\n\nSide Effects\n\nMay install system packages (ncbi-blast+, perl-doc) using sudo/apt-get\nFilters out numbered database fragments from results\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.merge_colors-Tuple{Any, Any}","page":"Home","title":"Mycelia.merge_colors","text":"merge_colors(c1, c2) -> Any\n\n\nMerge two colors by calculating their minimal color difference vector.\n\nArguments\n\nc1::Color: First color input\nc2::Color: Second color input \n\nReturns\n\nIf colors are equal, returns the input color\nOtherwise returns the color difference vector (c1-c2 or c2-c1) with minimal RGB sum\n\nDetails\n\nCalculates two difference vectors:\n\nmix_a = c1 - c2 \nmix_b = c2 - c1\n\nReturns the difference vector with the smallest sum of RGB components.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.merge_fasta_files-Tuple{}","page":"Home","title":"Mycelia.merge_fasta_files","text":"merge_fasta_files(; fasta_files, fasta_file)\n\n\nJoin fasta files while adding origin prefixes to the identifiers.\n\nDoes not guarantee uniqueness but will warn if conflicts arise\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.metasha256-Tuple{Vector{<:AbstractString}}","page":"Home","title":"Mycelia.metasha256","text":"metasha256(\n    vector_of_sha256s::Vector{<:AbstractString}\n) -> String\n\n\nCompute a single SHA256 hash from multiple SHA256 hashes.\n\nTakes a vector of hex-encoded SHA256 hashes and produces a new SHA256 hash by:\n\nSorting the input hashes lexicographically\nConcatenating them in sorted order\nComputing a new SHA256 hash over the concatenated data\n\nArguments\n\nvector_of_sha256s: Vector of hex-encoded SHA256 hash strings\n\nReturns\n\nA hex-encoded string representing the computed meta-hash\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_index-Tuple{}","page":"Home","title":"Mycelia.minimap_index","text":"minimap_index(\n;\n    fasta,\n    mem_gb,\n    mapping_type,\n    threads,\n    as_string,\n    denominator\n)\n\n\nGenerate a minimap2 index command and output file path for mapping DNA sequencing reads.\n\nRun this on the machine you intend to use to map the reads to confirm the index will fit.\n\nArguments\n\nfasta: Path to the reference FASTA file to be indexed\nmem_gb: Available system memory in gigabytes for indexing\nmapping_type: Sequencing technology preset. One of:\n\"map-hifi\": PacBio HiFi reads\n\"map-ont\": Oxford Nanopore reads\n\"map-pb\": PacBio CLR reads\n\"sr\": Short reads\n\"lr:hq\": High-quality long reads\nthreads: Number of threads to use for indexing\nas_string: Return command as String instead of Cmd (default: false)\ndenominator: Divisor for calculating index size (default: 10)\n\nReturns\n\nNamed tuple containing:\n\ncmd: The minimap2 indexing command (as String or Cmd)\noutfile: Path to the output index file (.mmi)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_map-Tuple{}","page":"Home","title":"Mycelia.minimap_map","text":"minimap_map(\n;\n    fasta,\n    fastq,\n    mapping_type,\n    as_string,\n    mem_gb,\n    threads,\n    denominator\n)\n\n\nGenerate minimap2 alignment commands for sequence mapping.\n\naligning and compressing. No sorting or filtering.\n\nUse shell_only=true to get string command to submit to SLURM\n\nCreates a command to align reads in FASTQ format to a reference FASTA using minimap2,  followed by SAM compression with pigz. Handles resource allocation and conda environment setup.\n\nArguments\n\nfasta: Path to reference FASTA file\nfastq: Path to query FASTQ file\nmapping_type: Alignment preset (\"map-hifi\", \"map-ont\", \"map-pb\", \"sr\", or \"lr:hq\")\nas_string: If true, returns shell command as string; if false, returns command array\nmem_gb: Available memory in GB for indexing (defaults to system free memory)\nthreads: Number of CPU threads to use (defaults to system threads)\ndenominator: Divisor for calculating minimap2 index size\n\nReturns\n\nNamed tuple containing:\n\ncmd: Shell command (as string or array)\noutfile: Path to compressed output SAM file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_map_paired_end-Tuple{}","page":"Home","title":"Mycelia.minimap_map_paired_end","text":"minimap_map_paired_end(\n;\n    fasta,\n    forward,\n    reverse,\n    mem_gb,\n    threads,\n    outdir,\n    as_string,\n    mapping_type,\n    denominator\n)\n\n\nMaps paired-end reads to a reference genome using minimap2 and compresses the output.\n\nArguments\n\nfasta::String: Path to reference genome FASTA file\nforward::String: Path to forward reads FASTQ file\nreverse::String: Path to reverse reads FASTQ file  \nmem_gb::Integer: Available system memory in GB\nthreads::Integer: Number of threads to use\noutdir::String: Output directory (defaults to forward reads directory)\nas_string::Bool: Return command as string instead of Cmd array\nmapping_type::String: Mapping preset, e.g. \"sr\" for short reads (default)\ndenominator::Float64: Memory scaling factor for minimap2 index\n\nReturns\n\nNamed tuple containing:\n\ncmd: Command(s) to execute (String or Vector{Cmd})\noutfile: Path to compressed output SAM file (*.sam.gz)\n\nDependencies\n\nRequires bioconda packages: minimap2, samtools, pigz\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_map_paired_end_with_index-Tuple{}","page":"Home","title":"Mycelia.minimap_map_paired_end_with_index","text":"minimap_map_paired_end_with_index(\n;\n    fasta,\n    forward,\n    reverse,\n    mem_gb,\n    threads,\n    outdir,\n    as_string,\n    mapping_type,\n    denominator\n)\n\n\nMap paired-end reads to a reference sequence using minimap2.\n\nArguments\n\nfasta::String: Path to reference FASTA file\nforward::String: Path to forward reads FASTQ file\nreverse::String: Path to reverse reads FASTQ file\nmem_gb::Integer: Available system memory in GB\nthreads::Integer: Number of threads to use\noutdir::String: Output directory (defaults to forward reads directory)\nas_string::Bool=false: Return command as string instead of Cmd array\nmapping_type::String=\"sr\": Minimap2 preset [\"map-hifi\", \"map-ont\", \"map-pb\", \"sr\", \"lr:hq\"]\ndenominator::Float64: Memory scaling factor for index size\n\nReturns\n\nNamed tuple containing:\n\ncmd: Command(s) to execute (String or Array{Cmd})\noutfile: Path to compressed output SAM file (*.sam.gz)\n\nNotes\n\nRequires minimap2, samtools, and pigz conda environments\nAutomatically compresses output using pigz\nIndex file must exist at $(fasta).x$(mapping_type).I$(index_size).mmi\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.minimap_map_with_index-Tuple{}","page":"Home","title":"Mycelia.minimap_map_with_index","text":"minimap_map_with_index(\n;\n    fasta,\n    mem_gb,\n    mapping_type,\n    threads,\n    fastq,\n    as_string,\n    denominator\n)\n\n\nGenerate minimap2 mapping commands with a pre-built index file.\n\nArguments\n\nfasta: Path to the reference FASTA file\nmem_gb: Available system memory in gigabytes for index generation\nmapping_type: Mapping preset. Must be one of: \"map-hifi\", \"map-ont\", \"map-pb\", \"sr\", or \"lr:hq\"\nthreads: Number of threads to use for mapping and compression\nfastq: Path to input FASTQ file\nas_string: If true, returns command as a string; if false, returns as command array\ndenominator: Divisor for index size calculation (default: 10)\n\nReturns\n\nNamed tuple containing:\n\ncmd: The minimap2 mapping command (string or array)\noutfile: Path to the output compressed SAM file\n\nNotes\n\nRequires pre-built index file with pattern: ${fasta}.x${mapping_type}.I${index_size}.mmi\nAutomatically installs required conda environments (minimap2, samtools, pigz)\nOutput is automatically compressed with pigz\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.mmseqs_pairwise_search-Tuple{}","page":"Home","title":"Mycelia.mmseqs_pairwise_search","text":"mmseqs_pairwise_search(; fasta, output)\n\n\nPerform all-vs-all sequence search using MMseqs2's easy-search command.\n\nArguments\n\nfasta::String: Path to input FASTA file containing sequences to compare\noutput::String: Output directory path (default: input filename + \".mmseqseasysearch_pairwise\")\n\nReturns\n\nString: Path to the output directory\n\nDetails\n\nExecutes MMseqs2 with sensitive search parameters (7 sensitivity steps) and outputs results in  tabular format with the following columns:\n\nquery, qheader: Query sequence ID and header\ntarget, theader: Target sequence ID and header  \npident: Percentage sequence identity\nfident: Fraction of identical matches\nnident: Number of identical matches\nalnlen: Alignment length\nmismatch: Number of mismatches\ngapopen: Number of gap openings\nqstart, qend, qlen: Query sequence coordinates and length\ntstart, tend, tlen: Target sequence coordinates and length\nevalue: Expected value\nbits: Bit score\n\nRequires MMseqs2 to be available through Bioconda.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.mutate_sequence-Tuple{Any}","page":"Home","title":"Mycelia.mutate_sequence","text":"mutate_sequence(reference_sequence) -> Tuple{Any, Any}\n\n\nGenerate a single random mutation in an amino acid sequence.\n\nArguments\n\nreference_sequence: Input amino acid sequence to be mutated\n\nReturns\n\nmutant_sequence: The sequence after applying the mutation\nhaplotype: A SequenceVariation.Haplotype object containing the mutation details\n\nDetails\n\nPerforms one of three possible mutation types:\n\nSubstitution: Replace one amino acid with another\nInsertion: Insert 1+ random amino acids at a position\nDeletion: Remove 1+ amino acids from a position\n\nInsertion and deletion sizes follow a truncated Poisson distribution (λ=1, min=1).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.n_maximally_distinguishable_colors-Tuple{Any}","page":"Home","title":"Mycelia.n_maximally_distinguishable_colors","text":"n_maximally_distinguishable_colors(n) -> Any\n\n\nGenerate n colors that are maximally distinguishable from each other.\n\nArguments\n\nn::Integer: The number of distinct colors to generate\n\nReturns\n\nA vector of n RGB colors that are optimized for maximum perceptual distinction, using white (RGB(1,1,1)) and black (RGB(0,0,0)) as anchor colors.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.name2taxid-Tuple{Any}","page":"Home","title":"Mycelia.name2taxid","text":"name2taxid(name) -> DataFrames.DataFrame\n\n\nConvert scientific name(s) to NCBI taxonomy ID(s) using taxonkit.\n\nArguments\n\nname::AbstractString: Scientific name(s) to query. Can be a single name or multiple names separated by newlines.\n\nReturns\n\nDataFrame with columns:\nname: Input scientific name\ntaxid: NCBI taxonomy ID\nrank: Taxonomic rank (e.g., \"species\", \"genus\")\n\nDependencies\n\nRequires taxonkit package (installed automatically via Bioconda)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.names2taxids-Tuple{AbstractVector{<:AbstractString}}","page":"Home","title":"Mycelia.names2taxids","text":"names2taxids(names::AbstractVector{<:AbstractString}) -> Any\n\n\nConvert a vector of species/taxon names to their corresponding NCBI taxonomy IDs.\n\nArguments\n\nnames::AbstractVector{<:AbstractString}: Vector of scientific names or common names\n\nReturns\n\nVector{Int}: Vector of NCBI taxonomy IDs corresponding to the input names\n\nProgress is displayed using ProgressMeter.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ncbi_ftp_path_to_url-Tuple{}","page":"Home","title":"Mycelia.ncbi_ftp_path_to_url","text":"ncbi_ftp_path_to_url(; ftp_path, extension)\n\n\nConstructs a complete NCBI FTP URL by combining a base FTP path with a file extension.\n\nArguments\n\nftp_path::String: Base FTP directory path for the resource\nextension::String: File extension to append to the resource name\n\nReturns\n\nString: Complete FTP URL path to the requested resource\n\nExtensions include:\n\ngenomic.fna.gz\ngenomic.gff.gz\nprotein.faa.gz\nassembly_report.txt\nassembly_stats.txt\ncdsfromgenomic.fna.gz\nfeature_count.txt.gz\nfeature_table.txt.gz\ngenomic.gbff.gz\ngenomic.gtf.gz\nprotein.gpff.gz\ntranslated_cds.faa.gz\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ncbi_genome_download_accession-Tuple{}","page":"Home","title":"Mycelia.ncbi_genome_download_accession","text":"ncbi_genome_download_accession(\n;\n    accession,\n    outdir,\n    outpath,\n    include_string\n)\n\n\nDownload an accession using NCBI datasets command line tool\n\nthe .zip download output to outpath will be unzipped\n\nreturns the outfolder\n\nncbi's default include string is  include_string = \"gff3,rna,cds,protein,genome,seq-report\"\n\nDownloads and extracts a genome from NCBI using the datasets command line tool.\n\nArguments\n\naccession: NCBI accession number for the genome\noutdir: Directory where files will be downloaded (defaults to current directory)\noutpath: Full path for the temporary zip file (defaults to outdir/accession.zip)\ninclude_string: Data types to download (defaults to all \"gff3,rna,cds,protein,genome,seq-report\").\n\nReturns\n\nPath to the extracted genome data directory\n\nNotes\n\nRequires the ncbi-datasets-cli conda package (automatically installed if missing)\nDownloaded zip file is automatically removed after extraction\nIf output folder already exists, download is skipped\nData is extracted to outdir/accession/ncbi_dataset/data/accession\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.ncbi_taxon_summary-Tuple{Any}","page":"Home","title":"Mycelia.ncbi_taxon_summary","text":"ncbi_taxon_summary(taxa_id) -> DataFrames.DataFrame\n\n\nRetrieve taxonomic information for a given NCBI taxonomy ID.\n\nArguments\n\ntaxa_id: NCBI taxonomy identifier (integer)\n\nReturns\n\nDataFrame: Taxonomy summary containing fields like tax_id, rank, species, etc.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.nearest_prime-Tuple{Int64}","page":"Home","title":"Mycelia.nearest_prime","text":"nearest_prime(n::Int64) -> Int64\n\n\nFind the closest prime number to the given integer n.\n\nReturns the nearest prime number to n. If two prime numbers are equally distant  from n, returns the smaller one.\n\nArguments\n\nn::Int: The input integer to find the nearest prime for\n\nReturns\n\nInt: The closest prime number to n\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.nersc_sbatch-Tuple{}","page":"Home","title":"Mycelia.nersc_sbatch","text":"nersc_sbatch(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    scriptdir,\n    qos,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd,\n    constraint\n)\n\n\nSubmit a batch job to NERSC's SLURM workload manager.\n\nArguments\n\njob_name: Identifier for the SLURM job\nmail_user: Email address for job notifications\nmail_type: Notification type (\"ALL\", \"BEGIN\", \"END\", \"FAIL\", or \"NONE\")\nlogdir: Directory for storing job output/error logs\nscriptdir: Directory for storing generated SLURM scripts\nqos: Quality of Service level (\"regular\", \"premium\", or \"preempt\")\nnodes: Number of nodes to allocate\nntasks: Number of tasks to run\ntime: Maximum wall time in format \"days-HH:MM:SS\"\ncpus_per_task: CPU cores per task\nmem_gb: Memory per node in GB\ncmd: Command(s) to execute (String or Vector{String})\nconstraint: Node type constraint (\"cpu\" or \"gpu\")\n\nReturns\n\ntrue if job submission succeeds\nfalse if submission fails\n\nQoS Options\n\nregular: Standard priority queue\npremium: High priority queue (5x throughput limit)\npreempt: Reduced credit usage but jobs may be interrupted\n\nhttps://docs.nersc.gov/jobs/policy/ https://docs.nersc.gov/systems/perlmutter/architecture/#cpu-nodes\n\ndefault is to use shared qos\n\nuse\n\nregular\npreempt (reduced credit usage but not guaranteed to finish)\npremium (priorty runs limited to 5x throughput)\n\nhttps://docs.nersc.gov/systems/perlmutter/running-jobs/#tips-and-tricks\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.nersc_sbatch_shared-Tuple{}","page":"Home","title":"Mycelia.nersc_sbatch_shared","text":"nersc_sbatch_shared(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    qos,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd,\n    constraint\n)\n\n\nSubmit a job to NERSC's SLURM scheduler using the shared QOS (Quality of Service).\n\nArguments\n\njob_name: Identifier for the job\nmail_user: Email address for job notifications\nmail_type: Notification type (\"ALL\", \"BEGIN\", \"END\", \"FAIL\", \"REQUEUE\", \"STAGE_OUT\")\nlogdir: Directory for storing job output and error logs\nqos: Quality of Service level (\"shared\", \"regular\", \"preempt\", \"premium\")\nnodes: Number of nodes to allocate\nntasks: Number of tasks to run\ntime: Maximum wall time in format \"days-hours:minutes:seconds\"\ncpus_per_task: Number of CPUs per task\nmem_gb: Memory per node in GB (default: 2GB per CPU)\ncmd: Command to execute\nconstraint: Node type constraint (\"cpu\" or \"gpu\")\n\nResource Limits\n\nMaximum memory per node: 512GB\nMaximum cores per node: 128\nDefault memory allocation: 2GB per CPU requested\n\nQOS Options\n\nshared: Default QOS for shared node usage\nregular: Standard priority\npreempt: Reduced credit usage but preemptible\npremium: 5x throughput priority (limited usage)\n\nReturns\n\ntrue if job submission succeeds\n\nhttps://docs.nersc.gov/jobs/policy/ https://docs.nersc.gov/systems/perlmutter/architecture/#cpu-nodes\n\ndefault is to use shared qos\n\nuse\n\nregular\npreempt (reduced credit usage but not guaranteed to finish)\npremium (priority runs limited to 5x throughput)\n\nmax request is 512Gb memory and 128 cores per node\n\nhttps://docs.nersc.gov/systems/perlmutter/running-jobs/#tips-and-tricks\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.node_type_to_dataframe-Tuple{}","page":"Home","title":"Mycelia.node_type_to_dataframe","text":"node_type_to_dataframe(; node_type, graph)\n\n\nConvert all nodes of a specific type in a MetaGraph to a DataFrame representation.\n\nArguments\n\nnode_type: The type of nodes to extract from the graph\ngraph: A MetaGraph containing the nodes\n\nReturns\n\nA DataFrame where:\n\nEach row represents a node of the specified type\nColumns correspond to all unique properties found across nodes\nValues are JSON-serialized strings for consistency\n\nNotes\n\nAll values are normalized through JSON serialization\nDictionary values receive double JSON encoding\nThe TYPE column is converted using type_to_string\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_codon_frequencies-Tuple{Any}","page":"Home","title":"Mycelia.normalize_codon_frequencies","text":"normalize_codon_frequencies(\n    codon_frequencies\n) -> Dict{BioSymbols.AminoAcid, Dict{Kmers.Kmer{BioSequences.DNAAlphabet{2}, 3, 1}, Float64}}\n\n\nNormalizes codon frequencies for each amino acid such that frequencies sum to 1.0.\n\nArguments\n\ncodon_frequencies: Nested dictionary mapping amino acids to their codon frequency distributions\n\nReturns\n\nNormalized codon frequencies where values for each amino acid sum to 1.0\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_countmap-Tuple{Any}","page":"Home","title":"Mycelia.normalize_countmap","text":"normalize_countmap(countmap) -> Dict\n\n\nNormalize a dictionary of counts into a probability distribution where values sum to 1.0.\n\nArguments\n\ncountmap::Dict: Dictionary mapping keys to count values\n\nReturns\n\nDict: New dictionary with same keys but values normalized by total sum\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.normalize_distance_matrix","text":"normalize_distance_matrix(distance_matrix) -> Any\n\n\nCreate distance matrix from a column-major counts matrix (features as rows and entities as columns) where distance is a proportional to total feature count magnitude (size) and cosine similarity (relative frequency)\n\nNormalize a distance matrix by dividing all elements by the maximum non-NaN value.\n\nArguments\n\ndistance_matrix: A matrix of distance values that may contain NaN, nothing, or missing values\n\nReturns\n\nNormalized distance matrix with values scaled to [0, 1] range\n\nDetails\n\nFilters out NaN, nothing, and missing values when finding the maximum\nAll elements are divided by the same maximum value to preserve relative distances\nIf all values are NaN/nothing/missing, may return NaN values\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalize_vcf-Tuple{}","page":"Home","title":"Mycelia.normalize_vcf","text":"normalize_vcf(; reference_fasta, vcf_file)\n\n\nNormalize a VCF file using bcftools norm, with automated handling of compression and indexing.\n\nArguments\n\nreference_fasta::String: Path to the reference FASTA file used for normalization\nvcf_file::String: Path to input VCF file (can be gzipped or uncompressed)\n\nReturns\n\nString: Path to the normalized, sorted, and compressed output VCF file (*.sorted.normalized.vcf.gz)\n\nNotes\n\nRequires bioconda packages: htslib, tabix, bcftools\nCreates intermediate files with extensions .tbi for indices\nSkips processing if output file already exists\nPerforms left-alignment and normalization of variants\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.normalized_current_datetime-Tuple{}","page":"Home","title":"Mycelia.normalized_current_datetime","text":"normalized_current_datetime() -> String\n\n\nReturns the current date and time as a normalized string with all non-word characters removed.\n\nThe output format is based on ISO datetime (YYYYMMDDThhmmss) but strips any special characters like hyphens, colons or dots.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.observe-Tuple{R} where R<:Union{FASTX.FASTA.Record, FASTX.FASTQ.Record}","page":"Home","title":"Mycelia.observe","text":"observe(\n    record::Union{FASTX.FASTA.Record, FASTX.FASTQ.Record};\n    error_rate\n)\n\n\nSimulate sequencing of a DNA/RNA record by introducing random errors at the specified rate.\n\nArguments\n\nrecord: A FASTA or FASTQ record containing the sequence to be \"observed\"\nerror_rate: Probability of error at each position (default: 0.0)\n\nReturns\n\nA new FASTQ.Record with:\n\nRandom UUID as identifier\nOriginal record's description \nModified sequence with introduced errors\nGenerated quality scores\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.observe-Union{Tuple{BioSequences.LongSequence{T}}, Tuple{T}} where T","page":"Home","title":"Mycelia.observe","text":"observe(sequence::BioSequences.LongSequence{T}; error_rate=nothing, tech::Symbol=:illumina) where T\n\nSimulates the “observation” of a biological polymer (DNA, RNA, or protein) by introducing realistic errors along with base‐quality scores. The simulation takes into account both random and systematic error components. In particular, for technologies:\n\nillumina: (mostly substitution errors) the per‐base quality decays along the read (from ~Q40 at the start to ~Q20 at the end);\nnanopore: errors are more frequent and include both substitutions and indels (with overall lower quality scores, and an extra “homopolymer” penalty);\npacbio: errors are dominated by indels (with quality scores typical of raw reads);\nultima: (UG 100/ppmSeq™) correct bases are assigned very high quality (~Q60) while errors are extremely rare and, if they occur, are given a modest quality.\n\nAn error is introduced at each position with a (possibly position‐dependent) probability. For Illumina, the error probability increases along the read; additionally, if a base is part of a homopolymer run (length ≥ 3) and the chosen technology is one that struggles with homopolymers (nanopore, pacbio, ultima), then the local error probability is multiplied by a constant factor.\n\nReturns a tuple (new_seq, quality_scores) where:\n\nnew_seq is a BioSequences.LongSequence{T} containing the “observed” sequence (which may be longer or shorter than the input if insertions or deletions occur), and \nquality_scores is a vector of integers representing the Phred quality scores (using the Sanger convention) for each base in the output sequence.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.open_fastx-Tuple{AbstractString}","page":"Home","title":"Mycelia.open_fastx","text":"open_fastx(\n    path::AbstractString\n) -> Union{FASTX.FASTA.Reader, FASTX.FASTQ.Reader{T} where T<:(TranscodingStreams.TranscodingStream{C, S} where {S<:IO, C<:TranscodingStreams.Codec})}\n\n\nOpen and return a reader for FASTA or FASTQ format files.\n\nArguments\n\npath::AbstractString: Path to input file. Can be:\nLocal file path\nHTTP/FTP URL\nGzip compressed (.gz extension)\n\nSupported formats\n\nFASTA (.fasta, .fna, .faa, .fa)\nFASTQ (.fastq, .fq)\n\nReturns\n\nFASTX.FASTA.Reader for FASTA files\nFASTX.FASTQ.Reader for FASTQ files\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.open_genbank-Tuple{Any}","page":"Home","title":"Mycelia.open_genbank","text":"open_genbank(\n    genbank_file\n) -> Vector{GenomicAnnotations.Record}\n\n\nOpens and parses a GenBank format file containing genomic sequence and annotation data.\n\nArguments\n\ngenbank_file::AbstractString: Path to the GenBank (.gb or .gbk) file\n\nReturns\n\nVector{GenomicAnnotations.Chromosome}: Vector containing parsed chromosome data\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.open_gff-Tuple{String}","page":"Home","title":"Mycelia.open_gff","text":"open_gff(path::String) -> Any\n\n\nOpens a GFF (General Feature Format) file for reading.\n\nArguments\n\npath::String: Path to GFF file. Can be:\nLocal file path\nHTTP/FTP URL (FTP URLs are automatically converted to HTTP)\nGzipped file (automatically decompressed)\n\nReturns\n\nIO: An IO stream ready to read the GFF content\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_blast_report-Tuple{Any}","page":"Home","title":"Mycelia.parse_blast_report","text":"parse_blast_report(blast_report) -> DataFrames.DataFrame\n\n\nExpects output type 7 from BLAST, default output type 6 doesn't have the header comments and won't auto-parse\n\nParse a BLAST output file into a structured DataFrame.\n\nArguments\n\nblast_report::AbstractString: Path to a BLAST output file in format 7 (tabular with comments)\n\nReturns\n\nDataFrame: Table containing BLAST results with columns matching the header fields. Returns empty DataFrame if no hits found.\n\nDetails\n\nRequires BLAST output format 7 (-outfmt 7), which includes header comments\nHandles missing values (encoded as \"N/A\") automatically\nInfers column types based on BLAST field names\nSupports standard BLAST tabular fields including sequence IDs, scores, alignments and taxonomic information\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_gfa-Tuple{Any}","page":"Home","title":"Mycelia.parse_gfa","text":"parse_gfa(gfa) -> MetaGraphs.MetaGraph{Int64, Float64}\n\n\nParse a GFA (Graphical Fragment Assembly) file into a MetaGraph representation.\n\nArguments\n\ngfa: Path to GFA format file\n\nReturns\n\nA MetaGraph where:\n\nVertices represent segments (contigs)\nEdges represent links between segments\nVertex properties include :id with segment identifiers\nGraph property :records contains the original FASTA records\n\nFormat Support\n\nHandles standard GFA v1 lines:\n\nH: Header lines (skipped)\nS: Segments (stored as nodes with FASTA records)\nL: Links (stored as edges)\nP: Paths (stored in paths dictionary)\nA: HiFiAsm specific lines (skipped)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_jsonl-Tuple{String}","page":"Home","title":"Mycelia.parse_jsonl","text":"parse_jsonl(filepath::String) -> Vector{Dict{String, Any}}\n\n\nParse a JSONL (JSON Lines) file into a vector of dictionaries.\n\nArguments\n\nfilepath::String: Path to the JSONL file to parse\n\nReturns\n\nVector{Dict{String, Any}}: Vector containing parsed JSON objects, one per line\n\nDescription\n\nReads a JSONL file line by line, parsing each line as a separate JSON object. Uses pre-allocation and progress tracking for efficient processing of large files.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_mmseqs_easy_taxonomy_lca_tsv-Tuple{Any}","page":"Home","title":"Mycelia.parse_mmseqs_easy_taxonomy_lca_tsv","text":"parse_mmseqs_easy_taxonomy_lca_tsv(\n    lca_tsv\n) -> DataFrames.DataFrame\n\n\nParse the taxonomic Last Common Ancestor (LCA) TSV output from MMseqs2's easy-taxonomy workflow.\n\nArguments\n\nlca_tsv: Path to the TSV file containing MMseqs2 taxonomy results\n\nReturns\n\nDataFrame with columns:\n\ncontig_id: Sequence identifier\ntaxon_id: NCBI taxonomy identifier \ntaxon_rank: Taxonomic rank (e.g. species, genus)\ntaxon_name: Scientific name\nfragments_retained: Number of fragments kept\nfragments_taxonomically_assigned: Number of fragments with taxonomy\nfragments_in_agreement_with_assignment: Fragments matching contig taxonomy\nsupport -log(E-value): Statistical support score\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_mmseqs_easy_taxonomy_tophit_report-Tuple{Any}","page":"Home","title":"Mycelia.parse_mmseqs_easy_taxonomy_tophit_report","text":"parse_mmseqs_easy_taxonomy_tophit_report(\n    tophit_report\n) -> DataFrames.DataFrame\n\n\nParse an MMseqs2 easy-taxonomy tophit report into a structured DataFrame.\n\nArguments\n\ntophit_report::String: Path to the MMseqs2 easy-taxonomy tophit report file (tab-delimited)\n\nReturns\n\nDataFrame: A DataFrame with columns:\ntarget_id: Target sequence identifier\nnumber of sequences aligning to target: Count of aligned sequences\nunique coverage of target: Ratio of uniqueAlignedResidues to targetLength\nTarget coverage: Ratio of alignedResidues to targetLength\nAverage sequence identity: Mean sequence identity\ntaxon_id: Taxonomic identifier\ntaxon_rank: Taxonomic rank\ntaxon_name: Species name and lineage\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_mmseqs_tophit_aln-Tuple{Any}","page":"Home","title":"Mycelia.parse_mmseqs_tophit_aln","text":"parse_mmseqs_tophit_aln(tophit_aln) -> DataFrames.DataFrame\n\n\nParse MMseqs2 tophit alignment output file into a structured DataFrame.\n\nArguments\n\ntophit_aln::AbstractString: Path to tab-delimited MMseqs2 alignment output file\n\nReturns\n\nDataFrame with columns:\n\nquery: Query sequence/profile identifier\ntarget: Target sequence/profile identifier  \npercent identity: Sequence identity percentage\nalignment length: Length of alignment\nnumber of mismatches: Count of mismatched positions\nnumber of gaps: Count of gap openings\nquery start: Start position in query sequence\nquery end: End position in query sequence\ntarget start: Start position in target sequence\ntarget end: End position in target sequence\nevalue: E-value of alignment\nbit score: Bit score of alignment\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_qualimap_contig_coverage-Tuple{Any}","page":"Home","title":"Mycelia.parse_qualimap_contig_coverage","text":"parse_qualimap_contig_coverage(\n    qualimap_report_txt\n) -> DataFrames.DataFrame\n\n\nParse contig coverage statistics from a Qualimap BAM QC report file.\n\nArguments\n\nqualimap_report_txt::String: Path to Qualimap bamqc report text file\n\nReturns\n\nDataFrame: Coverage statistics with columns:\nContig: Contig identifier\nLength: Contig length in bases\nMapped bases: Number of bases mapped to contig\nMean coverage: Average coverage depth\nStandard Deviation: Standard deviation of coverage\n% Mapped bases: Percentage of total mapped bases on this contig\n\nSupported Assemblers\n\nHandles output from both SPAdes and MEGAHIT assemblers:\n\nSPAdes format: NODEXlengthYcov_Z\nMEGAHIT format: kXX_Y \n\nParse the contig coverage information from qualimap bamqc text report, which looks like the following:\n\n# this is spades\n>>>>>>> Coverage per contig\n\n\tNODE_1_length_107478_cov_9.051896\t107478\t21606903\t201.0355886786133\t60.39424208607496\n\tNODE_2_length_5444_cov_1.351945\t5444\t153263\t28.152645113886848\t5.954250612823136\n\tNODE_3_length_1062_cov_0.154390\t1062\t4294\t4.043314500941619\t1.6655384692688975\n\tNODE_4_length_776_cov_0.191489\t776\t3210\t4.13659793814433\t2.252009588980858\n\n# below is megahit\n>>>>>>> Coverage per contig\n\n\tk79_175\t235\t3862\t16.43404255319149\t8.437436249612457\n\tk79_89\t303\t3803\t12.551155115511552\t5.709975376279777\n\tk79_262\t394\t6671\t16.931472081218274\t7.579217802849293\n\tk79_90\t379\t1539\t4.060686015831134\t1.2929729111266581\n\tk79_91\t211\t3749\t17.767772511848342\t11.899185693011933\n\tk79_0\t2042\t90867\t44.49902056807052\t18.356525483516613\n\nTo make this more robust, consider reading in the names of the contigs from the assembled fasta\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_rtg_eval_output-Tuple{Any}","page":"Home","title":"Mycelia.parse_rtg_eval_output","text":"parse_rtg_eval_output(f) -> DataFrames.DataFrame\n\n\nParse RTG evaluation output from a gzipped tab-separated file.\n\nArguments\n\nf: Path to a gzipped TSV file containing RTG evaluation output\n\nFormat\n\nExpected file format:\n\nHeader line starting with '#' and tab-separated column names\nData rows in tab-separated format\nEmpty files return a DataFrame with empty columns matching header\n\nReturns\n\nA DataFrame where:\n\nColumn names are taken from the header line (stripped of '#')\nData is parsed as Float64 values\nEmpty files result in empty columns preserving header structure\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_transterm_output-Tuple{Any}","page":"Home","title":"Mycelia.parse_transterm_output","text":"parse_transterm_output(\n    transterm_output\n) -> DataFrames.DataFrame\n\n\nParse TransTerm terminator prediction output into a structured DataFrame.\n\nTakes a TransTerm output file path and returns a DataFrame containing parsed terminator predictions. Each row represents one predicted terminator with the following columns:\n\nchromosome: Identifier of the sequence being analyzed\nterm_id: Unique terminator identifier (e.g. \"TERM 19\")\nstart: Start position of the terminator\nstop: End position of the terminator\nstrand: Strand orientation (\"+\" or \"-\")\nlocation: Context type, where:\nG/g = in gene interior (≥50bp from ends)\nF/f = between two +strand genes\nR/r = between two -strand genes\nT = between ends of +strand and -strand genes\nH = between starts of +strand and -strand genes\nN = none of the above\nLowercase indicates opposite strand from region\nconfidence: Overall confidence score (0-100)\nhairpin_score: Hairpin structure score\ntail_score: Tail sequence score  \nnotes: Additional annotations (e.g. \"bidir\")\n\nArguments\n\ntransterm_output::AbstractString: Path to TransTerm output file\n\nReturns\n\nDataFrame: Parsed terminator predictions with columns as described above\n\nSee TransTerm HP documentation for details on scoring and location codes.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_virsorter_score_tsv-Tuple{Any}","page":"Home","title":"Mycelia.parse_virsorter_score_tsv","text":"parse_virsorter_score_tsv(\n    virsorter_score_tsv\n) -> DataFrames.DataFrame\n\n\nParse a VirSorter score TSV file and return a DataFrame.\n\nArguments\n\nvirsorter_score_tsv::String: The file path to the VirSorter score TSV file.\n\nReturns\n\nDataFrame: A DataFrame containing the parsed data from the TSV file. If the file is empty, returns a DataFrame with the appropriate headers but no data.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_xam_to_mapped_records_table","page":"Home","title":"Mycelia.parse_xam_to_mapped_records_table","text":"parse_xam_to_mapped_records_table(\n    xam\n) -> DataFrames.DataFrame\nparse_xam_to_mapped_records_table(\n    xam,\n    primary_only\n) -> DataFrames.DataFrame\n\n\nParse SAM/BAM files into a DataFrame containing mapped read alignments.\n\nArguments\n\nxam::String: Path to input SAM/BAM file (supports .sam, .bam, or .sam.gz)\nprimary_only::Bool=false: Flag to filter for primary alignments only (currently unused)\n\nReturns\n\nDataFrame with columns:\n\ntemplate: Read template name\nflag: SAM flag\nreference: Reference sequence name\nposition: Alignment position range\nmappingquality: Mapping quality score\ntlen: Template length\nalignlength: Alignment length\nismapped: Boolean indicating if read is mapped\nisprimary: Boolean indicating if alignment is primary\nalignment_score: Alignment score (AS tag)\nmismatches: Number of mismatches (NM tag)\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.parse_xam_to_primary_mapping_table-Tuple{Any}","page":"Home","title":"Mycelia.parse_xam_to_primary_mapping_table","text":"parse_xam_to_primary_mapping_table(\n    xam\n) -> DataFrames.DataFrame\n\n\nParse a SAM/BAM alignment file and extract template-to-reference mapping information.\n\nArguments\n\nxam::String: Path to input alignment file (.sam, .sam.gz, or .bam format)\n\nReturns\n\nDataFrame: Table with columns:\ntemplate: Read template names\nreference: Reference sequence names\n\nOnly includes primary alignments (not secondary/supplementary) that are mapped to references. Skips header lines starting with '@'.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_xam_to_summary_table-Tuple{Any}","page":"Home","title":"Mycelia.parse_xam_to_summary_table","text":"parse_xam_to_summary_table(xam) -> DataFrames.DataFrame\n\n\nParse a SAM/BAM file into a summary DataFrame containing alignment metadata.\n\nArguments\n\nxam::AbstractString: Path to input SAM (.sam), BAM (.bam), or gzipped SAM (.sam.gz) file\n\nReturns\n\nDataFrame with columns:\n\ntemplate: Read name\nflag: SAM flag\nreference: Reference sequence name\nposition: Alignment position range (start:end)\nmappingquality: Mapping quality score\nalignment_score: Alignment score (AS tag)\nisprimary: Whether alignment is primary\nalignlength: Length of the alignment\nismapped: Whether read is mapped\nmismatches: Number of mismatches (NM tag)\n\nNote: Only mapped reads are included in the output DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.parse_xam_to_taxonomic_mapping_quality","page":"Home","title":"Mycelia.parse_xam_to_taxonomic_mapping_quality","text":"parse_xam_to_taxonomic_mapping_quality(\n    xam\n) -> DataFrames.DataFrame\nparse_xam_to_taxonomic_mapping_quality(\n    xam,\n    primary_only\n) -> DataFrames.DataFrame\n\n\nParse alignment data from SAM/BAM files into a structured DataFrame containing mapping quality and taxonomic information.\n\nArguments\n\nxam::String: Path to input file (.sam, .bam, or .sam.gz)\nprimary_only::Bool=false: When true, include only primary alignments (currently not implemented)\n\nReturns\n\nDataFrames.DataFrame with columns:\n\ntemplate: Read name\nflag: SAM flag\nreference: Reference sequence name  \nposition: Alignment position range\nmappingquality: Mapping quality score\ntlen: Template length\nalignlength: Alignment length\nismapped: Boolean indicating if read is mapped\nisprimary: Boolean indicating if alignment is primary\nalignment_score: Alignment score (AS tag)\nmismatches: Number of mismatches (NM tag)\n\nNotes\n\nSkips unmapped reads\nAutomatically detects and handles SAM/BAM/compressed SAM formats\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.path_to_sequence-Tuple{Any, Any}","page":"Home","title":"Mycelia.path_to_sequence","text":"path_to_sequence(kmers, path) -> Any\n\n\nConvert a path through k-mers into a single DNA sequence.\n\nTakes a vector of k-mers and a path representing the order to traverse them, reconstructs the original sequence by joining the k-mers according to the path. The first k-mer is used in full, then only the last nucleotide from each subsequent k-mer is added.\n\nArguments\n\nkmers: Vector of DNA k-mers (as LongDNA{4})\npath: Vector of tuples representing the path through the k-mers\n\nReturns\n\nLongDNA{4}: The reconstructed DNA sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.pixels_to_points-Tuple{Any}","page":"Home","title":"Mycelia.pixels_to_points","text":"pixels_to_points(pixels) -> Any\n\n\nConvert pixel measurements to point measurements using the standard 4:3 ratio.\n\nPoints are the standard unit for typography (1 point = 1/72 inch), while pixels are  used for screen measurements. This conversion uses the conventional 4:3 ratio where  3 points equal 4 pixels.\n\nArguments\n\npixels: The number of pixels to convert\n\nReturns\n\nThe equivalent measurement in points\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_graph-Tuple{Any}","page":"Home","title":"Mycelia.plot_graph","text":"plot_graph(graph) -> Any\n\n\nCreates a visualization of a kmer graph where nodes represent kmers and their sizes reflect counts.\n\nArguments\n\ngraph: A MetaGraph where vertices have :kmer and :count properties\n\nReturns\n\nA Plots.jl plot object showing the graph visualization\n\nDetails\n\nNode sizes are scaled based on kmer counts\nPlot dimensions scale logarithmically with number of vertices\nEach node is labeled with its kmer sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_kmer_frequency_spectra-Tuple{Any}","page":"Home","title":"Mycelia.plot_kmer_frequency_spectra","text":"plot_kmer_frequency_spectra(\n    counts;\n    log_scale,\n    kwargs...\n) -> Plots.Plot\n\n\nPlots a histogram of kmer counts against # of kmers with those counts\n\nReturns the plot object for adding additional layers and saving\n\nCreates a scatter plot visualizing the k-mer frequency spectrum - the relationship between k-mer frequencies and how many k-mers occur at each frequency.\n\nArguments\n\ncounts::AbstractVector{<:Integer}: Vector of k-mer counts/frequencies\nlog_scale::Union{Function,Nothing} = log2: Function to apply logarithmic scaling to both axes. Set to nothing to use linear scaling.\nkwargs...: Additional keyword arguments passed to StatsPlots.plot()\n\nReturns\n\nPlots.Plot: A scatter plot object that can be further modified or saved\n\nDetails\n\nThe x-axis shows k-mer frequencies (how many times each k-mer appears), while the y-axis shows how many distinct k-mers appear at each frequency. Both axes are log-scaled by default using log2.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.plot_optimal_cluster_assessment_results-Tuple{Any}","page":"Home","title":"Mycelia.plot_optimal_cluster_assessment_results","text":"plot_optimal_cluster_assessment_results(\n    clustering_results\n) -> Any\n\n\nVisualizes cluster assessment metrics and saves the resulting plots.\n\nArguments\n\nclustering_results: A named tuple containing:\nks_assessed: Vector of k values tested\nwithin_cluster_sum_of_squares: Vector of WCSS scores\nsilhouette_scores: Vector of silhouette scores\noptimal_number_of_clusters: Integer indicating optimal k\n\nDetails\n\nCreates two plots:\n\nWithin-cluster sum of squares (WCSS) vs number of clusters\nSilhouette scores vs number of clusters\n\nBoth plots include a vertical line indicating the optimal number of clusters.\n\nOutputs\n\nSaves two SVG files in the project directory:\n\nwcss.svg: WCSS plot\nsilhouette.svg: Silhouette scores plot\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.points_to_pixels-Tuple{Any}","page":"Home","title":"Mycelia.points_to_pixels","text":"points_to_pixels(points) -> Any\n\n\nConvert typographic points to pixels using a 4:3 ratio (1 point = 4/3 pixels).\n\nArguments\n\npoints: Size in typographic points (pt)\n\nReturns\n\nSize in pixels (px)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.polish_fastq-Tuple{}","page":"Home","title":"Mycelia.polish_fastq","text":"polish_fastq(; fastq, k)\n\n\nPolish FASTQ reads using a k-mer graph-based approach to correct potential sequencing errors.\n\nArguments\n\nfastq::String: Path to input FASTQ file\nk::Int=1: Initial k-mer size parameter. Final assembly k-mer size may differ.\n\nProcess\n\nBuilds a directed k-mer graph from input reads\nProcesses each read through the graph to find optimal paths\nWrites corrected reads to a new FASTQ file\nAutomatically compresses output with gzip\n\nReturns\n\nNamed tuple with:\n\nfastq::String: Path to output gzipped FASTQ file\nk::Int: Final assembly k-mer size used\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.prefetch-Tuple{}","page":"Home","title":"Mycelia.prefetch","text":"prefetch(; SRR, outdir)\n\n\nDownloads Sequence Read Archive (SRA) data using the prefetch tool from sra-tools.\n\nArguments\n\nSRR: SRA accession number (e.g., \"SRR12345678\")\noutdir: Directory where the downloaded data will be saved. Defaults to current directory.\n\nNotes\n\nRequires sra-tools which will be installed in a Conda environment\nDownloads are saved in .sra format\nInternet connection required\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.process_fastq_record-Tuple{}","page":"Home","title":"Mycelia.process_fastq_record","text":"process_fastq_record(\n;\n    record,\n    kmer_graph,\n    yen_k_shortest_paths_and_weights,\n    yen_k\n)\n\n\nProcess and error-correct a FASTQ sequence record using a kmer graph and path resampling.\n\nArguments\n\nrecord: FASTQ record containing the sequence to process\nkmer_graph: MetaGraph containing the kmer network and associated properties\nyen_k_shortest_paths_and_weights: Cache of pre-computed k-shortest paths between nodes\nyen_k: Number of alternative paths to consider during resampling (default: 3)\n\nDescription\n\nPerforms error correction by:\n\nTrimming low-quality sequence ends\nIdentifying stretches requiring resampling between solid branching kmers\nSelecting alternative paths through the kmer graph based on:\nPath quality scores\nTransition likelihoods\nPath length similarity to original sequence\n\nReturns\n\nModified FASTQ record with error-corrected sequence and updated quality scores\nOriginal record if no error correction was needed\n\nRequired Graph Properties\n\nThe kmer_graph must contain the following properties:\n\n:ordered_kmers\n:likelyvalidkmer_indices  \n:kmer_indices\n:branching_nodes\n:assembly_k\n:transition_likelihoods\n:kmermeanquality\n:kmertotalquality\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.q_value_to_error_rate-Tuple{Any}","page":"Home","title":"Mycelia.q_value_to_error_rate","text":"q_value_to_error_rate(q_value) -> Any\n\n\nConvert a Phred quality score (Q-value) to a probability of error.\n\nArguments\n\nq_value: Phred quality score, typically ranging from 0 to 40\n\nReturns\n\nError probability in range [0,1], where 0 indicates highest confidence\n\nA Q-value of 10 corresponds to an error rate of 0.1 (10%), while a Q-value of  30 corresponds to an error rate of 0.001 (0.1%).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qc_filter_long_reads_fastplong-Tuple{}","page":"Home","title":"Mycelia.qc_filter_long_reads_fastplong","text":"qc_filter_long_reads_fastplong(\n;\n    in_fastq,\n    report_title,\n    out_fastq,\n    html_report,\n    json_report,\n    min_length,\n    max_length\n)\n\n\nPerform QC filtering on long-read FASTQ files using fastplong.\n\nArguments\n\nin_fastq::String: Path to the input FASTQ file.\nout_fastq::String: Path to the output FASTQ file.\nquality_threshold::Int: Minimum average quality to retain a read (default 10).\nmin_length::Int: Minimum read length (default 1000).\nmax_length::Int=0: Maximum read length (default 0, no maximum).\n\nReturns\n\nString: Path to the filtered FASTQ file.\n\nDetails\n\nThis function uses fastplong to filter long reads based on quality and length criteria. It is optimized for Oxford Nanopore, PacBio, or similar long-read datasets.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qc_filter_long_reads_filtlong-Tuple{}","page":"Home","title":"Mycelia.qc_filter_long_reads_filtlong","text":"qc_filter_long_reads_filtlong(\n;\n    in_fastq,\n    out_fastq,\n    min_mean_q,\n    keep_percent\n)\n\n\nFilter and process long reads from a FASTQ file using Filtlong.\n\nThis function filters long sequencing reads based on quality and length criteria,  then compresses the output using pigz.\n\nArguments\n\nin_fastq::String: Path to the input FASTQ file.\nout_fastq::String: Path to the output filtered and compressed FASTQ file.   Defaults to the input filename with \".filtlong.fq.gz\" appended.\nmin_mean_q::Int: Minimum mean quality score for reads to be kept. Default is 20.\nkeep_percent::Int: Percentage of reads to keep after filtering. Default is 95.\n\nReturns\n\nout_fastq\n\nDetails\n\nThis function uses Filtlong to filter long reads and pigz for compression. It requires the Bioconda environment for Filtlong to be set up, which is handled internally.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.qc_filter_short_reads_fastp-Tuple{String, String}","page":"Home","title":"Mycelia.qc_filter_short_reads_fastp","text":"qc_filter_short_reads_fastp(\n    in_fastq::String,\n    out_fastq::String;\n    adapter_seq,\n    quality_threshold,\n    min_length\n)\n\n\nPerform quality control (QC) filtering and trimming on short-read FASTQ files using fastp.\n\nArguments\n\nin_fastq::String: Path to the input FASTQ file.\nout_fastq::String: Path to the output FASTQ file.\nadapter_seq::String: Adapter sequence to trim.\nquality_threshold::Int: Minimum phred score for trimming (default 20).\nmin_length::Int: Minimum read length to retain (default 50).\n\nReturns\n\nString: Path to the filtered and trimmed FASTQ file.\n\nDetails\n\nThis function uses fastp to remove adapter contamination, trim low‐quality bases from the 3′ end, and discard reads shorter than min_length. It’s a simple wrapper that executes the external fastp command.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rand_of_each_group-Tuple{DataFrames.GroupedDataFrame{DataFrames.DataFrame}}","page":"Home","title":"Mycelia.rand_of_each_group","text":"rand_of_each_group(\n    gdf::DataFrames.GroupedDataFrame{DataFrames.DataFrame}\n) -> Any\n\n\nSelect one random row from each group in a grouped DataFrame.\n\nArguments\n\ngdf::GroupedDataFrame: A grouped DataFrame created using groupby\n\nReturns\n\nDataFrame: A new DataFrame containing exactly one randomly sampled row from each group\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.random_fasta_record-Tuple{}","page":"Home","title":"Mycelia.random_fasta_record","text":"random_fasta_record(\n;\n    moltype,\n    seed,\n    L\n) -> FASTX.FASTA.Record\n\n\nGenerates a random FASTA record with a specified molecular type and sequence length.\n\nArguments\n\nmoltype::Symbol=:DNA: The type of molecule to generate (:DNA, :RNA, or :AA for amino acids).\nseed: The random seed used for sequence generation (default: a random integer).\nL: The length of the sequence (default: a random integer up to typemax(UInt16)).\n\nReturns\n\nA FASTX.FASTA.Record containing:\nA randomly generated UUID identifier.\nA randomly generated sequence of the specified type.\n\nErrors\n\nThrows an error if moltype is not one of :DNA, :RNA, or :AA.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.random_symmetric_distance_matrix-Tuple{Any}","page":"Home","title":"Mycelia.random_symmetric_distance_matrix","text":"random_symmetric_distance_matrix(n) -> Any\n\n\nGenerate a random symmetric distance matrix of size n×n with zeros on the diagonal.\n\nArguments\n\nn: Positive integer specifying the matrix dimensions\n\nReturns\n\nA symmetric n×n matrix with random values in [0,1), zeros on the diagonal\n\nDetails\n\nThe matrix is symmetric, meaning M[i,j] = M[j,i]\nDiagonal elements M[i,i] are set to 0.0\nOff-diagonal elements are uniformly distributed random values\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rclone_copy-Tuple{Any, Any}","page":"Home","title":"Mycelia.rclone_copy","text":"rclone_copy(source, dest; config, max_attempts, sleep_timer)\n\n\nCopy files between local and remote storage using rclone with automated retry logic.\n\nArguments\n\nsource::String: Source path or remote (e.g. \"local/path\" or \"gdrive:folder\")\ndest::String: Destination path or remote (e.g. \"gdrive:folder\" or \"local/path\")\n\nKeywords\n\nconfig::String=\"\": Optional path to rclone config file\nmax_attempts::Int=3: Maximum number of retry attempts\nsleep_timer::Int=60: Initial sleep duration between retries in seconds (doubles after each attempt)\n\nDetails\n\nUses optimized rclone settings for large files:\n\n2GB chunk size\n1TB upload cutoff\nRate limited to 1 transaction per second\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rclone_list_directories-Tuple{Any}","page":"Home","title":"Mycelia.rclone_list_directories","text":"rclone_list_directories(path) -> Any\n\n\nList all directories at the specified rclone path.\n\nArguments\n\npath::String: Remote path to list directories from (e.g. \"remote:/path/to/dir\")\n\nReturns\n\nVector{String}: Full paths to all directories found at the specified location\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_fastani-Tuple{String}","page":"Home","title":"Mycelia.read_fastani","text":"read_fastani(path::String) -> DataFrames.DataFrame\n\n\nImports results of fastani\n\nReads and processes FastANI output results from a tab-delimited file.\n\nArguments\n\npath::String: Path to the FastANI output file\n\nReturns\n\nDataFrame with columns:\n\nquery: Original query filepath\nquery_identifier: Extracted filename without extension\nreference: Original reference filepath\nreference_identifier: Extracted filename without extension\n%_identity: ANI percentage identity\nfragments_mapped: Number of fragments mapped\ntotal_query_fragments: Total number of query fragments\n\nNotes\n\nExpects tab-delimited input file from FastANI\nAutomatically strips .fasta, .fna, or .fa extensions from filenames\nColumn order is preserved as listed above\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_gff-Tuple{AbstractString}","page":"Home","title":"Mycelia.read_gff","text":"read_gff(gff::AbstractString) -> DataFrames.DataFrame\n\n\nReads a GFF (General Feature Format) file and parses it into a DataFrame.\n\nArguments\n\ngff::AbstractString: Path to the GFF file\n\nReturns\n\nDataFrame: A DataFrame containing the parsed GFF data with standard columns: seqid, source, type, start, end, score, strand, phase, and attributes\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_gff-Tuple{Any}","page":"Home","title":"Mycelia.read_gff","text":"read_gff(gff_io) -> DataFrames.DataFrame\n\n\nRead a GFF (General Feature Format) file into a DataFrame.\n\nArguments\n\ngff_io: An IO stream containing GFF formatted data\n\nReturns\n\nDataFrame: A DataFrame with standard GFF columns:\nseqid: sequence identifier\nsource: feature source\ntype: feature type\nstart: start position (1-based)\nend: end position\nscore: numeric score\nstrand: strand (+, -, or .)\nphase: phase (0, 1, 2 or .)\nattributes: semicolon-separated key-value pairs\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_kraken_report-Tuple{Any}","page":"Home","title":"Mycelia.read_kraken_report","text":"read_kraken_report(kraken_report) -> DataFrames.DataFrame\n\n\nParse a Kraken taxonomic classification report into a structured DataFrame.\n\nArguments\n\nkraken_report::AbstractString: Path to a tab-delimited Kraken report file\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\npercentage_of_fragments_at_or_below_taxon: Percentage of fragments covered\nnumber_of_fragments_at_or_below_taxon: Count of fragments at/below taxon\nnumber_of_fragments_assigned_directly_to_taxon: Direct fragment assignments\nrank: Taxonomic rank\nncbi_taxonid: NCBI taxonomy identifier\nscientific_name: Scientific name (whitespace-trimmed)\n\nNotes\n\nScientific names are automatically stripped of leading/trailing whitespace\nInput file must be tab-delimited\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.read_mmseqs_easy_search-Tuple{Any}","page":"Home","title":"Mycelia.read_mmseqs_easy_search","text":"read_mmseqs_easy_search(mmseqs_file) -> DataFrames.DataFrame\n\n\nRead results from MMSeqs2 easy-search output file into a DataFrame.\n\nArguments\n\nmmseqs_file::String: Path to the tab-delimited output file from MMSeqs2 easy-search\n\nReturns\n\nDataFrame: Contains search results with columns:\nquery: Query sequence identifier\ntarget: Target sequence identifier\nseqIdentity: Sequence identity (0.0-1.0)\nalnLen: Alignment length\nmismatch: Number of mismatches\ngapOpen: Number of gap openings\nqStart: Query start position\nqEnd: Query end position\ntStart: Target start position \ntEnd: Target end position\nevalue: Expected value\nbits: Bit score\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.reverse_translate-Tuple{BioSequences.LongAA}","page":"Home","title":"Mycelia.reverse_translate","text":"reverse_translate(\n    protein_sequence::BioSequences.LongAA\n) -> BioSequences.LongSequence{BioSequences.DNAAlphabet{2}}\n\n\nConvert a protein sequence back to a possible DNA coding sequence using weighted random codon selection.\n\nArguments\n\nprotein_sequence::BioSequences.LongAA: The amino acid sequence to reverse translate\n\nReturns\n\nBioSequences.LongDNA{2}: A DNA sequence that would translate to the input protein sequence\n\nDetails\n\nUses codon usage frequencies to randomly select codons for each amino acid, weighted by their  natural occurrence. Each selected codon is guaranteed to translate back to the original amino acid.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.rolling_centered_avg-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Home","title":"Mycelia.rolling_centered_avg","text":"rolling_centered_avg(data::AbstractArray{T, 1}; window_size)\n\n\nCompute a centered moving average over a vector using a sliding window.\n\nArguments\n\ndata::AbstractVector{T}: Input vector to be averaged\nwindow_size::Int: Size of the sliding window (odd number recommended)\n\nReturns\n\nVector{Float64}: Vector of same length as input containing moving averages\n\nDetails\n\nFor points near the edges, the window is truncated to available data\nWindow is centered on each point, using floor(window_size/2) points on each side\nResult type is always Float64 regardless of input type T\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_blast-Tuple{}","page":"Home","title":"Mycelia.run_blast","text":"run_blast(\n;\n    out_dir,\n    fasta,\n    blast_db,\n    blast_command,\n    force,\n    remote,\n    wait\n)\n\n\nRun a BLAST (Basic Local Alignment Search Tool) command with the specified parameters.\n\nArguments\n\nout_dir::String: The output directory where the BLAST results will be stored.\nfasta::String: The path to the input FASTA file.\nblast_db::String: The path to the BLAST database.\nblast_command::String: The BLAST command to be executed (e.g., blastn, blastp).\nforce::Bool: If true, forces the BLAST command to run even if the output file already exists. Default is false.\nremote::Bool: If true, runs the BLAST command remotely. Default is false.\nwait::Bool: If true, waits for the BLAST command to complete before returning. Default is true.\n\nReturns\n\noutfile::String: The path to the output file containing the BLAST results.\n\nDescription\n\nThis function constructs and runs a BLAST command based on the provided parameters. It creates the necessary output directory, constructs the output file name, and determines whether the BLAST command needs to be run based on the existence and size of the output file. The function supports both local and remote execution of the BLAST command.\n\nIf force is set to true or the output file does not exist or is empty, the BLAST command is executed. The function logs the command being run and measures the time taken for execution. The output file path is returned upon completion.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_blastn-Tuple{}","page":"Home","title":"Mycelia.run_blastn","text":"run_blastn(\n;\n    out_dir,\n    fasta,\n    blast_db,\n    task,\n    force,\n    remote,\n    wait\n)\n\n\nRun the BLASTN (Basic Local Alignment Search Tool for Nucleotides) command with specified parameters.\n\nArguments\n\nout_dir::String: The output directory where the BLASTN results will be saved.\nfasta::String: The path to the input FASTA file containing the query sequences.\nblast_db::String: The path to the BLAST database to search against.\ntask::String: The BLASTN task to perform. Default is \"megablast\".\nforce::Bool: If true, forces the BLASTN command to run even if the output file already exists. Default is false.\nremote::Bool: If true, runs the BLASTN command remotely. Default is false.\nwait::Bool: If true, waits for the BLASTN command to complete before returning. Default is true.\n\nReturns\n\noutfile::String: The path to the output file containing the BLASTN results.\n\nDescription\n\nThis function constructs and runs a BLASTN command based on the provided parameters. It creates an output directory if it doesn't exist, constructs the output file path, and checks if the BLASTN command needs to be run based on the existence and size of the output file. The function supports running the BLASTN command locally or remotely, with options to force re-running and to wait for completion.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_clustal_omega-Tuple{}","page":"Home","title":"Mycelia.run_clustal_omega","text":"run_clustal_omega(; fasta, outfmt)\n\n\nRun Clustal Omega multiple sequence alignment on a FASTA file.\n\nArguments\n\nfasta::String: Path to input FASTA file\noutfmt::String=\"clustal\": Output format for the alignment\n\nReturns\n\nString: Path to the output alignment file\n\nSupported Output Formats\n\n\"fasta\": FASTA format\n\"clustal\": Clustal format\n\"msf\": MSF format  \n\"phylip\": PHYLIP format\n\"selex\": SELEX format\n\"stockholm\": Stockholm format\n\"vienna\": Vienna format\n\nNotes\n\nUses Bioconda to manage the Clustal Omega installation\nCaches results - will return existing output file if already generated\nHandles single sequence files gracefully by returning output path without error\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_ectyper-Tuple{Any}","page":"Home","title":"Mycelia.run_ectyper","text":"run_ectyper(fasta_file) -> Any\n\n\nRun ECTyper for serotyping E. coli genome assemblies.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing assembled genome(s)\n\nReturns\n\nString: Path to output directory containing ECTyper results\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_hifiasm-Tuple{}","page":"Home","title":"Mycelia.run_hifiasm","text":"run_hifiasm(; fastq, outdir)\n\n\nRun the hifiasm genome assembler on PacBio HiFi reads.\n\nArguments\n\nfastq::String: Path to input FASTQ file containing HiFi reads\noutdir::String: Output directory path (default: \"{basename(fastq)}_hifiasm\")\n\nReturns\n\nNamed tuple containing:\n\noutdir::String: Path to output directory\nhifiasm_outprefix::String: Prefix used for hifiasm output files\n\nDetails\n\nAutomatically creates and uses a conda environment with hifiasm\nUses primary assembly mode (–primary) optimized for inbred samples\nSkips assembly if output files already exist at the specified prefix\nUtilizes all available CPU threads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_mlst-Tuple{Any}","page":"Home","title":"Mycelia.run_mlst","text":"run_mlst(fasta_file) -> String\n\n\nRun Multi-Locus Sequence Typing (MLST) analysis on a genome assembly.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing the genome assembly\n\nReturns\n\nPath to the output file containing MLST results (<input>.mlst.out)\n\nDetails\n\nUses the mlst tool from PubMLST to identify sequence types by comparing allelic  profiles of housekeeping genes against curated MLST schemes.\n\nDependencies\n\nRequires Bioconda and the mlst package\nAutomatically sets up conda environment if not present\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_mmseqs_easy_search-Tuple{}","page":"Home","title":"Mycelia.run_mmseqs_easy_search","text":"run_mmseqs_easy_search(\n;\n    query_fasta,\n    target_database,\n    out_dir,\n    outfile,\n    format_output,\n    threads,\n    force\n)\n\n\nRuns the MMseqs2 easy-search command on the given query FASTA file against the target database.\n\nArguments\n\nquery_fasta::String: Path to the query FASTA file.\ntarget_database::String: Path to the target database.\nout_dir::String: Directory to store the output file. Defaults to the directory of the query FASTA file.\noutfile::String: Name of the output file. Defaults to a combination of the query FASTA and target database filenames.\nformat_output::String: Format of the output. Defaults to a predefined set of fields.\nthreads::Int: Number of CPU threads to use. Defaults to the number of CPU threads available.\nforce::Bool: If true, forces the re-generation of the output file even if it already exists. Defaults to false.\n\nReturns\n\noutfile_path::String: Path to the generated output file.\n\nNotes\n\nAdds the mmseqs2 environment using Bioconda if not already present.\nRemoves temporary files created during the process.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_padloc-Tuple{Any}","page":"Home","title":"Mycelia.run_padloc","text":"run_padloc(fasta_file) -> Union{Nothing, Base.Process}\n\n\nRun the 'padloc' tool from the 'padlocbio' conda environment on a given FASTA file.\n\nhttps://doi.org/10.1093/nar/gkab883 https://github.com/padlocbio/padloc\n\nThis function first ensures that the 'padloc' environment is available via Bioconda.  It then attempts to update the 'padloc' database.  If a 'padloc' output file (with a '_padloc.csv' suffix) does not already exist for the input FASTA file,  it runs 'padloc' with the specified FASTA file as input.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_parallel_progress-Tuple{Function, AbstractVector}","page":"Home","title":"Mycelia.run_parallel_progress","text":"run_parallel_progress(\n    f::Function,\n    items::AbstractVector\n) -> Any\n\n\nRun a function f in parallel over a collection of items with a progress meter.\n\nArguments\n\nf::Function: The function to be applied to each item in the collection.\nitems::AbstractVector: A collection of items to be processed.\n\nDescription\n\nThis function creates a progress meter to track the progress of processing each item in the items collection.  It uses multithreading to run the function f on each item in parallel, updating the progress meter after each item is processed.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_prodigal-Tuple{}","page":"Home","title":"Mycelia.run_prodigal","text":"run_prodigal(; fasta_file, out_dir)\n\n\nRun Prodigal gene prediction software on input FASTA file to identify protein-coding genes in metagenomes or single genomes.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing genomic sequences\nout_dir::String=dirname(fasta_file): Directory for output files. Defaults to input file's directory\n\nReturns\n\nNamed tuple containing paths to all output files:\n\nfasta_file: Input FASTA file path\nout_dir: Output directory path  \ngff: Path to GFF format gene predictions\ngene_scores: Path to all potential genes and their scores\nfna: Path to nucleotide sequences of predicted genes\nfaa: Path to protein translations of predicted genes\nstd_out: Path to captured stdout\nstd_err: Path to captured stderr\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_pyrodigal-Tuple{}","page":"Home","title":"Mycelia.run_pyrodigal","text":"run_pyrodigal(; fasta_file, out_dir)\n\n\nRun Pyrodigal gene prediction on a FASTA file using the meta procedure optimized for metagenomic sequences.\n\nPyrodigal is a reimplementation of the Prodigal gene finder, which identifies protein-coding sequences in bacterial and archaeal genomes.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing genomic sequences\nout_dir::String: Output directory path (default: input filename + \"_pyrodigal\")\n\nReturns\n\nNamed tuple containing:\n\nfasta_file: Input FASTA file path\nout_dir: Output directory path\ngff: Path to GFF output file with gene predictions\nfaa: Path to FASTA file with predicted protein sequences \nfna: Path to FASTA file with nucleotide sequences\n\nNotes\n\nUses metagenomic mode (-p meta) optimized for mixed communities\nMasks runs of N nucleotides (-m flag)\nMinimum gene length set to 33bp\nMaximum overlap between genes set to 31bp\nRequires Pyrodigal to be available in a Conda environment\nSkips processing if output files already exist\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_samtools_flagstat","page":"Home","title":"Mycelia.run_samtools_flagstat","text":"run_samtools_flagstat(xam) -> Any\nrun_samtools_flagstat(xam, samtools_flagstat) -> Any\n\n\nGenerate alignment statistics for a SAM/BAM/CRAM file using samtools flagstat.\n\nArguments\n\nxam::AbstractString: Path to input SAM/BAM/CRAM alignment file\nsamtools_flagstat::AbstractString: Output path for flagstat results (default: input_path.samtools-flagstat.txt)\n\nReturns\n\nString: Path to the generated flagstat output file\n\nDetails\n\nRuns samtools flagstat to calculate statistics on the alignment file, including:\n\nTotal reads\nSecondary alignments\nSupplementary alignments  \nDuplicates\nMapped/unmapped reads\nProper pairs\nRead 1/2 counts\n\nRequirements\n\nRequires samtools to be available via Bioconda\nInput file must be in SAM, BAM or CRAM format\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.run_transterm-Tuple{}","page":"Home","title":"Mycelia.run_transterm","text":"run_transterm(; fasta, gff)\n\n\nRun TransTermHP to predict rho-independent transcription terminators in DNA sequences.\n\nArguments\n\nfasta: Path to input FASTA file containing DNA sequences\ngff: Optional path to GFF annotation file. If provided, improves prediction accuracy\n\nReturns\n\nString: Path to output file containing TransTermHP predictions\n\nDetails\n\nUses Conda environment 'transtermhp' for execution\nAutomatically generates coordinate file from FASTA or GFF input\nRemoves temporary coordinate file after completion\nRequires Mycelia's Conda setup\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.run_trnascan-Tuple{}","page":"Home","title":"Mycelia.run_trnascan","text":"run_trnascan(; fna_file, outdir)\n\n\nRun tRNAscan-SE to identify and annotate transfer RNA genes in the provided sequence file.\n\nArguments\n\nfna_file::String: Path to input FASTA nucleotide file\noutdir::String: Output directory path (default: inputfilepath + \"_trnascan\")\n\nReturns\n\nString: Path to the output directory containing tRNAscan-SE results\n\nOutput Files\n\nCreates the following files in outdir:\n\n*.trnascan.out: Main output with tRNA predictions\n*.trnascan.bed: BED format coordinates\n*.trnascan.fasta: FASTA sequences of predicted tRNAs\n*.trnascan.struct: Secondary structure predictions\n*.trnascan.stats: Summary statistics\n*.trnascan.log: Program execution log\n\nNotes\n\nUses the general tRNA model (-G flag) suitable for all domains of life\nAutomatically sets up tRNAscan-SE via Bioconda\nSkips processing if output directory contains files\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.samtools_index_fasta-Tuple{}","page":"Home","title":"Mycelia.samtools_index_fasta","text":"samtools_index_fasta(; fasta)\n\n\nCreates an index file (.fai) for a FASTA reference sequence using samtools.\n\nThe FASTA index allows efficient random access to the reference sequence. This is  required by many bioinformatics tools that need to quickly fetch subsequences  from the reference.\n\nArguments\n\nfasta: Path to the input FASTA file\n\nSide Effects\n\nCreates a {fasta}.fai index file in the same directory as input\nInstalls samtools via conda if not already present\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.save_graph-Tuple{Graphs.AbstractGraph, String}","page":"Home","title":"Mycelia.save_graph","text":"save_graph(\n    graph::Graphs.AbstractGraph,\n    outfile::String\n) -> String\n\n\nSaves the given graph to a file in JLD2 format.\n\nArguments\n\ngraph::Graphs.AbstractGraph: The graph to be saved.\noutfile::String: The name of the output file. If the file extension is not .jld2, it will be appended automatically.\n\nReturns\n\nString: The name of the output file with the .jld2 extension.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.save_matrix_jld2-Tuple{}","page":"Home","title":"Mycelia.save_matrix_jld2","text":"save_matrix_jld2(; matrix, filename)\n\n\nSaves a matrix to a JLD2 file format.\n\nArguments\n\nmatrix: The matrix to be saved\nfilename: String path where the file should be saved\n\nReturns\n\nThe filename string that was used to save the matrix\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.scg_sbatch-Tuple{}","page":"Home","title":"Mycelia.scg_sbatch","text":"scg_sbatch(\n;\n    job_name,\n    mail_user,\n    mail_type,\n    logdir,\n    partition,\n    account,\n    nodes,\n    ntasks,\n    time,\n    cpus_per_task,\n    mem_gb,\n    cmd\n)\n\n\nSubmit a job to SLURM using sbatch with specified parameters.\n\nArguments\n\njob_name::String: Name identifier for the SLURM job\nmail_user::String: Email address for job notifications\nmail_type::String: Type of mail notifications (default: \"ALL\")\nlogdir::String: Directory for error and output logs (default: \"~/workspace/slurmlogs\")\npartition::String: SLURM partition to submit job to\naccount::String: Account to charge for compute resources\nnodes::Int: Number of nodes to allocate (default: 1)\nntasks::Int: Number of tasks to run (default: 1)\ntime::String: Maximum wall time in format \"days-hours:minutes:seconds\" (default: \"1-00:00:00\")\ncpus_per_task::Int: CPUs per task (default: 1)\nmem_gb::Int: Memory in GB, defaults to 32GB per CPU\ncmd::String: Command to execute\n\nReturns\n\nBool: Returns true if submission succeeds\n\nNotes\n\nFunction includes 5-second delays before and after submission\nMemory is automatically scaled with CPU count\nLog files are named with job ID (%j) and job name (%x)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.seq2sha256-Tuple{AbstractString}","page":"Home","title":"Mycelia.seq2sha256","text":"seq2sha256(seq::AbstractString) -> String\n\n\nCompute the SHA-256 hash of a sequence string.\n\nArguments\n\nseq::AbstractString: Input sequence to be hashed\n\nReturns\n\nString: Hexadecimal representation of the SHA-256 hash\n\nDetails\n\nThe input sequence is converted to uppercase before hashing.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.seq2sha256-Tuple{BioSequences.BioSequence}","page":"Home","title":"Mycelia.seq2sha256","text":"seq2sha256(seq::BioSequences.BioSequence) -> String\n\n\nConvert a biological sequence to its SHA256 hash value.\n\nCalculates a cryptographic hash of the sequence by first converting it to a string representation. This method dispatches to the string version of seq2sha256.\n\nArguments\n\nseq::BioSequences.BioSequence: The biological sequence to hash\n\nReturns\n\nString: A 64-character hexadecimal string representing the SHA256 hash\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sequence_to_stranded_path-Tuple{Any, Any}","page":"Home","title":"Mycelia.sequence_to_stranded_path","text":"sequence_to_stranded_path(\n    stranded_kmers,\n    sequence\n) -> Vector{Pair{Int64, Bool}}\n\n\nConvert a DNA sequence into a path through a collection of stranded k-mers.\n\nArguments\n\nstranded_kmers: Collection of unique k-mers representing possible path vertices\nsequence: Input DNA sequence to convert to a path\n\nReturns\n\nVector of Pair{Int,Bool} where:\n\nFirst element (Int) is the index of the k-mer in stranded_kmers\nSecond element (Bool) indicates orientation (true=forward, false=reverse)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.setup_taxonkit_taxonomy-Tuple{}","page":"Home","title":"Mycelia.setup_taxonkit_taxonomy","text":"setup_taxonkit_taxonomy() -> String\n\n\nDownloads and extracts the NCBI taxonomy database required for taxonkit operations.\n\nDownloads taxdump.tar.gz from NCBI FTP server and extracts it to ~/.taxonkit/. This is a prerequisite for using taxonkit-based taxonomy functions.\n\nRequirements\n\nWorking internet connection\nSufficient disk space (~100MB)\ntaxonkit must be installed separately\n\nReturns\n\nNothing\n\nThrows\n\nSystemError if download fails or if unable to create directory\nErrorException if tar extraction fails\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sha256_file-Tuple{AbstractString}","page":"Home","title":"Mycelia.sha256_file","text":"sha256_file(file::AbstractString) -> String\n\n\nCompute the SHA-256 hash of the contents of a file.\n\nArguments\n\nfile::AbstractString: The path to the file for which the SHA-256 hash is to be computed.\n\nReturns\n\nString: The SHA-256 hash of the file contents, represented as a hexadecimal string.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.showall_blastdbs-Tuple{}","page":"Home","title":"Mycelia.showall_blastdbs","text":"showall_blastdbs(; source) -> Any\n\n\nDisplay available BLAST databases from specified source.\n\nArguments\n\nsource::String=\"ncbi\": Database source (default: \"ncbi\")\n\nReturns\n\nDataFrame: Table of available BLAST databases with columns:\nNAME: Database name\nSIZE (GB): Database size\nLAST_UPDATED: Update date\nand other metadata fields\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_nanopore_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_nanopore_reads","text":"simulate_nanopore_reads(; fasta, quantity, outfile)\n\n\nSimulate Oxford Nanopore sequencing reads using the Badread tool with 2023 error models.\n\nArguments\n\nfasta::String: Path to input reference FASTA file\nquantity::String: Either fold coverage (e.g. \"50x\") or total bases to sequence (e.g. \"1000000\")\noutfile::String: Output path for gzipped FASTQ file. Defaults to input filename with modified extension\n\nReturns\n\nString: Path to the generated output FASTQ file\n\nSee also: simulate_pacbio_reads, simulate_nearly_perfect_long_reads, simulate_short_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_nearly_perfect_long_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_nearly_perfect_long_reads","text":"simulate_nearly_perfect_long_reads()\n\n\nSimulate high-quality long reads with minimal errors using Badread.\n\nArguments\n\nreference::String: Path to reference FASTA file\nquantity::String: Coverage depth (e.g. \"50x\") or total bases (e.g. \"1000000\")\nlength_mean::Int=40000: Mean read length\nlength_sd::Int=20000: Standard deviation of read length\n\nReturns\n\nVector of simulated reads in FASTQ format\n\nDetails\n\nGenerates nearly perfect long reads by setting error rates and artifacts to minimum values. Uses ideal quality scores and disables common sequencing artifacts like chimeras and adapters.\n\nSee also: simulate_pacbio_reads, simulate_nanopore_reads, simulate_short_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_pacbio_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_pacbio_reads","text":"simulate_pacbio_reads(; fasta, quantity, outfile)\n\n\nSimulate PacBio HiFi reads using the Badread error model.\n\nArguments\n\nfasta::String: Path to input FASTA file containing reference sequence\nquantity::String: Coverage depth (e.g. \"50x\") or total bases (e.g. \"1000000\") - NOT TOTAL READS\noutfile::String: Output filepath for simulated reads. Defaults to input filename with \".badread.pacbio2021.{quantity}.fq.gz\" suffix\n\nReturns\n\nString: Path to the generated output file\n\nNotes\n\nRequires Badread tool from Bioconda\nUses PacBio 2021 error and quality score models\nAverage read length ~15kb\nOutput is gzipped FASTQ format\n\nSee also: simulate_nanopore_reads, simulate_nearly_perfect_long_reads, simulate_short_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_short_reads-Tuple{}","page":"Home","title":"Mycelia.simulate_short_reads","text":"simulate_short_reads(; in_fasta, coverage, outbase)\n\n\nSimulate Illumina paired-end short reads from a FASTA file using ART simulator.\n\nArguments\n\nin_fasta::String: Input FASTA file path\ncoverage::Number: Desired read coverage/depth\noutbase::String: Prefix for output files (default: \"in_fastaart{coverage}x.\")\n\nOutputs\n\nGenerates two gzipped FASTQ files:\n\n${outbase}1.fq.gz: Forward reads\n${outbase}2.fq.gz: Reverse reads\n\nDetails\n\nUses ART Illumina with the following parameters:\n\nRead length: 150bp\nFragment length: 500bp (SD: 10bp)\nSequencing system: HiSeq 2500 (HS25)\n\nDependencies\n\nRequires ART simulator (automatically installed via Bioconda)\n\nSee also: simulate_nanopore_reads, simulate_nearly_perfect_long_reads, simulate_pacbio_reads\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_variants-Tuple{FASTX.FASTA.Record}","page":"Home","title":"Mycelia.simulate_variants","text":"simulate_variants(\n    fasta_record::FASTX.FASTA.Record;\n    n_variants,\n    window_size,\n    variant_size_disbribution,\n    variant_type_likelihoods\n) -> Any\n\n\nSimulates genetic variants (substitutions, insertions, deletions, inversions) in a DNA sequence.\n\nArguments\n\nfasta_record: Input DNA sequence in FASTA format\n\nKeywords\n\nn_variants=√(sequence_length): Number of variants to generate\nwindow_size=sequence_length/n_variants: Size of windows for variant placement\nvariant_size_disbribution=Geometric(1/√window_size): Distribution for variant sizes\nvariant_type_likelihoods: Vector of pairs mapping variant types to probabilities\n:substitution => 10⁻¹\n:insertion => 10⁻² \n:deletion => 10⁻²\n:inversion => 10⁻²\n\nReturns\n\nDataFrame in VCF format containing simulated variants with columns: CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO, FORMAT, SAMPLE\n\nNotes\n\nVariants are distributed across sequence windows to ensure spread\nVariant sizes are capped by window size\nEquivalent variants are filtered out\nFILTER column indicates variant type\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.simulate_variants-Tuple{String}","page":"Home","title":"Mycelia.simulate_variants","text":"simulate_variants(fasta_file::String) -> String\n\n\nSimulates genetic variants from sequences in a FASTA file and generates corresponding VCF records.\n\nArguments\n\nfasta_file::String: Path to input FASTA file containing sequences to analyze\n\nDetails\n\nProcesses each record in the input FASTA file\nGenerates simulated variants for each sequence\nCreates a VCF file with the same base name as input file (.vcf extension)\nUpdates sequences with simulated variants in a new FASTA file (.vcf.fna extension)\n\nReturns\n\nPath to the modified FASTA file containing sequences with simulated variants\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.sort_fastq","page":"Home","title":"Mycelia.sort_fastq","text":"sort_fastq(input_fastq) -> String\nsort_fastq(input_fastq, output_fastq) -> Any\n\n\nThis turns a 4-line FASTQ entry into a single tab separated line, adds a column with the length of each read, passes it to Unix sort, removes the length column, and converts it back into a FASTQ file.\n\nsorts longest to shortest!!\n\nhttp://thegenomefactory.blogspot.com/2012/11/sorting-fastq-files-by-sequence-length.html\n\n\n\n\n\n","category":"function"},{"location":"#Mycelia.split_gff_attributes_into_columns-Tuple{Any}","page":"Home","title":"Mycelia.split_gff_attributes_into_columns","text":"split_gff_attributes_into_columns(gff_df) -> Any\n\n\nTakes a GFF (General Feature Format) DataFrame and expands the attributes column into separate columns.\n\nArguments\n\ngff_df::DataFrame: A DataFrame containing GFF data with an 'attributes' column formatted as key-value pairs separated by semicolons (e.g., \"ID=gene1;Name=BRCA1;Type=gene\")\n\nReturns\n\nDataFrame: The input DataFrame with additional columns for each attribute key found in the 'attributes' column\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.subsample_reads_seqkit-Tuple{}","page":"Home","title":"Mycelia.subsample_reads_seqkit","text":"subsample_reads_seqkit(\n;\n    in_fastq,\n    out_fastq,\n    n_reads,\n    proportion_reads\n)\n\n\nSubsample reads from a FASTQ file using seqkit.\n\nArguments\n\nin_fastq::String: Path to input FASTQ file\nout_fastq::String=\"\": Path to output FASTQ file. If empty, auto-generated based on input filename\nn_reads::Union{Missing,Int}=missing: Number of reads to sample\nproportion_reads::Union{Missing,Float64}=missing: Proportion of reads to sample (0.0-1.0)\n\nReturns\n\nString: Path to the output FASTQ file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.system_mem_to_minimap_index_size-Tuple{}","page":"Home","title":"Mycelia.system_mem_to_minimap_index_size","text":"system_mem_to_minimap_index_size(\n;\n    system_mem_gb,\n    denominator\n)\n\n\nCalculate appropriate minimap index size based on available system memory.\n\nConverts total system memory to a recommended minimap index size by dividing the available memory by a denominator factor. Returns the size as a string with 'G' suffix.\n\nArguments\n\nsystem_mem_gb::Number: Total system memory in gigabytes\ndenominator::Number=DEFAULT_MINIMAP_DENOMINATOR: Divisor to scale down memory allocation\n\nReturns\n\nString: Formatted memory size string (e.g. \"4G\")\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.system_overview-Tuple{}","page":"Home","title":"Mycelia.system_overview","text":"system_overview(\n;\n    path\n) -> @NamedTuple{system_threads::Int64, julia_threads::Int64, total_memory::String, available_memory::String, occupied_memory::String, total_storage::String, available_storage::String, occupied_storage::String}\n\n\nParse a JSONL (JSON Lines) file into a vector of dictionaries.\n\nArguments\n\nfilepath::String: Path to the JSONL file to parse\n\nReturns\n\nVector{Dict{String, Any}}: Vector containing parsed JSON objects, one per line\n\nDescription\n\nReads a JSONL file line by line, parsing each line as a separate JSON object. Uses pre-allocation and progress tracking for efficient processing of large files.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.tar_extract-Tuple{}","page":"Home","title":"Mycelia.tar_extract","text":"tar_extract(; tarchive, directory)\n\n\nExtract contents of a gzipped tar archive file to a specified directory.\n\nArguments\n\ntarchive::AbstractString: Path to the .tar.gz file to extract\ndirectory::AbstractString=dirname(tarchive): Target directory for extraction (defaults to the archive's directory)\n\nReturns\n\nAbstractString: Path to the directory where contents were extracted\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2lca-Tuple{Vector{Int64}}","page":"Home","title":"Mycelia.taxids2lca","text":"taxids2lca(ids::Vector{Int64}) -> Int64\n\n\nCalculate the Lowest Common Ancestor (LCA) taxonomic ID for a set of input taxonomic IDs.\n\nArguments\n\nids::Vector{Int}: Vector of NCBI taxonomic IDs\n\nReturns\n\nInt: The taxonomic ID of the lowest common ancestor\n\nDetails\n\nUses taxonkit to compute the LCA. Automatically sets up the required taxonomy database  if not already present in ~/.taxonkit/.\n\nDependencies\n\nRequires taxonkit (installed via Bioconda)\nRequires taxonomy database (downloaded automatically if missing)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2ncbi_taxonomy_table-Tuple{AbstractVector{Int64}}","page":"Home","title":"Mycelia.taxids2ncbi_taxonomy_table","text":"taxids2ncbi_taxonomy_table(\n    taxids::AbstractVector{Int64}\n) -> DataFrames.DataFrame\n\n\nConvert a vector of NCBI taxonomy IDs into a detailed taxonomy table using NCBI Datasets CLI.\n\nArguments\n\ntaxids::AbstractVector{Int}: Vector of NCBI taxonomy IDs to query\n\nReturns\n\nDataFrame: Table containing taxonomy information with columns including:\ntax_id\nspecies\ngenus\nfamily\norder\nclass\nphylum\nkingdom\n\nDependencies\n\nRequires ncbi-datasets-cli Conda package (automatically installed if missing)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2taxonkit_summarized_lineage_table-Tuple{AbstractVector{Int64}}","page":"Home","title":"Mycelia.taxids2taxonkit_summarized_lineage_table","text":"taxids2taxonkit_summarized_lineage_table(\n    taxids::AbstractVector{Int64}\n) -> DataFrames.DataFrame\n\n\nConvert a vector of taxonomy IDs to a summarized lineage table using taxonkit.\n\nArguments\n\ntaxids::AbstractVector{Int}: Vector of NCBI taxonomy IDs\n\nReturns\n\nDataFrame with the following columns:\n\ntaxid: Original input taxonomy ID\nspecies_taxid, species: Species level taxonomy ID and name\ngenus_taxid, genus: Genus level taxonomy ID and name  \nfamily_taxid, family: Family level taxonomy ID and name\nsuperkingdom_taxid, superkingdom: Superkingdom level taxonomy ID and name\n\nMissing values are used when a taxonomic rank is not available.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxids2taxonkit_taxid2lineage_ranks-Tuple{AbstractVector{Int64}}","page":"Home","title":"Mycelia.taxids2taxonkit_taxid2lineage_ranks","text":"taxids2taxonkit_taxid2lineage_ranks(\n    taxids::AbstractVector{Int64}\n) -> Dict{Int64, Dict{String, @NamedTuple{lineage::String, taxid::Union{Missing, Int64}}}}\n\n\nConvert taxonomic IDs to a structured lineage rank mapping.\n\nTakes a vector of taxonomic IDs and returns a nested dictionary mapping each input taxid  to its complete taxonomic lineage information. For each taxid, creates a dictionary where:\n\nKeys are taxonomic ranks (e.g., \"species\", \"genus\", \"family\")\nValues are NamedTuples containing:\nlineage::String: The taxonomic name at that rank\ntaxid::Union{Int, Missing}: The corresponding taxonomic ID (if available)\n\nExcludes \"no rank\" entries from the final output.\n\nReturns:     Dict{Int, Dict{String, NamedTuple{(:lineage, :taxid), Tuple{String, Union{Int, Missing}}}}}\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.taxonomic_id_to_children-Tuple{Any}","page":"Home","title":"Mycelia.taxonomic_id_to_children","text":"taxonomic_id_to_children(\n    tax_id;\n    DATABASE_ID,\n    USERNAME,\n    PASSWORD\n)\n\n\nQuery Neo4j database to find all descendant taxonomic IDs for a given taxonomic ID.\n\nArguments\n\ntax_id: Source taxonomic ID to find children for\nDATABASE_ID: Neo4j database identifier (required)\nUSERNAME: Neo4j database username (default: \"neo4j\")\nPASSWORD: Neo4j database password (required)\n\nReturns\n\nVector{Int}: Sorted array of unique child taxonomic IDs\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.translate_nucleic_acid_fasta-Tuple{Any, Any}","page":"Home","title":"Mycelia.translate_nucleic_acid_fasta","text":"translate_nucleic_acid_fasta(\n    fasta_nucleic_acid_file,\n    fasta_amino_acid_file\n) -> Any\n\n\nTranslates nucleic acid sequences from a FASTA file into amino acid sequences.\n\nArguments\n\nfasta_nucleic_acid_file::String: Path to input FASTA file containing nucleic acid sequences\nfasta_amino_acid_file::String: Path where the translated amino acid sequences will be written\n\nReturns\n\nString: Path to the output FASTA file containing translated amino acid sequences\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.transterm_output_to_gff-Tuple{Any}","page":"Home","title":"Mycelia.transterm_output_to_gff","text":"transterm_output_to_gff(transterm_output) -> Any\n\n\nConvert TransTerm terminator predictions output to GFF3 format.\n\nParses TransTerm output and generates a standardized GFF3 file with the following transformations:\n\nSets source field to \"transterm\"\nSets feature type to \"terminator\"  \nConverts terminator IDs to GFF attributes\nRenames fields to match GFF3 spec\n\nArguments\n\ntransterm_output::String: Path to the TransTerm output file\n\nReturns\n\nString: Path to the generated GFF3 file (original filename with .gff extension)\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.trim_galore-Tuple{}","page":"Home","title":"Mycelia.trim_galore","text":"trim_galore(\n;\n    outdir,\n    identifier\n) -> Union{Nothing, Base.Process}\n\n\nTrim paired-end FASTQ reads using Trim Galore, a wrapper around Cutadapt and FastQC.\n\nArguments\n\noutdir::String: Output directory containing input FASTQ files\nidentifier::String: Prefix for input/output filenames\n\nInput files\n\nExpects paired FASTQ files in outdir named:\n\n{identifier}_1.fastq.gz (forward reads)\n{identifier}_2.fastq.gz (reverse reads)\n\nOutput files\n\nCreates trimmed reads in outdir/trim_galore/:\n\n{identifier}_1_val_1.fq.gz (trimmed forward reads)\n{identifier}_2_val_2.fq.gz (trimmed reverse reads)\n\nDependencies\n\nRequires trim_galore conda environment:\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.trim_galore_paired-Tuple{}","page":"Home","title":"Mycelia.trim_galore_paired","text":"trim_galore_paired(; forward_reads, reverse_reads, outdir)\n\n\nTrim paired-end FASTQ reads using Trim Galore, a wrapper around Cutadapt and FastQC.\n\nArguments\n\nforward_reads::String: Path to forward reads FASTQ file\nreverse_reads::String: Path to reverse reads FASTQ file\noutdir::String: Output directory for trimmed files\n\nReturns\n\nTuple{String, String}: Paths to trimmed forward and reverse read files\n\nDependencies\n\nRequires trim_galore conda environment:\n\nmamba create -n trim_galore -c bioconda trim_galore\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.type_to_string-Tuple{AbstractString}","page":"Home","title":"Mycelia.type_to_string","text":"type_to_string(T::AbstractString) -> Any\n\n\nConverts an AbstractString type to its string representation.\n\nArguments\n\nT::AbstractString: The string type to convert\n\nReturns\n\nA string representation of the input type\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.type_to_string-Tuple{Any}","page":"Home","title":"Mycelia.type_to_string","text":"type_to_string(T) -> Any\n\n\nConvert a type to its string representation, with special handling for Kmer types.\n\nArguments\n\nT: The type to convert to string\n\nReturns\n\nString representation of the type\nFor Kmer types: Returns \"Kmers.DNAKmer{K}\" where K is the kmer length\nFor other types: Returns the standard string representation\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.update_bioconda_env-Tuple{Any}","page":"Home","title":"Mycelia.update_bioconda_env","text":"update_bioconda_env(pkg) -> Base.Process\n\n\nUpdate a package and its dependencies in its dedicated Conda environment.\n\nArguments\n\npkg::String: Name of the package/environment to update\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.update_fasta_with_vcf-Tuple{}","page":"Home","title":"Mycelia.update_fasta_with_vcf","text":"update_fasta_with_vcf(; in_fasta, vcf_file, out_fasta)\n\n\nApply variants from a VCF file to a reference FASTA sequence.\n\nArguments\n\nin_fasta: Path to input reference FASTA file\nvcf_file: Path to input VCF file containing variants\nout_fasta: Optional output path for modified FASTA. Defaults to replacing '.vcf' with '.normalized.vcf.fna'\n\nDetails\n\nNormalizes indels in the VCF using bcftools norm\nApplies variants to the reference sequence using bcftools consensus\nHandles temporary files and compression with bgzip/tabix\n\nRequirements\n\nRequires bioconda packages: htslib, tabix, bcftools\n\nReturns\n\nPath to the output FASTA file containing the modified sequence\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.update_gff_with_mmseqs-Tuple{Any, Any}","page":"Home","title":"Mycelia.update_gff_with_mmseqs","text":"update_gff_with_mmseqs(gff_file, mmseqs_file)\n\n\nUpdate GFF annotations with protein descriptions from MMseqs2 search results.\n\nArguments\n\ngff_file::String: Path to input GFF3 format file\nmmseqs_file::String: Path to MMseqs2 easy-search output file\n\nReturns\n\nDataFrame: Modified GFF table with updated attribute columns containing protein descriptions\n\nDetails\n\nTakes sequence matches from MMseqs2 and adds their descriptions as 'label' and 'product'  attributes in the GFF file. Only considers top hits from MMseqs2 results. Preserves existing  GFF attributes while prepending new annotations.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_edge_type_over_url_from_graph-Tuple{}","page":"Home","title":"Mycelia.upload_edge_type_over_url_from_graph","text":"upload_edge_type_over_url_from_graph(\n;\n    src_type,\n    dst_type,\n    edge_type,\n    graph,\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE,\n    window_size\n)\n\n\nUpload edges of a specific type from a MetaGraph to a Neo4j database, batching uploads in windows.\n\nArguments\n\nsrc_type: Type of source nodes to filter\ndst_type: Type of destination nodes to filter  \nedge_type: Type of edges to upload\ngraph: MetaGraph containing the nodes and edges\nADDRESS: Neo4j server URL\nUSERNAME: Neo4j username (default: \"neo4j\")\nPASSWORD: Neo4j password\nDATABASE: Neo4j database name (default: \"neo4j\")\nwindow_size: Number of edges to upload in each batch (default: 100)\n\nDetails\n\nFilters edges based on source, destination and edge types\nPreserves all edge properties except :TYPE when uploading\nUses MERGE operations to avoid duplicate nodes/relationships\nUploads are performed in batches for better performance\nProgress is shown via ProgressMeter\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_node_over_api-Tuple{Any, Any}","page":"Home","title":"Mycelia.upload_node_over_api","text":"upload_node_over_api(\n    graph,\n    v;\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE\n)\n\n\nUpload a single node from a MetaGraph to a Neo4j database using the HTTP API.\n\nArguments\n\ngraph: MetaGraph containing the node to be uploaded\nv: Vertex identifier in the graph\nADDRESS: Neo4j server address (e.g. \"http://localhost:7474\")\nUSERNAME: Neo4j authentication username (default: \"neo4j\")\nPASSWORD: Neo4j authentication password\nDATABASE: Target Neo4j database name (default: \"neo4j\")\n\nDetails\n\nGenerates and executes a Cypher MERGE command using the node's properties. The node's :TYPE  and :identifier properties are used for node labeling, while other non-empty properties  are added as node properties.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_node_table-Tuple{}","page":"Home","title":"Mycelia.upload_node_table","text":"upload_node_table(\n;\n    table,\n    window_size,\n    address,\n    password,\n    username,\n    database,\n    neo4j_import_dir\n)\n\n\nUpload a DataFrame to Neo4j as nodes in batched windows.\n\nArguments\n\ntable::DataFrame: Input DataFrame where each row becomes a node. Must contain a \"TYPE\" column.\naddress::String: Neo4j server address (e.g. \"bolt://localhost:7687\")\npassword::String: Neo4j database password\nneo4j_import_dir::String: Directory path accessible to Neo4j for importing files\nwindow_size::Int=1000: Number of rows to process in each batch\nusername::String=\"neo4j\": Neo4j database username\ndatabase::String=\"neo4j\": Target Neo4j database name\n\nNotes\n\nAll rows must have the same node type (specified in \"TYPE\" column)\nColumn names become node properties\nRequires write permissions on neo4jimportdir\nLarge tables are processed in batches of size window_size\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_node_type_over_url_from_graph-Tuple{}","page":"Home","title":"Mycelia.upload_node_type_over_url_from_graph","text":"upload_node_type_over_url_from_graph(\n;\n    node_type,\n    graph,\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE,\n    window_size\n)\n\n\nUpload nodes of a specific type from a graph to a Neo4j database using MERGE operations.\n\nArguments\n\nnode_type: The type label for the nodes to upload\ngraph: Source MetaGraph containing the nodes\nADDRESS: Neo4j server address (e.g. \"bolt://localhost:7687\")\nPASSWORD: Neo4j database password\nUSERNAME=\"neo4j\": Neo4j username (defaults to \"neo4j\")\nDATABASE=\"neo4j\": Target Neo4j database name (defaults to \"neo4j\")\nwindow_size=100: Number of nodes to upload in each batch (defaults to 100)\n\nDetails\n\nPerforms batched uploads of nodes using Neo4j MERGE operations. Node properties are  automatically extracted from the graph vertex properties, excluding the 'TYPE' property.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_nodes_over_api-Tuple{Any}","page":"Home","title":"Mycelia.upload_nodes_over_api","text":"upload_nodes_over_api(\n    graph;\n    ADDRESS,\n    USERNAME,\n    PASSWORD,\n    DATABASE\n)\n\n\nUploads all nodes from the given graph to a specified API endpoint.\n\nArguments\n\ngraph: The graph containing the nodes to be uploaded.\nADDRESS: The API endpoint address.\nUSERNAME: The username for authentication (default: \"neo4j\").\nPASSWORD: The password for authentication.\nDATABASE: The database name (default: \"neo4j\").\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.upload_nodes_to_neo4j-Tuple{}","page":"Home","title":"Mycelia.upload_nodes_to_neo4j","text":"upload_nodes_to_neo4j(\n;\n    graph,\n    address,\n    username,\n    password,\n    format,\n    database,\n    neo4j_import_directory\n)\n\n\nUpload all nodes from a MetaGraph to a Neo4j database, processing each unique node type separately.\n\nArguments\n\ngraph: A MetaGraph containing nodes to be uploaded\naddress: Neo4j server address (e.g., \"bolt://localhost:7687\")\nusername: Neo4j authentication username (default: \"neo4j\")\npassword: Neo4j authentication password\nformat: Data format for upload (default: \"auto\")\ndatabase: Target Neo4j database name (default: \"neo4j\")\nneo4j_import_directory: Path to Neo4j's import directory for bulk loading\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.vcat_with_missing-Tuple{Vararg{DataFrames.AbstractDataFrame}}","page":"Home","title":"Mycelia.vcat_with_missing","text":"vcat_with_missing(\n    dfs::DataFrames.AbstractDataFrame...\n) -> Union{DataFrames.DataFrame, Vector{Any}}\n\n\nVertically concatenate DataFrames with different column structures by automatically handling missing values.\n\nArguments\n\ndfs: Variable number of DataFrames to concatenate vertically\n\nReturns\n\nDataFrame: Combined DataFrame containing all rows and columns from input DataFrames,  with missing values where columns didn't exist in original DataFrames\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.visualize_genome_coverage-Tuple{Any}","page":"Home","title":"Mycelia.visualize_genome_coverage","text":"visualize_genome_coverage(coverage_table) -> Any\n\n\nCreates a multi-panel visualization of genome coverage across chromosomes.\n\nArguments\n\ncoverage_table: DataFrame containing columns \"chromosome\" and \"coverage\" with genomic coverage data\n\nReturns\n\nPlots.Figure: A composite figure with coverage plots for each chromosome\n\nDetails\n\nGenerates one subplot per chromosome, arranged vertically. Each subplot shows the coverage  distribution across genomic positions for that chromosome.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.viterbi_maximum_likelihood_traversals-Tuple{Any}","page":"Home","title":"Mycelia.viterbi_maximum_likelihood_traversals","text":"viterbi_maximum_likelihood_traversals(\n    stranded_kmer_graph;\n    error_rate,\n    verbosity\n) -> Vector{FASTX.FASTA.Record}\n\n\nFinds maximum likelihood paths through a stranded k-mer graph using the Viterbi algorithm to correct sequencing errors.\n\nArguments\n\nstranded_kmer_graph: A directed graph where vertices represent k-mers and edges represent overlaps\nerror_rate::Float64: Expected per-base error rate (default: 1/(k+1)). Must be < 0.5\nverbosity::String: Output detail level (\"debug\", \"reads\", or \"dataset\")\n\nReturns\n\nVector of FASTX.FASTA.Record containing error-corrected sequences\n\nDetails\n\nUses dynamic programming to find most likely path through k-mer graph\nAccounts for matches, mismatches, insertions and deletions\nState likelihoods based on k-mer coverage counts\nTransition probabilities derived from error rate\nProgress tracking based on verbosity level\n\nNotes\n\nError rate should be probability of error (e.g. 0.01 for 1%), not accuracy\nHigher verbosity levels (\"debug\", \"reads\") provide detailed path finding information\n\"dataset\" verbosity shows only summary statistics\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.wcss-Tuple{Any}","page":"Home","title":"Mycelia.wcss","text":"wcss(clustering_result) -> Any\n\n\nCalculate the Within-Cluster Sum of Squares (WCSS) for a clustering result.\n\nArguments\n\nclustering_result: A clustering result object containing:\ncounts: Vector with number of points in each cluster\nassignments: Vector of cluster assignments for each point\ncosts: Vector of distances/costs from each point to its cluster center\n\nReturns\n\nFloat64: The total within-cluster sum of squared distances\n\nDescription\n\nWCSS measures the compactness of clusters by summing the squared distances  between each data point and its assigned cluster center.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_fasta-Tuple{}","page":"Home","title":"Mycelia.write_fasta","text":"write_fasta(; outfile, records, gzip)\n\n\nWrites FASTA records to a file, optionally gzipped.\n\nArguments\n\noutfile::AbstractString: Path to the output FASTA file.  Will append \".gz\" if gzip is true.\nrecords::Vector{FASTX.FASTA.Record}: A vector of FASTA records.\ngzip::Bool=false: Whether to compress the output with gzip.\n\nReturns\n\noutfile::String: The path to the output FASTA file (including \".gz\" if applicable).\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_gff-Tuple{}","page":"Home","title":"Mycelia.write_gff","text":"write_gff(; gff, outfile)\n\n\nWrite GFF (General Feature Format) data to a tab-delimited file.\n\nArguments\n\ngff: DataFrame/Table containing GFF formatted data\noutfile: String path where the output file should be written\n\nReturns\n\nString: Path to the written output file\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.write_vcf_table-Tuple{}","page":"Home","title":"Mycelia.write_vcf_table","text":"write_vcf_table(; vcf_file, vcf_table, fasta_file)\n\n\nWrite variant data to a VCF v4.3 format file.\n\nArguments\n\nvcf_file::String: Output path for the VCF file\nvcf_table::DataFrame: Table containing variant data with standard VCF columns\nfasta_file::String: Path to the reference genome FASTA file\n\nDetails\n\nAutomatically filters out equivalent variants where REF == ALT. Includes standard VCF headers for substitutions, insertions, deletions, and inversions. Adds GT (Genotype) and GQ (Genotype Quality) format fields.\n\n\n\n\n\n","category":"method"},{"location":"#Mycelia.xam_to_contig_mapping_stats-Tuple{Any}","page":"Home","title":"Mycelia.xam_to_contig_mapping_stats","text":"xam_to_contig_mapping_stats(xam) -> Any\n\n\nGenerate detailed mapping statistics for each reference sequence/contig in a XAM (SAM/BAM/CRAM) file.\n\nArguments\n\nxam: Path to XAM file or XAM object\n\nReturns\n\nA DataFrame with per-contig statistics including:\n\nn_aligned_reads: Number of aligned reads\ntotal_aligned_bases: Sum of alignment lengths\ntotal_alignment_score: Sum of alignment scores\nMapping quality statistics (mean, std, median)\nAlignment length statistics (mean, std, median)\nAlignment score statistics (mean, std, median)\nPercent mismatches statistics (mean, std, median)\n\nNote: Only primary alignments (isprimary=true) and mapped reads (ismapped=true) are considered.\n\n\n\n\n\n","category":"method"}]
}
